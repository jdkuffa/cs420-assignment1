protected void setUp ( ) throws Exception { super . setUp ( ) ; b = new ConnectionFactoryBuilder ( ) ; }
public void testOverridingExecutorService ( ) { ConnectionFactory factory = b . build ( ) ; assertTrue ( factory . isDefaultExecutorService ( ) ) ; ExecutorService service = Executors . newFixedThreadPool ( 1 ) ; b . setListenerExecutorService ( service ) ; factory = b . build ( ) ; assertFalse ( factory . isDefaultExecutorService ( ) ) ; assertEquals ( service . hashCode ( ) , factory . getListenerExecutorService ( ) . hashCode ( ) ) ; }
public BlockingQueue < Operation > create ( ) { return queue ; }
private void assertNativeHash ( String key ) { assertHash ( DefaultHashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; }
protected void setUp ( ) throws Exception { serverList = TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER + " " + TestConfig . IPV4_ADDR + " : 11311 " ; super . setUp ( ) ; }
protected void tearDown ( ) throws Exception { serverList = TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ; super . tearDown ( ) ; }
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( serverList ) ) ; }
protected void flushPause ( ) throws InterruptedException { Thread . sleep ( 100 ) ; }
public void testQueueingToDownServer ( ) throws Exception { Future < Boolean > f = client . add ( " someKey " , 0 , " some object " ) ; try { boolean b = f . get ( ) ; fail ( " Should ' ve thrown an exception , returned " + b ) ; } catch ( ExecutionException e ) { } assertTrue ( f . isCancelled ( ) ) ; }
protected void tearDown ( ) throws Exception { client . shutdown ( ) ; }
public void run ( ) { client . cas ( " k " , 1 , " blah " ) ; }
public void run ( ) { client . gets ( " k " ) ; }
public void run ( ) { client . get ( " k " ) ; }
public void run ( ) { client . getBulk ( " k " , " k2 " ) ; }
public void run ( ) { client . incr ( " k " , 1 ) ; }
public void run ( ) { client . incr ( " k " , 1 , 5 ) ; }
public void receivedStatus ( OperationStatus s ) { assert ! s . isSuccess ( ) ; assert err . getValue ( ) . equals ( s . getMessage ( ) ) ; }
protected final void assertSequence ( String k , int . . . seq ) { runSequenceAssertion ( locator , k , seq ) ; runSequenceAssertion ( locator . getReadonlyCopy ( ) , k , seq ) ; }
public int hashCode ( ) { return ( socketAddress ! = null ? socketAddress . hashCode ( ) : 0 ) ; }
public Operation removeCurrentReadOp ( ) { return null ; }
public Operation removeCurrentWriteOp ( ) { return null ; }
public int writeSome ( ) throws IOException { return 0 ; }
public Collection < Operation > destroyInputQueue ( ) { return null ; }
public boolean isAuthenticated ( ) { return true ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; transcoder = new SerializingTranscoder ( ) ; clientMock = mock ( MemcachedClientIF . class ) ; clientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( transcoder ) ) ; client = ( MemcachedClientIF ) clientMock . proxy ( ) ; cacheMap = new CacheMap ( client , EXP , " blah " ) ; }
public void testNoExpConstructor ( ) throws Exception { clientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( transcoder ) ) ; CacheMap cm = new CacheMap ( client , " blah " ) ; Field f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; f . setAccessible ( true ) ; assertEquals ( 0 , f . getInt ( cm ) ) ; }
public void testBaseConstructor ( ) throws Exception { BaseCacheMap < Integer > bcm = new BaseCacheMap < Integer > ( client , EXP , " base " , new IntegerTranscoder ( ) ) ; Field f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; f . setAccessible ( true ) ; assertEquals ( EXP , f . getInt ( bcm ) ) ; }
public void testGetPositive ( ) { expectGetAndReturn ( " blaha " , " something " ) ; assertEquals ( " something " , cacheMap . get ( " a " ) ) ; }
public void testGetNegative ( ) { expectGetAndReturn ( " blaha " , null ) ; assertNull ( cacheMap . get ( " a " ) ) ; }
public void testGetNotString ( ) { assertNull ( cacheMap . get ( new Object ( ) ) ) ; }
public void testContainsPositive ( ) { expectGetAndReturn ( " blaha " , new Object ( ) ) ; assertTrue ( cacheMap . containsKey ( " a " ) ) ; }
public void testContainsNegative ( ) { expectGetAndReturn ( " blaha " , null ) ; assertFalse ( cacheMap . containsKey ( " a " ) ) ; }
public void testContainsValue ( ) { assertFalse ( cacheMap . containsValue ( " anything " ) ) ; }
public void testEntrySet ( ) { assertEquals ( 0 , cacheMap . entrySet ( ) . size ( ) ) ; }
public void testKeySet ( ) { assertEquals ( 0 , cacheMap . keySet ( ) . size ( ) ) ; }
public void testtIsEmpty ( ) { assertFalse ( cacheMap . isEmpty ( ) ) ; }
public void testPutAll ( ) { clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " vala " ) ) ; clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blahb " ) , eq ( EXP ) , eq ( " valb " ) ) ; Map < String , Object > m = new HashMap < String , Object > ( ) ; m . put ( " a " , " vala " ) ; m . put ( " b " , " valb " ) ; cacheMap . putAll ( m ) ; }
public void testSize ( ) { assertEquals ( 0 , cacheMap . size ( ) ) ; }
public void testValues ( ) { assertEquals ( 0 , cacheMap . values ( ) . size ( ) ) ; }
public void testRemove ( ) { expectGetAndReturn ( " blaha " , " olda " ) ; clientMock . expects ( once ( ) ) . method ( " delete " ) . with ( eq ( " blaha " ) ) ; assertEquals ( " olda " , cacheMap . remove ( " a " ) ) ; }
public void testRemoveNotString ( ) { assertNull ( cacheMap . remove ( new Object ( ) ) ) ; }
public void testPut ( ) { expectGetAndReturn ( " blaha " , " olda " ) ; clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " newa " ) ) ; assertEquals ( " olda " , cacheMap . put ( " a " , " newa " ) ) ; }
protected Collection < String > stringify ( Collection < ? > c ) { Collection < String > rv = new ArrayList < String > ( ) ; for ( Object o : c ) { rv . add ( String . valueOf ( o ) ) ; } return rv ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; initClient ( ) ; }
protected void tearDown ( ) throws Exception { client . shutdown ( ) ; client = null ; initClient ( ) ; flushPause ( ) ; assertTrue ( client . flush ( ) . get ( ) ) ; client . shutdown ( ) ; client = null ; super . tearDown ( ) ; }
protected boolean isMoxi ( ) { if ( moxi ! = null ) { return moxi . booleanValue ( ) ; } Map < SocketAddress , Map < String , String > > stats = client . getStats ( " proxy " ) ; for ( Map < String , String > node : stats . values ( ) ) { if ( node . get ( " basic : version " ) ! = null ) { moxi = true ; System . err . println ( " Using proxy " ) ; break ; } else { moxi = false ; System . err . println ( " Not using proxy " ) ; } } return moxi . booleanValue ( ) ; }
public void testAvailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( Collections . emptyList ( ) , client . getAvailableServers ( ) ) ; }
protected void tryTestSequence ( Future < ? > f ) throws Exception { tryTimeout ( f ) ; tryCancellation ( f ) ; }
public void testAsyncGetCancellation ( ) throws Exception { tryTestSequence ( client . asyncGet ( " k " ) ) ; }
public void testAsyncGetsCancellation ( ) throws Exception { tryTestSequence ( client . asyncGets ( " k " ) ) ; }
public void testAsyncGetBulkCancellationCollection ( ) throws Exception { tryTestSequence ( client . asyncGetBulk ( Arrays . asList ( " k " , " k2 " ) ) ) ; }
public void testAsyncGetBulkCancellationVararg ( ) throws Exception { tryTestSequence ( client . asyncGetBulk ( " k " , " k2 " ) ) ; }
public void testDeleteCancellation ( ) throws Exception { tryTestSequence ( client . delete ( " x " ) ) ; }
public void testflushCancellation ( ) throws Exception { tryTestSequence ( client . flush ( ) ) ; }
public void testDelayedflushCancellation ( ) throws Exception { tryTestSequence ( client . flush ( 3 ) ) ; }
public void testReplaceCancellation ( ) throws Exception { tryTestSequence ( client . replace ( " x " , 3 , " y " ) ) ; }
public void testAddCancellation ( ) throws Exception { tryTestSequence ( client . add ( " x " , 3 , " y " ) ) ; }
public void testSetCancellation ( ) throws Exception { tryTestSequence ( client . set ( " x " , 3 , " y " ) ) ; }
public void testCASCancellation ( ) throws Exception { tryTestSequence ( client . asyncCAS ( " x " , 3 , " y " ) ) ; }
public void complete ( ) { System . err . println ( " Complete . " ) ; }
public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line . " ) ; }
public void handleLine ( String line ) { System . out . println ( " Woo ! A line ! " ) ; }
public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage \ r \ n " . getBytes ( ) ) ) ; }
public void testAddGetSetStatusCodes ( ) throws Exception { OperationFuture < Boolean > set = client . set ( " statusCode1 " , 0 , " value " ) ; set . get ( ) ; assertEquals ( StatusCode . SUCCESS , set . getStatus ( ) . getStatusCode ( ) ) ; GetFuture < Object > get = client . asyncGet ( " statusCode1 " ) ; get . get ( ) ; assertEquals ( StatusCode . SUCCESS , get . getStatus ( ) . getStatusCode ( ) ) ; OperationFuture < Boolean > add = client . add ( " statusCode1 " , 0 , " value2 " ) ; add . get ( ) ; assertEquals ( StatusCode . ERR_NOT_STORED , add . getStatus ( ) . getStatusCode ( ) ) ; }
public void testSingle ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www . google . com : 80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; assertEquals ( " www . google . com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; }
public void testTwo ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www . google . com : 80 www . yahoo . com : 81 " ) ; assertEquals ( 2 , addrs . size ( ) ) ; assertEquals ( " www . google . com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; assertEquals ( " www . yahoo . com " , addrs . get ( 1 ) . getHostName ( ) ) ; assertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; }
public void testThree ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " , www . google . com : 80 , , , , www . yahoo . com : 81 , , , " ) ; assertEquals ( 2 , addrs . size ( ) ) ; assertEquals ( " www . google . com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; assertEquals ( " www . yahoo . com " , addrs . get ( 1 ) . getHostName ( ) ) ; assertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; }
public void testIPv6Host ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " : : 1 : 80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; Set < String > validLocalhostNames = new HashSet < String > ( ) ; validLocalhostNames . add ( " localhost " ) ; validLocalhostNames . add ( " ip6 - localhost " ) ; validLocalhostNames . add ( " 0 : 0 : 0 : 0 : 0 : 0 : 0 : 1 " ) ; validLocalhostNames . add ( " localhost6 . localdomain6 " ) ; assert ( validLocalhostNames . contains ( addrs . get ( 0 ) . getHostName ( ) ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; ofact = getOperationFactory ( ) ; genericCallback = new OperationCallback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status : " + status ) ; } } ; storeCallback = new StoreOperation . Callback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void gotData ( String key , long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status : " + status ) ; } } ; deleteCallback = new DeleteOperation . Callback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void gotData ( long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status : " + status ) ; } } ; testData = new byte [ 64 ] ; new Random ( ) . nextBytes ( testData ) ; }
public void complete ( ) { fail ( " Unexpected invocation " ) ; }
public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status : " + status ) ; }
public void testDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , deleteCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertDeleteCallback ( op2 ) ; }
public void testCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , storeCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertStoreCallback ( op2 ) ; }
public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }
public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }
public void testStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , testData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; }
public void testStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , testData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; }
public void testConcatenationOperationAppendCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . append , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . append , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }
public void testConcatenationOperationPrependCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . prepend , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . prepend , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }
public void testSingleGetOperationCloning ( ) { GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( TEST_KEY , callback ) ; GetOperation op2 = cloneOne ( GetOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; }
public void testSingleGetsOperationCloning ( ) { GetsOperation . Callback callback = ( GetsOperation . Callback ) mock ( GetsOperation . Callback . class ) . proxy ( ) ; GetsOperation op = ofact . gets ( TEST_KEY , callback ) ; GetsOperation op2 = cloneOne ( GetsOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; }
public void complete ( ) { latch . countDown ( ) ; }
protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; }
protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; }
protected void assertStoreCallback ( Operation op ) { assertSame ( storeCallback , op . getCallback ( ) ) ; }
protected void assertDeleteCallback ( Operation op ) { assertSame ( deleteCallback , op . getCallback ( ) ) ; }
private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( testData , bytes ) ) ; }
private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; }
protected < T > T cloneOne ( Class < T > c , KeyedOperation t ) { return assertOne ( c , ofact . clone ( t ) ) ; }
public void testSmallSet ( ) { runThisManyNodes ( 3 ) ; }
public void testLargeSet ( ) { runThisManyNodes ( 100 ) ; }
private List < MemcachedNode > createNodes ( List < InetSocketAddress > addresses ) { List < MemcachedNode > results = new ArrayList < MemcachedNode > ( ) ; for ( InetSocketAddress addr : addresses ) { results . add ( new MockMemcachedNode ( addr ) ) ; } return results ; }
protected void setUp ( ) throws Exception { serverList = TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER + " " + TestConfig . IPV4_ADDR + " : 11311 " ; super . setUp ( ) ; }
private static String resolveIpv6Addr ( ) { String ipv6 = System . getProperty ( IPV6_PROP , " : : 1 " ) ; if ( ! IPV4_ADDR . equals ( " 127 . 0 . 0 . 1 " ) & & ! IPV4_ADDR . equals ( " localhost " ) & & ipv6 . equals ( " : : 1 " ) ) { return " : : ffff : " + IPV4_ADDR ; } return ipv6 ; }
public static boolean defaultToIPV4 ( ) { if ( ( " : : ffff : " + IPV4_ADDR ) . equals ( IPV6_ADDR ) ) { return true ; } return false ; }
public static boolean isCITest ( ) { return TEST_TYPE . equals ( TYPE_TEST_CI ) ; }
public void testDefaultConstructor ( ) { new CASMutator < Long > ( client , new LongTranscoder ( ) ) ; }
public Long call ( ) throws Exception { return mutator . cas ( " test . cas . concurrent " , 0L , 0 , mutation ) ; }
public void testCASUpdateWithNullInitial ( ) throws Throwable { client . set ( " x " , 0 , 1L ) ; Long rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; assertEquals ( rv , ( Long ) 2L ) ; }
public void testCASUpdateWithNullInitialNoExistingVal ( ) throws Throwable { assertNull ( client . get ( " x " ) ) ; Long rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; assertNull ( rv ) ; assertNull ( client . get ( " x " ) ) ; }
public void testCASValueToString ( ) { CASValue < String > c = new CASValue < String > ( 717L , " hi " ) ; assertEquals ( " { CasValue 717 / hi } " , c . toString ( ) ) ; }
public void testTimeoutDontwrite ( ) { Operation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { System . err . println ( " Complete . " ) ; } public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line . " ) ; } } ) { @ Override public void handleLine ( String line ) { System . out . println ( " Woo ! A line ! " ) ; } @ Override public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage \ r \ n " . getBytes ( ) ) ) ; } } ; try { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } client . mconn . enqueueOperation ( " x " , op ) ; System . err . println ( " Operation attempted : " ) ; System . err . println ( op ) ; System . err . println ( " Trying to get : " ) ; try { client . get ( " x " ) ; String retValString = new String ( ) ; System . err . println ( retValString ) ; } catch ( net . spy . memcached . OperationTimeoutException ex ) { System . err . println ( " Timed out successfully : " + ex . getMessage ( ) ) ; } System . err . println ( " Op timed out is " + op . isTimedOut ( ) ) ; assert op . isTimedOut ( ) ; }
public void complete ( ) { System . err . println ( " Complete . " ) ; }
public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line . " ) ; }
public void handleLine ( String line ) { System . out . println ( " Woo ! A line ! " ) ; }
public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage \ r \ n " . getBytes ( ) ) ) ; }
public void testConnectionObserver ( ) throws Exception { ConnectionObserver obs = new LoggingObserver ( ) ; assertTrue ( " Didn ' t add observer . " , client . addObserver ( obs ) ) ; assertTrue ( " Didn ' t remove observer . " , client . removeObserver ( obs ) ) ; assertFalse ( " Removed observer more than once . " , client . removeObserver ( obs ) ) ; }
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { latch . countDown ( ) ; }
public void connectionLost ( SocketAddress sa ) { assert false : " Should not see this . " ; }
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { getLogger ( ) . info ( " Connection established to % s ( % s ) " , sa , reconnectCount ) ; }
public void connectionLost ( SocketAddress sa ) { getLogger ( ) . info ( " Connection lost from % s " , sa ) ; }
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { MemcachedConnection rv = super . createConnection ( addrs ) ; return rv ; }
public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; }
public BlockingQueue < Operation > createReadOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( ( int ) ( getOpQueueLen ( ) * 1 . 1 ) ) ; }
public BlockingQueue < Operation > createWriteOperationQueue ( ) { return createOperationQueue ( ) ; }
public boolean shouldOptimize ( ) { return false ; }
public void testOverflowingWriteQueue ( ) throws Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; if ( TestConfig . isCITest ( ) ) { return ; } r . nextBytes ( b ) ; runOverflowTest ( b ) ; }
public void testDebugBuffer ( ) throws Exception { String input = " this is a test _ " ; ByteBuffer bb = ByteBuffer . wrap ( input . getBytes ( ) ) ; String s = MemcachedConnection . dbgBuffer ( bb , input . length ( ) ) ; assertEquals ( " this is a test \ \ x5f " , s ) ; }
public void testConnectionsStatus ( ) throws Exception { ConnectionFactory factory = new DefaultConnectionFactory ( ) ; List < InetSocketAddress > addresses = AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " : 11211 " ) ; Collection < ConnectionObserver > observers = new ArrayList < ConnectionObserver > ( ) ; MemcachedConnection mcc = new MemcachedConnection ( 10240 , factory , addresses , observers , FailureMode . Retry , new BinaryOperationFactory ( ) ) ; assertNotNull ( mcc . connectionsStatus ( ) ) ; }
public void testBelongsToCluster ( ) throws Exception { ConnectionFactory factory = new DefaultConnectionFactory ( ) ; Collection < ConnectionObserver > observers = new ArrayList < ConnectionObserver > ( ) ; OperationFactory opfactory = new BinaryOperationFactory ( ) ; MemcachedNode node = new MockMemcachedNode ( new InetSocketAddress ( TestConfig . IPV4_ADDR , TestConfig . PORT_NUMBER ) ) ; MemcachedNode node2 = new MockMemcachedNode ( new InetSocketAddress ( " invalidIpAddr " , TestConfig . PORT_NUMBER ) ) ; List < InetSocketAddress > nodes = new ArrayList < InetSocketAddress > ( ) ; nodes . add ( ( InetSocketAddress ) node . getSocketAddress ( ) ) ; MemcachedConnection conn = new MemcachedConnection ( 100 , factory , nodes , observers , FailureMode . Retry , opfactory ) ; assertTrue ( conn . belongsToCluster ( node ) ) ; assertFalse ( conn . belongsToCluster ( node2 ) ) ; }
public void isDisabledByDefault ( ) throws Exception { System . clearProperty ( " net . spy . metrics . enable " ) ; System . clearProperty ( " net . spy . metrics . type " ) ; ConnectionFactory cf = new DefaultConnectionFactory ( ) ; assertEquals ( MetricType . OFF , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof NoopMetricCollector ) ; cf = new BinaryConnectionFactory ( ) ; assertEquals ( MetricType . OFF , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof NoopMetricCollector ) ; }
public void canBeEnabledManually ( ) throws Exception { ConnectionFactory cf = new ConnectionFactoryBuilder ( ) . setEnableMetrics ( MetricType . PERFORMANCE ) . build ( ) ; assertEquals ( MetricType . PERFORMANCE , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof DefaultMetricCollector ) ; System . setProperty ( " net . spy . metrics . enable " , " true " ) ; System . setProperty ( " net . spy . metrics . type " , " performance " ) ; cf = new ConnectionFactoryBuilder ( ) . build ( ) ; assertEquals ( MetricType . PERFORMANCE , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof DefaultMetricCollector ) ; }
public void setUp ( ) throws Exception { ip = InetAddress . getByAddress ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; noHostnameNode = new MockMemcachedNode ( new InetSocketAddress ( ip , 11211 ) ) ; }
public void testSpymemcachedFormatIsDefault ( ) throws Exception { KetamaNodeKeyFormatter formatter = new KetamaNodeKeyFormatter ( ) ; assertEquals ( formatter . getFormat ( ) , KetamaNodeKeyFormatter . Format . SPYMEMCACHED ) ; }
public void testSpymemcachedFormat ( ) throws Exception { KetamaNodeKeyFormatter formatter = new KetamaNodeKeyFormatter ( KetamaNodeKeyFormatter . Format . SPYMEMCACHED ) ; assertEquals ( " localhost / 127 . 0 . 0 . 1 : 11211 - 1 " , formatter . getKeyForNode ( defaultNode , 1 ) ) ; assertEquals ( " 1 . 2 . 3 . 4 : 11211 - 1 " , formatter . getKeyForNode ( noHostnameNode , 1 ) ) ; assertEquals ( " localhost / 127 . 0 . 0 . 1 : 11212 - 1 " , formatter . getKeyForNode ( noDefaultPortNode , 1 ) ) ; }
public void testLibmemcachedFormat ( ) throws Exception { KetamaNodeKeyFormatter formatter = new KetamaNodeKeyFormatter ( KetamaNodeKeyFormatter . Format . LIBMEMCACHED ) ; assertEquals ( " localhost - 1 " , formatter . getKeyForNode ( defaultNode , 1 ) ) ; assertEquals ( " 1 . 2 . 3 . 4 - 1 " , formatter . getKeyForNode ( noHostnameNode , 1 ) ) ; assertEquals ( " localhost : 11212 - 1 " , formatter . getKeyForNode ( noDefaultPortNode , 1 ) ) ; }
protected void tearDown ( ) throws Exception { if ( client ! = null ) { try { client . shutdown ( ) ; } catch ( NullPointerException e ) { } } super . tearDown ( ) ; }
public void testVarargConstructor ( ) throws Exception { client = new MemcachedClient ( new InetSocketAddress ( InetAddress . getByName ( TestConfig . IPV4_ADDR ) , TestConfig . PORT_NUMBER ) ) ; assertWorking ( ) ; }
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return null ; }
public void testCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; }
public void testDefaultProperties ( ) { KetamaConnectionFactory connectionFactory = new KetamaConnectionFactory ( ) ; assertEquals ( connectionFactory . getHashAlg ( ) , DefaultHashAlgorithm . KETAMA_HASH ) ; assertTrue ( connectionFactory . getWeights ( ) . isEmpty ( ) ) ; assertEquals ( connectionFactory . getKetamaNodeKeyFormat ( ) , KetamaNodeKeyFormatter . Format . SPYMEMCACHED ) ; }
public void testSettingProperties ( ) { Map < InetSocketAddress , Integer > weights = new HashMap < InetSocketAddress , Integer > ( ) ; weights . put ( new InetSocketAddress ( " localhost " , 11211 ) , 8 ) ; KetamaConnectionFactory connectionFactory = new KetamaConnectionFactory ( 1 , 1 , 1 , DefaultHashAlgorithm . FNV1_32_HASH , KetamaNodeKeyFormatter . Format . LIBMEMCACHED , weights ) ; assertEquals ( connectionFactory . getWeights ( ) , weights ) ; assertEquals ( connectionFactory . getHashAlg ( ) , DefaultHashAlgorithm . FNV1_32_HASH ) ; assertEquals ( connectionFactory . getKetamaNodeKeyFormat ( ) , KetamaNodeKeyFormatter . Format . LIBMEMCACHED ) ; }
public void testBinaryEmptyCons ( ) { new BinaryConnectionFactory ( ) ; }
public void testBinaryTwoIntCons ( ) { new BinaryConnectionFactory ( 5 , 5 ) ; }
public void testBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , DefaultHashAlgorithm . FNV1_64_HASH ) ; }
public void testPrimary ( ) throws Exception { setupNodes ( 4 ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; }
public void testAll ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; assertTrue ( all . contains ( nodes [ 0 ] ) ) ; assertTrue ( all . contains ( nodes [ 1 ] ) ) ; assertTrue ( all . contains ( nodes [ 2 ] ) ) ; assertTrue ( all . contains ( nodes [ 3 ] ) ) ; }
public void testAllClone ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; }
public void testSeq1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 1 , 2 ) ; }
public void testSeq2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 1 , 2 , 3 ) ; }
public void testSeqOnlyOneServer ( ) { setupNodes ( 1 ) ; assertSequence ( " noelani " ) ; }
public void testSeqWithTwoNodes ( ) { setupNodes ( 2 ) ; assertSequence ( " dustin " , 0 ) ; }
public void testDeleteWithCAS ( ) throws Exception { final String key = " delete . with . cas " ; final long wrongCAS = 1234 ; OperationFuture < Boolean > setFuture = client . set ( key , 0 , " test " ) ; assertTrue ( setFuture . get ( ) ) ; assertFalse ( client . delete ( key , wrongCAS ) . get ( ) ) ; assertTrue ( client . delete ( key , setFuture . getCas ( ) ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; }
public void testCASAppendFail ( ) throws Exception { final String key = " append . key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . append ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " test " , client . get ( key ) ) ; }
public void testCASAppendSuccess ( ) throws Exception { final String key = " append . key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . append ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " testes " , client . get ( key ) ) ; }
public void testCASPrependFail ( ) throws Exception { final String key = " append . key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . prepend ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " test " , client . get ( key ) ) ; }
public void testCASPrependSuccess ( ) throws Exception { final String key = " append . key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . prepend ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estest " , client . get ( key ) ) ; }
public void testAsyncCASResponse ( ) { String key = " testAsyncCASResponse " ; client . set ( key , 300 , key + " 0 " ) ; CASValue < Object > getsRes = client . gets ( key ) ; OperationFuture < CASResponse > casRes = client . asyncCAS ( key , getsRes . getCas ( ) , key + " 1 " ) ; try { casRes . get ( ) ; assertNotNull ( " OperationFuture is missing cas value . " , casRes . getCas ( ) ) ; } catch ( InterruptedException ex ) { fail ( " Interrupted while getting CASResponse " ) ; } catch ( ExecutionException ex ) { fail ( " Execution problem while getting CASResponse " ) ; } assertNotNull ( casRes . getCas ( ) ) ; }
public void testAsyncCASWithExpiration ( ) throws Exception { final String key = " casWithExpiration " ; final String value = " value " ; OperationFuture < Boolean > future = client . set ( key , 0 , value ) ; assertTrue ( future . get ( ) ) ; OperationFuture < CASResponse > casFuture = client . asyncCAS ( key , future . getCas ( ) , 2 , value ) ; assertEquals ( CASResponse . OK , casFuture . get ( ) ) ; Thread . sleep ( 2500 ) ; assertNull ( client . get ( key ) ) ; }
public void testKeyWithSpaces ( ) throws Exception { String key = " key with spaces " ; client . set ( key , 0 , " " ) ; assertNotNull ( " Couldn ' t get the key with spaces in it . " , client . get ( key ) ) ; }
public void testKeyWithNewline ( ) throws Exception { String key = " Key \ n " ; client . set ( key , 0 , " " ) ; assertNotNull ( client . get ( key ) ) ; }
public void testKeyWithReturn ( ) throws Exception { String key = " Key \ r " ; client . set ( key , 0 , " " ) ; assertNotNull ( client . get ( key ) ) ; }
public void testKeyWithASCIINull ( ) throws Exception { String key = " Key \ 0 " ; client . set ( key , 0 , " " ) ; assertNotNull ( client . get ( key ) ) ; }
public void testAddGetSetStatusCodes ( ) throws Exception { OperationFuture < Boolean > set = client . set ( " statusCode1 " , 0 , " value " ) ; set . get ( ) ; assertEquals ( StatusCode . SUCCESS , set . getStatus ( ) . getStatusCode ( ) ) ; GetFuture < Object > get = client . asyncGet ( " statusCode1 " ) ; get . get ( ) ; assertEquals ( StatusCode . SUCCESS , get . getStatus ( ) . getStatusCode ( ) ) ; OperationFuture < Boolean > add = client . add ( " statusCode1 " , 0 , " value2 " ) ; add . get ( ) ; assertEquals ( StatusCode . ERR_EXISTS , add . getStatus ( ) . getStatusCode ( ) ) ; }
public void testAsyncIncrementWithDefault ( ) throws Exception { String k = " async - incr - with - default " ; OperationFuture < Long > f = client . asyncIncr ( k , 1 , 5 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 5 , ( long ) f . get ( ) ) ; f = client . asyncIncr ( k , 1 , 5 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; }
public void testAsyncDecrementWithDefault ( ) throws Exception { String k = " async - decr - with - default " ; OperationFuture < Long > f = client . asyncDecr ( k , 4 , 10 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 10 , ( long ) f . get ( ) ) ; f = client . asyncDecr ( k , 4 , 10 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; }
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; OperationFuture < Boolean > setResult = client . set ( " bigassthing " , 60 , data , st ) ; assertFalse ( setResult . get ( ) ) ; assertEquals ( StatusCode . ERR_2BIG , setResult . getStatus ( ) . getStatusCode ( ) ) ; client . set ( " k " , 5 , " Blah " ) ; assertEquals ( " Blah " , client . get ( " k " ) ) ; }
public void testAssertions ( ) { boolean caught = false ; try { assert false ; } catch ( AssertionError e ) { caught = true ; } assertTrue ( " Assertions are not enabled ! " , caught ) ; }
public void testGetStats ( ) throws Exception { Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; System . out . println ( " Stats : " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " curr_items " ) ) ; }
public void testGetStatsSlabs ( ) throws Exception { if ( isMoxi ( ) ) { return ; } client . set ( " slabinitializer " , 0 , " hi " ) ; Map < SocketAddress , Map < String , String > > stats = client . getStats ( " slabs " ) ; System . out . println ( " Stats : " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " 1 : chunk_size " ) ) ; }
public void testDelayedFlush ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; assert client . set ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; assert client . set ( " test2 " , 5 , " test2value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; assertEquals ( " test2value " , client . get ( " test2 " ) ) ; assert client . flush ( 2 ) . getStatus ( ) . isSuccess ( ) ; Thread . sleep ( 2100 ) ; assertNull ( client . get ( " test1 " ) ) ; assertNull ( client . get ( " test2 " ) ) ; assert ! client . asyncGet ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; assert ! client . asyncGet ( " test2 " ) . getStatus ( ) . isSuccess ( ) ; }
public void testDoubleShutdown ( ) { client . shutdown ( ) ; client . shutdown ( ) ; }
public void testSimpleGet ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . set ( " test1 " , 5 , " test1value " ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; }
public void testSimpleCASGets ( ) throws Exception { assertNull ( client . gets ( " test1 " ) ) ; assert client . set ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " test1value " , client . gets ( " test1 " ) . getValue ( ) ) ; }
public void testCAS ( ) throws Exception { final String key = " castestkey " ; assertSame ( " Expected error CASing with no existing value . " , CASResponse . NOT_FOUND , client . cas ( key , 0x7fffffffffL , " bad value " ) ) ; assertTrue ( client . add ( key , 5 , " original value " ) . get ( ) ) ; CASValue < ? > getsVal = client . gets ( key ) ; assertEquals ( " original value " , getsVal . getValue ( ) ) ; assertSame ( " Expected error CASing with invalid id " , CASResponse . EXISTS , client . cas ( key , getsVal . getCas ( ) + 1 , " broken value " ) ) ; assertEquals ( " original value " , getsVal . getValue ( ) ) ; assertSame ( " Expected successful CAS with correct id ( " + getsVal . getCas ( ) + " ) " , CASResponse . OK , client . cas ( key , getsVal . getCas ( ) , " new value " ) ) ; assertEquals ( " new value " , client . get ( key ) ) ; assertSame ( " Expected unsuccessful CAS with replayed id " , CASResponse . EXISTS , client . cas ( key , getsVal . getCas ( ) , " crap value " ) ) ; assertEquals ( " new value " , client . get ( key ) ) ; final String key2 = " castestkey2 " ; assertTrue ( client . add ( key2 , 0 , " value " ) . get ( ) ) ; CASValue < Object > casValue = client . gets ( key2 ) ; assertEquals ( CASResponse . OK , client . cas ( key2 , casValue . getCas ( ) , 3 , " new val " ) ) ; Thread . sleep ( 5000 ) ; assertNull ( client . get ( key2 ) ) ; }
public void testExtendedUTF8Key ( ) throws Exception { String key = " \ u2013 \ u00ba \ u2013 \ u220f \ u2014 \ u00c4 " ; assertNull ( client . get ( key ) ) ; assert client . set ( key , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " test1value " , client . get ( key ) ) ; }
public void testAdd ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; assert ! client . asyncGet ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; assertTrue ( client . set ( " test1 " , 5 , " test1value " ) . get ( ) ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; assert client . asyncGet ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; assertFalse ( client . add ( " test1 " , 5 , " ignoredvalue " ) . get ( ) ) ; assert ! client . add ( " test1 " , 5 , " ignoredvalue " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; }
public void testAddWithTranscoder ( ) throws Exception { Transcoder < String > t = new TestTranscoder ( ) ; assertNull ( client . get ( " test1 " , t ) ) ; assert ! client . asyncGet ( " test1 " , t ) . getStatus ( ) . isSuccess ( ) ; assertTrue ( client . set ( " test1 " , 5 , " test1value " , t ) . get ( ) ) ; assertEquals ( " test1value " , client . get ( " test1 " , t ) ) ; assertFalse ( client . add ( " test1 " , 5 , " ignoredvalue " , t ) . get ( ) ) ; assert ! client . add ( " test1 " , 5 , " ignoredvalue " , t ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " test1value " , client . get ( " test1 " , t ) ) ; }
public void testUpdate ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . replace ( " test1 " , 5 , " test1value " ) ; assert ! client . replace ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " test1 " ) ) ; }
public void testUpdateWithTranscoder ( ) throws Exception { Transcoder < String > t = new TestTranscoder ( ) ; assertNull ( client . get ( " test1 " , t ) ) ; client . replace ( " test1 " , 5 , " test1value " , t ) ; assert ! client . replace ( " test1 " , 5 , " test1value " , t ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " test1 " , t ) ) ; }
public void testGetBulk ( ) throws Exception { Collection < String > keys = Arrays . asList ( " test1 " , " test2 " , " test3 " ) ; assertEquals ( 0 , client . getBulk ( keys ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " ) ; client . set ( " test2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( keys ) ; assert client . asyncGetBulk ( keys ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( " test2 " ) ) ; }
public void testGetBulkVararg ( ) throws Exception { assertEquals ( 0 , client . getBulk ( " test1 " , " test2 " , " test3 " ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " ) ; client . set ( " test2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( " test1 " , " test2 " , " test3 " ) ; assert client . asyncGetBulk ( " test1 " , " test2 " , " test3 " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( " test2 " ) ) ; }
public void testGetBulkVarargWithTranscoder ( ) throws Exception { Transcoder < String > t = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( t , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " , t ) ; client . set ( " test2 " , 5 , " val2 " , t ) ; Map < String , String > vals = client . getBulk ( t , " test1 " , " test2 " , " test3 " ) ; assert client . asyncGetBulk ( t , " test1 " , " test2 " , " test3 " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( " test2 " ) ) ; }
public void testAsyncGetBulkVarargWithTranscoder ( ) throws Exception { Transcoder < String > t = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( t , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " , t ) ; client . set ( " test2 " , 5 , " val2 " , t ) ; BulkFuture < Map < String , String > > vals = client . asyncGetBulk ( t , " test1 " , " test2 " , " test3 " ) ; assert vals . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . get ( ) . size ( ) ) ; assertEquals ( " val1 " , vals . get ( ) . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( ) . get ( " test2 " ) ) ; }
public void testUnavailableServers ( ) { client . getVersions ( ) ; assertEquals ( Collections . emptyList ( ) , client . getUnavailableServers ( ) ) ; }
public void testGetVersions ( ) throws Exception { Map < SocketAddress , String > vs = client . getVersions ( ) ; assertEquals ( 1 , vs . size ( ) ) ; Map . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; assertEquals ( getExpectedVersionSource ( ) , me . getKey ( ) . toString ( ) ) ; assertNotNull ( me . getValue ( ) ) ; }
public void testNonexistentMutate ( ) throws Exception { assertEquals ( - 1 , client . incr ( " nonexistent " , 1 ) ) ; assert ! client . asyncIncr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( - 1 , client . decr ( " nonexistent " , 1 ) ) ; assert ! client . asyncDecr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; }
public void testMutateWithDefault ( ) throws Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 ) ) ; }
public void testMutateWithDefaultAndExp ( ) throws Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 , 1 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 , 1 ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " mtest " ) ) ; OperationStatus status = client . asyncGet ( " mtest " ) . getStatus ( ) ; assertFalse ( status . isSuccess ( ) ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , status . getStatusCode ( ) ) ; }
public void testAsyncIncrement ( ) throws Exception { String k = " async - incr " ; client . set ( k , 0 , " 5 " ) ; OperationFuture < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; }
public void testAsyncIncrementNonExistent ( ) throws Exception { String k = " async - incr - non - existent " ; OperationFuture < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; }
public void testAsyncDecrement ( ) throws Exception { String k = " async - decr " ; client . set ( k , 0 , " 5 " ) ; OperationFuture < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 4 , ( long ) f . get ( ) ) ; }
public void testAsyncDecrementNonExistent ( ) throws Exception { String k = " async - decr - non - existent " ; OperationFuture < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; }
public Long call ( ) throws Exception { return client . incr ( " mtest " , 1 , 11 ) ; }
public void testImmediateDelete ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . set ( " test1 " , 5 , " test1value " ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; assert client . delete ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " test1 " ) ) ; }
public void testFlush ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . set ( " test1 " , 5 , " test1value " ) ; client . set ( " test2 " , 5 , " test2value " ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; assertEquals ( " test2value " , client . get ( " test2 " ) ) ; assertTrue ( client . flush ( ) . get ( ) ) ; assertNull ( client . get ( " test1 " ) ) ; assertNull ( client . get ( " test2 " ) ) ; }
public void testTouch ( ) throws Exception { assertNull ( client . get ( " touchtest " ) ) ; assertNull ( client . get ( " nonexistent " ) ) ; assertTrue ( client . set ( " touchtest " , 5 , " touchtest " ) . get ( ) ) ; assertTrue ( client . touch ( " touchtest " , 2 ) . get ( ) ) ; assertFalse ( client . touch ( " nonexistent " , 2 ) . get ( ) ) ; }
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn ' t fail setting bigass thing . " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing . Ass size " + data . length + " bytes doesn ' t fit . " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } client . set ( " k " , 5 , " Blah " ) ; assertEquals ( " Blah " , client . get ( " k " ) ) ; }
public void testStupidlyLargeSet ( ) throws Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn ' t fail setting bigass thing . " ) ; } catch ( IllegalArgumentException e ) { assertEquals ( " Cannot cache data larger than " + CachedData . MAX_SIZE + " bytes " + " ( you tried to cache a " + data . length + " byte object ) " , e . getMessage ( ) ) ; } client . set ( " k " , 5 , " Blah " ) ; assertEquals ( " Blah " , client . get ( " k " ) ) ; }
public void testAppend ( ) throws Exception { final String key = " append . key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assertEquals ( StatusCode . SUCCESS , op . getStatus ( ) . getStatusCode ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " testes " , client . get ( key ) ) ; }
public void testPrepend ( ) throws Exception { final String key = " prepend . key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assertEquals ( StatusCode . SUCCESS , op . getStatus ( ) . getStatusCode ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; }
public void testAppendNoSuchKey ( ) throws Exception { final String key = " append . missing " ; assertFalse ( client . append ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; }
public void testPrependNoSuchKey ( ) throws Exception { final String key = " prepend . missing " ; assertFalse ( client . prepend ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; }
public void testAppendWithoutCAS ( ) throws Exception { final String key = " append . key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " testes " , client . get ( key ) ) ; }
public void testPrependWithoutCAS ( ) throws Exception { final String key = " prepend . key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; }
public void testSetWithCallback ( ) throws Exception { OperationFuture < Boolean > setOp = client . set ( " setWithCallback " , 0 , " content " ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; setOp . addListener ( new OperationCompletionListener ( ) { @ Override public void onComplete ( OperationFuture < ? > f ) throws Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; }
public void onComplete ( OperationFuture < ? > f ) throws Exception { latch . countDown ( ) ; }
public void testGetWithCallback ( ) throws Exception { client . set ( " getWithCallback " , 0 , " content " ) . get ( ) ; GetFuture < Object > getOp = client . asyncGet ( " getWithCallback " ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; getOp . addListener ( new GetCompletionListener ( ) { @ Override public void onComplete ( GetFuture < ? > f ) throws Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; }
public void onComplete ( GetFuture < ? > f ) throws Exception { latch . countDown ( ) ; }
public void onComplete ( BulkGetFuture < ? > f ) throws Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; latch . countDown ( ) ; }
public void testEmptyGetBulk ( ) throws Exception { Map < String , Object > bulk = client . getBulk ( Collections . < String > emptyList ( ) ) ; assertTrue ( bulk . isEmpty ( ) ) ; }
public String decode ( CachedData d ) { assert d . getFlags ( ) = = FLAGS : " expected " + FLAGS + " got " + d . getFlags ( ) ; return new String ( d . getData ( ) ) ; }
public CachedData encode ( String o ) { return new CachedData ( FLAGS , o . getBytes ( ) , getMaxSize ( ) ) ; }
public boolean asyncDecode ( CachedData d ) { return false ; }
public String decode ( CachedData d ) { assert d . getFlags ( ) = = FLAGS : " expected " + FLAGS + " got " + d . getFlags ( ) ; ByteBuffer bb = ByteBuffer . wrap ( d . getData ( ) ) ; int keyLength = bb . getInt ( ) ; byte [ ] keyBytes = new byte [ keyLength ] ; bb . get ( keyBytes ) ; String k = new String ( keyBytes ) ; assertEquals ( key , k ) ; int valueLength = bb . getInt ( ) ; byte [ ] valueBytes = new byte [ valueLength ] ; bb . get ( valueBytes ) ; return new String ( valueBytes ) ; }
public CachedData encode ( String o ) { byte [ ] keyBytes = key . getBytes ( ) ; byte [ ] valueBytes = o . getBytes ( ) ; int length = 4 + keyBytes . length + 4 + valueBytes . length ; byte [ ] bytes = new byte [ length ] ; ByteBuffer bb = ByteBuffer . wrap ( bytes ) ; bb . putInt ( keyBytes . length ) . put ( keyBytes ) ; bb . putInt ( valueBytes . length ) . put ( valueBytes ) ; return new CachedData ( FLAGS , bytes , getMaxSize ( ) ) ; }
public void shouldWakeUpOnIdle ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 3 ) ; MemcachedConnection connection = new InstrumentedConnection ( latch , 1024 , new BinaryConnectionFactory ( ) , Arrays . asList ( new InetSocketAddress ( 11211 ) ) , Collections . < ConnectionObserver > emptyList ( ) , FailureMode . Redistribute , new BinaryOperationFactory ( ) ) ; assertTrue ( latch . await ( 5 , TimeUnit . SECONDS ) ) ; }
protected void handleWokenUpSelector ( ) { latch . countDown ( ) ; }
protected void setupNodes ( int n ) { setupNodes ( DefaultHashAlgorithm . KETAMA_HASH , n ) ; }
public void testAllClone ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; }
public void testLookups ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; }
public void testContinuumWrapping ( ) { setupNodes ( 4 ) ; assertEquals ( 4294887009L , ( ( KetamaNodeLocator ) locator ) . getMaxKey ( ) ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " V5XS8C8N " ) ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " 8KR2DKR2 " ) ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " L9KH6X4X " ) ) ; }
public void testClusterResizing ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; setupNodes ( 5 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; }
public void testSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 2 , 3 , 2 , 0 ) ; }
public void testSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 1 , 1 , 3 , 2 , 2 , 3 ) ; }
private void assertPosForKey ( String k , int nid ) { assertSame ( nodes [ nid ] , locator . getPrimary ( k ) ) ; }
public void testLibKetamaCompat ( ) { setupNodes ( 5 ) ; assertPosForKey ( " 36 " , 2 ) ; assertPosForKey ( " 10037 " , 3 ) ; assertPosForKey ( " 22051 " , 1 ) ; assertPosForKey ( " 49044 " , 4 ) ; }
public void testFNV1A32 ( ) { HashAlgorithm alg = DefaultHashAlgorithm . FNV1A_32_HASH ; setupNodes ( alg , 5 ) ; assertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 , 4 , 2 ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; }
public void addCounter ( String name ) { metrics . put ( name , 0 ) ; }
public void removeCounter ( String name ) { metrics . remove ( name ) ; }
public void incrementCounter ( String name ) { metrics . put ( name , metrics . get ( name ) + 1 ) ; }
public void incrementCounter ( String name , int amount ) { metrics . put ( name , metrics . get ( name ) + amount ) ; }
public void decrementCounter ( String name ) { metrics . put ( name , metrics . get ( name ) - 1 ) ; }
public void decrementCounter ( String name , int amount ) { metrics . put ( name , metrics . get ( name ) - amount ) ; }
public void addMeter ( String name ) { metrics . put ( name , 0 ) ; }
public void removeMeter ( String name ) { metrics . remove ( name ) ; }
public void markMeter ( String name ) { metrics . put ( name , metrics . get ( name ) + 1 ) ; }
public void addHistogram ( String name ) { metrics . put ( name , 0 ) ; }
public void removeHistogram ( String name ) { metrics . remove ( name ) ; }
public void updateHistogram ( String name , int amount ) { metrics . put ( name , metrics . get ( name ) + amount ) ; }
public void testGetEnginePrivate ( ) { long expResult = 0L ; long result = instance . getEnginePrivate ( ) ; assertEquals ( expResult , result ) ; }
public void testGetFlags ( ) { List < TapResponseFlag > result = instance . getFlags ( ) ; short expResultVal = 0 ; for ( TapResponseFlag flag : expectedFlags ) { expResultVal = ( short ) ( expResultVal + flag . getFlags ( ) ) ; } short resultVal = 0 ; for ( TapResponseFlag flag : result ) { resultVal = ( short ) ( resultVal + ( int ) flag . getFlags ( ) ) ; } assertEquals ( expResultVal , resultVal ) ; }
public void testGetTTL ( ) { int expResult = 0 ; int result = instance . getTTL ( ) ; assertEquals ( expResult , result ) ; }
public void testGetReserved1 ( ) { int expResult = 0 ; int result = instance . getReserved1 ( ) ; assertEquals ( expResult , result ) ; }
public void testGetReserved2 ( ) { int expResult = 0 ; int result = instance . getReserved2 ( ) ; assertEquals ( expResult , result ) ; }
public void testGetReserved3 ( ) { int expResult = 0 ; int result = instance . getReserved3 ( ) ; assertEquals ( expResult , result ) ; }
public void testGetVBucketState ( ) { int expResult = 0 ; int result = instance . getVBucketState ( ) ; assertEquals ( expResult , result ) ; }
public void testGetItemFlags ( ) { int expResult = ( int ) 0x0300 ; int result = instance . getItemFlags ( ) ; assertEquals ( expResult , result ) ; }
public void testGetItemExpiry ( ) { long expResult = 0L ; long result = instance . getItemExpiry ( ) ; assertEquals ( expResult , result ) ; }
public void testGetKey ( ) { String expResult = " a " ; String result = instance . getKey ( ) ; assertEquals ( expResult , result ) ; }
public void testGetValue ( ) { ByteBuffer bb = ByteBuffer . allocate ( 8 ) ; bb . put ( 7 , ( byte ) 42 ) ; byte [ ] expResult = bb . array ( ) ; byte [ ] result = instance . getValue ( ) ; assertArrayEquals ( expResult , result ) ; }
public void testGetBytes ( ) { byte [ ] result = instance . getBytes ( ) . array ( ) ; assertEquals ( ( byte ) 42 , result [ result . length - 1 ] ) ; }
public void testToString ( ) { assertNotNull ( instance . toString ( ) ) ; }
public void testGetEnginePrivate ( ) { long expResult = 4L ; long result = instance . getEnginePrivate ( ) ; assertEquals ( expResult , result ) ; }
public void testGetItemFlags ( ) { int expResult = ( int ) 0x0000 ; int result = instance . getItemFlags ( ) ; assertEquals ( expResult , result ) ; }
public void testGetValue ( ) { byte [ ] expResult = new byte [ 0 ] ; byte [ ] result = instance . getValue ( ) ; assertArrayEquals ( expResult , result ) ; }
public void testRevID ( ) { byte [ ] result = instance . getRevID ( ) ; assertEquals ( ' a ' , result [ 0 ] ) ; assertEquals ( ' b ' , result [ 1 ] ) ; assertEquals ( ' c ' , result [ 2 ] ) ; assertEquals ( ' d ' , result [ 3 ] ) ; }
public void testGetBytes ( ) { byte [ ] result = instance . getBytes ( ) . array ( ) ; assertEquals ( ' a ' , result [ result . length - 1 ] ) ; }
public void testDebugLogging ( ) { logger . debug ( " debug message " ) ; }
public void testInfoLogging ( ) { assertTrue ( logger . isInfoEnabled ( ) ) ; logger . info ( " info message " ) ; }
public void testOtherLogging ( ) { logger . warn ( " warn message " ) ; logger . warn ( " test % s " , " message " ) ; logger . error ( " error message " ) ; logger . error ( " test % s " , " message " ) ; logger . fatal ( " fatal message " ) ; logger . fatal ( " test % s " , " message " ) ; logger . log ( null , " test null " , null ) ; assertEquals ( getClass ( ) . getName ( ) , logger . getName ( ) ) ; }
public void testLevelStrings ( ) { assertEquals ( " { LogLevel : DEBUG } " , String . valueOf ( Level . DEBUG ) ) ; assertEquals ( " { LogLevel : INFO } " , String . valueOf ( Level . INFO ) ) ; assertEquals ( " { LogLevel : WARN } " , String . valueOf ( Level . WARN ) ) ; assertEquals ( " { LogLevel : ERROR } " , String . valueOf ( Level . ERROR ) ) ; assertEquals ( " { LogLevel : FATAL } " , String . valueOf ( Level . FATAL ) ) ; assertEquals ( " DEBUG " , Level . DEBUG . name ( ) ) ; assertEquals ( " INFO " , Level . INFO . name ( ) ) ; assertEquals ( " WARN " , Level . WARN . name ( ) ) ; assertEquals ( " ERROR " , Level . ERROR . name ( ) ) ; assertEquals ( " FATAL " , Level . FATAL . name ( ) ) ; }
public void testExceptionArg ( ) throws Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " test " ) } ; Throwable t = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNotNull ( t ) ; assertEquals ( " test " , t . getMessage ( ) ) ; }
public void testNoExceptionArg ( ) throws Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " test " ) , " x " } ; Throwable t = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNull ( t ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; BlockingQueue < Runnable > wq = new LinkedBlockingQueue < Runnable > ( ) ; es = new ThreadPoolExecutor ( 10 , 10 , 5 * 60 , TimeUnit . SECONDS , wq ) ; }
protected void tearDown ( ) throws Exception { es . shutdownNow ( ) ; super . tearDown ( ) ; }
public void testSimpleLoading ( ) throws Exception { Mock m = mock ( MemcachedClientIF . class ) ; LoadCounter sl = new LoadCounter ( ) ; CacheLoader cl = new CacheLoader ( ( MemcachedClientIF ) m . proxy ( ) , es , sl , 0 ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( returnValue ( new ImmediateFuture ( true ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( throwException ( new IllegalStateException ( " Full up " ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " b " ) , eq ( 0 ) , eq ( 2 ) ) . will ( returnValue ( new ImmediateFuture ( new RuntimeException ( " blah " ) ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " c " ) , eq ( 0 ) , eq ( 3 ) ) . will ( returnValue ( new ImmediateFuture ( false ) ) ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; cl . loadData ( map ) . get ( ) ; es . shutdown ( ) ; es . awaitTermination ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 1 , sl . success . get ( ) ) ; assertEquals ( 1 , sl . exceptions . get ( ) ) ; assertEquals ( 1 , sl . failure . get ( ) ) ; }
public void errorStoring ( String k , Exception e ) { exceptions . incrementAndGet ( ) ; }
public void shouldJoinChunk ( ) { List < String > chunks = Arrays . asList ( " chunk1 " ) ; String delimiter = " , " ; String expected = " chunk1 " ; String result = StringUtils . join ( chunks , delimiter ) ; assertEquals ( expected , result ) ; }
public void shouldJoinChunks ( ) { List < String > chunks = Arrays . asList ( " chunk1 " , " chunk2 " , " chunk3 " ) ; String delimiter = " , " ; String expected = " chunk1 , chunk2 , chunk3 " ; String result = StringUtils . join ( chunks , delimiter ) ; assertEquals ( expected , result ) ; }
public void shouldReturnEmptyStringWithNoChunks ( ) { String result = StringUtils . join ( Collections . < String > emptyList ( ) , " , " ) ; assertEquals ( " " , result ) ; }
public void shouldValidateJSONObject ( ) { assertTrue ( StringUtils . isJsonObject ( " { \ " a \ " : true } " ) ) ; assertTrue ( StringUtils . isJsonObject ( " [ 0 , 1 , 2 ] " ) ) ; assertTrue ( StringUtils . isJsonObject ( " true " ) ) ; assertTrue ( StringUtils . isJsonObject ( " false " ) ) ; assertTrue ( StringUtils . isJsonObject ( " null " ) ) ; assertTrue ( StringUtils . isJsonObject ( " 1 " ) ) ; assertTrue ( StringUtils . isJsonObject ( " - 1 " ) ) ; }
public void shouldValidateNonJSONObject ( ) { assertFalse ( StringUtils . isJsonObject ( " foobar " ) ) ; assertFalse ( StringUtils . isJsonObject ( " 0 . 5 " ) ) ; assertFalse ( StringUtils . isJsonObject ( " 1 , 244 . 0 " ) ) ; }
public void shouldWorkWithEmptyOrNullStrings ( ) { assertFalse ( StringUtils . isJsonObject ( " " ) ) ; assertFalse ( StringUtils . isJsonObject ( null ) ) ; assertFalse ( StringUtils . isJsonObject ( " \ r \ n " ) ) ; assertFalse ( StringUtils . isJsonObject ( " \ n " ) ) ; assertFalse ( StringUtils . isJsonObject ( " " ) ) ; }
public void shouldValidateAsciiKey ( ) { StringUtils . validateKey ( " mykey1234 " , false ) ; assertTrue ( true ) ; }
public void shouldFailValidationWithAsciiSpace ( ) { StringUtils . validateKey ( " key baz " , false ) ; }
public void shouldFailValidationWithAsciiNewline ( ) { StringUtils . validateKey ( " keybaz \ n " , false ) ; }
public void shouldFailValidationWithAsciiReturn ( ) { StringUtils . validateKey ( " keybaz \ r " , false ) ; }
public void shouldFailValidationWithAsciiNull ( ) { StringUtils . validateKey ( " keybaz \ 0 " , false ) ; }
public void shouldFailValidationWithAsciiTooLong ( ) { StringUtils . validateKey ( tooLongKey , false ) ; }
public void shouldFailValidationWithBinaryTooLong ( ) { StringUtils . validateKey ( tooLongKey , true ) ; }
public void shouldFailValidationWithAsciiEmpty ( ) { StringUtils . validateKey ( " " , false ) ; }
public void shouldFailValidationWithBinaryEmpty ( ) { StringUtils . validateKey ( " " , true ) ; }
public void shouldValidateBinaryKey ( ) { StringUtils . validateKey ( " mykey1234 " , true ) ; StringUtils . validateKey ( " key baz " , true ) ; StringUtils . validateKey ( " keybaz \ n " , true ) ; StringUtils . validateKey ( " keybaz \ r " , true ) ; StringUtils . validateKey ( " keybaz \ 0 " , true ) ; }
public boolean cancel ( boolean bln ) { cancelled = true ; notifyListeners ( ) ; return true ; }
public boolean isCancelled ( ) { return cancelled ; }
public T get ( long l , TimeUnit tu ) throws InterruptedException , ExecutionException , TimeoutException { return content ; }
public void set ( T c ) { notifyListeners ( ) ; content = c ; }
public DummyListenableFuture < T > addListener ( GenericCompletionListener listener ) { super . addToListeners ( listener ) ; return this ; }
public DummyListenableFuture < T > removeListener ( GenericCompletionListener listener ) { super . removeFromListeners ( listener ) ; return this ; }
private TestOperation buildOp ( int portNum ) { TestOperation op = new TestOperation ( ) ; MockMemcachedNode node = new MockMemcachedNode ( InetSocketAddress . createUnresolved ( TestConfig . IPV4_ADDR , portNum ) ) ; op . setHandlingNode ( node ) ; return op ; }
public void initialize ( ) { throw new RuntimeException ( " Not implemented . " ) ; }
public void readFromBuffer ( ByteBuffer data ) throws IOException { throw new RuntimeException ( " Not implemented " ) ; }
public void verifyOnComplete ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; future . addListener ( new GenericCompletionListener ( ) { @ Override public void onComplete ( Future future ) throws Exception { assertEquals ( " Hello World " , ( String ) future . get ( ) ) ; latch . countDown ( ) ; } } ) ; future . set ( " Hello World " ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; }
public void onComplete ( Future future ) throws Exception { assertEquals ( " Hello World " , ( String ) future . get ( ) ) ; latch . countDown ( ) ; }
public void verifyOnCompleteWhenAlreadyDone ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( true , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; future . addListener ( new GenericCompletionListener ( ) { @ Override public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; }
public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; }
public void verifyOnCompleteWhenCancelled ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; future . addListener ( new GenericCompletionListener ( ) { @ Override public void onComplete ( Future future ) throws Exception { assertTrue ( future . isCancelled ( ) ) ; latch . countDown ( ) ; } } ) ; future . cancel ( true ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; }
public void onComplete ( Future future ) throws Exception { assertTrue ( future . isCancelled ( ) ) ; latch . countDown ( ) ; }
public void verifyRemoval ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GenericCompletionListener listener = new GenericCompletionListener ( ) { @ Override public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } } ; future . addListener ( listener ) ; future . removeListener ( listener ) ; Thread . sleep ( 500 ) ; assertEquals ( 1 , latch . getCount ( ) ) ; }
public void verifyMultipleListeners ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; final GenericCompletionListener listener1 = new GenericCompletionListener ( ) { @ Override public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } } ; final GenericCompletionListener listener2 = new GenericCompletionListener ( ) { @ Override public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } } ; future . addListener ( listener1 ) ; future . addListener ( listener2 ) ; future . set ( " Hello World " ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; }
public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; }
public void testDataReadType ( ) throws Exception { SimpleOp op = new SimpleOp ( OperationReadType . DATA ) ; assertSame ( OperationReadType . DATA , op . getReadType ( ) ) ; try { op . handleLine ( " x " ) ; fail ( " Handled a line in data mode " ) ; } catch ( AssertionError e ) { } op . setBytesToRead ( 2 ) ; op . handleRead ( ByteBuffer . wrap ( " hi " . getBytes ( ) ) ) ; }
public void testLineReadType ( ) throws Exception { SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; assertSame ( OperationReadType . LINE , op . getReadType ( ) ) ; try { op . handleRead ( ByteBuffer . allocate ( 3 ) ) ; fail ( " Handled data in line mode " ) ; } catch ( AssertionError e ) { } op . handleLine ( " x " ) ; }
public void testPartialLine ( ) throws Exception { String input1 = " this is a " ; String input2 = " test \ r \ n " ; ByteBuffer b = ByteBuffer . allocate ( 20 ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; b . put ( input1 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertNull ( op . getCurrentLine ( ) ) ; b . clear ( ) ; b . put ( input2 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertEquals ( " this is a test " , op . getCurrentLine ( ) ) ; }
public void initialize ( ) { setBuffer ( ByteBuffer . allocate ( 0 ) ) ; }
public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }
public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }
public void testDelete ( ) { ( new DeleteOperationImpl ( " key " , null ) ) . toString ( ) ; }
public void testFlush ( ) { ( new FlushOperationImpl ( 0 , null ) ) . toString ( ) ; }
public void testGetAndTouch ( ) { ( new GetAndTouchOperationImpl ( " gat " , 15 , null , " key " ) ) . toString ( ) ; }
public void testTouch ( ) { ( new TouchOperationImpl ( " key " , 2 , null ) ) . toString ( ) ; }
public void testGetl ( ) { ( new GetlOperationImpl ( " key " , 10 , null ) ) . toString ( ) ; }
public void testGet ( ) { ( new GetOperationImpl ( " key " , null ) ) . toString ( ) ; }
public void testGets ( ) { ( new GetsOperationImpl ( " key " , null ) ) . toString ( ) ; }
public void testMutator ( ) { ( new MutatorOperationImpl ( Mutator . decr , " key " , 1 , null ) ) . toString ( ) ; }
public void testOptimizedGet ( ) { ( new OptimizedGetImpl ( new GetOperationImpl ( " key " , null ) ) ) . toString ( ) ; }
public void testStats ( ) { ( new StatsOperationImpl ( " hash " , null ) ) . toString ( ) ; }
public void testVersion ( ) { ( new VersionOperationImpl ( null ) ) . toString ( ) ; }
public void testEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( OperationErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException : GENERAL " , String . valueOf ( oe ) ) ; }
public void testGeneral ( ) { OperationException oe = new OperationException ( OperationErrorType . GENERAL , " GENERAL wtf " ) ; assertSame ( OperationErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException : GENERAL " , String . valueOf ( oe ) ) ; }
public void testOperationStatusString ( ) { String s = String . valueOf ( OperationImpl . STATUS_OK ) ; assertEquals ( " { OperationStatus success = true : OK } " , s ) ; }
public void testGetAndTouchOperationCloning ( ) { GetAndTouchOperation . Callback callback = ( GetAndTouchOperation . Callback ) mock ( GetAndTouchOperation . Callback . class ) . proxy ( ) ; GetAndTouchOperation op = ofact . getAndTouch ( TEST_KEY , 0 , callback ) ; GetAndTouchOperation op2 = cloneOne ( GetAndTouchOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op2 . getCallback ( ) ) ; }
public void testTouchOperationCloning ( ) { OperationCallback callback = ( OperationCallback ) mock ( OperationCallback . class ) . proxy ( ) ; TouchOperation op = ofact . touch ( TEST_KEY , 0 , callback ) ; TouchOperation op2 = cloneOne ( TouchOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op2 . getCallback ( ) ) ; }
public void testFlush ( ) { ( new FlushOperationImpl ( null ) ) . toString ( ) ; }
public void testGetAndTouch ( ) { ( new GetAndTouchOperationImpl ( " key " , 15 , null ) ) . toString ( ) ; }
public void testGetl ( ) { ( new GetlOperationImpl ( " key " , 0 , null ) ) . toString ( ) ; }
public void testMultiGet ( ) { ( new MultiGetOperationImpl ( Collections . singleton ( " key " ) , null ) ) . toString ( ) ; }
public void testMutator ( ) { ( new MutatorOperationImpl ( Mutator . decr , " key " , 1 , 0 , 15 , null ) ) . toString ( ) ; }
public void testNoop ( ) { ( new NoopOperationImpl ( null ) ) . toString ( ) ; }
public void testSASLAuth ( ) { ( new SASLAuthOperationImpl ( null , null , null , null , null ) ) . toString ( ) ; }
public void testSASLMechs ( ) { ( new SASLMechsOperationImpl ( null ) ) . toString ( ) ; }
public void testSASLStep ( ) { ( new SASLStepOperationImpl ( null , null , null , null , null , null ) ) . toString ( ) ; }
public void testStats ( ) { ( new StatsOperationImpl ( " dispatcher " , null ) ) . toString ( ) ; }
public void testTapAck ( ) { ( new TapAckOperationImpl ( TapOpcode . MUTATION , 10 , null ) ) . toString ( ) ; }
public void testTapBackfill ( ) { ( new TapBackfillOperationImpl ( null , 0 , null ) ) . toString ( ) ; }
public void testTapCustom ( ) { ( new TapCustomOperationImpl ( null , new RequestMessage ( ) , null ) ) . toString ( ) ; }
public void testTapDump ( ) { ( new TapDumpOperationImpl ( null , null ) ) . toString ( ) ; }
public void testTouch ( ) { ( new TouchOperationImpl ( " key " , 10 , null ) ) . toString ( ) ; }
public void testTapVersion ( ) { ( new VersionOperationImpl ( null ) ) . toString ( ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; tc = new SerializingTranscoder ( ) ; setTranscoder ( tc ) ; tu = new TranscoderUtils ( true ) ; }
public void testCompressedStringNotSmaller ( ) throws Exception { String s1 = " This is a test simple string that will not be compressed . " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( 0 , cd . getFlags ( ) ) ; assertTrue ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; }
public void testCompressedString ( ) throws Exception { String s1 = " aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertFalse ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; }
public void testObject ( ) throws Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; }
public void testCompressedObject ( ) throws Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; }
public void testUndecodeable ( ) throws Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; }
public void testUndecodeableSerialized ( ) throws Exception { CachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; }
public void testUndecodeableCompressed ( ) throws Exception { CachedData cd = new CachedData ( SerializingTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; System . out . println ( " got " + tc . decode ( cd ) ) ; assertNull ( tc . decode ( cd ) ) ; }
public void testToString ( ) throws Exception { String exp = " { CachedData flags = 13 data = [ 84 , 104 , 105 , 115 , 32 , 105 , " + " 115 , 32 , 97 , 32 , 115 , 105 , 109 , 112 , 108 , 101 , 32 , 116 , 101 , " + " 115 , 116 , 32 , 115 , 116 , 114 , 105 , 110 , 103 , 46 ] } " ; CachedData cd = new CachedData ( 13 , " This is a simple test string . " . getBytes ( " UTF - 8 " ) , CachedData . MAX_SIZE ) ; assertEquals ( exp , String . valueOf ( cd ) ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; setTranscoder ( new WhalinV1Transcoder ( ) ) ; }
public void testByteArray ( ) throws Exception { byte [ ] a = { ' a ' , ' b ' , ' c ' } ; CachedData cd = getTranscoder ( ) . encode ( a ) ; byte [ ] decoded = ( byte [ ] ) getTranscoder ( ) . decode ( cd ) ; assertNotNull ( decoded ) ; assertTrue ( Arrays . equals ( a , decoded ) ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; tu = new TranscoderUtils ( true ) ; }
public void testPackedLong ( ) { assertEquals ( " [ 1 ] " , Arrays . toString ( tu . encodeLong ( 1 ) ) ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; tc = new LongTranscoder ( ) ; }
public void testLong ( ) throws Exception { assertEquals ( 923 , tc . decode ( tc . encode ( 923L ) ) . longValue ( ) ) ; }
public void testDate ( ) throws Exception { Date d = new Date ( ) ; CachedData cd = tc . encode ( d ) ; assertEquals ( d , tc . decode ( cd ) ) ; }
public void testLong ( ) throws Exception { assertEquals ( 923L , tc . decode ( tc . encode ( 923L ) ) ) ; }
public void testInt ( ) throws Exception { assertEquals ( 923 , tc . decode ( tc . encode ( 923 ) ) ) ; }
public void testShort ( ) throws Exception { assertEquals ( ( short ) 923 , tc . decode ( tc . encode ( ( short ) 923 ) ) ) ; }
public void testChar ( ) throws Exception { assertEquals ( ' c ' , tc . decode ( tc . encode ( ' c ' ) ) ) ; }
public void testBoolean ( ) throws Exception { assertSame ( Boolean . TRUE , tc . decode ( tc . encode ( true ) ) ) ; assertSame ( Boolean . FALSE , tc . decode ( tc . encode ( false ) ) ) ; }
public void testByte ( ) throws Exception { assertEquals ( ( byte ) - 127 , tc . decode ( tc . encode ( ( byte ) - 127 ) ) ) ; }
public void testStringBuilder ( ) throws Exception { StringBuilder sb = new StringBuilder ( " test " ) ; StringBuilder sb2 = ( StringBuilder ) tc . decode ( tc . encode ( sb ) ) ; assertEquals ( sb . toString ( ) , sb2 . toString ( ) ) ; }
public void testStringBuffer ( ) throws Exception { StringBuffer sb = new StringBuffer ( " test " ) ; StringBuffer sb2 = ( StringBuffer ) tc . decode ( tc . encode ( sb ) ) ; assertEquals ( sb . toString ( ) , sb2 . toString ( ) ) ; }
private void assertFloat ( float f ) { assertEquals ( f , tc . decode ( tc . encode ( f ) ) ) ; }
public void testFloat ( ) throws Exception { assertFloat ( 0f ) ; assertFloat ( Float . MIN_VALUE ) ; assertFloat ( Float . MAX_VALUE ) ; assertFloat ( 3 . 14f ) ; assertFloat ( - 3 . 14f ) ; assertFloat ( Float . NaN ) ; assertFloat ( Float . POSITIVE_INFINITY ) ; assertFloat ( Float . NEGATIVE_INFINITY ) ; }
private void assertDouble ( double d ) { assertEquals ( d , tc . decode ( tc . encode ( d ) ) ) ; }
public void testDouble ( ) throws Exception { assertDouble ( 0d ) ; assertDouble ( Double . MIN_VALUE ) ; assertDouble ( Double . MAX_VALUE ) ; assertDouble ( 3 . 14d ) ; assertDouble ( - 3 . 14d ) ; assertDouble ( Double . NaN ) ; assertDouble ( Double . POSITIVE_INFINITY ) ; assertDouble ( Double . NEGATIVE_INFINITY ) ; }
private void assertLong ( long l ) { CachedData encoded = tc . encode ( l ) ; long decoded = ( Long ) tc . decode ( encoded ) ; assertEquals ( l , decoded ) ; }
public void testLongEncoding ( ) throws Exception { assertLong ( Long . MIN_VALUE ) ; assertLong ( 1 ) ; assertLong ( 23852 ) ; assertLong ( 0L ) ; assertLong ( - 1 ) ; assertLong ( - 23835 ) ; assertLong ( Long . MAX_VALUE ) ; }
private void assertInt ( int i ) { CachedData encoded = tc . encode ( i ) ; int decoded = ( Integer ) tc . decode ( encoded ) ; assertEquals ( i , decoded ) ; }
public void testIntEncoding ( ) throws Exception { assertInt ( Integer . MIN_VALUE ) ; assertInt ( 83526 ) ; assertInt ( 1 ) ; assertInt ( 0 ) ; assertInt ( - 1 ) ; assertInt ( - 238526 ) ; assertInt ( Integer . MAX_VALUE ) ; }
public void testBooleanEncoding ( ) throws Exception { assertTrue ( ( Boolean ) tc . decode ( tc . encode ( true ) ) ) ; assertFalse ( ( Boolean ) tc . decode ( tc . encode ( false ) ) ) ; }
public void testByteArray ( ) throws Exception { byte [ ] a = { ' a ' , ' b ' , ' c ' } ; CachedData cd = tc . encode ( a ) ; assertTrue ( Arrays . equals ( a , cd . getData ( ) ) ) ; assertTrue ( Arrays . equals ( a , ( byte [ ] ) tc . decode ( cd ) ) ) ; }
public void testStrings ( ) throws Exception { String s1 = " This is a simple test string . " ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; }
public void testUTF8String ( ) throws Exception { String s1 = " \ u2013 \ u00f3 \ u2013 \ u00a5 \ u2014 \ u00c4 \ u2013 \ u221e \ u2013 " + " \ u2264 \ u2014 \ u00c5 \ u2014 \ u00c7 \ u2013 \ u2264 \ u2014 \ u00c9 \ u2013 " + " \ u03c0 , \ u2013 \ u00ba \ u2013 \ u220f \ u2014 \ u00c4 . " ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; tc = new IntegerTranscoder ( ) ; }
public void testInt ( ) throws Exception { assertEquals ( 923 , tc . decode ( tc . encode ( 923 ) ) . intValue ( ) ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; tc = new WhalinTranscoder ( ) ; setTranscoder ( tc ) ; tu = new TranscoderUtils ( false ) ; }
public void testCompressedStringNotSmaller ( ) throws Exception { String s1 = " This is a test simple string that will not be compressed . " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( WhalinTranscoder . SPECIAL_STRING , cd . getFlags ( ) ) ; assertTrue ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; }
public void testCompressedString ( ) throws Exception { String s1 = " aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SPECIAL_STRING , cd . getFlags ( ) ) ; assertFalse ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; }
public void testObject ( ) throws Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; }
public void testCompressedObject ( ) throws Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED | WhalinTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; }
public void testUndecodeable ( ) throws Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; }
public void testUndecodeableSerialized ( ) throws Exception { CachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; }
public void testUndecodeableCompressed ( ) throws Exception { CachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; ts = new TranscodeService ( false ) ; }
protected void tearDown ( ) throws Exception { ts . shutdown ( ) ; assertTrue ( ts . isShutdown ( ) ) ; super . tearDown ( ) ; }
public void testNonExecuting ( ) throws Exception { CachedData cd = new CachedData ( 0 , new byte [ 0 ] , 0 ) ; Future < String > fs = ts . decode ( new TestTranscoder ( ) , cd ) ; assertEquals ( " Stuff ! " , fs . get ( ) ) ; }
public void testExecuting ( ) throws Exception { CachedData cd = new CachedData ( 1 , new byte [ 0 ] , 0 ) ; Future < String > fs = ts . decode ( new TestTranscoder ( ) , cd ) ; assertEquals ( " Stuff ! " , fs . get ( ) ) ; }
public boolean asyncDecode ( CachedData d ) { return d . getFlags ( ) = = 1 ; }
public String decode ( CachedData d ) { return " Stuff ! " ; }
public CachedData encode ( String o ) { throw new RuntimeException ( " Not invoked . " ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; ex = new Exposer ( ) ; }
public void testValidCharacterSet ( ) { ex . setCharset ( " KOI8 " ) ; }
public void testDecodeStringNull ( ) { assertNull ( ex . decodeString ( null ) ) ; }
public void testDeserializeNull ( ) { assertNull ( ex . deserialize ( null ) ) ; }
public void testDecompressNull ( ) { assertNull ( ex . decompress ( null ) ) ; }
public void testUndeserializable ( ) throws Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 115 , 114 , 0 , 4 , 84 , 101 , 115 , 116 , 2 , 61 , 102 , - 87 , - 28 , 17 , 52 , 30 , 2 , 0 , 1 , 73 , 0 , 9 , 115 , 111 , 109 , 101 , 116 , 104 , 105 , 110 , 103 , 120 , 112 , 0 , 0 , 0 , 5 } ; assertNull ( ex . deserialize ( data ) ) ; }
public void testDeserializable ( ) throws Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 116 , 0 , 5 , 104 , 101 , 108 , 108 , 111 } ; assertEquals ( " hello " , ex . deserialize ( data ) ) ; }
public void overrideCharsetSet ( String to ) { charset = to ; }
public byte [ ] compress ( byte [ ] in ) { return super . compress ( in ) ; }
public String decodeString ( byte [ ] data ) { return super . decodeString ( data ) ; }
public byte [ ] decompress ( byte [ ] in ) { return super . decompress ( in ) ; }
public Object deserialize ( byte [ ] in ) { return super . deserialize ( in ) ; }
public byte [ ] encodeString ( String in ) { return super . encodeString ( in ) ; }
public byte [ ] serialize ( Object o ) { return super . serialize ( o ) ; }
public void shutdown ( ) throws Exception { client . shutdown ( ) ; }
public void run ( ) { System . out . println ( " Available mechs : " + client . listSaslMechanisms ( ) ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } client . getVersions ( ) ; }
public static void main ( String [ ] a ) throws Exception { AuthTest lt = new AuthTest ( " testuser " , " testpass " ) ; lt . init ( ) ; long start = System . currentTimeMillis ( ) ; try { lt . run ( ) ; } finally { lt . shutdown ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( " Runtime : " + ( end - start ) + " ms " ) ; }
public static void main ( String [ ] args ) throws Exception { new ExcessivelyLargeGetTest ( ) . run ( ) ; }
public static void main ( String [ ] a ) throws Exception { LoaderTest lt = new LoaderTest ( 1000000 ) ; lt . init ( ) ; long start = System . currentTimeMillis ( ) ; try { lt . run ( ) ; } finally { lt . shutdown ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( " Runtime : " + ( end - start ) + " ms " ) ; }
public void connectionLost ( SocketAddress sa ) { System . out . println ( " * * * Lost connection : " + sa ) ; }
public boolean isDaemon ( ) { return false ; }
public void testCrap ( ) throws Exception { main ( new String [ ] { " 10000 " , " 100 " , " 11211 " , " 100 " } ) ; }
public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; }
public BlockingQueue < Operation > createReadOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }
public BlockingQueue < Operation > createWriteOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new ArrayModNodeLocator ( nodes , getHashAlg ( ) ) ; }
public Thread newThread ( Runnable r ) { return new Thread ( r , " FutureNotifyListener " ) ; }
public boolean isDefaultExecutorService ( ) { return true ; }
public boolean useNagleAlgorithm ( ) { return false ; }
public boolean shouldOptimize ( ) { return false ; }
public void remove ( ) { throw new UnsupportedOperationException ( " remove not supported " ) ; }
public void clear ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean containsKey ( Object key ) { return get ( key ) ! = null ; }
public boolean containsValue ( Object value ) { return false ; }
public Set < Map . Entry < String , V > > entrySet ( ) { return Collections . emptySet ( ) ; }
public V get ( Object key ) { V rv = null ; try { rv = client . get ( getKey ( ( String ) key ) , transcoder ) ; } catch ( ClassCastException e ) { } return rv ; }
public Set < String > keySet ( ) { return Collections . emptySet ( ) ; }
public V remove ( Object key ) { V rv = null ; try { rv = get ( key ) ; client . delete ( getKey ( ( String ) key ) ) ; } catch ( ClassCastException e ) { } return rv ; }
public Collection < V > values ( ) { return Collections . emptySet ( ) ; }
public V put ( String key , V value ) { V rv = get ( key ) ; client . set ( getKey ( key ) , exp , value ) ; return rv ; }
public String toString ( ) { return root . toString ( ) ; }
public void addOp ( Operation op ) { throw new UnsupportedOperationException ( ) ; }
public void insertOp ( Operation op ) { throw new UnsupportedOperationException ( ) ; }
public void connected ( ) { throw new UnsupportedOperationException ( ) ; }
public void copyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; }
public void fillWriteBuffer ( boolean optimizeGets ) { throw new UnsupportedOperationException ( ) ; }
public void fixupOps ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean hasReadOp ( ) { return root . hasReadOp ( ) ; }
public boolean hasWriteOp ( ) { return root . hasReadOp ( ) ; }
public boolean isActive ( ) { return root . isActive ( ) ; }
public void reconnecting ( ) { throw new UnsupportedOperationException ( ) ; }
public void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) { throw new UnsupportedOperationException ( ) ; }
public Operation removeCurrentReadOp ( ) { throw new UnsupportedOperationException ( ) ; }
public Operation removeCurrentWriteOp ( ) { throw new UnsupportedOperationException ( ) ; }
public void setupResend ( ) { throw new UnsupportedOperationException ( ) ; }
public void transitionWriteItem ( ) { throw new UnsupportedOperationException ( ) ; }
public int writeSome ( ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public Collection < Operation > destroyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; }
public void authComplete ( ) { throw new UnsupportedOperationException ( ) ; }
public void setupForAuth ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean isAuthenticated ( ) { throw new UnsupportedOperationException ( ) ; }
public long lastReadDelta ( ) { throw new UnsupportedOperationException ( ) ; }
public void completedRead ( ) { throw new UnsupportedOperationException ( ) ; }
public void updateLocator ( List < MemcachedNode > newNodes ) { this . nodes = newNodes . toArray ( new MemcachedNode [ newNodes . size ( ) ] ) ; }
public void remove ( ) { throw new UnsupportedOperationException ( " Can ' t remove a node " ) ; }
public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = ( MessageDigest ) md5Digest . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( " clone of MD5 not supported " , e ) ; } md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; }
public void updateLocator ( List < MemcachedNode > nodes ) { allNodes = nodes ; setKetamaNodes ( nodes ) ; }
public String toString ( ) { return " { CasValue " + cas + " / " + value + " } " ; }
public static synchronized void registerHashAlgorithm ( String name , HashAlgorithm alg ) { validateName ( name ) ; validateAlgorithm ( alg ) ; REGISTRY . put ( name . toLowerCase ( ) , alg ) ; }
public static synchronized HashAlgorithm lookupHashAlgorithm ( String name ) { validateName ( name ) ; return REGISTRY . get ( name . toLowerCase ( ) ) ; }
public ConnectionFactoryBuilder setInitialObservers ( Collection < ConnectionObserver > obs ) { initialObservers = obs ; return this ; }
public boolean isDaemon ( ) { return isDaemon ; }
public boolean shouldOptimize ( ) { return shouldOptimize ; }
public boolean useNagleAlgorithm ( ) { return useNagle ; }
public MetricType enableMetrics ( ) { return metricType = = null ? super . enableMetrics ( ) : metricType ; }
public boolean isDefaultExecutorService ( ) { return executorService = = null ; }
public void addTapAckOp ( MemcachedNode node , final Operation op ) { conn . addOperation ( node , op ) ; }
public CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of , conn . getLocator ( ) . getAll ( ) ) ; }
public boolean removeObserver ( ConnectionObserver obs ) { return conn . removeObserver ( obs ) ; }
public void shutdown ( ) { shutdown ( - 1 , TimeUnit . MILLISECONDS ) ; }
public void complete ( ) { latch . countDown ( ) ; }
private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of , nodes ) ; }
public CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , mconn . getLocator ( ) . getAll ( ) , true ) ; }
public CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { return broadcastOp ( of , nodes , true ) ; }
private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return mconn . broadcastOperation ( of , nodes ) ; }
public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; }
public void gotData ( String key , long cas ) { rv . setCas ( cas ) ; }
public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; }
private OperationFuture < Boolean > asyncStore ( StoreType storeType , String key , int exp , Object value ) { return asyncStore ( storeType , key , exp , value , transcoder ) ; }
private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > tc ) { CachedData co = tc . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { @ Override public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } @ Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; }
public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; }
public < T > OperationFuture < Boolean > touch ( final String key , final int exp ) { return touch ( key , exp , transcoder ) ; }
public < T > OperationFuture < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . touch ( key , exp , new OperationCallback ( ) { @ Override public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } @ Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; }
public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; }
public OperationFuture < Boolean > append ( long cas , String key , Object val ) { return append ( cas , key , val , transcoder ) ; }
public OperationFuture < Boolean > append ( String key , Object val ) { return append ( 0 , key , val , transcoder ) ; }
public < T > OperationFuture < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) { return asyncCat ( ConcatenationType . append , cas , key , val , tc ) ; }
public < T > OperationFuture < Boolean > append ( String key , T val , Transcoder < T > tc ) { return asyncCat ( ConcatenationType . append , 0 , key , val , tc ) ; }
public OperationFuture < Boolean > prepend ( long cas , String key , Object val ) { return prepend ( cas , key , val , transcoder ) ; }
public OperationFuture < Boolean > prepend ( String key , Object val ) { return prepend ( 0 , key , val , transcoder ) ; }
public < T > OperationFuture < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) { return asyncCat ( ConcatenationType . prepend , cas , key , val , tc ) ; }
public < T > OperationFuture < Boolean > prepend ( String key , T val , Transcoder < T > tc ) { return asyncCat ( ConcatenationType . prepend , 0 , key , val , tc ) ; }
public < T > OperationFuture < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) { return asyncCAS ( key , casId , 0 , value , tc ) ; }
public OperationFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) { return asyncCAS ( key , casId , value , transcoder ) ; }
public OperationFuture < CASResponse > asyncCAS ( String key , long casId , int exp , Object value ) { return asyncCAS ( key , casId , exp , value , transcoder ) ; }
public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) { return cas ( key , casId , 0 , value , tc ) ; }
public CASResponse cas ( String key , long casId , Object value ) { return cas ( key , casId , value , transcoder ) ; }
public CASResponse cas ( String key , long casId , int exp , Object value ) { return cas ( key , casId , exp , value , transcoder ) ; }
public < T > OperationFuture < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) { return asyncStore ( StoreType . add , key , exp , o , tc ) ; }
public OperationFuture < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreType . add , key , exp , o , transcoder ) ; }
public < T > OperationFuture < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) { return asyncStore ( StoreType . set , key , exp , o , tc ) ; }
public OperationFuture < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreType . set , key , exp , o , transcoder ) ; }
public < T > OperationFuture < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) { return asyncStore ( StoreType . replace , key , exp , o , tc ) ; }
public OperationFuture < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreType . replace , key , exp , o , transcoder ) ; }
public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key , executorService ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val ; @ Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @ Override public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = tcService . decode ( tc , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } @ Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; }
public GetFuture < Object > asyncGet ( final String key ) { return asyncGet ( key , transcoder ) ; }
public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val ; @ Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @ Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } @ Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
public OperationFuture < CASValue < Object > > asyncGets ( final String key ) { return asyncGets ( key , transcoder ) ; }
public CASValue < Object > gets ( String key ) { return gets ( key , transcoder ) ; }
public Object get ( String key ) { return get ( key , transcoder ) ; }
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcIter ) { return asyncGetBulk ( keys . iterator ( ) , tcIter ) ; }
public BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keyIter ) { return asyncGetBulk ( keyIter , transcoder ) ; }
public BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { return asyncGetBulk ( keys , transcoder ) ; }
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , tc ) ; }
public BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , transcoder ) ; }
public OperationFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) { return asyncGetAndTouch ( key , exp , transcoder ) ; }
public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val ; @ Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @ Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } @ Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; }
public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) { return getBulk ( keys . iterator ( ) , tc ) ; }
public void receivedStatus ( OperationStatus s ) { rv . put ( sa , s . getMessage ( ) ) ; }
public void gotStat ( String name , String val ) { rv . get ( sa ) . put ( name , val ) ; }
private long mutate ( Mutator m , String key , long by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; mconn . enqueueOperation ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @ Override public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " - 1 " ) ) ; } @ Override public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { if ( ! latch . await ( operationTimeout , TimeUnit . MILLISECONDS ) ) { throw new OperationTimeoutException ( " Mutate operation timed out , " + " unable to modify counter [ " + key + ' ] ' ) ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned % s " , rv ) ; return rv . get ( ) ; }
public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " - 1 " ) ) ; }
public void complete ( ) { latch . countDown ( ) ; }
public long incr ( String key , long by ) { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; }
public long incr ( String key , int by ) { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; }
public long decr ( String key , long by ) { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; }
public long decr ( String key , int by ) { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; }
public long incr ( String key , long by , long def , int exp ) { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; }
public long incr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; }
public long decr ( String key , long by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; }
public long decr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; }
private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { if ( ! ( opFact instanceof BinaryOperationFactory ) & & ( def ! = 0 | | exp ! = - 1 ) ) { throw new UnsupportedOperationException ( " Default value or expiration " + " time are not supported on the async mutate methods . Use either the " + " binary protocol or the sync variant . " ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @ Override public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " - 1 " ) , s ) ; } @ Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; }
public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " - 1 " ) , s ) ; }
public OperationFuture < Long > asyncIncr ( String key , long by ) { return asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; }
public OperationFuture < Long > asyncIncr ( String key , int by ) { return asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; }
public OperationFuture < Long > asyncDecr ( String key , long by ) { return asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; }
public OperationFuture < Long > asyncDecr ( String key , int by ) { return asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; }
public OperationFuture < Long > asyncIncr ( String key , long by , long def , int exp ) { return asyncMutate ( Mutator . incr , key , by , def , exp ) ; }
public OperationFuture < Long > asyncIncr ( String key , int by , long def , int exp ) { return asyncMutate ( Mutator . incr , key , by , def , exp ) ; }
public OperationFuture < Long > asyncDecr ( String key , long by , long def , int exp ) { return asyncMutate ( Mutator . decr , key , by , def , exp ) ; }
public OperationFuture < Long > asyncDecr ( String key , int by , long def , int exp ) { return asyncMutate ( Mutator . decr , key , by , def , exp ) ; }
public OperationFuture < Long > asyncIncr ( String key , long by , long def ) { return asyncMutate ( Mutator . incr , key , by , def , 0 ) ; }
public OperationFuture < Long > asyncIncr ( String key , int by , long def ) { return asyncMutate ( Mutator . incr , key , by , def , 0 ) ; }
public OperationFuture < Long > asyncDecr ( String key , long by , long def ) { return asyncMutate ( Mutator . decr , key , by , def , 0 ) ; }
public OperationFuture < Long > asyncDecr ( String key , int by , long def ) { return asyncMutate ( Mutator . decr , key , by , def , 0 ) ; }
public long incr ( String key , long by , long def ) { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }
public long incr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }
public long decr ( String key , long by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; }
public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; }
public OperationFuture < Boolean > delete ( String key , int hold ) { return delete ( key ) ; }
public OperationFuture < Boolean > delete ( String key ) { return delete ( key , 0L ) ; }
public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { @ Override public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } @ Override public void gotData ( long cas ) { rv . setCas ( cas ) ; } @ Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ; DeleteOperation op ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; }
public void gotData ( long cas ) { rv . setCas ( cas ) ; }
public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { @ Override public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } @ Override public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; }
public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; }
public void set ( Boolean o , OperationStatus s ) { super . set ( o , s ) ; notifyListeners ( ) ; }
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; } notifyListeners ( ) ; return rv ; }
public Boolean get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { status = new OperationStatus ( true , " OK " , StatusCode . SUCCESS ) ; return super . get ( duration , units ) ; }
public boolean isCancelled ( ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . isCancelled ( ) ; } return rv ; }
public boolean isDone ( ) { boolean rv = true ; for ( Operation op : ops ) { rv & = op . getState ( ) = = OperationState . COMPLETE ; } return rv | | isCancelled ( ) ; }
public OperationFuture < Boolean > flush ( ) { return flush ( - 1 ) ; }
public boolean removeObserver ( ConnectionObserver obs ) { return mconn . removeObserver ( obs ) ; }
private String buildTimeoutMessage ( long timeWaited , TimeUnit unit ) { StringBuilder message = new StringBuilder ( ) ; message . append ( MessageFormat . format ( " waited { 0 } ms . " , unit . convert ( timeWaited , TimeUnit . MILLISECONDS ) ) ) ; message . append ( " Node status : " ) . append ( mconn . connectionsStatus ( ) ) ; return message . toString ( ) ; }
public String toString ( ) { return connFactory . toString ( ) ; }
protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > addrs ) throws IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( addrs . size ( ) ) ; for ( SocketAddress sa : addrs ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; qa . setConnection ( this ) ; int ops = 0 ; Socket socket = ch . socket ( ) ; socket . setTcpNoDelay ( ! connectionFactory . useNagleAlgorithm ( ) ) ; socket . setKeepAlive ( connectionFactory . getKeepAlive ( ) ) ; try { if ( ch . connect ( sa ) ) { getLogger ( ) . info ( " Connected to % s immediately " , qa ) ; connected ( qa ) ; } else { getLogger ( ) . info ( " Added % s to connect queue " , qa ) ; ops = SelectionKey . OP_CONNECT ; } selector . wakeup ( ) ; qa . setSk ( ch . register ( selector , ops , qa ) ) ; assert ch . isConnected ( ) | | qa . getSk ( ) . interestOps ( ) = = SelectionKey . OP_CONNECT : " Not connected , and not wanting to connect " ; } catch ( SocketException e ) { getLogger ( ) . warn ( " Socket error on initial connect " , e ) ; queueReconnect ( qa ) ; } connections . add ( qa ) ; } return connections ; }
public void handleIO ( ) throws IOException { if ( shutDown ) { getLogger ( ) . debug ( " No IO while shut down . " ) ; return ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue . " ) ; long delay = wakeupDelay ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of % sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don ' t make sense . " ; int selected = selector . select ( delay ) ; if ( shutDown ) { return ; } else if ( selected = = 0 & & addedQueue . isEmpty ( ) ) { handleWokenUpSelector ( ) ; } else if ( selector . selectedKeys ( ) . isEmpty ( ) ) { handleEmptySelects ( ) ; } else { getLogger ( ) . debug ( " Selected % d , selected % d keys " , selected , selector . selectedKeys ( ) . size ( ) ) ; emptySelects = 0 ; Iterator < SelectionKey > iterator = selector . selectedKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { SelectionKey sk = iterator . next ( ) ; handleIO ( sk ) ; iterator . remove ( ) ; } } handleOperationalTasks ( ) ; }
private void handleOperationalTasks ( ) throws IOException { checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } if ( ! retryOps . isEmpty ( ) ) { ArrayList < Operation > operations = new ArrayList < Operation > ( retryOps ) ; retryOps . clear ( ) ; redistributeOperations ( operations ) ; } handleShutdownQueue ( ) ; }
public boolean addObserver ( final ConnectionObserver obs ) { return connObservers . add ( obs ) ; }
public boolean removeObserver ( final ConnectionObserver obs ) { return connObservers . remove ( obs ) ; }
private void handleIO ( final SelectionKey sk ) { MemcachedNode node = ( MemcachedNode ) sk . attachment ( ) ; try { getLogger ( ) . debug ( " Handling IO for : % s ( r = % s , w = % s , c = % s , op = % s ) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; if ( sk . isConnectable ( ) & & belongsToCluster ( node ) ) { getLogger ( ) . debug ( " Connection state changed for % s " , sk ) ; final SocketChannel channel = node . getChannel ( ) ; if ( channel . finishConnect ( ) ) { finishConnect ( sk , node ) ; } else { assert ! channel . isConnected ( ) : " connected " ; } } else { handleReadsAndWrites ( sk , node ) ; } } catch ( ClosedChannelException e ) { if ( ! shutDown ) { getLogger ( ) . info ( " Closed channel and not shutting down . Queueing " + " reconnect on % s " , node , e ) ; lostConnection ( node ) ; } } catch ( ConnectException e ) { getLogger ( ) . info ( " Reconnecting due to failure to connect to % s " , node , e ) ; queueReconnect ( node ) ; } catch ( OperationException e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnection due to exception handling a memcached " + " operation on % s . This may be due to an authentication failure . " , node , e ) ; lostConnection ( node ) ; } catch ( Exception e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnecting due to exception on % s " , node , e ) ; lostConnection ( node ) ; } node . fixupOps ( ) ; }
public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; }
public void enqueueOperation ( final String key , final Operation o ) { checkState ( ) ; StringUtils . validateKey ( key , opFact instanceof BinaryOperationFactory ) ; addOperation ( key , o ) ; }
public void insertOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . insertOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector . " ; getLogger ( ) . debug ( " Added % s to % s " , o , node ) ; }
protected void addOperation ( final MemcachedNode node , final Operation o ) { if ( ! node . isAuthenticated ( ) ) { retryOperation ( o ) ; return ; } o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector . " ; getLogger ( ) . debug ( " Added % s to % s " , o , node ) ; }
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of ) { return broadcastOperation ( of , locator . getAll ( ) ) ; }
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , final Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( nodes . size ( ) ) ; for ( MemcachedNode node : nodes ) { getLogger ( ) . debug ( " broadcast Operation : node = " + node ) ; Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector . " ; return latch ; }
public static void opTimedOut ( final Operation op ) { MemcachedConnection . setTimeout ( op , true ) ; }
public static void opSucceeded ( final Operation op ) { MemcachedConnection . setTimeout ( op , false ) ; }
protected void checkState ( ) { if ( shutDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running . " ; }
public void run ( ) { while ( running ) { try { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } catch ( ConcurrentModificationException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; }
public boolean isShutDown ( ) { return shutDown ; }
public TapStream tapCustom ( final String id , final RequestMessage message ) throws ConfigurationException , IOException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final TapStream ts = new TapStream ( ) ; conn . broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; } } ) ; synchronized ( omap ) { omap . put ( ts , conn ) ; } return ts ; }
public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; }
public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; }
public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; }
public void complete ( ) { latch . countDown ( ) ; }
public TapStream tapDump ( final String id ) throws IOException , ConfigurationException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final TapStream ts = new TapStream ( ) ; conn . broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; } } ) ; synchronized ( omap ) { omap . put ( ts , conn ) ; } return ts ; }
public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; }
private void tapAck ( TapConnectionProvider conn , MemcachedNode node , TapOpcode opcode , int opaque , OperationCallback cb ) { final Operation op = conn . getOpFactory ( ) . tapAck ( opcode , opaque , cb ) ; conn . addTapAckOp ( node , op ) ; }
public void decrementCounter ( String name ) { decrementCounter ( name , 1 ) ; }
public void incrementCounter ( String name ) { incrementCounter ( name , 1 ) ; }
public void addCounter ( String name ) { return ; }
public void removeCounter ( String name ) { return ; }
public void incrementCounter ( String name , int amount ) { return ; }
public void decrementCounter ( String name , int amount ) { return ; }
public void removeMeter ( String name ) { return ; }
public void addHistogram ( String name ) { return ; }
public void removeHistogram ( String name ) { return ; }
public void updateHistogram ( String name , int amount ) { return ; }
public void setvBucketCheckpoints ( Map < Short , Long > vbchkpnts ) { int oldSize = ( vBucketCheckpoints . size ( ) ) * 10 ; int newSize = ( vbchkpnts . size ( ) ) * 10 ; totalbody + = newSize - oldSize ; vBucketCheckpoints = vbchkpnts ; }
public void doBackfill ( long date ) { message . setBackfill ( date ) ; message . setFlags ( TapRequestFlag . BACKFILL ) ; }
public void doDump ( ) { message . setFlags ( TapRequestFlag . DUMP ) ; }
public void specifyVbuckets ( short [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapRequestFlag . LIST_VBUCKETS ) ; }
public void supportAck ( ) { message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; }
public void keysOnly ( ) { message . setFlags ( TapRequestFlag . KEYS_ONLY ) ; }
public void takeoverVbuckets ( short [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapRequestFlag . TAKEOVER_VBUCKETS ) ; }
public boolean isCancelled ( ) { for ( TapOperation op : ops ) { if ( ! op . isCancelled ( ) ) { return false ; } } return true ; }
public boolean hasErrored ( ) { for ( TapOperation op : ops ) { if ( ! op . hasErrored ( ) ) { return false ; } } return true ; }
public void addOp ( TapOperation op ) { ops . add ( op ) ; }
private Object deserialize ( ) { SerializingTranscoder tc = new SerializingTranscoder ( ) ; CachedData d = new CachedData ( this . getItemFlags ( ) , this . getValue ( ) , CachedData . MAX_SIZE ) ; Object rv = null ; rv = tc . decode ( d ) ; return rv ; }
public void run ( ) { try { barrier . await ( ) ; rv = callable . call ( ) ; } catch ( Throwable t ) { throwable = t ; } latch . countDown ( ) ; }
public T getResult ( ) throws Throwable { latch . await ( ) ; if ( throwable ! = null ) { throw throwable ; } return rv ; }
public static < T > int getDistinctResultCount ( int num , Callable < T > callable ) throws Throwable { IdentityHashMap < T , Object > found = new IdentityHashMap < T , Object > ( ) ; Collection < SyncThread < T > > threads = getCompletedThreads ( num , callable ) ; for ( SyncThread < T > s : threads ) { found . put ( s . getResult ( ) , new Object ( ) ) ; } return found . size ( ) ; }
public void trace ( Object message , Throwable exception ) { log ( Level . TRACE , message , exception ) ; }
public void trace ( Object message ) { trace ( message , null ) ; }
public void debug ( Object message , Throwable exception ) { log ( Level . DEBUG , message , exception ) ; }
public void debug ( Object message ) { debug ( message , null ) ; }
public void info ( Object message , Throwable exception ) { log ( Level . INFO , message , exception ) ; }
public void info ( Object message ) { info ( message , null ) ; }
public void warn ( Object message , Throwable exception ) { log ( Level . WARN , message , exception ) ; }
public void warn ( String message , Object . . . args ) { warn ( String . format ( message , args ) , getThrowable ( args ) ) ; }
public void warn ( Object message ) { warn ( message , null ) ; }
public void error ( Object message , Throwable exception ) { log ( Level . ERROR , message , exception ) ; }
public void error ( String message , Object . . . args ) { error ( String . format ( message , args ) , getThrowable ( args ) ) ; }
public void error ( Object message ) { error ( message , null ) ; }
public void fatal ( Object message , Throwable exception ) { log ( Level . FATAL , message , exception ) ; }
public void fatal ( String message , Object . . . args ) { fatal ( String . format ( message , args ) , getThrowable ( args ) ) ; }
public void fatal ( Object message ) { fatal ( message , null ) ; }
public void log ( Level level , Object message ) { log ( level , message , null ) ; }
public boolean isTraceEnabled ( ) { return logger . isTraceEnabled ( ) ; }
public boolean isDebugEnabled ( ) { return logger . isDebugEnabled ( ) ; }
public boolean isInfoEnabled ( ) { return logger . isInfoEnabled ( ) ; }
public boolean isTraceEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . FINEST ) ) ; }
public boolean isDebugEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . FINE ) ) ; }
public boolean isInfoEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . INFO ) ) ; }
private Logger internalGetLogger ( String name ) { assert name ! = null : " Name was null " ; Logger rv = instances . get ( name ) ; if ( rv = = null ) { Logger newLogger = null ; try { newLogger = getNewInstance ( name ) ; } catch ( Exception e ) { throw new RuntimeException ( " Problem getting logger " , e ) ; } Logger tmp = instances . putIfAbsent ( name , newLogger ) ; rv = tmp = = null ? newLogger : tmp ; } return ( rv ) ; }
private Logger getNewInstance ( String name ) throws InstantiationException , IllegalAccessException , InvocationTargetException { if ( instanceConstructor = = null ) { getConstructor ( ) ; } Object [ ] args = { name } ; Logger rv = instanceConstructor . newInstance ( args ) ; return ( rv ) ; }
public boolean isTraceEnabled ( ) { return ( false ) ; }
public boolean isDebugEnabled ( ) { return ( false ) ; }
public boolean isInfoEnabled ( ) { return ( true ) ; }
public String toString ( ) { return ( " { LogLevel : " + name ( ) + " } " ) ; }
public boolean isTraceEnabled ( ) { return ( l4jLogger . isTraceEnabled ( ) ) ; }
public boolean isDebugEnabled ( ) { return ( l4jLogger . isDebugEnabled ( ) ) ; }
public boolean isInfoEnabled ( ) { return ( l4jLogger . isInfoEnabled ( ) ) ; }
public void log ( Level level , Object message , Throwable e ) { org . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; switch ( level = = null ? Level . FATAL : level ) { case TRACE : pLevel = org . apache . log4j . Level . TRACE ; break ; case DEBUG : pLevel = org . apache . log4j . Level . DEBUG ; break ; case INFO : pLevel = org . apache . log4j . Level . INFO ; break ; case WARN : pLevel = org . apache . log4j . Level . WARN ; break ; case ERROR : pLevel = org . apache . log4j . Level . ERROR ; break ; case FATAL : pLevel = org . apache . log4j . Level . FATAL ; break ; default : pLevel = org . apache . log4j . Level . FATAL ; l4jLogger . log ( " net . spy . compat . log . AbstractLogger " , pLevel , " Unhandled " + " log level : " + level + " for the following message " , null ) ; } l4jLogger . log ( " net . spy . compat . log . AbstractLogger " , pLevel , message , e ) ; }
public static String join ( final Collection < String > chunks , final String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! chunks . isEmpty ( ) ) { Iterator < String > itr = chunks . iterator ( ) ; sb . append ( itr . next ( ) ) ; while ( itr . hasNext ( ) ) { sb . append ( delimiter ) ; sb . append ( itr . next ( ) ) ; } } return sb . toString ( ) ; }
public < T > Future < ? > loadData ( Iterator < Map . Entry < String , T > > i ) { Future < Boolean > mostRecent = null ; while ( i . hasNext ( ) ) { Map . Entry < String , T > e = i . next ( ) ; mostRecent = push ( e . getKey ( ) , e . getValue ( ) ) ; watch ( e . getKey ( ) , mostRecent ) ; } return mostRecent = = null ? new ImmediateFuture ( true ) : mostRecent ; }
public < T > Future < ? > loadData ( Map < String , T > map ) { return loadData ( map . entrySet ( ) . iterator ( ) ) ; }
public < T > Future < Boolean > push ( String k , T value ) { Future < Boolean > rv = null ; while ( rv = = null ) { try { rv = client . set ( k , expiration , value ) ; } catch ( IllegalStateException ex ) { try { if ( rv ! = null ) { rv . get ( 250 , TimeUnit . MILLISECONDS ) ; } else { Thread . sleep ( 250 ) ; } } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; } catch ( Exception e2 ) { } } } return rv ; }
public synchronized void authConnection ( MemcachedConnection conn , OperationFactory opFact , AuthDescriptor authDescriptor , MemcachedNode node ) { interruptOldAuth ( node ) ; AuthThread newSASLAuthenticator = new AuthThread ( conn , opFact , authDescriptor , node ) ; nodeMap . put ( node , newSASLAuthenticator ) ; }
protected String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @ Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs : " + status . getMessage ( ) ) ; } else { getLogger ( ) . warn ( " Received non - success response for SASL mechs : " + status ) ; } } @ Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; try { if ( ! conn . isShutDown ( ) ) { listMechsLatch . await ( ) ; } else { done . set ( true ) ; } } catch ( InterruptedException ex ) { getLogger ( ) . warn ( " Interrupted in Auth while waiting for SASL mechs . " ) ; Thread . currentThread ( ) . interrupt ( ) ; if ( listMechsOp ! = null ) { listMechsOp . cancel ( ) ; } done . set ( true ) ; } String supported = supportedMechs . get ( ) ; if ( supported = = null | | supported . isEmpty ( ) ) { return null ; } return supported . split ( MECH_SEPARATOR ) ; }
public void complete ( ) { listMechsLatch . countDown ( ) ; }
public boolean cancel ( boolean mayInterruptIfRunning ) { return false ; }
public Boolean get ( ) throws InterruptedException , ExecutionException { if ( exception ! = null ) { throw exception ; } return value ; }
public Boolean get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( exception ! = null ) { throw exception ; } return value ; }
public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; notifyListeners ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; }
public boolean cancel ( ) { assert op ! = null : " No operation " ; op . cancel ( ) ; notifyListeners ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; }
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { MemcachedConnection . opTimedOut ( op ) ; if ( op ! = null ) { op . timeOut ( ) ; } throw new CheckedOperationTimeoutException ( " Timed out waiting for operation " , op ) ; } else { MemcachedConnection . opSucceeded ( op ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new CancellationException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { throw new ExecutionException ( new CheckedOperationTimeoutException ( " Operation timed out . " , op ) ) ; } return objRef . get ( ) ; }
public void set ( T o , OperationStatus s ) { objRef . set ( o ) ; status = s ; }
public boolean isCancelled ( ) { assert op ! = null : " No operation " ; return op . isCancelled ( ) ; }
public OperationFuture < T > addListener ( OperationCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return this ; }
public OperationFuture < T > removeListener ( OperationCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return this ; }
public void signalComplete ( ) { notifyListeners ( ) ; }
private static String createMessage ( String message , Collection < Operation > ops ) { StringBuilder rv = new StringBuilder ( message ) ; rv . append ( " - failing node " ) ; rv . append ( ops . size ( ) = = 1 ? " : " : " s : " ) ; boolean first = true ; for ( Operation op : ops ) { if ( first ) { first = false ; } else { rv . append ( " , " ) ; } MemcachedNode node = op = = null ? null : op . getHandlingNode ( ) ; rv . append ( node = = null ? " < unknown > " : node . getSocketAddress ( ) ) ; } return rv . toString ( ) ; }
public Thread newThread ( Runnable r ) { Thread t = new Thread ( r , namePrefix + threadNumber . getAndIncrement ( ) ) ; t . setDaemon ( daemon ) ; return t ; }
public boolean cancel ( boolean ign ) { boolean result = rv . cancel ( ign ) ; notifyListeners ( ) ; return result ; }
public T get ( ) throws InterruptedException , ExecutionException { Future < T > v = rv . get ( ) ; return v = = null ? null : v . get ( ) ; }
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { Future < T > v = rv . get ( duration , units ) ; return v = = null ? null : v . get ( ) ; }
public void set ( Future < T > d , OperationStatus s ) { rv . set ( d , s ) ; }
public boolean isCancelled ( ) { return rv . isCancelled ( ) ; }
public boolean isDone ( ) { return rv . isDone ( ) ; }
public GetFuture < T > addListener ( GetCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return this ; }
public GetFuture < T > removeListener ( GetCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return this ; }
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = true ; status = new OperationStatus ( false , " Cancelled " , StatusCode . CANCELLED ) ; notifyListeners ( ) ; return rv ; }
public boolean isDone ( ) { return latch . getCount ( ) = = 0 ; }
public Future < Map < String , T > > addListener ( BulkGetCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return this ; }
public Future < Map < String , T > > removeListener ( BulkGetCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return this ; }
protected ExecutorService executor ( ) { return service ; }
protected Future < T > addToListeners ( final GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { throw new IllegalArgumentException ( " The listener can ' t be null . " ) ; } synchronized ( this ) { listeners . add ( listener ) ; } if ( isDone ( ) ) { notifyListeners ( ) ; } return this ; }
protected void notifyListeners ( ) { notifyListeners ( this ) ; }
protected Future < T > removeFromListeners ( GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { throw new IllegalArgumentException ( " The listener can ' t be null . " ) ; } if ( ! isDone ( ) ) { synchronized ( this ) { listeners . remove ( listener ) ; } } return this ; }
public final void copyInputQueue ( ) { Collection < Operation > tmp = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( tmp , writeQ . remainingCapacity ( ) ) ; writeQ . addAll ( tmp ) ; }
public Collection < Operation > destroyInputQueue ( ) { Collection < Operation > rv = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( rv ) ; return rv ; }
private boolean preparePending ( ) { copyInputQueue ( ) ; Operation nextOp = getCurrentWriteOp ( ) ; while ( nextOp ! = null & & nextOp . isCancelled ( ) ) { getLogger ( ) . info ( " Removing cancelled operation : % s " , nextOp ) ; removeCurrentWriteOp ( ) ; nextOp = getCurrentWriteOp ( ) ; } return nextOp ! = null ; }
public final void transitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; getLogger ( ) . debug ( " Finished writing % s " , op ) ; }
public final Operation removeCurrentReadOp ( ) { return readQ . remove ( ) ; }
public final Operation removeCurrentWriteOp ( ) { Operation rv = optimizedOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { optimizedOp = null ; } return rv ; }
public final boolean hasReadOp ( ) { return ! readQ . isEmpty ( ) ; }
public final boolean hasWriteOp ( ) { return ! ( optimizedOp = = null & & writeQ . isEmpty ( ) ) ; }
public final void insertOp ( Operation op ) { ArrayList < Operation > tmp = new ArrayList < Operation > ( inputQueue . size ( ) + 1 ) ; tmp . add ( op ) ; inputQueue . drainTo ( tmp ) ; inputQueue . addAll ( tmp ) ; }
public boolean isAuthenticated ( ) { return ( 0 = = authLatch . getCount ( ) ) ; }
public final void reconnecting ( ) { reconnectAttempt . incrementAndGet ( ) ; continuousTimeout . set ( 0 ) ; }
public final void connected ( ) { reconnectAttempt . set ( 0 ) ; continuousTimeout . set ( 0 ) ; }
public final void registerChannel ( SocketChannel ch , SelectionKey skey ) { setChannel ( ch ) ; setSk ( skey ) ; }
public long lastReadDelta ( ) { return TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - lastReadTimestamp ) ; }
public void completedRead ( ) { lastReadTimestamp = System . nanoTime ( ) ; }
public final synchronized boolean isCancelled ( ) { return cancelled ; }
public final boolean hasErrored ( ) { return exception ! = null ; }
public final synchronized void cancel ( ) { cancelled = true ; synchronized ( clones ) { Iterator < Operation > i = clones . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . cancel ( ) ; } } wasCancelled ( ) ; callback . receivedStatus ( CANCELLED ) ; callback . complete ( ) ; }
protected void wasCancelled ( ) { getLogger ( ) . debug ( " was cancelled . " ) ; }
public final void writing ( ) { transitionState ( OperationState . WRITING ) ; }
public final void writeComplete ( ) { writeCompleteTimestamp = System . nanoTime ( ) ; transitionState ( OperationState . READING ) ; }
protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error : % s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } callback . receivedStatus ( new OperationStatus ( false , exception . getMessage ( ) , StatusCode . ERR_INTERNAL ) ) ; transitionState ( OperationState . COMPLETE ) ; throw exception ; }
public void handleRead ( ByteBuffer data ) { assert false ; }
public synchronized void timeOut ( ) { timedout = true ; synchronized ( clones ) { Iterator < Operation > i = clones . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . timeOut ( ) ; } } callback . receivedStatus ( TIMED_OUT ) ; callback . complete ( ) ; }
public synchronized boolean isTimedOut ( ) { return timedout ; }
public boolean isTimedOutUnsent ( ) { return timedOutUnsent ; }
public void addClone ( Operation op ) { clones . add ( op ) ; }
public int numKeys ( ) { return callbacks . size ( ) ; }
public int numCallbacks ( ) { return allCallbacks . size ( ) ; }
public void complete ( ) { assert ! completed ; cb . complete ( ) ; completed = true ; }
public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read ` ` " + line + " ' ' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED , NOT_FOUND , EXISTS ) ) ; transitionState ( OperationState . COMPLETE ) ; }
public void handleLine ( String line ) { getLogger ( ) . debug ( " Touch completed successfully " ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , OK ) ) ; transitionState ( OperationState . COMPLETE ) ; }
public void initialize ( ) { ByteBuffer b = null ; b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + String . valueOf ( exp ) . length ( ) + OVERHEAD ) ; b . put ( ( " touch " + key + " " + exp + " \ r \ n " ) . getBytes ( ) ) ; b . flip ( ) ; setBuffer ( b ) ; }
public String toString ( ) { return " Cmd : touch key : " + key + " exp : " + exp ; }
public DeleteOperation delete ( String key , DeleteOperation . Callback cb ) { return new DeleteOperationImpl ( key , cb ) ; }
public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( delay , cb ) ; }
public GetOperation get ( String key , GetOperation . Callback cb ) { return new GetOperationImpl ( key , cb ) ; }
public GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) { return new GetOperationImpl ( keys , cb ) ; }
public GetlOperation getl ( String key , int exp , GetlOperation . Callback cb ) { return new GetlOperationImpl ( key , exp , cb ) ; }
public UnlockOperation unlock ( String key , long casId , OperationCallback cb ) { return new UnlockOperationImpl ( key , casId , cb ) ; }
public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetsOperationImpl ( key , cb ) ; }
public MutatorOperation mutate ( Mutator m , String key , long by , long exp , int def , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; }
public StatsOperation stats ( String arg , StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; }
public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , cb ) ; }
public TouchOperation touch ( String key , int expiration , OperationCallback cb ) { return new TouchOperationImpl ( key , expiration , cb ) ; }
public VersionOperation version ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; }
public NoopOperation noop ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; }
public CASOperation cas ( StoreType type , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new CASOperationImpl ( key , casId , flags , exp , data , cb ) ; }
public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , cb ) ; }
public void handleLine ( String line ) { getLogger ( ) . debug ( " Unlock of % s returned % s " , key , line ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , UNLOCKED , NOT_FOUND ) ) ; transitionState ( OperationState . COMPLETE ) ; }
public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , CMD , key , cas ) ; b . flip ( ) ; setBuffer ( b ) ; }
public String toString ( ) { return " Cmd : " + CMD + " Key : " + key + " Cas Value : " + cas ; }
public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( true , line . substring ( " VERSION " . length ( ) ) , StatusCode . SUCCESS ) ) ; transitionState ( OperationState . COMPLETE ) ; }
public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( REQUEST ) ) ; }
public String toString ( ) { return " Cmd : version " ; }
OperationErrorType classifyError ( String line ) { OperationErrorType rv = null ; if ( line . startsWith ( " ERROR " ) ) { rv = OperationErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { rv = OperationErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { rv = OperationErrorType . SERVER ; } return rv ; }
public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of % s returned % s " , key , line ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , DELETED , NOT_FOUND ) ) ; transitionState ( OperationState . COMPLETE ) ; }
public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , " delete " , key ) ; b . flip ( ) ; setBuffer ( b ) ; }
public String toString ( ) { return " Cmd : delete Key : " + key ; }
public void handleLine ( String line ) { getLogger ( ) . debug ( " Flush completed successfully " ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , OK ) ) ; transitionState ( OperationState . COMPLETE ) ; }
public void initialize ( ) { ByteBuffer b = null ; if ( delay = = - 1 ) { b = ByteBuffer . wrap ( FLUSH ) ; } else { b = ByteBuffer . allocate ( 32 ) ; b . put ( ( " flush_all " + delay + " \ r \ n " ) . getBytes ( ) ) ; b . flip ( ) ; } setBuffer ( b ) ; }
public String toString ( ) { return " Cmd : flush_all Delay : " + delay ; }
public void handleLine ( String line ) { getLogger ( ) . debug ( " Result : % s " , line ) ; OperationStatus found = null ; if ( line . equals ( " NOT_FOUND " ) ) { found = NOT_FOUND ; } else { found = new OperationStatus ( true , line , StatusCode . SUCCESS ) ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( OperationState . COMPLETE ) ; }
public void initialize ( ) { int size = KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ; ByteBuffer b = ByteBuffer . allocate ( size ) ; setArguments ( b , mutator . name ( ) , key , amount ) ; b . flip ( ) ; setBuffer ( b ) ; }
protected void wasCancelled ( ) { getCallback ( ) . receivedStatus ( CANCELLED ) ; }
public String toString ( ) { return " Cmd : " + mutator . name ( ) + " Key : " + key + " Amount : " + amount ; }
public void addOperation ( GetOperation o ) { getKeys ( ) . addAll ( o . getKeys ( ) ) ; pcb . addCallbacks ( o ) ; }
public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read ` ` " + line + " ' ' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED ) ) ; transitionState ( OperationState . COMPLETE ) ; }
public final void initialize ( ) { int size = 6 ; Collection < byte [ ] > keyBytes = KeyUtil . getKeyBytes ( keys ) ; for ( byte [ ] k : keyBytes ) { size + = k . length ; size + + ; } size + = afterKeyBytesSize ( ) ; ByteBuffer b = ByteBuffer . allocate ( size ) ; b . put ( cmd . getBytes ( ) ) ; for ( byte [ ] k : keyBytes ) { b . put ( ( byte ) ' ' ) ; b . put ( k ) ; } afterKeyBytes ( b ) ; b . put ( RN_BYTES ) ; b . flip ( ) ; setBuffer ( b ) ; }
protected int afterKeyBytesSize ( ) { if ( expBytes = = null ) { return 0 ; } return expBytes . length + 1 ; }
protected final void wasCancelled ( ) { getCallback ( ) . receivedStatus ( CANCELLED ) ; }
public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( msg ) ) ; }
protected void wasCancelled ( ) { cb . receivedStatus ( CANCELLED ) ; }
public String toString ( ) { return " Cmd : " + Arrays . toString ( msg ) ; }
public void initialize ( ) { prepareBuffer ( key , 0 , EMPTY_BYTES , exp ) ; }
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetlOperation . Callback gcb = ( GetlOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
public String toString ( ) { return super . toString ( ) + " Exp : " + exp ; }
public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES ) ; }
protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
public void initialize ( ) { prepareBuffer ( key , 0 , EMPTY_BYTES ) ; }
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetsOperation . Callback gcb = ( GetsOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
private static byte cmdMap ( StoreType t ) { byte rv ; switch ( t ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; default : rv = DUMMY_OPCODE ; } assert rv ! = DUMMY_OPCODE : " Unhandled store type : " + t ; return rv ; }
public void initialize ( ) { prepareBuffer ( key , cas , data , flags , exp ) ; }
protected void decodePayload ( byte [ ] pl ) { super . decodePayload ( pl ) ; ( ( StoreOperation . Callback ) getCallback ( ) ) . gotData ( key , responseCas ) ; }
public void initialize ( ) { prepareBuffer ( key , cas , EMPTY_BYTES ) ; }
public String toString ( ) { return super . toString ( ) + " Cas : " + cas ; }
protected byte [ ] buildResponse ( SaslClient sc ) throws SaslException { return sc . evaluateChallenge ( challenge ) ; }
public String toString ( ) { return " SASL steps operation " ; }
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_RES ) ; message . setOpcode ( opcode ) ; message . setOpaque ( opaque ) ; setBuffer ( message . getBytes ( ) ) ; }
public void streamClosed ( OperationState state ) { transitionState ( state ) ; }
public String toString ( ) { return " Cmd : tap ack Opcode : " + opcode + " Opaque : " + opaque ; }
public void initialize ( ) { message . setFlags ( TapRequestFlag . FIX_BYTEORDER ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; }
public String toString ( ) { return " Cmd : tap custom " ; }
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN - keyLen ] ; System . arraycopy ( pl , ( EXTRA_HDR_LEN + keyLen ) , data , 0 , pl . length - EXTRA_HDR_LEN - keyLen ) ; Callback gcb = ( Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . BACKFILL ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; message . setFlags ( TapRequestFlag . FIX_BYTEORDER ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } message . setBackfill ( date ) ; setBuffer ( message . getBytes ( ) ) ; }
public String toString ( ) { return " Cmd : tap dump Flags : backfill , ack " ; }
protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; synchronized ( vbmap ) { vbmap . put ( k , new Short ( ( short ) 0 ) ) ; } } return rv ; }
public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } ByteBuffer bb = ByteBuffer . allocate ( size ) ; for ( Map . Entry < Integer , byte [ ] > me : bkeys . entrySet ( ) ) { final byte [ ] keyBytes = me . getValue ( ) ; final String key = keys . get ( me . getKey ( ) ) ; bb . put ( REQ_MAGIC ) ; bb . put ( CMD_GETQ ) ; bb . putShort ( ( short ) keyBytes . length ) ; bb . put ( ( byte ) 0 ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( vbmap . get ( key ) . shortValue ( ) ) ; bb . putInt ( keyBytes . length ) ; bb . putInt ( me . getKey ( ) ) ; bb . putLong ( 0 ) ; bb . put ( keyBytes ) ; } bb . put ( REQ_MAGIC ) ; bb . put ( ( byte ) NoopOperationImpl . CMD ) ; bb . putShort ( ( short ) 0 ) ; bb . put ( ( byte ) 0 ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( ( short ) 0 ) ; bb . putInt ( 0 ) ; bb . putInt ( terminalOpaque ) ; bb . putLong ( 0 ) ; bb . flip ( ) ; setBuffer ( bb ) ; }
protected boolean opaqueIsValid ( ) { return responseOpaque = = terminalOpaque | | keys . containsKey ( responseOpaque ) ; }
protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response : % s " , new String ( pl ) ) ; }
public String toString ( ) { return " SASL base operation " ; }
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN - keyLen ] ; System . arraycopy ( pl , ( EXTRA_HDR_LEN + keyLen ) , data , 0 , pl . length - EXTRA_HDR_LEN - keyLen ) ; ReplicaGetOperation . Callback gcb = ( ReplicaGetOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
protected void resetInput ( ) { payload = null ; payloadOffset = 0 ; headerOffset = 0 ; }
private void readHeaderFromBuffer ( final ByteBuffer buffer ) { int toRead = MIN_RECV_PACKET - headerOffset ; int available = buffer . remaining ( ) ; toRead = Math . min ( toRead , available ) ; getLogger ( ) . debug ( " Reading % d header bytes " , toRead ) ; buffer . get ( header , headerOffset , toRead ) ; headerOffset + = toRead ; }
private void parseHeaderFromBuffer ( ) { int magic = header [ 0 ] ; assert magic = = RES_MAGIC : " Invalid magic : " + magic ; responseCmd = header [ 1 ] ; assert cmd = = DUMMY_OPCODE | | responseCmd = = cmd : " Unexpected response command value " ; keyLen = decodeShort ( header , 2 ) ; errorCode = decodeShort ( header , 6 ) ; int bytesToRead = decodeInt ( header , 8 ) ; payload = new byte [ bytesToRead ] ; responseOpaque = decodeInt ( header , 12 ) ; responseCas = decodeLong ( header , 16 ) ; assert opaqueIsValid ( ) : " Opaque is not valid " ; }
protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 0 : " Payload has bytes , but decode isn ' t overridden " ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
protected boolean opaqueIsValid ( ) { if ( responseOpaque ! = opaque ) { getLogger ( ) . warn ( " Expected opaque : % d , got opaque : % d \ n " , responseOpaque , opaque ) ; } return responseOpaque = = opaque ; }
static int decodeByte ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) ; }
private int calculateExtraLength ( final Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else if ( o instanceof Short ) { extraLen + = 2 ; } else { assert false : " Unhandled extra header type : " + o . getClass ( ) ; } } return extraLen ; }
public String toString ( ) { return " Cmd : " + cmd + " Opaque : " + opaque ; }
private static byte cmdMap ( ConcatenationType t ) { byte rv ; switch ( t ) { case append : rv = APPEND ; break ; case prepend : rv = PREPEND ; break ; default : rv = DUMMY_OPCODE ; } assert rv ! = DUMMY_OPCODE : " Unhandled store type : " + t ; return rv ; }
public void initialize ( ) { prepareBuffer ( key , cas , data ) ; }
public String toString ( ) { return super . toString ( ) + " Cas : " + cas + " Data Length : " + data . length ; }
protected void decodePayload ( byte [ ] pl ) { super . decodePayload ( pl ) ; ( ( DeleteOperation . Callback ) getCallback ( ) ) . gotData ( responseCas ) ; }
public void addNotMyVbucketNode ( MemcachedNode node ) { notMyVbucketNodes . add ( node ) ; }
public String toString ( ) { return super . toString ( ) + " Key : " + key ; }
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetAndTouchOperation . Callback gcb = ( GetAndTouchOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( byteCount ) ; for ( CASOperation so : ops ) { Iterator < String > is = so . getKeys ( ) . iterator ( ) ; String k = is . next ( ) ; byte [ ] keyBytes = KeyUtil . getKeyBytes ( k ) ; assert ! is . hasNext ( ) ; int myOpaque = generateOpaque ( ) ; callbacks . put ( myOpaque , so . getCallback ( ) ) ; byte [ ] data = so . getData ( ) ; bb . put ( REQ_MAGIC ) ; bb . put ( cmdMap ( so . getStoreType ( ) ) ) ; bb . putShort ( ( short ) keyBytes . length ) ; bb . put ( ( byte ) StoreOperationImpl . EXTRA_LEN ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( ( ( VBucketAware ) so ) . getVBucket ( k ) ) ; bb . putInt ( keyBytes . length + data . length + StoreOperationImpl . EXTRA_LEN ) ; bb . putInt ( myOpaque ) ; bb . putLong ( so . getCasValue ( ) ) ; bb . putInt ( so . getFlags ( ) ) ; bb . putInt ( so . getExpiration ( ) ) ; bb . put ( keyBytes ) ; bb . put ( data ) ; } bb . put ( REQ_MAGIC ) ; bb . put ( ( byte ) NoopOperationImpl . CMD ) ; bb . putShort ( ( short ) 0 ) ; bb . put ( ( byte ) 0 ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( ( short ) 0 ) ; bb . putInt ( 0 ) ; bb . putInt ( terminalOpaque ) ; bb . putLong ( 0 ) ; bb . flip ( ) ; setBuffer ( bb ) ; }
private static byte cmdMap ( StoreType t ) { byte rv ; switch ( t ) { case set : rv = StoreOperationImpl . SETQ ; break ; case add : rv = StoreOperationImpl . ADDQ ; break ; case replace : rv = StoreOperationImpl . REPLACEQ ; break ; default : rv = DUMMY_OPCODE ; } assert rv ! = DUMMY_OPCODE : " Unhandled store type : " + t ; return rv ; }
protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( responseOpaque = = terminalOpaque ) { for ( OperationCallback cb : callbacks . values ( ) ) { cb . receivedStatus ( STATUS_OK ) ; cb . complete ( ) ; } transitionState ( OperationState . COMPLETE ) ; } else { OperationCallback cb = callbacks . remove ( responseOpaque ) ; assert cb ! = null : " No callback for " + responseOpaque ; assert errorCode ! = 0 : " Got no error on a quiet mutation . " ; super . finishedPayload ( pl ) ; } resetInput ( ) ; }
protected void decodePayload ( byte [ ] pl ) { final short keylen = ( short ) decodeShort ( pl , 2 ) ; keystate = ( byte ) decodeByte ( pl , keylen + 4 ) ; retCas = ( long ) decodeLong ( pl , keylen + 5 ) ; ObserveResponse r = ObserveResponse . valueOf ( keystate ) ; ( ( ObserveOperation . Callback ) getCallback ( ) ) . gotData ( key , retCas , getHandlingNode ( ) , r ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES , delay ) ; }
public String toString ( ) { return super . toString ( ) + " Delay : " + delay ; }
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetOperation . Callback gcb = ( GetOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
public void initialize ( ) { String keyval = " key " + key + " " + getVBucket ( key ) ; prepareBuffer ( keyval , 0 , EMPTY_BYTES ) ; }
public DeleteOperation delete ( String key , DeleteOperation . Callback operationCallback ) { return new DeleteOperationImpl ( key , operationCallback ) ; }
public DeleteOperation delete ( String key , long cas , DeleteOperation . Callback operationCallback ) { return new DeleteOperationImpl ( key , cas , operationCallback ) ; }
public ObserveOperation observe ( String key , long casId , int index , ObserveOperation . Callback cb ) { return new ObserveOperationImpl ( key , casId , index , cb ) ; }
public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( cb ) ; }
public GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) { return new GetAndTouchOperationImpl ( key , expiration , cb ) ; }
public GetOperation get ( String key , Callback callback ) { return new GetOperationImpl ( key , callback ) ; }
public ReplicaGetOperation replicaGet ( String key , int index , ReplicaGetOperation . Callback callback ) { return new ReplicaGetOperationImpl ( key , index , callback ) ; }
public ReplicaGetsOperation replicaGets ( String key , int index , ReplicaGetsOperation . Callback callback ) { return new ReplicaGetsOperationImpl ( key , index , callback ) ; }
public GetOperation get ( Collection < String > value , Callback cb ) { return new MultiGetOperationImpl ( value , cb ) ; }
public StatsOperation keyStats ( String key , StatsOperation . Callback cb ) { return new KeyStatsOperationImpl ( key , cb ) ; }
public MutatorOperation mutate ( Mutator m , String key , long by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; }
public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; }
public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , 0 , cb ) ; }
public NoopOperation noop ( OperationCallback cb ) { return new NoopOperationImpl ( cb ) ; }
public CASOperation cas ( StoreType type , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new StoreOperationImpl ( type , key , flags , exp , data , casId , cb ) ; }
public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , casId , cb ) ; }
public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { return new SASLAuthOperationImpl ( mech , serverName , props , cbh , cb ) ; }
public SASLMechsOperation saslMechs ( OperationCallback cb ) { return new SASLMechsOperationImpl ( cb ) ; }
public TapOperation tapBackfill ( String id , long date , OperationCallback cb ) { return new TapBackfillOperationImpl ( id , date , cb ) ; }
public TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) { return new TapCustomOperationImpl ( id , message , cb ) ; }
public TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) { return new TapAckOperationImpl ( opcode , opaque , cb ) ; }
public TapOperation tapDump ( String id , OperationCallback cb ) { return new TapDumpOperationImpl ( id , cb ) ; }
public String toString ( ) { return " SASL auth operation " ; }
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . DUMP ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; message . setFlags ( TapRequestFlag . FIX_BYTEORDER ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; }
public String toString ( ) { return " Cmd : tap dump Flags : dump , ack " ; }
public String toString ( ) { return " SASL mechs operation " ; }
public boolean asyncDecode ( CachedData d ) { return false ; }
public CachedData encode ( java . lang . Integer l ) { return new CachedData ( FLAGS , tu . encodeInt ( l ) , getMaxSize ( ) ) ; }
public < T > Future < T > decode ( final Transcoder < T > tc , final CachedData cachedData ) { assert ! pool . isShutdown ( ) : " Pool has already shut down . " ; TranscodeService . Task < T > task = new TranscodeService . Task < T > ( new Callable < T > ( ) { public T call ( ) { return tc . decode ( cachedData ) ; } } ) ; if ( tc . asyncDecode ( cachedData ) ) { this . pool . execute ( task ) ; } return task ; }
public T call ( ) { return tc . decode ( cachedData ) ; }
public boolean isShutdown ( ) { return pool . isShutdown ( ) ; }
public T get ( ) throws InterruptedException , ExecutionException { this . run ( ) ; return super . get ( ) ; }
public T get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { this . run ( ) ; return super . get ( timeout , unit ) ; }
public byte [ ] encodeLong ( long l ) { return encodeNum ( l , 8 ) ; }
public byte [ ] encodeInt ( int in ) { return encodeNum ( in , 4 ) ; }
public byte [ ] encodeByte ( byte in ) { return new byte [ ] { in } ; }
public byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? ' 1 ' : ' 0 ' ) ; return rv ; }
public boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = ' 1 ' ; }
protected byte [ ] serialize ( Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can ' t serialize null " ) ; } byte [ ] rv = null ; ByteArrayOutputStream bos = null ; ObjectOutputStream os = null ; try { bos = new ByteArrayOutputStream ( ) ; os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . toByteArray ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " Non - serializable object " , e ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( bos ) ; } return rv ; }
protected Object deserialize ( byte [ ] in ) { Object rv = null ; ByteArrayInputStream bis = null ; ObjectInputStream is = null ; try { if ( in ! = null ) { bis = new ByteArrayInputStream ( in ) ; is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding % d bytes of data " , in = = null ? 0 : in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding % d bytes of data " , in = = null ? 0 : in . length , e ) ; } finally { CloseUtil . close ( is ) ; CloseUtil . close ( bis ) ; } return rv ; }
protected byte [ ] compress ( byte [ ] in ) { if ( in = = null ) { throw new NullPointerException ( " Can ' t compress null " ) ; } ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . toByteArray ( ) ; getLogger ( ) . debug ( " Compressed % d bytes to % d " , in . length , rv . length ) ; return rv ; }
protected String decodeString ( byte [ ] data ) { String rv = null ; try { if ( data ! = null ) { rv = new String ( data , charset ) ; } } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return rv ; }
protected byte [ ] encodeString ( String in ) { byte [ ] rv = null ; try { rv = in . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return rv ; }
private Short decodeShort ( byte [ ] data ) { return Short . valueOf ( ( short ) decodeInteger ( data ) . intValue ( ) ) ; }
private Float decodeFloat ( byte [ ] in ) { assert in . length = = 5 : " Wrong length for a float " ; Integer l = decodeInteger ( in ) ; return Float . valueOf ( Float . intBitsToFloat ( l . intValue ( ) ) ) ; }
private Double decodeDouble ( byte [ ] in ) { assert in . length = = 9 : " Wrong length for a double " ; Long l = decodeLong ( in ) ; return Double . valueOf ( Double . longBitsToDouble ( l . longValue ( ) ) ) ; }
private Boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 2 : " Wrong length for a boolean " ; return Boolean . valueOf ( in [ 1 ] = = 1 ) ; }
private Character decodeCharacter ( byte [ ] b ) { return Character . valueOf ( ( char ) decodeInteger ( b ) . intValue ( ) ) ; }
private byte [ ] encodeByte ( Byte value ) { byte [ ] b = new byte [ 2 ] ; b [ 0 ] = SPECIAL_BYTE ; b [ 1 ] = value . byteValue ( ) ; return b ; }
private byte [ ] encodeBoolean ( Boolean value ) { byte [ ] b = new byte [ 2 ] ; b [ 0 ] = SPECIAL_BOOLEAN ; b [ 1 ] = ( byte ) ( value . booleanValue ( ) ? 1 : 0 ) ; return b ; }
private byte [ ] encodeInteger ( Integer value ) { byte [ ] b = encodeNum ( value , 4 ) ; b [ 0 ] = SPECIAL_INTEGER ; return b ; }
private byte [ ] encodeLong ( Long value , int type ) { byte [ ] b = encodeNum ( value , 8 ) ; b [ 0 ] = ( byte ) type ; return b ; }
private byte [ ] encodeLong ( Long value ) { return encodeLong ( value , SPECIAL_LONG ) ; }
private byte [ ] encodeShort ( Short value ) { byte [ ] b = encodeInteger ( ( int ) value . shortValue ( ) ) ; b [ 0 ] = SPECIAL_SHORT ; return b ; }
private byte [ ] encodeFloat ( Float value ) { byte [ ] b = encodeInteger ( Float . floatToIntBits ( value ) ) ; b [ 0 ] = SPECIAL_FLOAT ; return b ; }
private byte [ ] encodeDouble ( Double value ) { byte [ ] b = encodeLong ( Double . doubleToLongBits ( value ) ) ; b [ 0 ] = SPECIAL_DOUBLE ; return b ; }
private byte [ ] encodeCharacter ( Character value ) { byte [ ] result = encodeInteger ( ( int ) value . charValue ( ) ) ; result [ 0 ] = SPECIAL_CHARACTER ; return result ; }
private byte [ ] encodeStringBuffer ( StringBuffer value ) { byte [ ] b = encodeW1String ( value . toString ( ) ) ; b [ 0 ] = SPECIAL_STRINGBUFFER ; return b ; }
private byte [ ] encodeStringbuilder ( StringBuilder value ) { byte [ ] b = encodeW1String ( value . toString ( ) ) ; b [ 0 ] = SPECIAL_STRINGBUILDER ; return b ; }
private byte [ ] encodeW1String ( String value ) { byte [ ] svalue = null ; try { svalue = value . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } byte [ ] result = new byte [ svalue . length + 1 ] ; System . arraycopy ( svalue , 0 , result , 1 , svalue . length ) ; result [ 0 ] = SPECIAL_STRING ; return result ; }
protected Character decodeCharacter ( byte [ ] b ) { return Character . valueOf ( ( char ) tu . decodeInt ( b ) ) ; }
public byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? 1 : 0 ) ; return rv ; }
public boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = 1 ; }
public CachedData encode ( java . lang . Long l ) { return new CachedData ( FLAGS , tu . encodeLong ( l ) , getMaxSize ( ) ) ; }
public boolean isSuccess ( ) { return isSuccess ; }
public String toString ( ) { return " { OperationStatus success = " + isSuccess + " : " + message + " } " ; }
public String toString ( ) { String rv = null ; if ( type = = OperationErrorType . GENERAL ) { rv = " OperationException : " + type ; } else { rv = " OperationException : " + type + " : " + getMessage ( ) ; } return rv ; }
public void receivedStatus ( OperationStatus status ) { mostRecentStatus = status ; }
public BlockingQueue < Operation > create ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }
public BlockingQueue < Operation > create ( ) { return new ArrayBlockingQueue < Operation > ( capacity ) ; }
private String first ( Collection < String > keys ) { return keys . iterator ( ) . next ( ) ; }
public void gotData ( String key , int flags , long cas , byte [ ] data ) { ( ( GetsOperation . Callback ) originalCallback ) . gotData ( key , flags , cas , data ) ; }
public void gotData ( String key , int flags , byte [ ] data ) { ( ( GetOperation . Callback ) originalCallback ) . gotData ( key , flags , data ) ; }
public void gotData ( String key , int flags , byte [ ] data ) { ( ( ReplicaGetOperation . Callback ) originalCallback ) . gotData ( key , flags , data ) ; }
public Object getObject ( ) throws Exception { return client ; }
private static void downloadFileFromURL ( String urlString , File destination ) throws Exception { URL website = new URL ( urlString ) ; ReadableByteChannel rbc ; rbc = Channels . newChannel ( website . openStream ( ) ) ; FileOutputStream fos = new FileOutputStream ( destination ) ; fos . getChannel ( ) . transferFrom ( rbc , 0 , Long . MAX_VALUE ) ; fos . close ( ) ; rbc . close ( ) ; }
public void shouldReturnNotNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain toolchain = new ReturningToolChain ( null ) ; assertNotNull ( JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; }
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) { Toolchain toolchain = new ReturningToolChain ( " my - path - to - java " ) ; assertEquals ( " my - path - to - java " , JavaLocator . findExecutableFromToolchain ( toolchain ) . getPath ( ) ) ; }
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " parent / child / my - path - to - java " ) ) ; assertEquals ( " parent " , home . getPath ( ) ) ; }
public void shouldReturnNullWhenFileIsNotPresent ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " my - path - to - java " ) ) ; assertNull ( home ) ; }
public String findTool ( String toolName ) { return tool ; }
public void stringUtilsSplit ( ) throws Exception { assertEquals ( 1 , StringUtils . split ( " hello " , " | " ) . length ) ; assertEquals ( 1 , StringUtils . split ( " hello | " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel | lo " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel | | lo " , " | " ) . length ) ; }
public void compare ( ) throws Exception { assertEquals ( 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 1 . 0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 1 . 9 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 2 . 0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 2 . 7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 2 . 7 - rc " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 2 . 7 . 0 " ) ) ) ; assertEquals ( 0 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 2 . 7 . 1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 2 . 7 . 2 - rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 2 . 8 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumber ( " 3 . 0 " ) ) ) ; }
public void parse ( ) throws Exception { assertParseVN ( " 2 . 7 . 1 " , 2 , 7 , 1 , null ) ; assertParseVN ( " 2 . 7 " , 2 , 7 , 0 , null ) ; assertParseVN ( " 2 . 7 . 1 . RC " , 2 , 7 , 1 , " . RC " ) ; assertParseVN ( " 2 . 7 . 1 . RC " , 2 , 7 , 1 , " . RC " ) ; assertParseVN ( " 2 . 7 . RC " , 2 , 7 , 0 , " . RC " ) ; assertParseVN ( " 2 . 7 - RC " , 2 , 7 , 0 , " - RC " ) ; assertParseVN ( " 2 . 7 . 1 - SNAPSHOT " , 2 , 7 , 1 , " - SNAPSHOT " ) ; }
public void compareMask ( ) throws Exception { assertEquals ( 1 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 1 . 0 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 1 . 9 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 2 . 0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 2 . 7 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 2 . 7 - rc " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 2 . 7 . 0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 2 . 7 . 1 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 2 . 7 . 2 - rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 2 . 8 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2 . 7 " ) . compareTo ( new VersionNumber ( " 3 . 0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2 . 7 - rc " ) . compareTo ( new VersionNumberMask ( " 2 . 7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2 . 7 . 0 " ) . compareTo ( new VersionNumberMask ( " 2 . 7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2 . 7 . 1 " ) . compareTo ( new VersionNumberMask ( " 2 . 7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2 . 7 . 2 - rc1 " ) . compareTo ( new VersionNumberMask ( " 2 . 7 " ) ) ) ; }
private void assertParseVN ( String str , int major , int minor , int bugfix , String modifier ) { VersionNumber v = new VersionNumber ( str ) ; assertEquals ( " test major of " + str , major , v . major ) ; assertEquals ( " test minor of " + str , minor , v . minor ) ; assertEquals ( " test bugfix of " + str , bugfix , v . bugfix ) ; assertEquals ( " test modifier of " + str , modifier , v . modifier ) ; }
private LevelState assertLevelState ( String input , LevelState previous , Level expectedLevel , String expectedUntilContains ) throws Exception { LevelState back = LogProcessorUtils . levelStateOf ( input , previous ) ; assertEquals ( expectedLevel , back . level ) ; assertEquals ( expectedUntilContains , back . untilContains ) ; return back ; }
public static void main ( String [ ] args ) { System . out . println ( " Hello world " ) ; }
public static void main ( String [ ] args ) { JavaClass test = new JavaClass ( ) ; test . abstractJavaMethod ( ) ; }
public void sayHello ( ) { System . out . println ( " Java says : Hello Scala ! " ) ; HelloScala . sayHello ( ) ; }
public static String pathOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; }
public static File fileOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; }
public static Set < File > fromStrings ( Collection < String > s ) { return s . stream ( ) . map ( File : : new ) . collect ( Collectors . toSet ( ) ) ; }
public static String toMultiPath ( Collection < File > paths ) { return paths . stream ( ) . map ( File : : getPath ) . collect ( Collectors . joining ( File . pathSeparator ) ) ; }
public static List < Path > listDirectoryContent ( Path directory , Function < Path , Boolean > filter ) throws IOException { List < Path > paths = new ArrayList < > ( ) ; Files . walkFileTree ( directory , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; } } ) ; return paths ; }
public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; }
public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; }
public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; }
public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; }
public static String makeArtifactNameString ( Artifact artifact ) { if ( artifact = = null ) { return " < null artifact > " ; } return artifact . getGroupId ( ) + " : " + artifact . getArtifactId ( ) + " : " + artifact . getVersion ( ) ; }
public static File findHomeFromToolchain ( Toolchain toolchain ) { File executable = findExecutableFromToolchain ( toolchain ) ; File executableParent = executable . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParentFile ( ) ; }
public static ForkLogLevel level ( String line ) { if ( line . startsWith ( DEBUG . header ) ) { return DEBUG ; } else if ( line . startsWith ( INFO . header ) ) { return INFO ; } else if ( line . startsWith ( WARN . header ) ) { return WARN ; } else if ( line . startsWith ( ERROR . header ) ) { return ERROR ; } return null ; }
public String addHeader ( String line ) { return header + line ; }
public String removeHeader ( String line ) { return line . substring ( header . length ( ) ) ; }
public final void forceNextLineToFlush ( ) { forceFlush = true ; }
public static LevelState levelStateOf ( String line , LevelState previous ) { LevelState back = new LevelState ( ) ; String lineLowerCase = line . toLowerCase ( ) ; if ( lineLowerCase . contains ( " error " ) ) { back . level = Level . ERROR ; if ( lineLowerCase . contains ( " . scala " ) ) { back . untilContains = " ^ " ; } } else if ( lineLowerCase . contains ( " warn " ) ) { back . level = Level . WARNING ; if ( lineLowerCase . contains ( " . scala " ) ) { back . untilContains = " ^ " ; } } else if ( previous . untilContains ! = null ) { if ( ! lineLowerCase . contains ( previous . untilContains ) ) { back = previous ; } else { back . level = previous . level ; back . untilContains = null ; } } return back ; }
private long lengthOf ( List < String > l , long sepLength ) { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; }
public void redirectToLog ( ) { _redirectToLog = true ; }
public void addOption ( String key , String value ) { if ( StringUtils . isEmpty ( value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value ) ; }
public void addOption ( String key , File value ) { if ( ( value = = null ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; }
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key ) ; }
public void run ( boolean displayCmd ) throws Exception { run ( displayCmd , true ) ; }
private static void runMain ( ClassLoader cl , String mainClassName , String [ ] args ) throws Exception { Class < ? > mainClass = cl . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( " main " , String [ ] . class ) ; int mods = mainMethod . getModifiers ( ) ; if ( mainMethod . getReturnType ( ) ! = void . class | | ! Modifier . isStatic ( mods ) | | ! Modifier . isPublic ( mods ) ) { throw new NoSuchMethodException ( " main " ) ; } mainMethod . invoke ( null , new Object [ ] { args } ) ; }
public static String [ ] findFiles ( File dir , String [ ] includes , String [ ] excludes ) { DirectoryScanner scanner = new DirectoryScanner ( ) ; scanner . setBasedir ( dir ) ; scanner . setIncludes ( includes ) ; scanner . setExcludes ( excludes ) ; scanner . addDefaultExcludes ( ) ; scanner . scan ( ) ; return scanner . getIncludedFiles ( ) ; }
public static String toClasspathString ( ClassLoader cl ) { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new ArrayList < > ( ) ; appendUrlToClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . toString ( ) ; }
private static String escapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . matches ( " . * \ \ s . * " ) ) { return ' " ' + arg + ' " ' ; } return arg ; }
private static String unescapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . charAt ( 0 ) = = ' " ' & & arg . charAt ( arg . length ( ) - 1 ) = = ' " ' ) { return arg . substring ( 1 , arg . length ( ) - 1 ) ; } return arg ; }
static File createArgFile ( List < String > args ) throws IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; try ( PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( argFile ) ) ) ) { for ( String arg : args ) { out . println ( escapeArgumentForScalacArgumentFile ( arg ) ) ; } } return argFile ; }
static List < String > readArgFile ( File argFile ) throws IOException { ArrayList < String > back = new ArrayList < > ( ) ; try ( BufferedReader in = new BufferedReader ( new FileReader ( argFile ) ) ) { String line ; while ( ( line = in . readLine ( ) ) ! = null ) { back . add ( unescapeArgumentForScalacArgumentFile ( line ) ) ; } } return back ; }
static void runMain ( String mainClassName , List < String > args , ClassLoader cl ) throws Exception { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } Class < ? > mainClass = cl . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( " main " , String [ ] . class ) ; int mods = mainMethod . getModifiers ( ) ; if ( mainMethod . getReturnType ( ) ! = void . class | | ! Modifier . isStatic ( mods ) | | ! Modifier . isPublic ( mods ) ) { throw new NoSuchMethodException ( " main " ) ; } String [ ] argArray = args . toArray ( new String [ ] { } ) ; mainMethod . invoke ( null , new Object [ ] { argArray } ) ; }
private void runInternal ( boolean displayCmd ) throws Exception { String [ ] argArray = args . toArray ( new String [ ] { } ) ; if ( displayCmd ) { mavenLogger . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; }
public void redirectToLog ( ) { mavenLogger . warn ( " redirection to log is not supported for ' inProcess ' mode " ) ; }
public String [ ] generateArgs ( ) { List < String > args = new ArrayList < > ( ) ; args . add ( javaHome . toString ( ) ) ; args . add ( cacheFile . getPath ( ) ) ; args . add ( compileOrder . name ( ) ) ; args . add ( compilerBridgeJar . getPath ( ) ) ; args . add ( scalaVersion ) ; writeCollection ( args , compilerAndDependencies , File : : getPath ) ; writeCollection ( args , libraryAndDependencies , File : : getPath ) ; writeCollection ( args , classpathElements , File : : getPath ) ; writeCollection ( args , sources , File : : getPath ) ; args . add ( classesDirectory . toString ( ) ) ; writeCollection ( args , scalacOptions , Function . identity ( ) ) ; writeCollection ( args , javacOptions , Function . identity ( ) ) ; args . add ( String . valueOf ( debugEnabled ) ) ; return args . toArray ( new String [ ] { } ) ; }
public void success ( Function0 < String > message ) { log ( Level . Info ( ) , message ) ; }
public void onException ( Exception t ) { mavenLogger . error ( t ) ; }
public void onError ( String content ) { mavenLogger . error ( content ) ; }
public void onWarn ( String content ) { mavenLogger . warn ( content ) ; }
public void onInfo ( String content ) { mavenLogger . info ( content ) ; }
public void onDebug ( String content ) { mavenLogger . debug ( content ) ; }
protected void processLine ( String line , int level ) { forkLogger . processLine ( line ) ; }
public void close ( ) throws IOException { forkLogger . forceNextLineToFlush ( ) ; super . close ( ) ; }
List < File > findSourceWithFilters ( ) throws Exception { return findSourceWithFilters ( getSourceDirectories ( ) ) ; }
List < File > findSourceWithFilters ( List < File > sourceRootDirs ) throws Exception { List < File > sourceFiles = new ArrayList < > ( ) ; initFilters ( ) ; for ( File dir : sourceRootDirs ) { String [ ] tmpFiles = MainHelper . findFiles ( dir , includes . toArray ( new String [ ] { } ) , excludes . toArray ( new String [ ] { } ) ) ; for ( String tmpLocalFile : tmpFiles ) { File tmpAbsFile = FileUtils . fileOf ( new File ( dir , tmpLocalFile ) , useCanonicalPath ) ; sourceFiles . add ( tmpAbsFile ) ; } } Collections . sort ( sourceFiles ) ; return sourceFiles ; }
List < File > normalize ( List < String > compileSourceRootsList ) throws Exception { List < File > newCompileSourceRootsList = new ArrayList < > ( ) ; if ( compileSourceRootsList ! = null ) { for ( String srcDir : compileSourceRootsList ) { File srcDirFile = FileUtils . fileOf ( new File ( srcDir ) , useCanonicalPath ) ; if ( ! newCompileSourceRootsList . contains ( srcDirFile ) & & srcDirFile . exists ( ) ) { newCompileSourceRootsList . add ( srcDirFile ) ; } } } return newCompileSourceRootsList ; }
public String toString ( ) { return " BasicArtifact ( " + groupId + " , " + artifactId + " , " + version + " , " + classifier + " ) " ; }
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return normalize ( sources ) ; }
public boolean canGenerateReport ( ) { return findSourceFiles ( ) . size ( ) ! = 0 ; }
private List < File > findSourceFiles ( ) { if ( _sourceFiles = = null ) { try { _sourceFiles = findSourceWithFilters ( ) ; } catch ( Exception exc ) { throw new RuntimeException ( " can ' t define source to process " , exc ) ; } } return _sourceFiles ; }
public boolean isExternalReport ( ) { return true ; }
public void doExecute ( ) throws Exception { generate ( null , Locale . getDefault ( ) ) ; }
public int hashCode ( ) { return Objects . hash ( major , minor , bugfix , modifier ) ; }
public boolean isZero ( ) { return ( major = = 0 ) & & ( minor = = 0 ) & & ( bugfix = = 0 ) ; }
String applyScalaArtifactVersioningScheme ( String name ) { return name + ' _ ' + ( modifier = = null ? ( major + " . " + minor ) : toString ( ) ) ; }
public void execute ( ) throws MojoExecutionException , MojoFailureException { if ( skip ) { getLog ( ) . info ( " Not compiling test sources " ) ; return ; } super . execute ( ) ; }
protected Set < File > getClasspathElements ( ) throws Exception { Set < File > back = FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ; back . remove ( new File ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ) ; addAdditionalDependencies ( back ) ; return back ; }
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = testSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return normalize ( sources ) ; }
public Set < Artifact > getJarAndDependencies ( String groupId , String artifactId , String version , String classifier ) { Artifact artifact = createJarArtifact ( groupId , artifactId , version , classifier ) ; return resolve ( artifact , true ) ; }
protected JavaMainCaller getScalaCommand ( ) throws Exception { Context sc = findScalaContext ( ) ; return getScalaCommand ( fork , sc . compilerMainClassName ( scalaClassName , false ) ) ; }
boolean hasCompileErrors ( ) { return compileErrors ; }
void clearCompileErrors ( ) { compileErrors = false ; }
void setLastSuccessfulTS ( long v ) throws Exception { if ( ! _lastCompileAtFile . exists ( ) ) { org . codehaus . plexus . util . FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; }
private int incrementalCompile ( Set < File > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } if ( incremental = = null ) { Context sc = findScalaContext ( ) ; File javaHome = JavaLocator . findHomeFromToolchain ( getToolchain ( ) ) ; incremental = SbtIncrementalCompilers . make ( javaHome , new MavenArtifactResolver ( factory , session ) , secondaryCacheDir , getLog ( ) , cacheFile , compileOrder , sc . version ( ) , sc . findCompilerAndDependencies ( ) . stream ( ) . map ( Artifact : : getFile ) . collect ( Collectors . toList ( ) ) , sc . findLibraryAndDependencies ( ) . stream ( ) . map ( Artifact : : getFile ) . collect ( Collectors . toList ( ) ) , jvmArgs , JavaLocator . findExecutableFromToolchain ( getToolchain ( ) ) , pluginArtifacts . stream ( ) . map ( Artifact : : getFile ) . collect ( Collectors . toList ( ) ) ) ; } try { incremental . compile ( classpathElements , sources , outputDir , getScalacOptions ( ) , getJavacOptions ( ) ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; }
protected JavaMainCaller getScalaCommand ( ) throws Exception { Context sc = findScalaContext ( ) ; JavaMainCaller jcmd = getScalaCommand ( fork , sc . compilerMainClassName ( scalaClassName , useFsc ) ) ; if ( useFsc & & verbose ) { jcmd . addOption ( " - verbose " , true ) ; } return jcmd ; }
private void failOnError ( String prefix , Exception e ) throws MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } throw new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; }
public void doExecute ( ) throws Exception { JavaMainCaller jcmd ; if ( ! versionOnly ) { jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " - help " ) ; jcmd . addArgs ( " - X " ) ; jcmd . addArgs ( " - Y " ) ; jcmd . run ( displayCmd ) ; } jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " - version " ) ; jcmd . run ( displayCmd ) ; }
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources = new LinkedList < > ( sources ) ; sources . add ( scalaSourceDir ) ; } return normalize ( sources ) ; }
public void execute ( ) throws MojoExecutionException , MojoFailureException { if ( skipMain ) { getLog ( ) . info ( " Not compiling main sources " ) ; return ; } super . execute ( ) ; }
static List < String > addOsgiClasspathElements ( MavenProject project ) { if ( getLocationsMethod = = null ) { return Collections . emptyList ( ) ; } List < Object > classpath = ( List < Object > ) getContextValue ( project , TychoConstants_CTX_ECLIPSE_PLUGIN_CLASSPATH ) ; if ( classpath = = null | | classpath . isEmpty ( ) ) return Collections . emptyList ( ) ; List < String > osgiClasspath = new ArrayList < > ( ) ; for ( Object classpathEntry : classpath ) { for ( File file : getLocations ( classpathEntry ) ) osgiClasspath . add ( file . getAbsolutePath ( ) ) ; } return osgiClasspath ; }
public MavenArtifactResolver findMavenArtifactResolver ( ) { if ( mavenArtifactResolver = = null ) { mavenArtifactResolver = new MavenArtifactResolver ( factory , session ) ; } return mavenArtifactResolver ; }
public Context findScalaContext ( ) throws Exception { if ( scalaContext = = null ) { VersionNumber scalaVersion = findScalaVersion ( ) ; ArtifactIds aids = scalaVersion . major = = 3 ? new ArtifactIds4Scala3 ( scalaVersion ) : new ArtifactIds4Scala2 ( ) ; VersionNumber requiredScalaVersion = StringUtils . isNotEmpty ( scalaCompatVersion ) ? new VersionNumberMask ( scalaCompatVersion ) : scalaVersion ; if ( requiredScalaVersion . compareTo ( scalaVersion ) ! = 0 ) { String msg = String . format ( " Scala library detected % s doesn ' t match scala . compat . version : % s " , scalaVersion , requiredScalaVersion ) ; if ( failOnMultipleScalaVersions ) { getLog ( ) . error ( msg ) ; throw new MojoFailureException ( msg ) ; } getLog ( ) . warn ( msg ) ; } scalaContext = StringUtils . isNotEmpty ( scalaHome ) ? new Context4ScalaHome ( scalaVersion , requiredScalaVersion , aids , new File ( scalaHome ) ) : new Context4ScalaRemote ( scalaVersion , requiredScalaVersion , aids , scalaOrganization , findMavenArtifactResolver ( ) ) ; } return scalaContext ; }
private VersionNumber findScalaVersion ( ) throws Exception { if ( detectedScalaVersion = = null ) { detectedScalaVersion = findScalaVersion0 ( ) ; } return detectedScalaVersion ; }
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) throws Exception { List < DependencyNodeFilter > filters = new ArrayList < > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( findScalaContext ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; }
final JavaMainCaller getEmptyScalaCommand ( final String mainClass ) throws Exception { return getEmptyScalaCommand ( mainClass , fork ) ; }
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) throws Exception { if ( forkOverride ! = fork ) { super . getLog ( ) . info ( " Fork behavior overridden " ) ; super . getLog ( ) . info ( String . format ( " Fork for this execution is % s . " , String . valueOf ( forkOverride ) ) ) ; } JavaMainCaller cmd ; String toolcp = getToolClasspath ( ) ; if ( forkOverride ) { boolean bootcp = true ; if ( args ! = null ) { for ( String arg : args ) { bootcp = bootcp & & ! " - nobootcp " . equals ( arg ) ; } } String cp = bootcp ? " " : toolcp ; bootcp = bootcp & & ! ( StringUtils . isNotEmpty ( addScalacArgs ) & & addScalacArgs . contains ( " - nobootcp " ) ) ; getLog ( ) . debug ( " use java command with args in file forced : " + forceUseArgFile ) ; cmd = new JavaMainCallerByFork ( getLog ( ) , mainClass , cp , null , null , forceUseArgFile , JavaLocator . findExecutableFromToolchain ( getToolchain ( ) ) ) ; if ( bootcp ) { cmd . addJvmArgs ( " - Xbootclasspath / a : " + toolcp ) ; } } else { cmd = new JavaMainCallerInProcess ( getLog ( ) , mainClass , toolcp , null , null ) ; } return cmd ; }
private String getToolClasspath ( ) throws Exception { Set < File > classpath = new TreeSet < > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; if ( dependencies ! = null ) { for ( BasicArtifact artifact : dependencies ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , " " , classpath , true ) ; } } return FileUtils . toMultiPath ( classpath ) ; }
private static String computeTargetOption ( String target ) { if ( target . equals ( " 1 . 5 " ) | | target . equals ( " 5 " ) ) { return " jvm - 1 . 5 " ; } else if ( target . equals ( " 1 . 6 " ) | | target . equals ( " 6 " ) ) { return " jvm - 1 . 6 " ; } else if ( target . equals ( " 1 . 7 " ) | | target . equals ( " 7 " ) ) { return " jvm - 1 . 7 " ; } else if ( target . equals ( " 1 . 8 " ) | | target . equals ( " 8 " ) ) { return " jvm - 1 . 8 " ; } return null ; }
private static String computeReleaseOptionFromTarget ( String target ) { if ( target . equals ( " 1 . 5 " ) ) { return " 5 " ; } else if ( target . equals ( " 1 . 6 " ) ) { return " 6 " ; } else if ( target . equals ( " 1 . 7 " ) ) { return " 7 " ; } else if ( target . equals ( " 1 . 8 " ) ) { return " 8 " ; } return target ; }
protected List < String > getScalacOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; options . addAll ( computeBytecodeVersionOptions ( target , release , findScalaVersion ( ) ) ) ; return options ; }
private Set < File > getCompilerPlugins ( ) throws Exception { Set < File > plugins = new TreeSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < File > ignoreClasspath = new TreeSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin : " + artifact . toString ( ) ) ; Set < File > pluginClassPath = new TreeSet < > ( ) ; addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , artifact . classifier , pluginClassPath , false ) ; pluginClassPath . removeAll ( ignoreClasspath ) ; plugins . addAll ( pluginClassPath ) ; } } return plugins ; }
protected void doExecute ( ) throws Exception { Context sc = findScalaContext ( ) ; final JavaMainCaller jcmd = super . getScalaCommand ( false , sc . consoleMainClassName ( mainConsole ) ) ; final VersionNumber scalaVersion = super . findScalaContext ( ) . version ( ) ; final Set < File > classpath = this . setupClassPathForConsole ( scalaVersion ) ; if ( super . fork ) { super . getLog ( ) . info ( " Ignoring fork for console execution . " ) ; } final String classpathStr = FileUtils . toMultiPath ( classpath ) ; jcmd . addArgs ( super . args ) ; jcmd . addOption ( " - cp " , classpathStr ) ; super . addCompilerPluginOptions ( jcmd ) ; this . handleJavaRebel ( jcmd ) ; jcmd . run ( super . displayCmd ) ; }
private Set < File > setupClassPathForConsole ( final VersionNumber scalaVersion ) throws Exception { final Set < File > classpath = new TreeSet < File > ( ) ; classpath . addAll ( this . setupProjectClasspaths ( ) ) ; classpath . addAll ( this . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; }
private Set < File > setupConsoleClasspaths ( final VersionNumber scalaVersion ) throws Exception { final Set < File > classpath = new TreeSet < File > ( ) ; Artifact a = this . resolveJLine ( this . fallbackJLine ( scalaVersion ) ) ; addToClasspath ( a . getGroupId ( ) , a . getArtifactId ( ) , a . getVersion ( ) , a . getClassifier ( ) , classpath , true ) ; return classpath ; }
private Artifact resolveJLine ( final Artifact defaultFallback ) throws Exception { final Set < Artifact > compilerDeps = findScalaContext ( ) . findCompilerAndDependencies ( ) ; for ( final Artifact a : compilerDeps ) { if ( filterForJline ( a ) ) { return a ; } } getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM . Falling back to hard - coded defaults . " ) ; getLog ( ) . warn ( " If you get an InvocationTargetException , then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine : % s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; }
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; return artifactId . equals ( ScalaConsoleMojo . JLINE ) & & groupId . equals ( ScalaConsoleMojo . JLINE ) ; }
private static String scriptBaseNameOf ( File scriptFile , int idx ) { if ( scriptFile = = null ) { return " embeddedScript_ " + idx ; } int dot = scriptFile . getName ( ) . lastIndexOf ( ' . ' ) ; if ( dot = = - 1 ) { return scriptFile . getName ( ) + " _ " + idx ; } return scriptFile . getName ( ) . substring ( 0 , dot ) + " _ " + idx ; }
private URLClassLoader createScriptClassloader ( File scriptDir , Set < File > classpath ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , " org . apache . maven " ) ; rScript . addURL ( scriptDir . toURI ( ) . toURL ( ) ) ; for ( File f : classpath ) { rScript . addURL ( f . toURI ( ) . toURL ( ) ) ; } return rScript ; }
private void compileScript ( File scriptDir , File destFile , URLClassLoader loader ) throws Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " - classpath " , MainHelper . toClasspathString ( loader ) ) ; jcmd . addArgs ( " - d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " - sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; }
private void delete ( File scriptDir ) { if ( scriptDir . isDirectory ( ) ) { for ( File file : scriptDir . listFiles ( ) ) { delete ( file ) ; } } scriptDir . deleteOnExit ( ) ; scriptDir . delete ( ) ; }
public boolean accept ( DependencyNode node ) { return include ( node . getArtifact ( ) ) ; }
public boolean hasInDistro ( Artifact artifact ) throws Exception { return false ; }
public Set < Artifact > findLibraryAndDependencies ( ) throws Exception { File lib = new File ( scalaHome , " lib " ) ; File f = new File ( lib , aids . scalaLibraryArtifactId ( ) + " . jar " ) ; Set < Artifact > d = new TreeSet < > ( ) ; d . add ( new LocalFileArtifact ( " local " , aids . scalaLibraryArtifactId ( ) , scalaVersion . toString ( ) , f ) ) ; return d ; }
public Set < Artifact > findCompilerAndDependencies ( ) throws Exception { Set < Artifact > d = new TreeSet < > ( ) ; for ( File f : new File ( scalaHome , " lib " ) . listFiles ( ) ) { String name = f . getName ( ) ; if ( name . endsWith ( " . jar " ) ) { d . add ( new LocalFileArtifact ( " local " , name . substring ( 0 , name . length ( ) - 4 ) , scalaVersion . toString ( ) , f ) ) ; } } return d ; }
public boolean hasClassifier ( ) { return false ; }
public void addMetadata ( ArtifactMetadata metadata ) { throw new UnsupportedOperationException ( " not implemented " ) ; }
public void updateVersion ( String version , ArtifactRepository localRepository ) { throw new UnsupportedOperationException ( " not implemented " ) ; }
public void selectVersion ( String version ) { throw new UnsupportedOperationException ( " not implemented " ) ; }
public ArtifactVersion getSelectedVersion ( ) throws OverConstrainedVersionException { throw new UnsupportedOperationException ( " not implemented " ) ; }
public boolean isSelectedVersionKnown ( ) throws OverConstrainedVersionException { throw new UnsupportedOperationException ( " not implemented " ) ; }
public int compareTo ( Artifact o ) { int c = groupId . compareTo ( o . getGroupId ( ) ) ; if ( c ! = 0 ) return c ; c = artifactId . compareTo ( o . getArtifactId ( ) ) ; if ( c ! = 0 ) return c ; return version . compareTo ( o . getVersion ( ) ) ; }
public boolean endVisit ( DependencyNode node ) { return ! _failed ; }
public List < String > scalaDistroArtifactIds ( ) throws Exception { return SCALA_DISTRO_ARTIFACTS ; }
public String scalaLibraryArtifactId ( ) throws Exception { return SCALA_LIBRARY_ARTIFACTID ; }
public String scalaCompilerArtifactId ( ) throws Exception { return SCALA_COMPILER_ARTIFACTID ; }
public String compilerMainClassName ( boolean useFsc ) throws Exception { return useFsc ? " scala . tools . nsc . CompileClient " : " scala . tools . nsc . Main " ; }
public String consoleMainClassName ( ) throws Exception { return " scala . tools . nsc . MainGenericRunner " ; }
public String apidocMainClassName ( ) throws Exception { return " scala . tools . nsc . ScalaDoc " ; }
public VersionNumber version ( ) { return scalaVersion ; }
public VersionNumber versionCompat ( ) { return scalaCompatVersion ; }
public String scalaLibraryArtifactId ( ) throws Exception { return getScala3ArtifactId ( SCALA_LIBRARY_ARTIFACTID ) ; }
public String scalaCompilerArtifactId ( ) throws Exception { return getScala3ArtifactId ( SCALA_COMPILER_ARTIFACTID ) ; }
public String compilerMainClassName ( boolean useFsc ) throws Exception { return " dotty . tools . dotc . Main " ; }
public String consoleMainClassName ( ) throws Exception { return " dotty . tools . repl . Main " ; }
public String apidocMainClassName ( ) throws Exception { return " dotty . tools . dotc . Main " ; }
public void testModifiedTimeIsSet ( ) throws Exception { File dir = prepareSubdir ( ) ; DataProducer dirProducer = new DataProducerDirectory ( dir , null , null , null ) ; DataProducer fileProducer = new DataProducerFile ( new File ( " pom . xml " ) , " / usr / share / myapp / pom . xml " , null , null , null ) ; DataProducer linkProducer = new DataProducerLink ( " pomLink . xml " , " / usr / share / myapp / pom . xml " , true , null , null , null ) ; File archive = prepareArchive ( ) ; DataBuilder builder = new DataBuilder ( new NullConsole ( ) , EXPECTED_MODIFIED_TIME ) ; builder . buildData ( Arrays . asList ( fileProducer , linkProducer , dirProducer ) , archive , new StringBuilder ( ) , new TarOptions ( ) . compression ( Compression . NONE ) , false ) ; assertExpectedModTimeInArchive ( archive ) ; }
public void testIgnoreBrokenLinks ( ) throws Exception { File dir = prepareSubdirWithSymlink ( ) ; DataProducer dirProducer = new DataProducerDirectory ( dir , null , null , null ) ; File archive = prepareArchive ( ) ; DataBuilder builder = new DataBuilder ( new NullConsole ( ) , null ) ; try { builder . buildData ( Arrays . asList ( dirProducer ) , archive , new StringBuilder ( ) , new TarOptions ( ) . compression ( Compression . NONE ) , false ) ; fail ( " buildData should not be successful with ignoreBrokenLinks set to false " ) ; } catch ( ProducerFileNotFoundException e ) { } builder . buildData ( Arrays . asList ( dirProducer ) , archive , new StringBuilder ( ) , new TarOptions ( ) . compression ( Compression . NONE ) , true ) ; }
private File prepareArchive ( ) { File archive = new File ( " target / data . tar " ) ; if ( archive . exists ( ) ) { archive . delete ( ) ; } return archive ; }
private File prepareSubdir ( ) throws IOException { File subDir = new File ( " target / subDir " ) ; subDir . mkdir ( ) ; File file = new File ( subDir , " file . txt " ) ; file . createNewFile ( ) ; File nestedDir = new File ( subDir , " nested - dir " ) ; nestedDir . mkdir ( ) ; File file2 = new File ( nestedDir , " file2 . txt " ) ; file2 . createNewFile ( ) ; return subDir ; }
private File prepareSubdirWithSymlink ( ) throws IOException { File subDir = new File ( " target / subDirWithLinks " ) ; subDir . mkdir ( ) ; File file1 = new File ( subDir , " file1 . txt " ) ; file1 . createNewFile ( ) ; Path targetPath = Paths . get ( " nonExistentFile . txt " ) ; Path linkPath = Paths . get ( subDir . getPath ( ) + " / link . txt " ) ; Files . createSymbolicLink ( linkPath , targetPath ) ; return subDir ; }
public static boolean walkControl ( File deb , final ArchiveVisitor < TarArchiveEntry > visitor ) throws IOException { return walkEmbedded ( deb , " control . tar " , visitor , Compression . GZIP ) ; }
public static boolean walkData ( File deb , final ArchiveVisitor < TarArchiveEntry > visitor , final Compression compression ) throws IOException { return walkEmbedded ( deb , " data . tar " , visitor , compression ) ; }
public static void walkArchive ( File deb , ArchiveVisitor < ArArchiveEntry > visitor ) throws IOException { ArArchiveInputStream in = new ArArchiveInputStream ( new FileInputStream ( deb ) ) ; ArchiveWalker . walk ( in , visitor ) ; }
public void testConstantModifiedTime ( ) throws Exception { DataProducer [ ] data = prepareData ( ) ; File deb = File . createTempFile ( " jdeb " , " . deb " ) ; Collection < DataProducer > confFileProducers = Arrays . asList ( new DataProducer [ ] { new EmptyDataProducer ( ) } ) ; DebMaker maker = new DebMaker ( new NullConsole ( ) , Arrays . asList ( data ) , confFileProducers ) ; maker . setEncoding ( StandardCharsets . UTF_8 ) ; maker . setControl ( new File ( getClass ( ) . getResource ( " deb / control " ) . toURI ( ) ) ) ; maker . setDeb ( deb ) ; maker . setOutputTimestampMs ( EXPECTED_MODIFIED_TIME ) ; BinaryPackageControlFile packageControlFile = maker . createDeb ( Compression . GZIP ) ; assertTrue ( packageControlFile . isValid ( ) ) ; ArchiveWalker . walkArchive ( deb , new ArchiveModifiedTimeAssert ( ) ) ; ModifiedTimeAssert modifiedTimeAssert = new ModifiedTimeAssert ( ) ; ArchiveWalker . walkData ( deb , modifiedTimeAssert , Compression . GZIP ) ; ArchiveWalker . walkControl ( deb , modifiedTimeAssert ) ; assertTrue ( " Cannot delete the file " + deb , deb . delete ( ) ) ; }
public void testChangesValidation ( ) throws Exception { File deb = File . createTempFile ( " jdeb " , " . deb " ) ; File changesSave = File . createTempFile ( " changesSave " , " . txt " ) ; File directory = new File ( getClass ( ) . getResource ( " deb / data " ) . toURI ( ) ) ; DebMaker maker = new DebMaker ( new NullConsole ( ) , Arrays . asList ( new UseNullAsInputStream ( ) ) , null ) ; maker . setEncoding ( StandardCharsets . UTF_8 ) ; assertThrows ( PackagingException . class , maker : : validate ) ; maker . setControl ( new File ( getClass ( ) . getResource ( " deb / control " ) . toURI ( ) ) ) ; assertThrows ( PackagingException . class , maker : : validate ) ; maker . setDeb ( deb ) ; maker . validate ( ) ; maker . setChangesEnabled ( true ) ; maker . validate ( ) ; maker . setChangesIn ( directory ) ; assertThrows ( PackagingException . class , maker : : validate ) ; maker . setChangesIn ( new File ( getClass ( ) . getResource ( " changes / changes . txt " ) . toURI ( ) ) ) ; maker . validate ( ) ; maker . setChangesSave ( directory ) ; assertThrows ( PackagingException . class , maker : : validate ) ; maker . setChangesSave ( null ) ; maker . setChangesOut ( directory ) ; assertThrows ( PackagingException . class , maker : : validate ) ; maker . setChangesOut ( null ) ; maker . setChangesSave ( changesSave ) ; maker . validate ( ) ; maker . setChangesIn ( null ) ; assertThrows ( PackagingException . class , maker : : validate ) ; maker . setChangesEnabled ( false ) ; maker . setCompression ( null ) ; assertThrows ( PackagingException . class , maker : : validate ) ; }
public void visit ( TarArchiveEntry entry , byte [ ] content ) throws IOException { assertEquals ( " Modified time does not match the expected value for " + entry . getName ( ) , EXPECTED_MODIFIED_TIME , entry . getModTime ( ) . getTime ( ) ) ; }
public void visit ( ArArchiveEntry entry , byte [ ] content ) throws IOException { assertEquals ( " Modified time does not match the expected value for " + entry . getName ( ) , EXPECTED_MODIFIED_TIME / 1000 , entry . getLastModified ( ) ) ; }
public void produce ( DataConsumer receiver ) throws IOException { receiver . onEachFile ( null , createEntry ( ) ) ; }
private TarArchiveEntry createEntry ( ) { TarArchiveEntry entry = new TarArchiveEntry ( " missing_file " ) ; return entry ; }
public void testEmptyPackage ( ) { project . executeTarget ( " empty - package " ) ; assertTrue ( " package not build " , new File ( " target / test - classes / test . deb " ) . exists ( ) ) ; }
public void testPackageWithArchive ( ) { project . executeTarget ( " with - archive " ) ; assertTrue ( " package not build " , new File ( " target / test - classes / test . deb " ) . exists ( ) ) ; }
public void testPackageWithDirectory ( ) { project . executeTarget ( " with - directory " ) ; assertTrue ( " package not build " , new File ( " target / test - classes / test . deb " ) . exists ( ) ) ; }
private void redirectOutput ( OutputStream out ) { DefaultLogger logger = new DefaultLogger ( ) ; logger . setOutputPrintStream ( new PrintStream ( out ) ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; project . addBuildListener ( logger ) ; }
public void testVerboseEnabled ( ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; redirectOutput ( out ) ; project . executeTarget ( " verbose - enabled " ) ; assertTrue ( out . toString ( ) . contains ( " Total size " ) ) ; }
public void testVerboseDisabled ( ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; redirectOutput ( out ) ; project . executeTarget ( " verbose - disabled " ) ; assertTrue ( ! out . toString ( ) . contains ( " Total size " ) ) ; }
public void testFileSet ( ) { project . executeTarget ( " fileset " ) ; assertTrue ( " package not build " , new File ( " target / test - classes / test . deb " ) . exists ( ) ) ; }
public void testPackageConffiles ( ) { project . executeTarget ( " conffiles " ) ; assertTrue ( " package not build " , new File ( " target / test - classes / test . deb " ) . exists ( ) ) ; }
public void testEntryNameWithRelativePath ( ) { PermMapper mapper = createMapper ( ) ; TarArchiveEntry mappedEntry = mapper . map ( new TarArchiveEntry ( " foo / bar " , true ) ) ; assertEquals ( " " , " foo / bar " , mappedEntry . getName ( ) ) ; }
public void testEntryNameWithAbsolutePath ( ) { PermMapper mapper = createMapper ( ) ; TarArchiveEntry mappedEntry = mapper . map ( new TarArchiveEntry ( " / foo / bar " , true ) ) ; assertEquals ( " " , " foo / bar " , mappedEntry . getName ( ) ) ; }
PermMapper createMapper ( ) { return new PermMapper ( - 1 , - 1 , null , null , null , null , - 1 , null ) ; }
public void testModes ( ) throws Exception { final ByteArrayInputStream is = new ByteArrayInputStream ( output . getBytes ( UTF_8 ) ) ; final Mapper mapper = new LsMapper ( is ) ; final TarArchiveEntry entry1 = mapper . map ( new TarArchiveEntry ( " trunk / target / test - classes / org / vafer / dependency " , true ) ) ; assertEquals ( 493 , entry1 . getMode ( ) ) ; assertEquals ( " tcurdt " , entry1 . getUserName ( ) ) ; assertEquals ( " tcurdt " , entry1 . getGroupName ( ) ) ; final TarArchiveEntry entry2 = mapper . map ( new TarArchiveEntry ( " trunk / target / test - classes / org / vafer / dependency / DependenciesTestCase . class " , true ) ) ; assertEquals ( 420 , entry2 . getMode ( ) ) ; assertEquals ( " tcurdt " , entry2 . getUserName ( ) ) ; assertEquals ( " tcurdt " , entry2 . getGroupName ( ) ) ; }
public void setUp ( ) throws Exception { file1 = File . createTempFile ( getClass ( ) . getSimpleName ( ) + " . 1 " , " txt " ) ; file2 = File . createTempFile ( getClass ( ) . getSimpleName ( ) + " . 2 " , " txt " ) ; }
public void tearDown ( ) throws Exception { file1 . delete ( ) ; file2 . delete ( ) ; }
public void testTypical ( ) throws Exception { String [ ] paths = { " / var / log / " , " / var / lib / " } ; dataProducer = new DataProducerPathTemplate ( paths , INCLUDES , EXCLUDES , mappers ) ; dataProducer . produce ( captureDataConsumer ) ; assertEquals ( 2 , captureDataConsumer . invocations . size ( ) ) ; CaptureDataConsumer . Invocation invocation = captureDataConsumer . invocations . get ( 0 ) ; assertEquals ( " / var / log / " , invocation . dirname ) ; assertEquals ( 0 , invocation . gid ) ; assertEquals ( " root " , invocation . group ) ; assertEquals ( " " , invocation . linkname ) ; assertEquals ( TarArchiveEntry . DEFAULT_DIR_MODE , invocation . mode ) ; assertEquals ( 0 , invocation . size ) ; assertEquals ( 0 , invocation . uid ) ; assertEquals ( " root " , invocation . user ) ; invocation = captureDataConsumer . invocations . get ( 1 ) ; assertEquals ( " / var / lib / " , invocation . dirname ) ; assertEquals ( 0 , invocation . gid ) ; assertEquals ( " root " , invocation . group ) ; assertEquals ( " " , invocation . linkname ) ; assertEquals ( TarArchiveEntry . DEFAULT_DIR_MODE , invocation . mode ) ; assertEquals ( 0 , invocation . size ) ; assertEquals ( 0 , invocation . uid ) ; assertEquals ( " root " , invocation . user ) ; }
public void testClearSign ( ) throws Exception { final InputStream ring = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " org / vafer / gpg / secring . gpg " ) ; assertNotNull ( ring ) ; String input = " TEST1 \ n - TEST2 \ n \ nTEST3 \ n " ; final String expectedOutputStr = " - - - - - BEGIN PGP SIGNED MESSAGE - - - - - \ n " + " Hash : SHA1 \ n " + " \ n " + " TEST1 \ n " + " - - TEST2 \ n " + " \ n " + " TEST3 \ n " + " - - - - - BEGIN PGP SIGNATURE - - - - - \ n " + " Version : BCPG v1 . 58 \ n " + " \ n " + " iEYEARECABAFAkax1rgJEHM9pIAuB02PAABIJgCghFmoCJCZ0CGiqgVLGGPd / Yh5 \ n " + " FQQAnRVqvI2ij45JQSHYJBblZ0Vv2meN \ n " + " = aAAT \ n " + " - - - - - END PGP SIGNATURE - - - - - \ n " ; final byte [ ] expectedOutput = expectedOutputStr . getBytes ( UTF_8 ) ; final ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; PGPSigner signer = new PGPSigner ( ring , " 2E074D8F " , " test " , PGPUtil . SHA1 ) ; signer . clearSign ( input , os ) ; final byte [ ] output = fixCRLF ( os . toByteArray ( ) ) ; final int sign_from = expectedOutputStr . indexOf ( " iEYEAREC " ) ; final int sign_until = expectedOutputStr . indexOf ( " = aAAT " ) + 5 ; Arrays . fill ( output , sign_from , sign_until , ( byte ) ' ? ' ) ; Arrays . fill ( expectedOutput , sign_from , sign_until , ( byte ) ' ? ' ) ; final int version_from = expectedOutputStr . indexOf ( " v1 . " ) ; final int version_until = expectedOutputStr . indexOf ( " \ n " , sign_from ) - 1 ; Arrays . fill ( output , version_from , version_until , ( byte ) ' ? ' ) ; Arrays . fill ( expectedOutput , version_from , version_until , ( byte ) ' ? ' ) ; assertEquals ( new String ( expectedOutput ) , new String ( output ) ) ; }
public void testKeyLoading ( ) throws Exception { InputStream ring = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " org / vafer / gpg / secring . gpg " ) ; PGPSigner signer = new PGPSigner ( ring , " 2E074D8F " , " test " , PGPUtil . SHA1 ) ; assertEquals ( " correct key found " , " 733da4802e074d8f " , String . format ( " % 016x " , signer . getSecretKey ( ) . getKeyID ( ) ) ) ; ring . reset ( ) ; signer = new PGPSigner ( ring , " 0C1FF47A " , " test " , PGPUtil . SHA1 ) ; assertEquals ( " key with leading 0 found " , " 21970bb80c1ff47a " , String . format ( " % 016x " , signer . getSecretKey ( ) . getKeyID ( ) ) ) ; }
private byte [ ] fixCRLF ( byte [ ] b ) { String s = new String ( b ) ; s = s . replaceAll ( " \ r \ n " , " \ n " ) ; return s . getBytes ( ) ; }
public void testFormatSimpleValue ( ) { ControlField field = new ControlField ( " Field - Name " ) ; assertEquals ( " Field - Name : value \ n " , field . format ( " value " ) ) ; }
public void testFormatMultilineValue1 ( ) { ControlField field = new ControlField ( " Field - Name " , false , ControlField . Type . MULTILINE ) ; assertEquals ( " Field - Name : value1 \ n value2 \ n . \ n value3 \ n " , field . format ( " value1 \ nvalue2 \ n \ nvalue3 " ) ) ; }
public void testFormatMultilineValue2 ( ) { ControlField field = new ControlField ( " Field - Name " , false , ControlField . Type . MULTILINE , true ) ; assertEquals ( " Field - Name : \ n value1 \ n value2 \ n . \ n value3 \ n " , field . format ( " value1 \ nvalue2 \ n \ nvalue3 " ) ) ; }
public void before ( ) { defaultTimeZone = TimeZone . getDefault ( ) ; }
public void after ( ) { TimeZone . setDefault ( defaultTimeZone ) ; }
public void testToString ( ) throws Exception { BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . set ( " Package " , " test - package " ) ; packageControlFile . set ( " Description " , " This is \ na description \ non several lines " ) ; packageControlFile . set ( " Version " , " 1 . 0 " ) ; packageControlFile . set ( " XC - UserDefinedField " , " This is a user defined field . " ) ; ChangesFile changes = new ChangesFile ( ) ; changes . setChanges ( new ChangeSet [ 0 ] ) ; changes . initialize ( packageControlFile ) ; assertEquals ( " 1 . 0 " , changes . get ( " Version " ) ) ; assertEquals ( " This is a user defined field . " , changes . get ( " UserDefinedField " ) ) ; }
public void testFormatDate ( ) { TimeZone . setDefault ( TimeZone . getTimeZone ( " America / Chicago " ) ) ; assertEquals ( " Mon , 26 Aug 2024 09 : 00 : 00 - 0500 " , ChangesFile . formatDate ( new Date ( 1724680800000L ) ) ) ; }
public void testFormatDateUTC ( ) { TimeZone . setDefault ( TimeZone . getTimeZone ( " America / Chicago " ) ) ; assertEquals ( " Mon , 26 Aug 2024 14 : 00 : 00 + 0000 " , ChangesFile . formatDateUTC ( new Date ( 1724680800000L ) ) ) ; }
public void testParse ( ) throws Exception { String input = " Key1 : Value1 \ n " + " Key2 : Value2 \ n " + " Value2 . 1 \ n " + " Value2 . 2 \ n " + " Key3 : Value3 \ n " ; BinaryPackageControlFile d = new BinaryPackageControlFile ( input ) ; assertFalse ( d . isValid ( ) ) ; assertEquals ( " key 1 " , " Value1 " , d . get ( " Key1 " ) ) ; assertEquals ( " key 2 " , " Value2 \ nValue2 . 1 \ nValue2 . 2 " , d . get ( " Key2 " ) ) ; assertEquals ( " key 3 " , " Value3 " , d . get ( " Key3 " ) ) ; }
public void testComments ( ) throws Exception { String input = " Key1 : Value1 \ n " + " Key2 : Value2 \ n " + " Value2 . 1 \ n " + " # Value2 . 2 \ n " + " # Key3 : Value3comment \ n " + " Key3 : Value3 \ n " + " # Value3 . 1 \ n " + " Value3 . 2 \ n " + " Key4 : Value4 \ n " + " # Value4 . 1 \ n " + " # Value4 . 2 \ n " + " # Key5 : Value5 \ n " ; BinaryPackageControlFile d = new BinaryPackageControlFile ( input ) ; assertFalse ( d . isValid ( ) ) ; assertEquals ( " key 1 " , " Value1 " , d . get ( " Key1 " ) ) ; assertEquals ( " key 2 " , " Value2 \ nValue2 . 1 " , d . get ( " Key2 " ) ) ; assertEquals ( " key 3 " , " Value3 \ nValue3 . 2 " , d . get ( " Key3 " ) ) ; assertEquals ( " key 4 " , " Value4 " , d . get ( " Key4 " ) ) ; assertEquals ( " key 5 " , null , d . get ( " Key5 " ) ) ; }
public void testToString ( ) throws Exception { BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . set ( " Package " , " test - package " ) ; packageControlFile . set ( " Description " , " This is \ na description \ non several lines " ) ; packageControlFile . set ( " Version " , " 1 . 0 " ) ; String s = packageControlFile . toString ( ) ; BinaryPackageControlFile packageControlFile2 = new BinaryPackageControlFile ( s ) ; assertEquals ( " Package " , packageControlFile . get ( " Package " ) , packageControlFile2 . get ( " Package " ) ) ; assertEquals ( " Description " , packageControlFile . get ( " Description " ) , packageControlFile2 . get ( " Description " ) ) ; assertEquals ( " Version 3 " , packageControlFile . get ( " Version " ) , packageControlFile2 . get ( " Version " ) ) ; }
public void testGetShortDescription ( ) { BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; assertNull ( packageControlFile . getShortDescription ( ) ) ; packageControlFile . set ( " Description " , " This is the short description \ nThis is the loooooong description " ) ; assertEquals ( " short description " , " This is the short description " , packageControlFile . getShortDescription ( ) ) ; packageControlFile . set ( " Description " , " \ nThere is no short description " ) ; assertEquals ( " short description " , " " , packageControlFile . getShortDescription ( ) ) ; }
public void testGetUserDefinedFields ( ) throws Exception { BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . parse ( new FileInputStream ( " target / test - classes / org / vafer / jdeb / deb / control / control " ) ) ; assertEquals ( " UserDefinedField " , " This is a user defined field . " , packageControlFile . get ( " UserDefinedField " ) ) ; }
public void testChangedByNotSet ( ) throws Exception { TimeZone . setDefault ( TimeZone . getTimeZone ( " America / Chicago " ) ) ; final String input = " release distribution = production , date = 14 : 00 13 . 01 . 2007 , version = 12324 , urgency = low \ n " + " * change1 \ n " + " * change2 \ n " ; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . set ( " Package " , " package " ) ; packageControlFile . set ( " Version " , " version " ) ; packageControlFile . set ( " Date " , " Mon , 20 Aug 2007 15 : 25 : 57 + 0200 " ) ; final TextfileChangesProvider provider = new TextfileChangesProvider ( new ByteArrayInputStream ( input . getBytes ( UTF_8 ) ) , packageControlFile , StandardCharsets . UTF_8 ) ; final ChangeSet [ ] changeSets = provider . getChangesSets ( ) ; assertNotNull ( changeSets ) ; assertEquals ( 1 , changeSets . length ) ; assertEquals ( 1168718400000L , changeSets [ 0 ] . getDate ( ) . getTime ( ) ) ; ChangesFile changesFile = new ChangesFile ( ) ; changesFile . setChanges ( provider . getChangesSets ( ) ) ; changesFile . initialize ( packageControlFile ) ; assertNotNull ( changesFile ) ; assertEquals ( null , changesFile . get ( " Changed - By " ) ) ; }
public void testChangedByFromControl ( ) throws Exception { TimeZone . setDefault ( TimeZone . getTimeZone ( " America / Chicago " ) ) ; final String input = " release distribution = production , date = 14 : 00 13 . 01 . 2007 , version = 12324 , urgency = low \ n " + " * change1 \ n " + " * change2 \ n " ; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . set ( " Package " , " package " ) ; packageControlFile . set ( " Version " , " version " ) ; packageControlFile . set ( " Maintainer " , " tcurdt @ joost . com " ) ; packageControlFile . set ( " Date " , " Mon , 20 Aug 2007 15 : 25 : 57 + 0200 " ) ; final TextfileChangesProvider provider = new TextfileChangesProvider ( new ByteArrayInputStream ( input . getBytes ( UTF_8 ) ) , packageControlFile , StandardCharsets . UTF_8 ) ; final ChangeSet [ ] changeSets = provider . getChangesSets ( ) ; assertNotNull ( changeSets ) ; assertEquals ( 1 , changeSets . length ) ; assertEquals ( 1168718400000L , changeSets [ 0 ] . getDate ( ) . getTime ( ) ) ; ChangesFile changesFile = new ChangesFile ( ) ; changesFile . setChanges ( provider . getChangesSets ( ) ) ; changesFile . initialize ( packageControlFile ) ; assertNotNull ( changesFile ) ; assertEquals ( " tcurdt @ joost . com " , changesFile . get ( " Changed - By " ) ) ; }
public void testChangedByFromChangesProvider ( ) throws Exception { TimeZone . setDefault ( TimeZone . getTimeZone ( " America / Chicago " ) ) ; final String input = " release distribution = production , date = 14 : 00 13 . 01 . 2007 , version = 12324 , urgency = low , by = mrasko @ test . com \ n " + " * change1 \ n " + " * change2 \ n " ; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . set ( " Package " , " package " ) ; packageControlFile . set ( " Version " , " version " ) ; packageControlFile . set ( " Maintainer " , " tcurdt @ joost . com " ) ; packageControlFile . set ( " Date " , " Mon , 20 Aug 2007 15 : 25 : 57 + 0200 " ) ; final TextfileChangesProvider provider = new TextfileChangesProvider ( new ByteArrayInputStream ( input . getBytes ( UTF_8 ) ) , packageControlFile , StandardCharsets . UTF_8 ) ; final ChangeSet [ ] changeSets = provider . getChangesSets ( ) ; assertNotNull ( changeSets ) ; assertEquals ( 1 , changeSets . length ) ; assertEquals ( 1168718400000L , changeSets [ 0 ] . getDate ( ) . getTime ( ) ) ; ChangesFile changesFile = new ChangesFile ( ) ; changesFile . setChanges ( provider . getChangesSets ( ) ) ; changesFile . initialize ( packageControlFile ) ; assertNotNull ( changesFile ) ; assertEquals ( " mrasko @ test . com " , changesFile . get ( " Changed - By " ) ) ; }
public void testReproducible ( ) throws Exception { TimeZone . setDefault ( TimeZone . getTimeZone ( " America / Chicago " ) ) ; final String input = " release distribution = production , date = 14 : 00 13 . 01 . 2007 , version = 12324 , urgency = low \ n " + " * change1 \ n " + " * change2 \ n " ; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . set ( " Package " , " package " ) ; packageControlFile . set ( " Version " , " version " ) ; packageControlFile . set ( " Date " , " Mon , 20 Aug 2007 15 : 25 : 57 + 0200 " ) ; final TextfileChangesProvider provider = new TextfileChangesProvider ( new ByteArrayInputStream ( input . getBytes ( UTF_8 ) ) , packageControlFile , 1175385600000L , StandardCharsets . UTF_8 ) ; final ChangeSet [ ] changeSets = provider . getChangesSets ( ) ; assertNotNull ( changeSets ) ; assertEquals ( 1 , changeSets . length ) ; assertEquals ( 1168696800000L , changeSets [ 0 ] . getDate ( ) . getTime ( ) ) ; ChangesFile changesFile = new ChangesFile ( ) ; changesFile . setChanges ( provider . getChangesSets ( ) ) ; changesFile . initialize ( packageControlFile ) ; assertNotNull ( changesFile ) ; assertEquals ( null , changesFile . get ( " Changed - By " ) ) ; }
public void testParsing ( ) throws Exception { TimeZone . setDefault ( TimeZone . getTimeZone ( " America / Chicago " ) ) ; final String input = " * change1 \ n " + " * change2 \ n " + " release date = 14 : 00 13 . 01 . 2007 , version = 12324 , urgency = low , by = tcurdt @ joost . com \ n " + " * change1 \ n " + " * change2 \ n " + " release date = 12 : 00 10 . 01 . 2007 , version = 10324 , urgency = low , by = tcurdt @ joost . com \ n " + " * change1 \ n " + " * change2 \ n " ; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . set ( " Package " , " package " ) ; packageControlFile . set ( " Version " , " version " ) ; packageControlFile . set ( " Distribution " , " distribution " ) ; packageControlFile . set ( " Date " , " Mon , 20 Aug 2007 15 : 25 : 57 + 0200 " ) ; final TextfileChangesProvider provider = new TextfileChangesProvider ( new ByteArrayInputStream ( input . getBytes ( UTF_8 ) ) , packageControlFile , StandardCharsets . UTF_8 ) ; final ChangeSet [ ] changeSets = provider . getChangesSets ( ) ; assertNotNull ( changeSets ) ; assertEquals ( 3 , changeSets . length ) ; assertEquals ( 1168718400000L , changeSets [ 1 ] . getDate ( ) . getTime ( ) ) ; assertEquals ( 1168452000000L , changeSets [ 2 ] . getDate ( ) . getTime ( ) ) ; }
public void testDistributionFromChangesProvider ( ) throws Exception { TimeZone . setDefault ( TimeZone . getTimeZone ( " America / Chicago " ) ) ; final String input = " release distribution = production \ n " + " * change1 \ n " + " * change2 \ n " + " release distribution = staging , date = 14 : 00 13 . 01 . 2007 , version = 12324 , urgency = low , by = tcurdt @ joost . com \ n " + " * change1 \ n " + " * change2 \ n " + " release distribution = development , date = 12 : 00 10 . 01 . 2007 , version = 10324 , urgency = low , by = tcurdt @ joost . com \ n " + " * change1 \ n " + " * change2 \ n " ; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . set ( " Package " , " package " ) ; packageControlFile . set ( " Version " , " version " ) ; packageControlFile . set ( " Date " , " Mon , 20 Aug 2007 15 : 25 : 57 + 0200 " ) ; final TextfileChangesProvider provider = new TextfileChangesProvider ( new ByteArrayInputStream ( input . getBytes ( UTF_8 ) ) , packageControlFile , StandardCharsets . UTF_8 ) ; final ChangeSet [ ] changeSets = provider . getChangesSets ( ) ; assertNotNull ( changeSets ) ; assertEquals ( 3 , changeSets . length ) ; assertEquals ( " production " , changeSets [ 0 ] . getDistribution ( ) ) ; assertEquals ( " staging " , changeSets [ 1 ] . getDistribution ( ) ) ; assertEquals ( 1168718400000L , changeSets [ 1 ] . getDate ( ) . getTime ( ) ) ; assertEquals ( " development " , changeSets [ 2 ] . getDistribution ( ) ) ; assertEquals ( 1168452000000L , changeSets [ 2 ] . getDate ( ) . getTime ( ) ) ; }
public void testReproducible ( ) throws Exception { TimeZone . setDefault ( TimeZone . getTimeZone ( " America / Chicago " ) ) ; final String input = " * change1 \ n " + " * change2 \ n " + " release date = 14 : 00 13 . 01 . 2007 , version = 12324 , urgency = low , by = tcurdt @ joost . com \ n " + " * change1 \ n " + " * change2 \ n " + " release date = 12 : 00 10 . 01 . 2007 , version = 10324 , urgency = low , by = tcurdt @ joost . com \ n " + " * change1 \ n " + " * change2 \ n " ; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( ) ; packageControlFile . set ( " Package " , " package " ) ; packageControlFile . set ( " Version " , " version " ) ; packageControlFile . set ( " Distribution " , " distribution " ) ; packageControlFile . set ( " Date " , " Mon , 20 Aug 2007 15 : 25 : 57 + 0200 " ) ; final TextfileChangesProvider provider = new TextfileChangesProvider ( new ByteArrayInputStream ( input . getBytes ( UTF_8 ) ) , packageControlFile , 1175385600000L , StandardCharsets . UTF_8 ) ; final ChangeSet [ ] changeSets = provider . getChangesSets ( ) ; assertNotNull ( changeSets ) ; assertEquals ( 3 , changeSets . length ) ; assertEquals ( 1175385600000L , changeSets [ 0 ] . getDate ( ) . getTime ( ) ) ; assertEquals ( 1168696800000L , changeSets [ 1 ] . getDate ( ) . getTime ( ) ) ; assertEquals ( 1168430400000L , changeSets [ 2 ] . getDate ( ) . getTime ( ) ) ; }
public void setUp ( ) throws Exception { data = new Data ( ) ; missingFile = new File ( " this - file - does - not - exist " ) ; file = File . createTempFile ( getClass ( ) . getSimpleName ( ) , " dat " ) ; }
public void testFailOnMissingSrcIgnoreFileMissing ( ) throws IOException { data . setSrc ( missingFile ) ; data . setMissingSrc ( " ignore " ) ; data . produce ( null ) ; }
public void testFailOnMissingSrcIgnoreFileMissingVaryInput ( ) throws IOException { data . setSrc ( missingFile ) ; data . setMissingSrc ( " IGNORE " ) ; data . produce ( null ) ; }
public void testFailOnMissingSrcDefaultFileExists ( ) throws IOException { IOException unknownTypeException = null ; try { data . setSrc ( file ) ; data . produce ( null ) ; } catch ( IOException expected ) { unknownTypeException = expected ; } assertTrue ( unknownTypeException . getMessage ( ) . startsWith ( " Unknown type " ) ) ; }
public void testFailOnMissingSrcIgnoreFileExists ( ) throws IOException { IOException unknownTypeException = null ; try { data . setSrc ( file ) ; data . setMissingSrc ( " ignore " ) ; data . produce ( null ) ; } catch ( IOException expected ) { unknownTypeException = expected ; } assertTrue ( unknownTypeException . getMessage ( ) . startsWith ( " Unknown type " ) ) ; }
public void testFailOnMissingSrcFailFileExists ( ) throws IOException { IOException unknownTypeException = null ; try { data . setSrc ( file ) ; data . setMissingSrc ( " fail " ) ; data . produce ( null ) ; } catch ( IOException expected ) { unknownTypeException = expected ; } assertTrue ( unknownTypeException . getMessage ( ) . startsWith ( " Unknown type " ) ) ; }
public void testUTF8CRLF ( ) throws Exception { InformationInputStream informationStream = new InformationInputStream ( getStream ( " utf8 - crlf . txt " ) ) ; Utils . copy ( informationStream , new ByteArrayOutputStream ( ) ) ; assertTrue ( " Should be windows line endings " , ! informationStream . hasUnixLineEndings ( ) ) ; assertTrue ( " Shebang not detected " , informationStream . isShell ( ) ) ; assertTrue ( " BOM detected " , ! informationStream . hasBom ( ) ) ; assertEquals ( " Encoding " , null , informationStream . getEncoding ( ) ) ; }
public void testUTF8 ( ) throws Exception { InformationInputStream informationStream = new InformationInputStream ( getStream ( " utf8 - lf . txt " ) ) ; Utils . copy ( informationStream , new ByteArrayOutputStream ( ) ) ; assertTrue ( " Shebang not detected " , informationStream . isShell ( ) ) ; assertTrue ( " BOM detected " , ! informationStream . hasBom ( ) ) ; assertEquals ( " Encoding " , null , informationStream . getEncoding ( ) ) ; }
public void testUTF8BOM ( ) throws Exception { InformationInputStream informationStream = new InformationInputStream ( getStream ( " utf8 - lf - bom . txt " ) ) ; Utils . copy ( informationStream , new ByteArrayOutputStream ( ) ) ; assertTrue ( " Shebang not detected " , informationStream . isShell ( ) ) ; assertTrue ( " BOM not detected " , informationStream . hasBom ( ) ) ; assertEquals ( " Encoding " , " UTF - 8 " , informationStream . getEncoding ( ) ) ; }
public void testUTF16BE ( ) throws Exception { InformationInputStream informationStream = new InformationInputStream ( getStream ( " utf16be - lf . txt " ) ) ; Utils . copy ( informationStream , new ByteArrayOutputStream ( ) ) ; assertTrue ( " Shebang not detected " , informationStream . isShell ( ) ) ; assertTrue ( " BOM detected " , ! informationStream . hasBom ( ) ) ; assertEquals ( " Encoding " , " UTF - 16BE " , informationStream . getEncoding ( ) ) ; }
public void testUTF16BEBOM ( ) throws Exception { InformationInputStream informationStream = new InformationInputStream ( getStream ( " utf16be - lf - bom . txt " ) ) ; Utils . copy ( informationStream , new ByteArrayOutputStream ( ) ) ; assertTrue ( " Shebang not detected " , informationStream . isShell ( ) ) ; assertTrue ( " BOM not detected " , informationStream . hasBom ( ) ) ; assertEquals ( " Encoding " , " UTF - 16BE " , informationStream . getEncoding ( ) ) ; }
public void testUTF16LE ( ) throws Exception { InformationInputStream informationStream = new InformationInputStream ( getStream ( " utf16le - lf . txt " ) ) ; Utils . copy ( informationStream , new ByteArrayOutputStream ( ) ) ; assertTrue ( " Shebang not detected " , informationStream . isShell ( ) ) ; assertTrue ( " BOM detected " , ! informationStream . hasBom ( ) ) ; assertEquals ( " Encoding " , " UTF - 16LE " , informationStream . getEncoding ( ) ) ; }
public void testUTF16LEBOM ( ) throws Exception { InformationInputStream informationStream = new InformationInputStream ( getStream ( " utf16le - lf - bom . txt " ) ) ; Utils . copy ( informationStream , new ByteArrayOutputStream ( ) ) ; assertTrue ( " Shebang not detected " , informationStream . isShell ( ) ) ; assertTrue ( " BOM not detected " , informationStream . hasBom ( ) ) ; assertEquals ( " Encoding " , " UTF - 16LE " , informationStream . getEncoding ( ) ) ; }
public void setUp ( ) throws Exception { Map < String , String > map = new HashMap < > ( ) ; map . put ( " artifactId " , " jdeb " ) ; map . put ( " myProperty1 " , " custom1 " ) ; map . put ( " myProperty2 " , " custom2 " ) ; variableResolver = new MapVariableResolver ( map ) ; }
public void testTokenSubstitution ( ) throws Exception { InputStream in = new ReaderInputStream ( new StringReader ( " # ! / bin / sh \ ncat [ [ artifactId ] ] [ [ myProperty1 ] ] \ necho ' [ [ myProperty2 ] ] ' \ n " ) ) ; FilteredFile placeHolder = new FilteredFile ( in , variableResolver , StandardCharsets . UTF_8 ) ; String actual = placeHolder . toString ( ) ; assertEquals ( " # ! / bin / sh \ ncat jdebcustom1 \ necho ' custom2 ' \ n " , actual ) ; }
public void testCustomTokenSubstitution ( ) throws Exception { InputStream in = new ReaderInputStream ( new StringReader ( " # ! / bin / sh \ ncat { [ { artifactId } ] } { [ { myProperty1 } ] } \ necho ' { [ { myProperty2 } ] } ' \ n " ) ) ; FilteredFile placeHolder = new FilteredFile ( in , variableResolver , StandardCharsets . UTF_8 , " { [ { " , " } ] } " ) ; String actual = placeHolder . toString ( ) ; assertEquals ( " # ! / bin / sh \ ncat jdebcustom1 \ necho ' custom2 ' \ n " , actual ) ; }
public void testJoinPath ( ) { assertEquals ( " " , " foo / bar " , Utils . joinUnixPath ( null , " foo " , " bar " ) ) ; assertEquals ( " " , " / foo / bar " , Utils . joinUnixPath ( null , " / foo " , " / bar " ) ) ; assertEquals ( " " , " foo / bar " , Utils . joinUnixPath ( null , " foo / bar " ) ) ; }
public void testStripPath ( ) { assertEquals ( " foo / bar " , Utils . stripPath ( 0 , " foo / bar " ) ) ; assertEquals ( " bar " , Utils . stripPath ( 1 , " foo / bar " ) ) ; assertEquals ( " bar / baz " , Utils . stripPath ( 1 , " foo / bar / baz " ) ) ; assertEquals ( " baz " , Utils . stripPath ( 2 , " foo / bar / baz " ) ) ; assertEquals ( " foo / " , Utils . stripPath ( 0 , " foo / " ) ) ; assertEquals ( " " , Utils . stripPath ( 1 , " foo / " ) ) ; assertEquals ( " foo / " , Utils . stripPath ( 2 , " foo / " ) ) ; }
private String convert ( String s ) throws Exception { byte [ ] data = Utils . toUnixLineEndings ( new ByteArrayInputStream ( s . getBytes ( StandardCharsets . UTF_8 ) ) , StandardCharsets . UTF_8 ) ; return new String ( data , StandardCharsets . UTF_8 ) ; }
public void testNewlineConversionLF ( ) throws Exception { String expected = " test \ ntest \ n \ ntest \ n " ; String actual = convert ( " test \ ntest \ n \ ntest " ) ; assertEquals ( expected , actual ) ; }
public void testNewlineConversionCRLF ( ) throws Exception { String expected = " test \ ntest \ n \ ntest \ n " ; String actual = convert ( " test \ r \ ntest \ r \ n \ r \ ntest " ) ; assertEquals ( expected , actual ) ; }
public void testNewlineConversionCR ( ) throws Exception { String expected = " test \ ntest \ n \ ntest \ n " ; String actual = convert ( " test \ rtest \ r \ rtest " ) ; assertEquals ( expected , actual ) ; }
public void testVersionConversionWithTemplate ( ) { Calendar cal = new GregorianCalendar ( 2013 , Calendar . FEBRUARY , 17 ) ; assertEquals ( " should match " , " 1 . 0 ~ 20130217000000 " , Utils . convertToDebianVersion ( " 1 . 0 + SNAPSHOT " , true , " SNAPSHOT " , " [ yyyyMMddHHmmss ] " , cal . getTime ( ) ) ) ; assertEquals ( " should match " , " 1 . 0 ~ 130217000000 " , Utils . convertToDebianVersion ( " 1 . 0 + SNAPSHOT " , true , " SNAPSHOT " , " [ yyMMddHHmmss ] " , cal . getTime ( ) ) ) ; assertEquals ( " should match " , " 1 . 0 ~ 20130217 " , Utils . convertToDebianVersion ( " 1 . 0 + SNAPSHOT " , true , " SNAPSHOT " , " [ yyyyMMdd ] " , cal . getTime ( ) ) ) ; assertEquals ( " should match " , " 1 . 0 ~ 100 . 20130217 " , Utils . convertToDebianVersion ( " 1 . 0 + SNAPSHOT " , true , " SNAPSHOT " , " 100 . [ yyyyMMdd ] " , cal . getTime ( ) ) ) ; assertEquals ( " should match " , " 1 . 0 ~ 100 . 20130217 . 50 " , Utils . convertToDebianVersion ( " 1 . 0 + SNAPSHOT " , true , " SNAPSHOT " , " 100 . [ yyyyMMdd ] . 50 " , cal . getTime ( ) ) ) ; assertEquals ( " should match " , " 1 . 0 ~ 100 . 20130217 . foo " , Utils . convertToDebianVersion ( " 1 . 0 + SNAPSHOT " , true , " SNAPSHOT " , " 100 . [ yyyyMMdd ] . foo " , cal . getTime ( ) ) ) ; }
public void testMovePath ( ) { assertEquals ( " / usr / share / file . txt " , Utils . movePath ( " file . txt " , " / usr / share " ) ) ; assertEquals ( " / usr / share / file . txt " , Utils . movePath ( " file . txt " , " / usr / share / " ) ) ; assertEquals ( " / usr / share / noext " , Utils . movePath ( " noext " , " / usr / share / " ) ) ; assertEquals ( " / usr / share / file . txt " , Utils . movePath ( " / home / user / file . txt " , " / usr / share " ) ) ; assertEquals ( " / usr / share / file . txt " , Utils . movePath ( " . . / relative / file . txt " , " / usr / share / " ) ) ; }
public void testParameterInIsoFormat ( ) { Long result = resolver . resolveOutputTimestamp ( " 2021 - 01 - 01T12 : 00 : 00Z " ) ; assertEquals ( ( Long ) 1609502400000L , result ) ; }
public void testParameterInIsoFormatWithSpecificTimezone ( ) { Long result = resolver . resolveOutputTimestamp ( " 2021 - 01 - 01T12 : 00 : 00 + 13 : 00 " ) ; assertEquals ( ( Long ) 1609455600000L , result ) ; }
public void testParameterInEpochSeconds ( ) { Long result = resolver . resolveOutputTimestamp ( " 1600000000 " ) ; assertEquals ( ( Long ) 1600000000000L , result ) ; }
public void testInvalidParameter ( ) { try { resolver . resolveOutputTimestamp ( " invalid " ) ; } catch ( IllegalArgumentException e ) { return ; } fail ( " Exception expected on invalid value " ) ; }
public void testEnvVariable ( ) { doReturn ( " 1600000000 " ) . when ( envReader ) . getSourceDateEpoch ( ) ; Long result = resolver . resolveOutputTimestamp ( null ) ; assertEquals ( ( Long ) 1600000000000L , result ) ; }
public void testInvalidEnvVariable ( ) { doReturn ( " invalid " ) . when ( envReader ) . getSourceDateEpoch ( ) ; try { resolver . resolveOutputTimestamp ( null ) ; } catch ( IllegalArgumentException e ) { return ; } fail ( " Exception expected on invalid value " ) ; }
public void testNoTimestamp ( ) { Long result = resolver . resolveOutputTimestamp ( null ) ; assertNull ( result ) ; }
public void testParamTakesPrecedenceOverEnvVar ( ) { doReturn ( " 1600000000 " ) . when ( envReader ) . getSourceDateEpoch ( ) ; Long result = resolver . resolveOutputTimestamp ( " 1610000000 " ) ; assertEquals ( ( Long ) 1610000000000L , result ) ; }
public static void main ( String [ ] args ) { System . out . println ( " jdeb example ! " ) ; }
public static void main ( String [ ] args ) { System . out . println ( " jdeb example ! " ) ; }
private boolean isWritableFile ( File file ) { return ! file . exists ( ) | | file . isFile ( ) & & file . canWrite ( ) ; }
public void validate ( ) throws PackagingException { if ( control = = null | | ! control . isDirectory ( ) ) { throw new PackagingException ( " The ' control ' attribute doesn ' t point to a directory . " + control ) ; } if ( changesEnabled ) { if ( changesIn ! = null ) { if ( changesIn . exists ( ) & & ( ! changesIn . isFile ( ) | | ! changesIn . canRead ( ) ) ) { throw new PackagingException ( " The ' changesIn ' setting needs to point to a readable file . " + changesIn + " was not found / readable . " ) ; } if ( changesOut ! = null & & ! isWritableFile ( changesOut ) ) { throw new PackagingException ( " Cannot write the output for ' changesOut ' to " + changesOut ) ; } if ( changesSave ! = null & & ! isWritableFile ( changesSave ) ) { throw new PackagingException ( " Cannot write the output for ' changesSave ' to " + changesSave ) ; } } else { if ( changesOut ! = null | | changesSave ! = null ) { throw new PackagingException ( " The ' changesOut ' or ' changesSave ' settings may only be used when there is a ' changesIn ' specified . " ) ; } } } if ( Compression . toEnum ( compression ) = = null ) { throw new PackagingException ( " The compression method ' " + compression + " ' is not supported ( expected ' none ' , ' gzip ' , ' bzip2 ' or ' xz ' ) " ) ; } if ( deb = = null ) { throw new PackagingException ( " You need to specify where the deb file is supposed to be created . " ) ; } PGPSigner . getDigestCode ( digest ) ; }
private List < String > populateConffiles ( Collection < DataProducer > producers ) { final List < String > result = new ArrayList < > ( ) ; if ( producers = = null | | producers . isEmpty ( ) ) { return result ; } final DataConsumer receiver = new DataConsumer ( ) { public void onEachFile ( InputStream input , TarArchiveEntry entry ) { String tempConffileItem = entry . getName ( ) ; if ( tempConffileItem . startsWith ( " . " ) ) { tempConffileItem = tempConffileItem . substring ( 1 ) ; } if ( ! tempConffileItem . startsWith ( " / " ) ) { tempConffileItem = " / " + tempConffileItem ; } console . info ( " Adding conffile : " + tempConffileItem ) ; result . add ( tempConffileItem ) ; } public void onEachLink ( TarArchiveEntry entry ) { } public void onEachDir ( TarArchiveEntry tarArchiveEntry ) { } } ; try { for ( DataProducer data : producers ) { data . produce ( receiver ) ; } } catch ( Exception e ) { } return result ; }
public void onEachFile ( InputStream input , TarArchiveEntry entry ) { String tempConffileItem = entry . getName ( ) ; if ( tempConffileItem . startsWith ( " . " ) ) { tempConffileItem = tempConffileItem . substring ( 1 ) ; } if ( ! tempConffileItem . startsWith ( " / " ) ) { tempConffileItem = " / " + tempConffileItem ; } console . info ( " Adding conffile : " + tempConffileItem ) ; result . add ( tempConffileItem ) ; }
public BinaryPackageControlFile createDeb ( Compression compression ) throws PackagingException { return createSignedDeb ( compression , null , null ) ; }
private String addFile ( String name , String input ) { return addLine ( md5Hash ( input ) , sha1Hash ( input ) , input . length ( ) , name ) ; }
private String addFile ( String name , File input ) { return addLine ( md5Hash ( input ) , sha1Hash ( input ) , input . length ( ) , name ) ; }
private String addLine ( String md5 , String sha1 , long size , String name ) { return " \ t " + md5 + " " + sha1 + " " + size + " " + name + " \ n " ; }
private String md5Hash ( String input ) { return md5Hash ( input . getBytes ( ) ) ; }
private String md5Hash ( File input ) { try { return md5Hash ( FileUtils . readFileToByteArray ( input ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
private String md5Hash ( byte [ ] input ) { MD5Digest md5 = new MD5Digest ( ) ; md5 . update ( input , 0 , input . length ) ; byte [ ] digest = new byte [ md5 . getDigestSize ( ) ] ; md5 . doFinal ( digest , 0 ) ; return new String ( Hex . encode ( digest ) ) ; }
private String sha1Hash ( String input ) { return sha1Hash ( input . getBytes ( ) ) ; }
private String sha1Hash ( File input ) { try { return sha1Hash ( FileUtils . readFileToByteArray ( input ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
private String sha1Hash ( byte [ ] input ) { try { MessageDigest hash = MessageDigest . getInstance ( digest ) ; hash . update ( input ) ; byte [ ] digest = hash . digest ( ) ; return new String ( Hex . encode ( digest ) ) ; } catch ( NoSuchAlgorithmException e ) { System . err . println ( " No such algorithm " ) ; e . printStackTrace ( ) ; } return null ; }
private void addTo ( ArArchiveOutputStream pOutput , String pName , String pContent ) throws IOException { final byte [ ] content = pContent . getBytes ( ) ; ArArchiveEntry archiveEntry = createArArchiveEntry ( pName , content . length ) ; pOutput . putArchiveEntry ( archiveEntry ) ; pOutput . write ( content ) ; pOutput . closeArchiveEntry ( ) ; }
private void addTo ( ArArchiveOutputStream pOutput , String pName , File pContent ) throws IOException { ArArchiveEntry archiveEntry = createArArchiveEntry ( pName , pContent . length ( ) ) ; pOutput . putArchiveEntry ( archiveEntry ) ; try ( InputStream input = new FileInputStream ( pContent ) ) { Utils . copy ( input , pOutput ) ; } pOutput . closeArchiveEntry ( ) ; }
private void addTo ( final PGPSignatureOutputStream pOutput , final String pContent ) throws IOException { final byte [ ] content = pContent . getBytes ( ) ; pOutput . write ( content ) ; }
private ArArchiveEntry createArArchiveEntry ( String pName , long contentLength ) { if ( outputTimestampMs ! = null ) { return new ArArchiveEntry ( pName , contentLength , 0 , 0 , DEFAULT_MODE , outputTimestampMs / TimeUnit . SECONDS . toMillis ( 1 ) ) ; } return new ArArchiveEntry ( pName , contentLength ) ; }
public TarOptions compression ( Compression compression ) { this . compression = compression ; return this ; }
public TarOptions longFileMode ( String input ) { if ( " posix " . equals ( input ) ) { longFileMode = TarArchiveOutputStream . LONGFILE_POSIX ; } else if ( " error " . equals ( input ) ) { longFileMode = TarArchiveOutputStream . LONGFILE_ERROR ; } else if ( " truncate " . equals ( input ) ) { longFileMode = TarArchiveOutputStream . LONGFILE_TRUNCATE ; } else { longFileMode = TarArchiveOutputStream . LONGFILE_GNU ; } return this ; }
public TarOptions bigNumberMode ( String input ) { if ( " error " . equals ( input ) ) { bigNumberMode = TarArchiveOutputStream . BIGNUMBER_ERROR ; } else if ( " posix " . equals ( input ) ) { bigNumberMode = TarArchiveOutputStream . BIGNUMBER_POSIX ; } else { bigNumberMode = TarArchiveOutputStream . BIGNUMBER_STAR ; } return this ; }
public int longFileMode ( ) { return longFileMode ; }
public int bigNumberMode ( ) { return bigNumberMode ; }
public Compression compression ( ) { return compression ; }
public void add ( long size ) { count = count . add ( BigInteger . valueOf ( size ) ) ; }
public String toString ( ) { return " " + count ; }
public void onEachDir ( TarArchiveEntry dirEntry ) throws IOException { checkField ( dirEntry . getLinkName ( ) , TarConstants . NAMELEN ) ; checkField ( dirEntry . getUserName ( ) , TarConstants . UNAMELEN ) ; checkField ( dirEntry . getUserName ( ) , TarConstants . GNAMELEN ) ; dirEntry . setName ( fixPathTar ( dirEntry . getName ( ) ) ) ; createParentDirectories ( dirEntry . getName ( ) , dirEntry . getUserName ( ) , dirEntry . getLongUserId ( ) , dirEntry . getGroupName ( ) , dirEntry . getLongGroupId ( ) ) ; createDirectory ( dirEntry . getName ( ) , dirEntry . getUserName ( ) , dirEntry . getLongUserId ( ) , dirEntry . getGroupName ( ) , dirEntry . getLongGroupId ( ) , dirEntry . getMode ( ) , 0 ) ; console . debug ( " dir : " + dirEntry . getName ( ) ) ; }
public void onEachFile ( InputStream input , TarArchiveEntry fileEntry ) throws IOException { checkField ( fileEntry . getLinkName ( ) , TarConstants . NAMELEN ) ; checkField ( fileEntry . getUserName ( ) , TarConstants . UNAMELEN ) ; checkField ( fileEntry . getGroupName ( ) , TarConstants . GNAMELEN ) ; String rawFileEntryName = fileEntry . getName ( ) ; fileEntry . setName ( fixPathTar ( fileEntry . getName ( ) ) ) ; if ( outputTimestampMs ! = null ) { fileEntry . setModTime ( outputTimestampMs ) ; } createParentDirectories ( fileEntry . getName ( ) , fileEntry . getUserName ( ) , fileEntry . getLongUserId ( ) , fileEntry . getGroupName ( ) , fileEntry . getLongGroupId ( ) ) ; tarOutputStream . putArchiveEntry ( fileEntry ) ; dataSize . add ( fileEntry . getSize ( ) ) ; digest . reset ( ) ; Utils . copy ( input , new DigestOutputStream ( tarOutputStream , digest ) ) ; final String md5 = Utils . toHex ( digest . digest ( ) ) ; tarOutputStream . closeArchiveEntry ( ) ; console . debug ( " file : " + fileEntry . getName ( ) + " size : " + fileEntry . getSize ( ) + " mode : " + fileEntry . getMode ( ) + " linkname : " + fileEntry . getLinkName ( ) + " username : " + fileEntry . getUserName ( ) + " userid : " + fileEntry . getLongUserId ( ) + " groupname : " + fileEntry . getGroupName ( ) + " groupid : " + fileEntry . getLongGroupId ( ) + " modtime : " + fileEntry . getModTime ( ) + " md5 : " + md5 ) ; checksums . append ( md5 ) . append ( " " ) . append ( fixPathMd5 ( rawFileEntryName ) ) . append ( ' \ n ' ) ; }
private String fixPathBase ( String path ) { if ( path = = null | | path . equals ( " . " ) ) { return path ; } if ( path . contains ( " \ \ " ) ) { path = path . replace ( ' \ \ ' , ' / ' ) ; } return path ; }
private String fixPathTar ( String path ) { if ( path = = null | | path . equals ( " . " ) ) { return path ; } path = fixPathBase ( path ) ; if ( path . startsWith ( " / " ) ) { path = " . " + path ; } else if ( ! path . startsWith ( " . / " ) ) { path = " . / " + path ; } return path ; }
private String fixPathMd5 ( String path ) { if ( path = = null | | path . equals ( " . " ) ) { return path ; } path = fixPathBase ( path ) ; if ( path . startsWith ( " / " ) ) { path = path . substring ( 1 ) ; } else if ( path . startsWith ( " . / " ) ) { path = path . substring ( 2 ) ; } return path ; }
public ChangesFile createChanges ( BinaryPackageControlFile packageControlFile , File binaryPackage , ChangesProvider changesProvider ) throws IOException , PackagingException { ChangesFile changesFile = new ChangesFile ( ) ; changesFile . setChanges ( changesProvider . getChangesSets ( ) ) ; changesFile . initialize ( packageControlFile ) ; changesFile . set ( " Date " , outputTimestampMs = = null ? ChangesFile . formatDate ( new Date ( ) ) : ChangesFile . formatDateUTC ( new Date ( outputTimestampMs ) ) ) ; try { InformationOutputStream md5output = new InformationOutputStream ( NullOutputStream . INSTANCE , MessageDigest . getInstance ( " MD5 " ) ) ; InformationOutputStream sha1output = new InformationOutputStream ( md5output , MessageDigest . getInstance ( " SHA1 " ) ) ; InformationOutputStream sha256output = new InformationOutputStream ( sha1output , MessageDigest . getInstance ( " SHA - 256 " ) ) ; FileUtils . copyFile ( binaryPackage , sha256output ) ; changesFile . set ( " Checksums - Sha1 " , sha1output . getHexDigest ( ) + " " + binaryPackage . length ( ) + " " + binaryPackage . getName ( ) ) ; changesFile . set ( " Checksums - Sha256 " , sha256output . getHexDigest ( ) + " " + binaryPackage . length ( ) + " " + binaryPackage . getName ( ) ) ; StringBuilder files = new StringBuilder ( md5output . getHexDigest ( ) ) ; files . append ( ' ' ) . append ( binaryPackage . length ( ) ) ; files . append ( ' ' ) . append ( packageControlFile . get ( " Section " ) ) ; files . append ( ' ' ) . append ( packageControlFile . get ( " Priority " ) ) ; files . append ( ' ' ) . append ( binaryPackage . getName ( ) ) ; changesFile . set ( " Files " , files . toString ( ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new PackagingException ( " Unable to compute the checksums for " + binaryPackage , e ) ; } if ( ! changesFile . isValid ( ) ) { throw new PackagingException ( " Changes file fields are invalid " + changesFile . invalidFields ( ) + " . The following fields are mandatory : " + changesFile . getMandatoryFields ( ) + " . Please check your pom . xml / build . xml and your control file . " ) ; } return changesFile ; }
private String createPackageConffilesFile ( final List < String > conffiles ) { StringBuilder content = new StringBuilder ( ) ; if ( conffiles ! = null & & ! conffiles . isEmpty ( ) ) { for ( String nextFileName : conffiles ) { content . append ( nextFileName ) . append ( " \ n " ) ; } } return content . toString ( ) ; }
public BinaryPackageControlFile createPackageControlFile ( File file , BigInteger pDataSize ) throws IOException , ParseException { return createPackageControlFile ( file , pDataSize , Charset . defaultCharset ( ) , " [ [ " , " ] ] " ) ; }
public BinaryPackageControlFile createPackageControlFile ( File file , BigInteger pDataSize , Charset encoding , String openToken , String closeToken ) throws IOException , ParseException { FilteredFile controlFile = new FilteredFile ( new FileInputStream ( file ) , resolver , encoding , openToken , closeToken ) ; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile ( controlFile . toString ( ) ) ; if ( packageControlFile . get ( " Distribution " ) = = null ) { packageControlFile . set ( " Distribution " , " unknown " ) ; } if ( packageControlFile . get ( " Urgency " ) = = null ) { packageControlFile . set ( " Urgency " , " low " ) ; } packageControlFile . set ( " Installed - Size " , pDataSize . divide ( BigInteger . valueOf ( 1024 ) ) . toString ( ) ) ; final String debVersion = System . getenv ( " DEBVERSION " ) ; if ( debVersion ! = null ) { packageControlFile . set ( " Version " , debVersion ) ; console . debug ( " Using version ' " + debVersion + " ' from the environment variables . " ) ; } final String debFullName = System . getenv ( " DEBFULLNAME " ) ; final String debEmail = System . getenv ( " DEBEMAIL " ) ; if ( debFullName ! = null & & debEmail ! = null ) { final String maintainer = debFullName + " < " + debEmail + " > " ; packageControlFile . set ( " Maintainer " , maintainer ) ; console . debug ( " Using maintainer ' " + maintainer + " ' from the environment variables . " ) ; } return packageControlFile ; }
private void addControlEntry ( final String pName , final String pContent , final TarArchiveOutputStream pOutput ) throws IOException { console . info ( " Adding control : " + pName ) ; final byte [ ] data = pContent . getBytes ( UTF_8 ) ; final TarArchiveEntry entry = new TarArchiveEntry ( " . / " + pName , true ) ; entry . setSize ( data . length ) ; entry . setNames ( " root " , " root " ) ; if ( outputTimestampMs ! = null ) { entry . setModTime ( outputTimestampMs ) ; } if ( MAINTAINER_SCRIPTS . contains ( pName ) ) { entry . setMode ( PermMapper . toMode ( " 755 " ) ) ; } else { entry . setMode ( PermMapper . toMode ( " 644 " ) ) ; } pOutput . putArchiveEntry ( entry ) ; pOutput . write ( data ) ; pOutput . closeArchiveEntry ( ) ; }
public org . vafer . jdeb . mapping . Mapper createMapper ( ) throws IOException { if ( " perm " . equalsIgnoreCase ( mapperType ) ) { return new PermMapper ( uid , gid , user , group , fileMode , dirMode , strip , prefix ) ; } if ( " ls " . equalsIgnoreCase ( mapperType ) ) { try { return new LsMapper ( new FileInputStream ( src ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } throw new IOException ( " Unknown mapper type ' " + mapperType + " ' " ) ; }
DataProducer toDataProducer ( ) { org . vafer . jdeb . mapping . Mapper mapper = new PermMapper ( uid , gid , username , group , mode , mode , 0 , null ) ; return new DataProducerLink ( name , target , symbolic , null , null , new org . vafer . jdeb . mapping . Mapper [ ] { mapper } ) ; }
public boolean isSymbolic ( ) { return symbolic ; }
public void addMapper ( Mapper mapper ) { mapperWrapper . add ( mapper ) ; }
public void addFileSet ( FileSet fileset ) { dataProducers . add ( new DataProducerFileSet ( fileset ) ) ; }
public void addTarFileSet ( Tar . TarFileSet fileset ) { dataProducers . add ( new DataProducerFileSet ( fileset ) ) ; }
public void addData ( Data data ) { dataProducers . add ( data ) ; }
public void addLink ( Link link ) { links . add ( link ) ; }
public void info ( String message ) { task . log ( message ) ; }
public void warn ( String message ) { task . log ( message , Project . MSG_WARN ) ; }
private String readBase ( final BufferedReader reader ) throws IOException , ParseError { final String line = reader . readLine ( ) ; if ( line = = null ) { return null ; } final Matcher matcher = basePattern . matcher ( line ) ; if ( ! matcher . matches ( ) ) { throw new ParseError ( " expected base line but got \ " " + line + " \ " " ) ; } return matcher . group ( 1 ) ; }
private String readTotal ( final BufferedReader reader ) throws IOException , ParseError { final String line = reader . readLine ( ) ; final Matcher matcher = totalPattern . matcher ( line ) ; if ( ! matcher . matches ( ) ) { throw new ParseError ( " expected total line but got \ " " + line + " \ " " ) ; } return matcher . group ( 1 ) ; }
private TarArchiveEntry readDir ( final BufferedReader reader , final String base ) throws IOException , ParseError { final String current = reader . readLine ( ) ; final Matcher currentMatcher = dirPattern . matcher ( current ) ; if ( ! currentMatcher . matches ( ) ) { throw new ParseError ( " expected dirline but got \ " " + current + " \ " " ) ; } final String parent = reader . readLine ( ) ; final Matcher parentMatcher = dirPattern . matcher ( parent ) ; if ( ! parentMatcher . matches ( ) ) { throw new ParseError ( " expected dirline but got \ " " + parent + " \ " " ) ; } final TarArchiveEntry entry = new TarArchiveEntry ( base , true ) ; entry . setMode ( convertModeFromString ( currentMatcher . group ( 1 ) ) ) ; entry . setUserName ( currentMatcher . group ( 3 ) ) ; entry . setGroupName ( currentMatcher . group ( 4 ) ) ; return entry ; }
private Map < String , TarArchiveEntry > parse ( final InputStream pInput ) throws IOException , ParseError { final Map < String , TarArchiveEntry > mapping = new HashMap < > ( ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( pInput , StandardCharsets . UTF_8 ) ) ; boolean first = true ; while ( true ) { final String base ; if ( first ) { base = " " ; first = false ; } else { base = readBase ( reader ) ; if ( base = = null ) { break ; } } readTotal ( reader ) ; final TarArchiveEntry dir = readDir ( reader , base ) ; mapping . put ( dir . getName ( ) , dir ) ; while ( true ) { final TarArchiveEntry file = readFile ( reader , base ) ; if ( file = = null ) { break ; } mapping . put ( file . getName ( ) , file ) ; } } return mapping ; }
public TarArchiveEntry map ( final TarArchiveEntry pEntry ) { final TarArchiveEntry entry = mapping . get ( pEntry . getName ( ) ) ; if ( entry ! = null ) { return entry ; } return pEntry ; }
public TarArchiveEntry map ( final TarArchiveEntry pEntry ) { return pEntry ; }
public void produce ( final DataConsumer pReceiver ) throws IOException { TarArchiveEntry entry = new TarArchiveEntry ( path , symlink ? TarArchiveEntry . LF_SYMLINK : TarArchiveEntry . LF_LINK ) ; entry . setLinkName ( linkName ) ; entry . setUserId ( Producers . ROOT_UID ) ; entry . setUserName ( Producers . ROOT_NAME ) ; entry . setGroupId ( Producers . ROOT_UID ) ; entry . setGroupName ( Producers . ROOT_NAME ) ; entry . setMode ( TarArchiveEntry . DEFAULT_FILE_MODE ) ; entry = map ( entry ) ; entry . setName ( path ) ; entry . setLinkName ( linkName ) ; pReceiver . onEachLink ( entry ) ; }
static TarArchiveEntry defaultFileEntryWithName ( final String fileName ) { TarArchiveEntry entry = new TarArchiveEntry ( fileName , true ) ; entry . setUserId ( ROOT_UID ) ; entry . setUserName ( ROOT_NAME ) ; entry . setGroupId ( ROOT_UID ) ; entry . setGroupName ( ROOT_NAME ) ; entry . setMode ( TarArchiveEntry . DEFAULT_FILE_MODE ) ; return entry ; }
static TarArchiveEntry defaultDirEntryWithName ( final String dirName ) { TarArchiveEntry entry = new TarArchiveEntry ( dirName , true ) ; entry . setUserId ( ROOT_UID ) ; entry . setUserName ( ROOT_NAME ) ; entry . setGroupId ( ROOT_UID ) ; entry . setGroupName ( ROOT_NAME ) ; entry . setMode ( TarArchiveEntry . DEFAULT_DIR_MODE ) ; return entry ; }
static void produceDirEntry ( final DataConsumer consumer , final TarArchiveEntry dirEntry ) throws IOException { consumer . onEachDir ( dirEntry ) ; }
public boolean isIncluded ( final String pName ) { if ( ! isIncluded ( pName , includes ) ) { return false ; } if ( isExcluded ( pName , excludes ) ) { return false ; } return true ; }
private boolean isIncluded ( String name , String [ ] includes ) { for ( String include : includes ) { if ( SelectorUtils . matchPath ( include , name ) ) { return true ; } } return false ; }
private boolean isExcluded ( String name , String [ ] excludes ) { for ( String exclude : excludes ) { if ( SelectorUtils . matchPath ( exclude , name ) ) { return true ; } } return false ; }
public void produceDir ( final DataConsumer consumer , final String dirName ) throws IOException { final String name = dirName . endsWith ( " / " ) ? dirName : dirName + " / " ; TarArchiveEntry entry = Producers . defaultDirEntryWithName ( name ) ; entry = map ( entry ) ; entry . setSize ( 0 ) ; Producers . produceDirEntry ( consumer , entry ) ; }
public TarArchiveEntry map ( final TarArchiveEntry pEntry ) { TarArchiveEntry entry = pEntry ; for ( Mapper mapper : mappers ) { entry = mapper . map ( entry ) ; } return entry ; }
public void clearSign ( String input , OutputStream output ) throws IOException , PGPException { clearSign ( new ByteArrayInputStream ( input . getBytes ( UTF_8 ) ) , output ) ; }
public void clearSign ( InputStream input , OutputStream output ) throws IOException , PGPException { PGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator ( new BcPGPContentSignerBuilder ( privateKey . getPublicKeyPacket ( ) . getAlgorithm ( ) , digest ) ) ; signatureGenerator . init ( PGPSignature . CANONICAL_TEXT_DOCUMENT , privateKey ) ; ArmoredOutputStream armoredOutput = new ArmoredOutputStream ( output ) ; armoredOutput . beginClearText ( digest ) ; LineIterator iterator = new LineIterator ( new InputStreamReader ( input ) ) ; while ( iterator . hasNext ( ) ) { String line = iterator . nextLine ( ) ; byte [ ] data = trim ( line ) . getBytes ( UTF_8 ) ; armoredOutput . write ( data ) ; armoredOutput . write ( EOL ) ; signatureGenerator . update ( data ) ; if ( iterator . hasNext ( ) ) { signatureGenerator . update ( EOL ) ; } } armoredOutput . endClearText ( ) ; PGPSignature signature = signatureGenerator . generate ( ) ; signature . encode ( new BCPGOutputStream ( armoredOutput ) ) ; armoredOutput . close ( ) ; }
public boolean isMandatory ( ) { return mandatory ; }
public boolean isFirstLineEmpty ( ) { return firstLineEmpty ; }
public void parse ( String input ) throws IOException , ParseException { parse ( new ByteArrayInputStream ( input . getBytes ( UTF_8 ) ) ) ; }
public String get ( String field ) { return values . get ( field ) ; }
public boolean isValid ( ) { return invalidFields ( ) . size ( ) = = 0 ; }
public String toString ( ControlField . . . fields ) { StringBuilder s = new StringBuilder ( ) ; for ( ControlField field : fields ) { String value = values . get ( field . getName ( ) ) ; s . append ( field . format ( value ) ) ; } return s . toString ( ) ; }
public String toString ( ) { List < ControlField > fields = new ArrayList < > ( ) ; fields . addAll ( Arrays . asList ( getFields ( ) ) ) ; fields . addAll ( getUserDefinedFieldNames ( ) ) ; return toString ( fields . toArray ( new ControlField [ fields . size ( ) ] ) ) ; }
public static String formatDate ( Date date ) { final DateFormat format = createDateFormat ( ) ; return format . format ( date ) ; }
public static String formatDateUTC ( Date date ) { final DateFormat format = createDateFormat ( ) ; format . setTimeZone ( TimeZone . getTimeZone ( " UTC " ) ) ; return format . format ( date ) ; }
private static DateFormat createDateFormat ( ) { return new SimpleDateFormat ( " EEE , d MMM yyyy HH : mm : ss Z " , Locale . ENGLISH ) ; }
public void set ( final String field , final String value ) { super . set ( field , value ) ; }
public org . vafer . jdeb . mapping . Mapper createMapper ( ) throws IOException { if ( " ls " . equalsIgnoreCase ( type ) ) { try { return new LsMapper ( new FileInputStream ( src ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( " perm " . equalsIgnoreCase ( type ) ) { return new PermMapper ( uid , gid , user , group , filemode , dirmode , strip , prefix ) ; } return NullMapper . INSTANCE ; }
public void produce ( final DataConsumer pReceiver ) throws IOException { org . vafer . jdeb . mapping . Mapper [ ] mappers = null ; if ( mapper ! = null ) { mappers = new org . vafer . jdeb . mapping . Mapper [ ] { mapper . createMapper ( ) } ; } if ( typeIs ( " link " ) ) { if ( linkName = = null ) { throw new RuntimeException ( " linkName is not set " ) ; } if ( linkTarget = = null ) { throw new RuntimeException ( " linkTarget is not set " ) ; } new DataProducerLink ( linkName , linkTarget , symlink , includePatterns , excludePatterns , mappers ) . produce ( pReceiver ) ; return ; } if ( typeIs ( " template " ) ) { checkPaths ( ) ; new DataProducerPathTemplate ( paths , includePatterns , excludePatterns , mappers ) . produce ( pReceiver ) ; return ; } if ( typeIs ( " files " ) ) { checkPaths ( ) ; new DataProducerFiles ( paths , dst , mappers ) . produce ( pReceiver ) ; return ; } if ( src = = null | | ! src . exists ( ) ) { if ( missingSrc = = IGNORE ) { return ; } else { throw new FileNotFoundException ( " Data source not found : " + src ) ; } } if ( typeIs ( " file " ) ) { new DataProducerFile ( src , dst , includePatterns , excludePatterns , mappers ) . produce ( pReceiver ) ; return ; } if ( typeIs ( " archive " ) ) { new DataProducerArchive ( src , includePatterns , excludePatterns , mappers ) . produce ( pReceiver ) ; return ; } if ( typeIs ( " directory " ) ) { new DataProducerDirectory ( src , includePatterns , excludePatterns , mappers ) . produce ( pReceiver ) ; return ; } throw new IOException ( " Unknown type ' " + type + " ' ( file | directory | archive | template | link ) for " + src ) ; }
private boolean typeIs ( final String type ) { return type . equalsIgnoreCase ( this . type ) ; }
public void info ( String message ) { log . info ( message ) ; }
public void warn ( String message ) { log . warn ( message ) ; }
private boolean isPOM ( ) { String type = getProject ( ) . getArtifact ( ) . getType ( ) ; return " pom " . equalsIgnoreCase ( type ) ; }
private boolean isType ( ) { return type . equals ( getProject ( ) . getArtifact ( ) . getType ( ) ) ; }
private boolean isSubmodule ( ) { return ! session . getExecutionRootDirectory ( ) . equalsIgnoreCase ( baseDir . toString ( ) ) ; }
private boolean hasMainArtifact ( ) { final MavenProject project = getProject ( ) ; final Artifact artifact = project . getArtifact ( ) ; return artifact . getFile ( ) ! = null & & artifact . getFile ( ) . isFile ( ) ; }
private String decrypt ( final String maybeEncryptedPassphrase ) { if ( maybeEncryptedPassphrase = = null ) { return null ; } try { final String decrypted = secDispatcher . decrypt ( maybeEncryptedPassphrase ) ; if ( maybeEncryptedPassphrase . equals ( decrypted ) ) { console . info ( " Passphrase was not encrypted " ) ; } else { console . info ( " Passphrase was successfully decrypted " ) ; } return decrypted ; } catch ( SecDispatcherException e ) { console . warn ( " Unable to decrypt passphrase : " + e . getMessage ( ) ) ; } return maybeEncryptedPassphrase ; }
public boolean hasBom ( ) { return bom ! = BOM . NONE ; }
public boolean isShell ( ) { return shell ! = Shell . NONE ; }
public boolean hasUnixLineEndings ( ) { return cr = = 0 ; }
public int read ( ) throws IOException { int b = super . read ( ) ; if ( b ! = - 1 ) { add ( b & 0xFF ) ; } return b ; }
public void write ( int b ) throws IOException { signatureGenerator . update ( new byte [ ] { ( byte ) b } ) ; }
public void write ( byte [ ] b ) throws IOException { signatureGenerator . update ( b ) ; }
public void write ( byte [ ] b , int off , int len ) throws IOException { signatureGenerator . update ( b , off , len ) ; }
public PGPSignature generateSignature ( ) throws PGPException { return signatureGenerator . generate ( ) ; }
public void write ( byte [ ] b , int off , int len ) throws IOException { super . write ( b , off , len ) ; size + = len ; }
public void write ( int b ) throws IOException { super . write ( b ) ; size + + ; }
public Long resolveOutputTimestamp ( String paramValue ) { if ( paramValue ! = null ) { Optional < Instant > outputDate = MavenArchiver . parseBuildOutputTimestamp ( paramValue ) ; if ( outputDate . isPresent ( ) ) { console . info ( " Accepted outputTimestamp parameter : " + paramValue ) ; return outputDate . get ( ) . toEpochMilli ( ) ; } } String sourceDate = envReader . getSourceDateEpoch ( ) ; if ( sourceDate ! = null & & ! sourceDate . isEmpty ( ) ) { try { long sourceDateVal = Long . parseLong ( sourceDate ) ; console . info ( " Accepted SOURCE_DATE_EPOCH environment variable : " + sourceDate ) ; return sourceDateVal * TimeUnit . SECONDS . toMillis ( 1 ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( " Invalid SOURCE_DATE_EPOCH environment variable value : " + sourceDate , e ) ; } } return null ; }
public static int copy ( final InputStream pInput , final OutputStream pOutput ) throws IOException { final byte [ ] buffer = new byte [ 2048 ] ; int count = 0 ; int n ; while ( - 1 ! = ( n = pInput . read ( buffer ) ) ) { pOutput . write ( buffer , 0 , n ) ; count + = n ; } return count ; }
public static String joinUnixPath ( String . . . paths ) { return joinPath ( ' / ' , paths ) ; }
public static String joinLocalPath ( String . . . paths ) { return joinPath ( File . separatorChar , paths ) ; }
public static String stripLeadingSlash ( final String s ) { if ( s = = null ) { return s ; } if ( s . length ( ) = = 0 ) { return s ; } if ( s . charAt ( 0 ) = = ' / ' | | s . charAt ( 0 ) = = ' \ \ ' ) { return s . substring ( 1 ) ; } return s ; }
public static byte [ ] toUnixLineEndings ( InputStream input ) throws IOException { String encoding = " ISO - 8859 - 1 " ; return toUnixLineEndings ( input , Charset . forName ( encoding ) ) ; }
public static byte [ ] toUnixLineEndings ( InputStream input , Charset encoding ) throws IOException { FixCrLfFilter filter = new FixCrLfFilter ( new InputStreamReader ( input , encoding ) ) ; filter . setEol ( FixCrLfFilter . CrLf . newInstance ( " unix " ) ) ; ByteArrayOutputStream filteredFile = new ByteArrayOutputStream ( ) ; Utils . copy ( new ReaderInputStream ( filter , encoding ) , filteredFile ) ; return filteredFile . toByteArray ( ) ; }
public static String movePath ( final String file , final String target ) { final String name = new File ( file ) . getName ( ) ; return target . endsWith ( " / " ) ? target + name : target + ' / ' + name ; }
public static String lookupIfEmpty ( final String value , final Map < String , String > props , final String key ) { return value ! = null ? value : props . get ( key ) ; }
public static File guessKeyRingFile ( ) throws FileNotFoundException { final Collection < String > possibleLocations = getKnownPGPSecureRingLocations ( ) ; for ( final String location : possibleLocations ) { final File candidate = new File ( location ) ; if ( candidate . exists ( ) ) { return candidate ; } } final StringBuilder message = new StringBuilder ( " Could not locate secure keyring , locations tried : " ) ; final Iterator < String > it = possibleLocations . iterator ( ) ; while ( it . hasNext ( ) ) { message . append ( it . next ( ) ) ; if ( it . hasNext ( ) ) { message . append ( " , " ) ; } } throw new FileNotFoundException ( message . toString ( ) ) ; }
public static boolean isNullOrEmpty ( final String str ) { return str = = null | | str . length ( ) = = 0 ; }
public static String defaultString ( final String str , final String fallback ) { return isNullOrEmpty ( str ) ? fallback : str ; }
public static String readSymbolicLink ( final File file ) throws IOException { return file . getCanonicalFile ( ) . getPath ( ) ; }
public String get ( String key ) { return map . get ( key ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( String line : lines ) { builder . append ( line ) . append ( ' \ n ' ) ; } return builder . toString ( ) ; }
public static void main ( String [ ] argv ) throws Exception { InputStream is = null ; OutputStream os = null ; IOUtils . copy ( is , os ) ; }
final ClazzpathUnit to ( Clazzpath clazzpath , String filename ) throws IOException { return to ( clazzpath , filename , filename ) ; }
private static Path resourcePath ( String filename ) { return Paths . get ( filename ) ; }
private static File resourceFile ( String filename ) { return Paths . get ( filename ) . toFile ( ) ; }
private static Set < ClazzpathUnit > unitSet ( ClazzpathUnit [ ] ar ) { return new HashSet < ClazzpathUnit > ( Arrays . asList ( ar ) ) ; }
ClazzpathUnit to ( Clazzpath toClazzpath , String filename , String id ) throws IOException { final String p = filename + " . jar " ; InputStream resourceAsStream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( p ) ; assertNotNull ( " missing : " + p , resourceAsStream ) ; return toClazzpath . addClazzpathUnit ( resourceAsStream , id ) ; }
ClazzpathUnit to ( Clazzpath toClazzpath , String filename , String id ) throws IOException { final String p = filename + " . jar " ; File file = resourceFile ( p ) ; assertTrue ( " missing : " + file , file . exists ( ) & & file . isFile ( ) ) ; return toClazzpath . addClazzpathUnit ( file , id ) ; }
ClazzpathUnit to ( Clazzpath toClazzpath , String filename , String id ) throws IOException { final String p = filename ; File file = resourceFile ( p ) ; assertTrue ( " missing : " + file , file . exists ( ) & & file . isDirectory ( ) ) ; return toClazzpath . addClazzpathUnit ( file , id ) ; }
ClazzpathUnit to ( Clazzpath toClazzpath , String filename , String id ) throws IOException { final String p = filename + " . jar " ; Path path = resourcePath ( p ) ; assertTrue ( " missing : " + path , Files . exists ( path ) & & Files . isRegularFile ( path ) ) ; return toClazzpath . addClazzpathUnit ( path , id ) ; }
ClazzpathUnit to ( Clazzpath toClazzpath , String filename , String id ) throws IOException { final String p = filename ; Path path = resourcePath ( p ) ; assertTrue ( " missing : " + path , Files . exists ( path ) & & Files . isDirectory ( path ) ) ; return toClazzpath . addClazzpathUnit ( path , id ) ; }
public void testShouldRemoveClasspathUnit ( ) throws IOException { final Clazzpath cp = new Clazzpath ( ) ; final ClazzpathUnit unit1 = addClazzpathUnit . to ( cp , " jar1 " ) ; assertEquals ( 59 , cp . getClazzes ( ) . size ( ) ) ; final ClazzpathUnit unit2 = addClazzpathUnit . to ( cp , " jar2 " ) ; assertEquals ( 129 , cp . getClazzes ( ) . size ( ) ) ; cp . removeClazzpathUnit ( unit1 ) ; assertEquals ( 70 , cp . getClazzes ( ) . size ( ) ) ; cp . removeClazzpathUnit ( unit2 ) ; assertEquals ( 0 , cp . getClazzes ( ) . size ( ) ) ; }
public void testShouldRevealMissingClasses ( ) throws IOException { final Clazzpath cp = new Clazzpath ( ) ; addClazzpathUnit . to ( cp , " jar1 - missing " ) ; final Set < Clazz > missing = cp . getMissingClazzes ( ) ; final Set < String > actual = new HashSet < String > ( ) ; for ( Clazz clazz : missing ) { String name = clazz . getName ( ) ; if ( ! name . startsWith ( " java " ) ) { actual . add ( name ) ; } } final Set < String > expected = new HashSet < String > ( Arrays . asList ( " org . apache . commons . io . output . ProxyOutputStream " , " org . apache . commons . io . input . ProxyInputStream " ) ) ; assertEquals ( expected , actual ) ; }
public void testShouldFindUnusedClasses ( ) throws IOException { final Clazzpath cp = new Clazzpath ( ) ; final ClazzpathUnit artifact = addClazzpathUnit . to ( cp , " jar3using1 " ) ; addClazzpathUnit . to ( cp , " jar1 " ) ; final Set < Clazz > removed = cp . getClazzes ( ) ; removed . removeAll ( artifact . getClazzes ( ) ) ; removed . removeAll ( artifact . getTransitiveDependencies ( ) ) ; assertEquals ( " " + removed , 56 , removed . size ( ) ) ; final Set < Clazz > kept = cp . getClazzes ( ) ; kept . removeAll ( removed ) ; assertEquals ( " " + kept , 4 , kept . size ( ) ) ; }
public void testWithModuleInfo ( ) throws Exception { final Clazzpath cp = new Clazzpath ( ) ; final ClazzpathUnit artifact = addClazzpathUnit . to ( cp , " asm - 6 . 0_BETA " ) ; assertNull ( artifact . getClazz ( " module - info " ) ) ; }
private static Path resourcePath ( String filename ) { File file = resourceFile ( filename ) ; if ( file = = null ) { return null ; } return file . toPath ( ) ; }
private static File resourceFile ( String filename ) { ClassLoader classLoader = ClazzpathUnitTestCase . class . getClassLoader ( ) ; URL resource = classLoader . getResource ( filename ) ; if ( resource = = null ) { return null ; } return new File ( resource . getFile ( ) ) ; }
public void testShouldHaveUnitId ( ) throws IOException { final Clazzpath cp = new Clazzpath ( ) ; final ClazzpathUnit u1 = cp . addClazzpathUnit ( resourceFile ( " jar1 . jar " ) ) ; assertTrue ( u1 . toString ( ) . endsWith ( File . separator + " jar1 . jar " ) ) ; final ClazzpathUnit u1e = cp . addClazzpathUnit ( resourceFile ( " jar1 . jar " ) , " jar1 " ) ; assertEquals ( u1e . toString ( ) , " jar1 " ) ; final ClazzpathUnit u2 = cp . addClazzpathUnit ( resourcePath ( " jar2 . jar " ) ) ; assertTrue ( u2 . toString ( ) . endsWith ( File . separator + " jar2 . jar " ) ) ; final ClazzpathUnit u2e = cp . addClazzpathUnit ( resourcePath ( " jar2 . jar " ) , " jar2 " ) ; assertEquals ( u2e . toString ( ) , " jar2 " ) ; }
private void verifyFileNameParsing ( String fileName , String forJava , String className ) { Clazz . ParsedFileName result = parseClassFileName ( fileName ) ; assertEquals ( className , result . className ) ; assertEquals ( forJava , result . forJava ) ; }
private void verifyFileNameParsingInvalid ( String fileName ) { assertNull ( parseClassFileName ( fileName ) ) ; }
public void testFileNameCheck ( ) { assertFalse ( Clazz . isMultiReleaseClassFile ( " org / vafer / multijdk / App . class " ) ) ; assertTrue ( Clazz . isMultiReleaseClassFile ( " META - INF / versions / 11 / org / vafer / multijdk / App . class " ) ) ; assertTrue ( Clazz . isMultiReleaseClassFile ( " META - INF / versions / 1234 / org / vafer / multijdk / App . class " ) ) ; }
public void testFileNameParsing ( ) { verifyFileNameParsing ( " org / vafer / multijdk / App . class " , " 8 " , " org . vafer . multijdk . App " ) ; verifyFileNameParsing ( " META - INF / versions / 11 / org / vafer / multijdk / App . class " , " 11 " , " org . vafer . multijdk . App " ) ; verifyFileNameParsing ( " META - INF / versions / 1234 / org / vafer / multijdk / App . class " , " 1234 " , " org . vafer . multijdk . App " ) ; verifyFileNameParsingInvalid ( " org / vafer / multijdk / App . classsssss " ) ; verifyFileNameParsingInvalid ( " org / vafer / multijdk / App . txt " ) ; verifyFileNameParsingInvalid ( " META - INF / versions / xxx / org / vafer / multijdk / App . class " ) ; }
private void verifyClazzFiles ( Clazz clazz , boolean have8 , boolean have11 , boolean have17 ) { String expectedFilename = clazz . getName ( ) . replace ( " . " , " / " ) + " . class " ; verifyFileInClazz ( clazz , expectedFilename , " 8 " , have8 ) ; verifyFileInClazz ( clazz , " META - INF / versions / 11 / " + expectedFilename , " 11 " , have11 ) ; verifyFileInClazz ( clazz , " META - INF / versions / 17 / " + expectedFilename , " 17 " , have17 ) ; }
public void testMultiReleaseJar ( ) throws IOException { final Clazzpath cp = new Clazzpath ( ) ; final ClazzpathUnit app = cp . addClazzpathUnit ( resourceFile ( " uses - multi - jdk - 1 . 0 . jar " ) ) ; Map < String , Clazz > appClazzes = app . getClazzesMap ( ) ; assertEquals ( 1 , appClazzes . size ( ) ) ; verifyClazzFiles ( appClazzes . get ( " nl . example . Main " ) , true , false , false ) ; final ClazzpathUnit dependency = cp . addClazzpathUnit ( resourceFile ( " multi - jdk - 1 . 0 . 0 . jar " ) ) ; Map < String , Clazz > dependencyClazzes = dependency . getClazzesMap ( ) ; verifyClazzFiles ( dependencyClazzes . get ( " org . vafer . multijdk . Main " ) , true , false , false ) ; verifyClazzFiles ( dependencyClazzes . get ( " org . vafer . multijdk . App " ) , true , true , true ) ; verifyClazzFiles ( dependencyClazzes . get ( " org . vafer . multijdk . AbstractJavaVersion " ) , true , false , false ) ; verifyClazzFiles ( dependencyClazzes . get ( " org . vafer . multijdk . JavaVersion " ) , true , true , false ) ; verifyClazzFiles ( dependencyClazzes . get ( " org . vafer . multijdk . Unused " ) , true , true , true ) ; verifyClazzFiles ( dependencyClazzes . get ( " org . vafer . multijdk . OnlyUsedInJava17 " ) , false , true , false ) ; verifyClazzFiles ( dependencyClazzes . get ( " org . vafer . multijdk . SpecificToJava11 " ) , false , true , false ) ; verifyClazzFiles ( dependencyClazzes . get ( " org . vafer . multijdk . SpecificToJava17 " ) , false , false , true ) ; final Set < Clazz > removable = cp . getClazzes ( ) ; removable . removeAll ( appClazzes . values ( ) ) ; removable . removeAll ( app . getTransitiveDependencies ( ) ) ; Map < String , Clazz > removableClazzes = removable . stream ( ) . collect ( Collectors . toMap ( Clazz : : getName , Function . identity ( ) ) ) ; assertEquals ( 2 , removableClazzes . size ( ) ) ; assertTrue ( removableClazzes . containsKey ( " org . vafer . multijdk . Main " ) ) ; assertTrue ( removableClazzes . containsKey ( " org . vafer . multijdk . Unused " ) ) ; }
public static void main ( String [ ] args ) { JavaVersion javaVersion = new JavaVersion ( ) ; System . out . println ( " Java detect : " + javaVersion . getCodeVersion ( ) ) ; System . out . println ( " Java major : " + javaVersion . getJavaMajorVersion ( ) ) ; System . out . println ( " App code : " + new App ( ) . doSomething ( ) ) ; }
public String doSomething ( ) { return " java 17 " ; }
public String doSomething ( ) { return new SpecificToJava17 ( ) . doSomething ( ) + " " + new OnlyUsedInJava17 ( ) . doSomething ( ) ; }
public String doSomething ( ) { return " java " ; }
public String doSomething ( ) { return " java 11 " ; }
public String doSomething ( ) { return new SpecificToJava11 ( ) . doSomething ( ) + " 11 " ; }
public String doSomething ( ) { return new JavaVersion ( ) . getJavaMajorVersion ( ) ; }
public String doSomething ( ) { return " base " ; }
public static void main ( String [ ] args ) { JavaVersion javaVersion = new JavaVersion ( ) ; System . out . println ( " Java detect : " + javaVersion . getCodeVersion ( ) ) ; System . out . println ( " Java major : " + javaVersion . getJavaMajorVersion ( ) ) ; System . out . println ( " App code : " + new App ( ) . doSomething ( ) ) ; System . out . println ( " Unused : " + new Unused ( ) . doSomething ( ) ) ; }
public ClazzpathUnit addClazzpathUnit ( final File pFile ) throws IOException { return addClazzpathUnit ( pFile . toPath ( ) ) ; }
public ClazzpathUnit addClazzpathUnit ( final File pFile , final String pId ) throws IOException { return addClazzpathUnit ( pFile . toPath ( ) , pId ) ; }
public ClazzpathUnit addClazzpathUnit ( final Path pPath ) throws IOException { return addClazzpathUnit ( pPath , pPath . toString ( ) ) ; }
InputStream getInputStream ( ) throws IOException { return Files . newInputStream ( p ) ; }
InputStream getInputStream ( ) throws IOException { return inputStream ; }
public static ParsedFileName parseClassFileName ( String pFileName ) { if ( pFileName = = null | | ! pFileName . endsWith ( " . class " ) ) { return null ; } Matcher matcher = EXTRACT_MULTI_RELEASE_JAVA_VERSION . matcher ( pFileName ) ; if ( ! matcher . matches ( ) ) { return null ; } ParsedFileName result = new ParsedFileName ( ) ; result . forJava = matcher . group ( 1 ) ; result . className = separatorsToUnix ( matcher . group ( 2 ) ) . replace ( ' / ' , ' . ' ) ; if ( result . forJava = = null | | result . forJava . isEmpty ( ) ) { if ( result . className . contains ( " - " ) ) { return null ; } result . forJava = " 8 " ; } return result ; }
public static boolean isMultiReleaseClassFile ( String pFileName ) { if ( pFileName = = null ) { return false ; } Matcher matcher = EXTRACT_MULTI_RELEASE_JAVA_VERSION . matcher ( pFileName ) ; if ( ! matcher . matches ( ) ) { return false ; } return matcher . group ( 1 ) ! = null & & ! matcher . group ( 1 ) . isEmpty ( ) ; }
public void addMultiReleaseFile ( ClazzpathUnit pUnit , String pForJava , String pFileName ) { classFilenames . put ( pForJava , new ClazzFile ( pUnit , pFileName ) ) ; }
public void addClazzpathUnit ( final ClazzpathUnit pUnit , final String pDigest ) { units . put ( pUnit , pDigest ) ; }
public void removeClazzpathUnit ( final ClazzpathUnit pUnit ) { units . remove ( pUnit ) ; }
public void addDependency ( final Clazz pClazz ) { pClazz . references . add ( this ) ; dependencies . add ( pClazz ) ; }
public void removeDependency ( final Clazz pClazz ) { pClazz . references . remove ( this ) ; dependencies . remove ( pClazz ) ; }
public int hashCode ( ) { return name . hashCode ( ) ; }
public int compareTo ( final Clazz pO ) { return name . compareTo ( ( ( Clazz ) pO ) . name ) ; }
public String toString ( ) { return name + " in " + classFilenames ; }
public String toString ( ) { return id ; }
public String map ( String pClassName ) { classes . add ( pClassName . replace ( ' / ' , ' . ' ) ) ; return pClassName ; }
public AnnotationVisitor visitAnnotation ( String name , String desc ) { return this ; }
public AnnotationVisitor visitArray ( String name ) { return this ; }
public AnnotationVisitor visitAnnotationDefault ( ) { return av ; }
public AnnotationVisitor visitAnnotation ( String desc , boolean visible ) { return av ; }
public AnnotationVisitor visitParameterAnnotation ( int parameter , String desc , boolean visible ) { return av ; }
public AnnotationVisitor visitInsnAnnotation ( int typeRef , TypePath typePath , String descriptor , boolean visible ) { return av ; }
public AnnotationVisitor visitLocalVariableAnnotation ( int typeRef , TypePath typePath , Label [ ] start , Label [ ] end , int [ ] index , String descriptor , boolean visible ) { return av ; }
public AnnotationVisitor visitTryCatchAnnotation ( int typeRef , TypePath typePath , String descriptor , boolean visible ) { return av ; }
public AnnotationVisitor visitTypeAnnotation ( int typeRef , TypePath typePath , String descriptor , boolean visible ) { return av ; }
public AnnotationVisitor visitAnnotation ( String desc , boolean visible ) { return av ; }
public AnnotationVisitor visitAnnotation ( String descriptor , boolean visible ) { return av ; }
public AnnotationVisitor visitTypeAnnotation ( int typeRef , TypePath typePath , String descriptor , boolean visible ) { return av ; }
public AnnotationVisitor visitAnnotation ( String desc , boolean visible ) { return av ; }
public FieldVisitor visitField ( int access , String name , String desc , String signature , Object value ) { return fieldVisitor ; }
public MethodVisitor visitMethod ( int access , String name , String desc , String signature , String [ ] exceptions ) { return mv ; }
public AnnotationVisitor visitTypeAnnotation ( int typeRef , TypePath typePath , String descriptor , boolean visible ) { return av ; }
public ModuleVisitor visitModule ( String name , int access , String version ) { return moduleVisitor ; }
public RecordComponentVisitor visitRecordComponent ( String name , String descriptor , String signature ) { return recordComponentVisitor ; }
public static Set < String > getDependenciesOfClass ( final InputStream pInputStream ) throws IOException { final DependenciesClassAdapter v = new DependenciesClassAdapter ( ) ; new ClassReader ( pInputStream ) . accept ( v , ClassReader . EXPAND_FRAMES ) ; final Set < String > depNames = v . getDependencies ( ) ; return depNames ; }
public static Set < String > getDependenciesOfClass ( final Class < ? > pClass ) throws IOException { final String resource = " / " + pClass . getName ( ) . replace ( ' . ' , ' / ' ) + " . class " ; return getDependenciesOfClass ( pClass . getResourceAsStream ( resource ) ) ; }
protected Decompiler createDecompiler ( CompilerEnvirons compilerEnv ) { return new Decompiler ( ) ; }
RuntimeException reportError ( String messageId ) { addError ( messageId ) ; throw new ParserException ( ) ; }
private int peekToken ( ) throws IOException { int tt = currentFlaggedToken ; if ( tt = = Token . EOF ) { tt = ts . getToken ( ) ; if ( tt = = Token . EOL ) { do { tt = ts . getToken ( ) ; } while ( tt = = Token . EOL ) ; tt | = TI_AFTER_EOL ; } currentFlaggedToken = tt ; } return tt & CLEAR_TI_MASK ; }
private int peekFlaggedToken ( ) throws IOException { peekToken ( ) ; return currentFlaggedToken ; }
private void consumeToken ( ) { currentFlaggedToken = Token . EOF ; }
private int nextToken ( ) throws IOException { int tt = peekToken ( ) ; consumeToken ( ) ; return tt ; }
private int nextFlaggedToken ( ) throws IOException { peekToken ( ) ; int ttFlagged = currentFlaggedToken ; consumeToken ( ) ; return ttFlagged ; }
private boolean matchToken ( int toMatch ) throws IOException { int tt = peekToken ( ) ; if ( tt ! = toMatch ) { return false ; } consumeToken ( ) ; return true ; }
private int peekTokenOrEOL ( ) throws IOException { int tt = peekToken ( ) ; if ( ( currentFlaggedToken & TI_AFTER_EOL ) ! = 0 ) { tt = Token . EOL ; } return tt ; }
public boolean eof ( ) { return ts . eof ( ) ; }
boolean insideFunction ( ) { return nestingOfFunction ! = 0 ; }
void pushScope ( Node node ) { Node . Scope scopeNode = ( Node . Scope ) node ; if ( scopeNode . getParentScope ( ) ! = null ) throw Kit . codeBug ( ) ; scopeNode . setParent ( currentScope ) ; currentScope = scopeNode ; }
void popScope ( ) { currentScope = currentScope . getParentScope ( ) ; }
private Node enterLoop ( Node loopLabel , boolean doPushScope ) { Node loop = nf . createLoopNode ( loopLabel , ts . getLineno ( ) ) ; if ( loopSet = = null ) { loopSet = new ObjArray ( ) ; if ( loopAndSwitchSet = = null ) { loopAndSwitchSet = new ObjArray ( ) ; } } loopSet . push ( loop ) ; loopAndSwitchSet . push ( loop ) ; if ( doPushScope ) { pushScope ( loop ) ; } return loop ; }
private Node enterSwitch ( Node switchSelector , int lineno ) { Node switchNode = nf . createSwitch ( switchSelector , lineno ) ; if ( loopAndSwitchSet = = null ) { loopAndSwitchSet = new ObjArray ( ) ; } loopAndSwitchSet . push ( switchNode ) ; return switchNode ; }
private void exitSwitch ( ) { loopAndSwitchSet . pop ( ) ; }
public ScriptOrFnNode parse ( Reader sourceReader , String sourceURI , int lineno ) throws IOException { this . sourceURI = sourceURI ; this . ts = new TokenStream ( this , sourceReader , null , lineno ) ; return parse ( ) ; }
private Node parseFunctionBody ( ) throws IOException { + + nestingOfFunction ; Node pn = nf . createBlock ( ts . getLineno ( ) ) ; try { bodyLoop : for ( ; ; ) { Node n ; int tt = peekToken ( ) ; switch ( tt ) { case Token . ERROR : case Token . EOF : case Token . RC : break bodyLoop ; case Token . FUNCTION : consumeToken ( ) ; n = function ( FunctionNode . FUNCTION_STATEMENT ) ; break ; default : n = statement ( ) ; break ; } nf . addChildToBack ( pn , n ) ; } } catch ( ParserException e ) { } finally { - - nestingOfFunction ; } return pn ; }
private Node matchJumpLabelName ( ) throws IOException , ParserException { Node label = null ; int tt = peekTokenOrEOL ( ) ; if ( tt = = Token . NAME ) { consumeToken ( ) ; String name = ts . getString ( ) ; decompiler . addName ( name ) ; if ( labelSet ! = null ) { label = labelSet . get ( name ) ; } if ( label = = null ) { reportError ( " msg . undef . label " ) ; } } return label ; }
private Node statement ( ) throws IOException { try { Node pn = statementHelper ( null ) ; if ( pn ! = null ) { if ( compilerEnv . isStrictMode ( ) & & ! pn . hasSideEffects ( ) ) addStrictWarning ( " msg . no . side . effects " , " " ) ; return pn ; } } catch ( ParserException e ) { } int lineno = ts . getLineno ( ) ; guessingStatementEnd : for ( ; ; ) { int tt = peekTokenOrEOL ( ) ; consumeToken ( ) ; switch ( tt ) { case Token . ERROR : case Token . EOF : case Token . EOL : case Token . SEMI : break guessingStatementEnd ; } } return nf . createExprStatement ( nf . createName ( " error " ) , lineno ) ; }
private static final boolean nowAllSet ( int before , int after , int mask ) { return ( ( before & mask ) ! = mask ) & & ( ( after & mask ) = = mask ) ; }
private Node returnOrYield ( int tt , boolean exprContext ) throws IOException , ParserException { if ( ! insideFunction ( ) ) { reportError ( tt = = Token . RETURN ? " msg . bad . return " : " msg . bad . yield " ) ; } consumeToken ( ) ; decompiler . addToken ( tt ) ; int lineno = ts . getLineno ( ) ; Node e ; switch ( peekTokenOrEOL ( ) ) { case Token . SEMI : case Token . RC : case Token . EOF : case Token . EOL : case Token . ERROR : case Token . RB : case Token . RP : case Token . YIELD : e = null ; break ; default : e = expr ( false ) ; break ; } int before = endFlags ; Node ret ; if ( tt = = Token . RETURN ) { if ( e = = null ) { endFlags | = Node . END_RETURNS ; } else { endFlags | = Node . END_RETURNS_VALUE ; } ret = nf . createReturn ( e , lineno ) ; if ( nowAllSet ( before , endFlags , Node . END_RETURNS | Node . END_RETURNS_VALUE ) ) { addStrictWarning ( " msg . return . inconsistent " , " " ) ; } } else { endFlags | = Node . END_YIELDS ; ret = nf . createYield ( e , lineno ) ; if ( ! exprContext ) ret = new Node ( Token . EXPR_VOID , ret , lineno ) ; } if ( nowAllSet ( before , endFlags , Node . END_YIELDS | Node . END_RETURNS_VALUE ) ) { String name = ( ( FunctionNode ) currentScriptOrFn ) . getFunctionName ( ) ; if ( name . length ( ) = = 0 ) addError ( " msg . anon . generator . returns " , " " ) ; else addError ( " msg . generator . returns " , name ) ; } return ret ; }
private Node variables ( boolean inFor , int declType ) throws IOException , ParserException { Node result = nf . createVariables ( declType , ts . getLineno ( ) ) ; boolean first = true ; for ( ; ; ) { Node destructuring = null ; String s = null ; int tt = peekToken ( ) ; if ( tt = = Token . LB | | tt = = Token . LC ) { destructuring = primaryExpr ( ) ; } else { mustMatchToken ( Token . NAME , " msg . bad . var " ) ; s = ts . getString ( ) ; if ( ! first ) decompiler . addToken ( Token . COMMA ) ; first = false ; decompiler . addName ( s ) ; defineSymbol ( declType , inFor , s ) ; } Node init = null ; if ( matchToken ( Token . ASSIGN ) ) { decompiler . addToken ( Token . ASSIGN ) ; init = assignExpr ( inFor ) ; } if ( destructuring ! = null ) { if ( init = = null ) { if ( ! inFor ) reportError ( " msg . destruct . assign . no . init " ) ; nf . addChildToBack ( result , destructuring ) ; } else { nf . addChildToBack ( result , nf . createDestructuringAssignment ( declType , destructuring , init ) ) ; } } else { Node name = nf . createName ( s ) ; if ( init ! = null ) nf . addChildToBack ( name , init ) ; nf . addChildToBack ( result , name ) ; } if ( ! matchToken ( Token . COMMA ) ) break ; } return result ; }
private Node let ( boolean isStatement ) throws IOException , ParserException { mustMatchToken ( Token . LP , " msg . no . paren . after . let " ) ; decompiler . addToken ( Token . LP ) ; Node result = nf . createScopeNode ( Token . LET , ts . getLineno ( ) ) ; pushScope ( result ) ; try { Node vars = variables ( false , Token . LET ) ; nf . addChildToBack ( result , vars ) ; mustMatchToken ( Token . RP , " msg . no . paren . let " ) ; decompiler . addToken ( Token . RP ) ; if ( isStatement & & peekToken ( ) = = Token . LC ) { consumeToken ( ) ; decompiler . addEOL ( Token . LC ) ; nf . addChildToBack ( result , statements ( null ) ) ; mustMatchToken ( Token . RC , " msg . no . curly . let " ) ; decompiler . addToken ( Token . RC ) ; } else { result . setType ( Token . LETEXPR ) ; nf . addChildToBack ( result , expr ( false ) ) ; if ( isStatement ) { result = nf . createExprStatement ( result , ts . getLineno ( ) ) ; } } } finally { popScope ( ) ; } return result ; }
private Node expr ( boolean inForInit ) throws IOException , ParserException { Node pn = assignExpr ( inForInit ) ; while ( matchToken ( Token . COMMA ) ) { decompiler . addToken ( Token . COMMA ) ; if ( compilerEnv . isStrictMode ( ) & & ! pn . hasSideEffects ( ) ) addStrictWarning ( " msg . no . side . effects " , " " ) ; if ( peekToken ( ) = = Token . YIELD ) { reportError ( " msg . yield . parenthesized " ) ; } pn = nf . createBinary ( Token . COMMA , pn , assignExpr ( inForInit ) ) ; } return pn ; }
private Node condExpr ( boolean inForInit ) throws IOException , ParserException { Node pn = orExpr ( inForInit ) ; if ( matchToken ( Token . HOOK ) ) { decompiler . addToken ( Token . HOOK ) ; Node ifTrue = assignExpr ( false ) ; mustMatchToken ( Token . COLON , " msg . no . colon . cond " ) ; decompiler . addToken ( Token . COLON ) ; Node ifFalse = assignExpr ( inForInit ) ; return nf . createCondExpr ( pn , ifTrue , ifFalse ) ; } return pn ; }
private Node orExpr ( boolean inForInit ) throws IOException , ParserException { Node pn = andExpr ( inForInit ) ; if ( matchToken ( Token . OR ) ) { decompiler . addToken ( Token . OR ) ; pn = nf . createBinary ( Token . OR , pn , orExpr ( inForInit ) ) ; } return pn ; }
private Node andExpr ( boolean inForInit ) throws IOException , ParserException { Node pn = bitOrExpr ( inForInit ) ; if ( matchToken ( Token . AND ) ) { decompiler . addToken ( Token . AND ) ; pn = nf . createBinary ( Token . AND , pn , andExpr ( inForInit ) ) ; } return pn ; }
private Node bitOrExpr ( boolean inForInit ) throws IOException , ParserException { Node pn = bitXorExpr ( inForInit ) ; while ( matchToken ( Token . BITOR ) ) { decompiler . addToken ( Token . BITOR ) ; pn = nf . createBinary ( Token . BITOR , pn , bitXorExpr ( inForInit ) ) ; } return pn ; }
private Node bitXorExpr ( boolean inForInit ) throws IOException , ParserException { Node pn = bitAndExpr ( inForInit ) ; while ( matchToken ( Token . BITXOR ) ) { decompiler . addToken ( Token . BITXOR ) ; pn = nf . createBinary ( Token . BITXOR , pn , bitAndExpr ( inForInit ) ) ; } return pn ; }
private Node bitAndExpr ( boolean inForInit ) throws IOException , ParserException { Node pn = eqExpr ( inForInit ) ; while ( matchToken ( Token . BITAND ) ) { decompiler . addToken ( Token . BITAND ) ; pn = nf . createBinary ( Token . BITAND , pn , eqExpr ( inForInit ) ) ; } return pn ; }
private Node relExpr ( boolean inForInit ) throws IOException , ParserException { Node pn = shiftExpr ( ) ; for ( ; ; ) { int tt = peekToken ( ) ; switch ( tt ) { case Token . IN : if ( inForInit ) break ; case Token . INSTANCEOF : case Token . LE : case Token . LT : case Token . GE : case Token . GT : consumeToken ( ) ; decompiler . addToken ( tt ) ; pn = nf . createBinary ( tt , pn , shiftExpr ( ) ) ; continue ; } break ; } return pn ; }
private Node shiftExpr ( ) throws IOException , ParserException { Node pn = addExpr ( ) ; for ( ; ; ) { int tt = peekToken ( ) ; switch ( tt ) { case Token . LSH : case Token . URSH : case Token . RSH : consumeToken ( ) ; decompiler . addToken ( tt ) ; pn = nf . createBinary ( tt , pn , addExpr ( ) ) ; continue ; } break ; } return pn ; }
private Node addExpr ( ) throws IOException , ParserException { Node pn = mulExpr ( ) ; for ( ; ; ) { int tt = peekToken ( ) ; if ( tt = = Token . ADD | | tt = = Token . SUB ) { consumeToken ( ) ; decompiler . addToken ( tt ) ; pn = nf . createBinary ( tt , pn , mulExpr ( ) ) ; continue ; } break ; } return pn ; }
private Node mulExpr ( ) throws IOException , ParserException { Node pn = unaryExpr ( ) ; for ( ; ; ) { int tt = peekToken ( ) ; switch ( tt ) { case Token . MUL : case Token . DIV : case Token . MOD : consumeToken ( ) ; decompiler . addToken ( tt ) ; pn = nf . createBinary ( tt , pn , unaryExpr ( ) ) ; continue ; } break ; } return pn ; }
private void argumentList ( Node listNode ) throws IOException , ParserException { boolean matched ; matched = matchToken ( Token . RP ) ; if ( ! matched ) { boolean first = true ; do { if ( ! first ) decompiler . addToken ( Token . COMMA ) ; first = false ; if ( peekToken ( ) = = Token . YIELD ) { reportError ( " msg . yield . parenthesized " ) ; } nf . addChildToBack ( listNode , assignExpr ( false ) ) ; } while ( matchToken ( Token . COMMA ) ) ; mustMatchToken ( Token . RP , " msg . no . paren . arg " ) ; } decompiler . addToken ( Token . RP ) ; }
private Node memberExpr ( boolean allowCallSyntax ) throws IOException , ParserException { int tt ; Node pn ; tt = peekToken ( ) ; if ( tt = = Token . NEW ) { consumeToken ( ) ; decompiler . addToken ( Token . NEW ) ; pn = nf . createCallOrNew ( Token . NEW , memberExpr ( false ) ) ; if ( matchToken ( Token . LP ) ) { decompiler . addToken ( Token . LP ) ; argumentList ( pn ) ; } tt = peekToken ( ) ; if ( tt = = Token . LC ) { nf . addChildToBack ( pn , primaryExpr ( ) ) ; } } else { pn = primaryExpr ( ) ; } return memberExprTail ( allowCallSyntax , pn ) ; }
private Node attributeAccess ( Node pn , int memberTypeFlags ) throws IOException { memberTypeFlags | = Node . ATTRIBUTE_FLAG ; int tt = nextToken ( ) ; switch ( tt ) { case Token . NAME : { String s = ts . getString ( ) ; decompiler . addName ( s ) ; pn = propertyName ( pn , s , memberTypeFlags ) ; } break ; case Token . MUL : decompiler . addName ( " * " ) ; pn = propertyName ( pn , " * " , memberTypeFlags ) ; break ; case Token . LB : decompiler . addToken ( Token . LB ) ; pn = nf . createElementGet ( pn , null , expr ( false ) , memberTypeFlags ) ; mustMatchToken ( Token . RB , " msg . no . bracket . index " ) ; decompiler . addToken ( Token . RB ) ; break ; default : reportError ( " msg . no . name . after . xmlAttr " ) ; pn = nf . createPropertyGet ( pn , null , " ? " , memberTypeFlags ) ; break ; } return pn ; }
private Node propertyName ( Node pn , String name , int memberTypeFlags ) throws IOException , ParserException { String namespace = null ; if ( matchToken ( Token . COLONCOLON ) ) { decompiler . addToken ( Token . COLONCOLON ) ; namespace = name ; int tt = nextToken ( ) ; switch ( tt ) { case Token . NAME : name = ts . getString ( ) ; decompiler . addName ( name ) ; break ; case Token . MUL : decompiler . addName ( " * " ) ; name = " * " ; break ; case Token . LB : decompiler . addToken ( Token . LB ) ; pn = nf . createElementGet ( pn , namespace , expr ( false ) , memberTypeFlags ) ; mustMatchToken ( Token . RB , " msg . no . bracket . index " ) ; decompiler . addToken ( Token . RB ) ; return pn ; default : reportError ( " msg . no . name . after . coloncolon " ) ; name = " ? " ; } } pn = nf . createPropertyGet ( pn , namespace , name , memberTypeFlags ) ; return pn ; }
private void plainProperty ( ObjArray elems , Object property ) throws IOException { mustMatchToken ( Token . COLON , " msg . no . colon . prop " ) ; decompiler . addToken ( Token . OBJECTLIT ) ; elems . add ( property ) ; elems . add ( assignExpr ( false ) ) ; }
String tokenToString ( int token ) { if ( Token . printTrees ) { String name = Token . name ( token ) ; switch ( token ) { case Token . STRING : case Token . REGEXP : case Token . NAME : return name + " ` " + this . string + " ' " ; case Token . NUMBER : return " NUMBER " + this . number ; } return name ; } return " " ; }
static boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
boolean isXMLAttribute ( ) { return xmlIsAttribute ; }
private void addToString ( int c ) { int N = stringBufferTop ; if ( N = = stringBuffer . length ) { char [ ] tmp = new char [ stringBuffer . length * 2 ] ; System . arraycopy ( stringBuffer , 0 , tmp , 0 , N ) ; stringBuffer = tmp ; } stringBuffer [ N ] = ( char ) c ; stringBufferTop = N + 1 ; }
private void ungetChar ( int c ) { if ( ungetCursor ! = 0 & & ungetBuffer [ ungetCursor - 1 ] = = ' \ n ' ) Kit . codeBug ( ) ; ungetBuffer [ ungetCursor + + ] = c ; }
private int peekChar ( ) throws IOException { int c = getChar ( ) ; ungetChar ( c ) ; return c ; }
private void ungetCharIgnoreLineEnd ( int c ) { ungetBuffer [ ungetCursor + + ] = c ; }
int markFunctionStart ( int functionType ) { int savedOffset = getCurrentOffset ( ) ; addToken ( Token . FUNCTION ) ; append ( ( char ) functionType ) ; return savedOffset ; }
int markFunctionEnd ( int functionStart ) { int offset = getCurrentOffset ( ) ; append ( ( char ) FUNCTION_END ) ; return offset ; }
void addName ( String str ) { addToken ( Token . NAME ) ; appendString ( str ) ; }
void addString ( String str ) { addToken ( Token . STRING ) ; appendString ( str ) ; }
void addRegexp ( String regexp , String flags ) { addToken ( Token . REGEXP ) ; appendString ( ' / ' + regexp + ' / ' + flags ) ; }
void addJScriptConditionalComment ( String str ) { addToken ( Token . CONDCOMMENT ) ; appendString ( str ) ; }
void addPreservedComment ( String str ) { addToken ( Token . KEEPCOMMENT ) ; appendString ( str ) ; }
private void append ( char c ) { if ( sourceTop = = sourceBuffer . length ) { increaseSourceCapacity ( sourceTop + 1 ) ; } sourceBuffer [ sourceTop ] = c ; + + sourceTop ; }
void preventMunging ( ) { markedForMunging = false ; }
boolean isMarkedForMunging ( ) { return markedForMunging ; }
void incrementRefcount ( ) { refcount + + ; }
public static void main ( String args [ ] ) throws Exception { ClassLoader loader = new JarClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; Class c = loader . loadClass ( YUICompressor . class . getName ( ) ) ; Method main = c . getMethod ( " main " , new Class [ ] { String [ ] . class } ) ; main . invoke ( null , new Object [ ] { args } ) ; }
private static boolean isValidIdentifier ( String s ) { Matcher m = SIMPLE_IDENTIFIER_NAME_PATTERN . matcher ( s ) ; return ( m . matches ( ) & & ! reserved . contains ( s ) ) ; }
private void enterScope ( ScriptOrFnScope scope ) { scopes . push ( scope ) ; }
private void leaveCurrentScope ( ) { scopes . pop ( ) ; }
private JavaScriptToken consumeToken ( ) { return ( JavaScriptToken ) tokens . get ( offset + + ) ; }
private void parseCatch ( ) { String symbol ; JavaScriptToken token ; ScriptOrFnScope currentScope ; JavaScriptIdentifier identifier ; token = getToken ( - 1 ) ; assert token . getType ( ) = = Token . CATCH ; token = consumeToken ( ) ; assert token . getType ( ) = = Token . LP ; token = consumeToken ( ) ; assert token . getType ( ) = = Token . NAME ; symbol = token . getValue ( ) ; currentScope = getCurrentScope ( ) ; if ( mode = = BUILDING_SYMBOL_TREE ) { currentScope . declareIdentifier ( symbol ) ; } else { identifier = getIdentifier ( symbol , currentScope ) ; identifier . incrementRefcount ( ) ; } token = consumeToken ( ) ; assert token . getType ( ) = = Token . RP ; }
private void buildSymbolTree ( ) { offset = 0 ; braceNesting = 0 ; scopes . clear ( ) ; indexedScopes . clear ( ) ; indexedScopes . put ( new Integer ( 0 ) , globalScope ) ; mode = BUILDING_SYMBOL_TREE ; parseScope ( globalScope ) ; }
private void mungeSymboltree ( ) { if ( ! munge ) { return ; } offset = 0 ; braceNesting = 0 ; scopes . clear ( ) ; mode = CHECKING_SYMBOL_TREE ; parseScope ( globalScope ) ; globalScope . munge ( ) ; }
private void printMungeMapping ( Writer map ) throws IOException { StringBuffer sb = new StringBuffer ( ) ; globalScope . getFullMapping ( sb , " " ) ; map . write ( sb . toString ( ) ) ; }
public Class loadClass ( String name ) throws ClassNotFoundException { Class c = findLoadedClass ( name ) ; if ( c = = null ) { c = findClass ( name ) ; } if ( c = = null ) { c = ClassLoader . getSystemClassLoader ( ) . loadClass ( name ) ; } return c ; }
protected Class findClass ( String name ) { Class c = null ; String jarPath = getJarPath ( ) ; if ( jarPath ! = null ) { JarFile jarFile = null ; try { jarFile = new JarFile ( jarPath ) ; c = loadClassData ( jarFile , name ) ; } catch ( IOException ioe ) { } finally { if ( jarFile ! = null ) { try { jarFile . close ( ) ; } catch ( IOException ioe ) { } } } } return c ; }
public EvaluatorException runtimeError ( String message , String sourceName , int line , String lineSource , int lineOffset ) { error ( message , sourceName , line , lineSource , lineOffset ) ; return new EvaluatorException ( message ) ; }
private static void version ( ) { System . err . println ( " @ VERSION @ " ) ; }
JavaScriptIdentifier declareIdentifier ( String symbol ) { JavaScriptIdentifier identifier = ( JavaScriptIdentifier ) identifiers . get ( symbol ) ; if ( identifier = = null ) { identifier = new JavaScriptIdentifier ( symbol , this ) ; identifiers . put ( symbol , identifier ) ; } return identifier ; }
void addHint ( String variableName , String variableType ) { hints . put ( variableName , variableType ) ; }
int incrementVarCount ( ) { varcount + + ; return varcount ; }
public void testReadWriteLongZero ( ) { testReadWriteLong ( ( byte ) 0 ) ; }
public void testReadWriteLongMax ( ) { testReadWriteLong ( Byte . MAX_VALUE ) ; }
public void testReadWriteLongMin ( ) { testReadWriteLong ( Byte . MIN_VALUE ) ; }
public void testReadWriteLongRnd ( ) { Random rnd = new Random ( ) ; byte [ ] buf = new byte [ 1 ] ; rnd . nextBytes ( buf ) ; testReadWriteLong ( buf [ 0 ] ) ; }
public void testReadWriteIntZero ( ) { testReadWriteInt ( ( byte ) 0 ) ; }
public void testReadWriteIntMin ( ) { testReadWriteInt ( Byte . MIN_VALUE ) ; }
public void testReadWriteIntMax ( ) { testReadWriteInt ( Byte . MAX_VALUE ) ; }
public void testReadWriteShortMin ( ) { testReadWriteShort ( Byte . MIN_VALUE ) ; }
public void testReadWriteShortMax ( ) { testReadWriteShort ( Byte . MAX_VALUE ) ; }
public void testReadWriteByteZero ( ) { testReadWriteByte ( ( byte ) 0 ) ; }
public void testReadWriteByteMin ( ) { testReadWriteByte ( Byte . MIN_VALUE ) ; }
public void testReadWriteByteMax ( ) { testReadWriteShort ( Byte . MAX_VALUE ) ; }
public void testDate ( ) { Calendar cal = Calendar . getInstance ( ) ; Calendar expected = Calendar . getInstance ( ) ; expected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; byte [ ] buf = PwDate . writeTime ( expected . getTime ( ) , cal ) ; Calendar actual = Calendar . getInstance ( ) ; actual . setTime ( PwDate . readTime ( buf , 0 , cal ) ) ; assertEquals ( " Year mismatch : " , 2008 , actual . get ( Calendar . YEAR ) ) ; assertEquals ( " Month mismatch : " , 1 , actual . get ( Calendar . MONTH ) ) ; assertEquals ( " Day mismatch : " , 1 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; assertEquals ( " Hour mismatch : " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; assertEquals ( " Minute mismatch : " , 4 , actual . get ( Calendar . MINUTE ) ) ; assertEquals ( " Second mismatch : " , 5 , actual . get ( Calendar . SECOND ) ) ; }
public void testUUID ( ) { Random rnd = new Random ( ) ; byte [ ] bUUID = new byte [ 16 ] ; rnd . nextBytes ( bUUID ) ; UUID uuid = Types . bytestoUUID ( bUUID ) ; byte [ ] eUUID = Types . UUIDtoBytes ( uuid ) ; assertArrayEquals ( " UUID match failed " , bUUID , eUUID ) ; }
public void testParseVersion ( ) { long ver1 = Types . parseVersion ( " 1 . 00 " ) ; assertEquals ( " Version 1 . 00 doesn ' t match " , ver1 , 0x0001000000000000L ) ; long ver2 = Types . parseVersion ( " 2 . 00 " ) ; assertEquals ( " Version 2 . 00 doesn ' t match " , ver2 , 0x0002000000000000L ) ; }
public void testName ( ) { assertTrue ( " Name was " + mPE . title , mPE . title . equals ( " Amazon " ) ) ; }
public void testPassword ( ) throws UnsupportedEncodingException { String sPass = " 12345 " ; byte [ ] password = sPass . getBytes ( " UTF - 8 " ) ; assertArrayEquals ( password , mPE . getPasswordBytes ( ) ) ; }
public void testCreation ( ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( mPE . tCreation . getJDate ( ) ) ; assertEquals ( " Incorrect year . " , cal . get ( Calendar . YEAR ) , 2009 ) ; assertEquals ( " Incorrect month . " , cal . get ( Calendar . MONTH ) , 3 ) ; assertEquals ( " Incorrect day . " , cal . get ( Calendar . DAY_OF_MONTH ) , 23 ) ; }
public void testGroupName ( ) { assertTrue ( " Name was " + mPG . name , mPG . name . equals ( " Internet " ) ) ; }
public static InputStream getKeyFileInputStream ( Context ctx , String keyfile ) throws FileNotFoundException { InputStream keyIs = null ; if ( ! EmptyUtils . isNullOrEmpty ( keyfile ) ) { Uri uri = UriUtil . parseDefaultFile ( keyfile ) ; keyIs = UriUtil . getUriInputStream ( ctx , uri ) ; } return keyIs ; }
private void testKeyfile ( String dbAsset , String keyAsset , String password ) throws Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; File sdcard = Environment . getExternalStorageDirectory ( ) ; String keyPath = ctx . getFilesDir ( ) . getAbsolutePath ( ) + " / key " ; TestUtil . extractKey ( ctx , keyAsset , keyPath ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; importer . openDatabase ( is , password , TestUtil . getKeyFileInputStream ( ctx , keyPath ) ) ; is . close ( ) ; }
public void testXMLKeyFile ( ) throws Exception { testKeyfile ( " kdb_with_xml_keyfile . kdb " , " keyfile . key " , " 12345 " ) ; }
public void testBinary64KeyFile ( ) throws Exception { testKeyfile ( " binary - key . kdb " , " binary . key " , " 12345 " ) ; }
public void testSavingKDBXV3 ( ) throws IOException , InvalidDBException , PwDbOutputException { testSaving ( " test . kdbx " , " 12345 " , " test - out . kdbx " ) ; }
public void testSavingKDBXV4 ( ) throws IOException , InvalidDBException , PwDbOutputException { testSaving ( " test - kdbxv4 . kdbx " , " 1 " , " test - kdbxv4 - out . kdbx " ) ; }
public static Database GetDb1 ( Context ctx ) throws Exception { return GetDb1 ( ctx , false ) ; }
public static Database GetDb1 ( Context ctx , boolean forceReload ) throws Exception { if ( mDb1 = = null | | forceReload ) { mDb1 = GetDb ( ctx , TEST1_KDB , TEST1_PASSWORD , TEST1_KEYFILE , " / sdcard / test1 . kdb " ) ; } return mDb1 ; }
public static PwDatabaseV3Debug GetTest1 ( Context ctx ) throws Exception { if ( mDb1 = = null ) { GetDb1 ( ctx ) ; } return ( PwDatabaseV3Debug ) mDb1 . pm ; }
public void testBackup ( ) { PwDatabaseV4 db = new PwDatabaseV4 ( ) ; db . historyMaxItems = 2 ; PwEntryV4 entry = new PwEntryV4 ( ) ; entry . setTitle ( " Title1 " , db ) ; entry . setUsername ( " User1 " , db ) ; entry . createBackup ( db ) ; entry . setTitle ( " Title2 " , db ) ; entry . setUsername ( " User2 " , db ) ; entry . createBackup ( db ) ; entry . setTitle ( " Title3 " , db ) ; entry . setUsername ( " User3 " , db ) ; entry . createBackup ( db ) ; PwEntryV4 backup = entry . history . get ( 0 ) ; assertEquals ( " Title2 " , backup . getTitle ( ) ) ; assertEquals ( " User2 " , backup . getUsername ( ) ) ; }
public void setUp ( ) throws Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " test . kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; db = importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; spr = SprEngine . getInstance ( db ) ; }
private UUID decodeUUID ( String encoded ) { if ( encoded = = null | | encoded . length ( ) = = 0 ) { return PwDatabaseV4 . UUID_ZERO ; } byte [ ] buf = Base64 . decode ( encoded , Base64 . NO_WRAP ) ; return Types . bytestoUUID ( buf ) ; }
public void testEncrypt ( ) throws InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , IllegalBlockSizeException , BadPaddingException , InvalidAlgorithmParameterException { testFinal ( 15 ) ; testFinal ( 16 ) ; testFinal ( 17 ) ; int size = mRand . nextInt ( 494 ) + 18 ; testFinal ( size ) ; }
private void testFinal ( int dataSize ) throws NoSuchAlgorithmException , NoSuchPaddingException , IllegalBlockSizeException , BadPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { byte [ ] input = new byte [ dataSize ] ; mRand . nextBytes ( input ) ; byte [ ] keyArray = new byte [ 32 ] ; mRand . nextBytes ( keyArray ) ; SecretKeySpec key = new SecretKeySpec ( keyArray , " AES " ) ; byte [ ] ivArray = new byte [ 16 ] ; mRand . nextBytes ( ivArray ) ; IvParameterSpec iv = new IvParameterSpec ( ivArray ) ; Cipher android = CipherFactory . getInstance ( " AES / CBC / PKCS5Padding " , true ) ; android . init ( Cipher . ENCRYPT_MODE , key , iv ) ; byte [ ] outAndroid = android . doFinal ( input , 0 , dataSize ) ; Cipher nat = CipherFactory . getInstance ( " AES / CBC / PKCS5Padding " ) ; nat . init ( Cipher . ENCRYPT_MODE , key , iv ) ; byte [ ] outNative = nat . doFinal ( input , 0 , dataSize ) ; assertArrayEquals ( " Arrays differ on size : " + dataSize , outAndroid , outNative ) ; }
public void setUp ( ) throws Exception { mRand = new Random ( ) ; }
public void testNativeAndroid ( ) throws IOException { testNativeFinalKey ( 5 ) ; testNativeFinalKey ( 6 ) ; }
public void testCipherFactory ( ) throws InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException { byte [ ] key = new byte [ 32 ] ; byte [ ] iv = new byte [ 16 ] ; byte [ ] plaintext = new byte [ 1024 ] ; rand . nextBytes ( key ) ; rand . nextBytes ( iv ) ; rand . nextBytes ( plaintext ) ; CipherEngine aes = CipherFactory . getInstance ( AesEngine . CIPHER_UUID ) ; Cipher encrypt = aes . getCipher ( Cipher . ENCRYPT_MODE , key , iv ) ; Cipher decrypt = aes . getCipher ( Cipher . DECRYPT_MODE , key , iv ) ; byte [ ] secrettext = encrypt . doFinal ( plaintext ) ; byte [ ] decrypttext = decrypt . doFinal ( secrettext ) ; assertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; }
public void testCipherStreams ( ) throws InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException , IOException { final int MESSAGE_LENGTH = 1024 ; byte [ ] key = new byte [ 32 ] ; byte [ ] iv = new byte [ 16 ] ; byte [ ] plaintext = new byte [ MESSAGE_LENGTH ] ; rand . nextBytes ( key ) ; rand . nextBytes ( iv ) ; rand . nextBytes ( plaintext ) ; CipherEngine aes = CipherFactory . getInstance ( AesEngine . CIPHER_UUID ) ; Cipher encrypt = aes . getCipher ( Cipher . ENCRYPT_MODE , key , iv ) ; Cipher decrypt = aes . getCipher ( Cipher . DECRYPT_MODE , key , iv ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; CipherOutputStream cos = new CipherOutputStream ( bos , encrypt ) ; cos . write ( plaintext ) ; cos . close ( ) ; byte [ ] secrettext = bos . toByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( secrettext ) ; BetterCipherInputStream cis = new BetterCipherInputStream ( bis , decrypt ) ; LEDataInputStream lis = new LEDataInputStream ( cis ) ; byte [ ] decrypttext = lis . readBytes ( MESSAGE_LENGTH ) ; assertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; }
public void testBlockAligned ( ) throws IOException { testSize ( 1024 , 1024 ) ; }
public void testOffset ( ) throws IOException { testSize ( 1500 , 1024 ) ; }
public void setUp ( ) throws Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; mPM = TestData . GetTest1 ( ctx ) ; }
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertTrue ( " Version incompatible " , PwDbHeaderV3 . compatibleHeaders ( expected . version , actual . version ) ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . masterSeed , actual . masterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . transformSeed , actual . transformSeed ) ; }
public void testIndexOfIgnoreCase1 ( ) { assertEquals ( 1 , StrUtil . indexOfIgnoreCase ( text , search , Locale . ENGLISH ) ) ; }
public void testIndexOfIgnoreCase2 ( ) { assertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( text , search , Locale . ENGLISH ) , 2 ) ; }
public void testIndexOfIgnoreCase3 ( ) { assertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( text , badSearch , Locale . ENGLISH ) ) ; }
public void testReplaceAllIgnoresCase1 ( ) { assertEquals ( repResult , StrUtil . replaceAllIgnoresCase ( repText , repSearch , repNew , Locale . ENGLISH ) ) ; }
public void testReplaceAllIgnoresCase2 ( ) { assertEquals ( repText , StrUtil . replaceAllIgnoresCase ( repText , repSearchBad , repNew , Locale . ENGLISH ) ) ; }
public void setUp ( ) throws Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; mDb = TestData . GetDb1 ( ctx , true ) ; }
public Object get ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { return entry . getValue ( ) ; } entry = entry . next ; } return null ; }
public boolean isEmpty ( ) { return ( size = = 0 ) ; }
public boolean containsKey ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; }
public Object put ( Object key , Object value ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; int index = hashIndex ( hashCode , data . length ) ; HashEntry entry = data [ index ] ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { Object oldValue = entry . getValue ( ) ; updateEntry ( entry , value ) ; return oldValue ; } entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; return null ; }
public Object remove ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; int index = hashIndex ( hashCode , data . length ) ; HashEntry entry = data [ index ] ; HashEntry previous = null ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { Object oldValue = entry . getValue ( ) ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ; } return null ; }
protected Object convertKey ( Object key ) { return ( key = = null ? NULL : key ) ; }
protected boolean isEqualKey ( Object key1 , Object key2 ) { return ( key1 = = key2 | | key1 . equals ( key2 ) ) ; }
protected boolean isEqualValue ( Object value1 , Object value2 ) { return ( value1 = = value2 | | value1 . equals ( value2 ) ) ; }
protected int hashIndex ( int hashCode , int dataSize ) { return hashCode & ( dataSize - 1 ) ; }
protected void updateEntry ( HashEntry entry , Object newValue ) { entry . setValue ( newValue ) ; }
protected void reuseEntry ( HashEntry entry , int hashIndex , int hashCode , Object key , Object value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; entry . key = key ; entry . value = value ; }
protected void addMapping ( int hashIndex , int hashCode , Object key , Object value ) { modCount + + ; HashEntry entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size + + ; checkCapacity ( ) ; }
protected HashEntry createEntry ( HashEntry next , int hashCode , Object key , Object value ) { return new HashEntry ( next , hashCode , key , value ) ; }
protected void addEntry ( HashEntry entry , int hashIndex ) { data [ hashIndex ] = entry ; }
protected void removeMapping ( HashEntry entry , int hashIndex , HashEntry previous ) { modCount + + ; removeEntry ( entry , hashIndex , previous ) ; size - - ; destroyEntry ( entry ) ; }
protected void destroyEntry ( HashEntry entry ) { entry . next = null ; entry . key = null ; entry . value = null ; }
protected int calculateThreshold ( int newCapacity , float factor ) { return ( int ) ( newCapacity * factor ) ; }
protected HashEntry entryNext ( HashEntry entry ) { return entry . next ; }
protected int entryHashCode ( HashEntry entry ) { return entry . hashCode ; }
protected Object entryKey ( HashEntry entry ) { return entry . key ; }
protected Object entryValue ( HashEntry entry ) { return entry . value ; }
public MapIterator mapIterator ( ) { if ( size = = 0 ) { return EmptyMapIterator . INSTANCE ; } return new HashMapIterator ( this ) ; }
public Object next ( ) { return super . nextEntry ( ) . getKey ( ) ; }
public Set entrySet ( ) { if ( entrySet = = null ) { entrySet = new EntrySet ( this ) ; } return entrySet ; }
protected Iterator createEntrySetIterator ( ) { if ( size ( ) = = 0 ) { return EmptyIterator . INSTANCE ; } return new EntrySetIterator ( this ) ; }
public int size ( ) { return parent . size ( ) ; }
public void clear ( ) { parent . clear ( ) ; }
public boolean contains ( Object entry ) { if ( entry instanceof Map . Entry ) { Map . Entry e = ( Map . Entry ) entry ; Entry match = parent . getEntry ( e . getKey ( ) ) ; return ( match ! = null & & match . equals ( e ) ) ; } return false ; }
public boolean remove ( Object obj ) { if ( obj instanceof Map . Entry = = false ) { return false ; } if ( contains ( obj ) = = false ) { return false ; } Map . Entry entry = ( Map . Entry ) obj ; Object key = entry . getKey ( ) ; parent . remove ( key ) ; return true ; }
public Iterator iterator ( ) { return parent . createEntrySetIterator ( ) ; }
public Object next ( ) { return super . nextEntry ( ) ; }
public Set keySet ( ) { if ( keySet = = null ) { keySet = new KeySet ( this ) ; } return keySet ; }
protected Iterator createKeySetIterator ( ) { if ( size ( ) = = 0 ) { return EmptyIterator . INSTANCE ; } return new KeySetIterator ( this ) ; }
public boolean contains ( Object key ) { return parent . containsKey ( key ) ; }
public boolean remove ( Object key ) { boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; }
public Iterator iterator ( ) { return parent . createKeySetIterator ( ) ; }
public Collection values ( ) { if ( values = = null ) { values = new Values ( this ) ; } return values ; }
protected Iterator createValuesIterator ( ) { if ( size ( ) = = 0 ) { return EmptyIterator . INSTANCE ; } return new ValuesIterator ( this ) ; }
public boolean contains ( Object value ) { return parent . containsValue ( value ) ; }
public Iterator iterator ( ) { return parent . createValuesIterator ( ) ; }
public Object next ( ) { return super . nextEntry ( ) . getValue ( ) ; }
public String toString ( ) { return new StringBuffer ( ) . append ( getKey ( ) ) . append ( ' = ' ) . append ( getValue ( ) ) . toString ( ) ; }
public boolean hasNext ( ) { return ( next ! = null ) ; }
protected HashEntry currentEntry ( ) { return last ; }
public void remove ( ) { if ( last = = null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount ! = expectedModCount ) { throw new ConcurrentModificationException ( ) ; } parent . remove ( last . getKey ( ) ) ; last = null ; expectedModCount = parent . modCount ; }
public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj instanceof Map = = false ) { return false ; } Map map = ( Map ) obj ; if ( map . size ( ) ! = size ( ) ) { return false ; } MapIterator it = mapIterator ( ) ; try { while ( it . hasNext ( ) ) { Object key = it . next ( ) ; Object value = it . getValue ( ) ; if ( value = = null ) { if ( map . get ( key ) ! = null | | map . containsKey ( key ) = = false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) = = false ) { return false ; } } } } catch ( ClassCastException ignored ) { return false ; } catch ( NullPointerException ignored ) { return false ; } return true ; }
public int hashCode ( ) { int total = 0 ; Iterator it = createEntrySetIterator ( ) ; while ( it . hasNext ( ) ) { total + = it . next ( ) . hashCode ( ) ; } return total ; }
protected void init ( ) { queue = new ReferenceQueue ( ) ; }
public int size ( ) { purgeBeforeRead ( ) ; return super . size ( ) ; }
public boolean isEmpty ( ) { purgeBeforeRead ( ) ; return super . isEmpty ( ) ; }
public boolean containsKey ( Object key ) { purgeBeforeRead ( ) ; Entry entry = getEntry ( key ) ; if ( entry = = null ) { return false ; } return ( entry . getValue ( ) ! = null ) ; }
public boolean containsValue ( Object value ) { purgeBeforeRead ( ) ; if ( value = = null ) { return false ; } return super . containsValue ( value ) ; }
public Object get ( Object key ) { purgeBeforeRead ( ) ; Entry entry = getEntry ( key ) ; if ( entry = = null ) { return null ; } return entry . getValue ( ) ; }
public Object put ( Object key , Object value ) { if ( key = = null ) { throw new NullPointerException ( " null keys not allowed " ) ; } if ( value = = null ) { throw new NullPointerException ( " null values not allowed " ) ; } purgeBeforeWrite ( ) ; return super . put ( key , value ) ; }
public Object remove ( Object key ) { if ( key = = null ) { return null ; } purgeBeforeWrite ( ) ; return super . remove ( key ) ; }
public void clear ( ) { super . clear ( ) ; while ( queue . poll ( ) ! = null ) { } }
public MapIterator mapIterator ( ) { return new ReferenceMapIterator ( this ) ; }
public Set entrySet ( ) { if ( entrySet = = null ) { entrySet = new ReferenceEntrySet ( this ) ; } return entrySet ; }
public Set keySet ( ) { if ( keySet = = null ) { keySet = new ReferenceKeySet ( this ) ; } return keySet ; }
public Collection values ( ) { if ( values = = null ) { values = new ReferenceValues ( this ) ; } return values ; }
protected void purgeBeforeRead ( ) { purge ( ) ; }
protected void purgeBeforeWrite ( ) { purge ( ) ; }
protected HashEntry createEntry ( HashEntry next , int hashCode , Object key , Object value ) { return new ReferenceEntry ( this , next , hashCode , key , value ) ; }
protected Iterator createEntrySetIterator ( ) { return new ReferenceEntrySetIterator ( this ) ; }
protected Iterator createKeySetIterator ( ) { return new ReferenceKeySetIterator ( this ) ; }
protected Iterator createValuesIterator ( ) { return new ReferenceValuesIterator ( this ) ; }
public Object [ ] toArray ( ) { return toArray ( new Object [ 0 ] ) ; }
public Object [ ] toArray ( Object [ ] arr ) { ArrayList list = new ArrayList ( ) ; Iterator iterator = iterator ( ) ; while ( iterator . hasNext ( ) ) { Entry e = ( Entry ) iterator . next ( ) ; list . add ( new DefaultMapEntry ( e . getKey ( ) , e . getValue ( ) ) ) ; } return list . toArray ( arr ) ; }
public Object [ ] toArray ( Object [ ] arr ) { List list = new ArrayList ( parent . size ( ) ) ; for ( Iterator it = iterator ( ) ; it . hasNext ( ) ; ) { list . add ( it . next ( ) ) ; } return list . toArray ( arr ) ; }
public int hashCode ( ) { return parent . hashEntry ( getKey ( ) , getValue ( ) ) ; }
protected ReferenceEntry next ( ) { return ( ReferenceEntry ) next ; }
private boolean nextNull ( ) { return ( nextKey = = null ) | | ( nextValue = = null ) ; }
protected ReferenceEntry nextEntry ( ) { checkMod ( ) ; if ( nextNull ( ) & & ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } previous = entry ; entry = entry . next ( ) ; currentKey = nextKey ; currentValue = nextValue ; nextKey = null ; nextValue = null ; return previous ; }
protected ReferenceEntry currentEntry ( ) { checkMod ( ) ; return previous ; }
public Object next ( ) { return nextEntry ( ) ; }
public void remove ( ) { checkMod ( ) ; if ( previous = = null ) { throw new IllegalStateException ( ) ; } parent . remove ( currentKey ) ; previous = null ; currentKey = null ; currentValue = null ; expectedModCount = parent . modCount ; }
public Object next ( ) { return nextEntry ( ) . getKey ( ) ; }
public Object next ( ) { return nextEntry ( ) . getValue ( ) ; }
public int hashCode ( ) { return hash ; }
private void writeObject ( ObjectOutputStream out ) throws IOException { out . defaultWriteObject ( ) ; doWriteObject ( out ) ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; doReadObject ( in ) ; }
public boolean hasNext ( ) { return false ; }
public Object next ( ) { throw new NoSuchElementException ( " Iterator contains no elements " ) ; }
public boolean hasPrevious ( ) { return false ; }
public Object previous ( ) { throw new NoSuchElementException ( " Iterator contains no elements " ) ; }
public int previousIndex ( ) { return - 1 ; }
public void add ( Object obj ) { throw new UnsupportedOperationException ( " add ( ) not supported for empty Iterator " ) ; }
public void set ( Object obj ) { throw new IllegalStateException ( " Iterator contains no elements " ) ; }
public void remove ( ) { throw new IllegalStateException ( " Iterator contains no elements " ) ; }
protected PwGroupIdV3 retrieveGroupId ( Intent i ) { int id = i . getIntExtra ( KEY_ENTRY , - 1 ) ; if ( id = = - 1 ) { return null ; } return new PwGroupIdV3 ( id ) ; }
protected void setupButtons ( ) { super . setupButtons ( ) ; addEntryEnabled = ! isRoot & & ! readOnly ; }
public static void Launch ( Activity act ) { Intent i = new Intent ( act , GroupEditActivity . class ) ; act . startActivityForResult ( i , 0 ) ; }
public void onClick ( View v ) { IconPickerActivity . Launch ( GroupEditActivity . this ) ; }
public void onClick ( View v ) { final Intent intent = new Intent ( ) ; setResult ( Activity . RESULT_CANCELED , intent ) ; finish ( ) ; }
protected PwEntry populateNewEntry ( PwEntry entry ) { PwEntry newEntry = super . populateNewEntry ( entry ) ; if ( mSelectedIconID = = - 1 ) { if ( mIsNew ) { newEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( 0 ) ; } else { newEntry . icon = mEntry . icon ; } } else { newEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( mSelectedIconID ) ; } return newEntry ; }
protected static void putParentId ( Intent i , String parentKey , PwGroupV3 parent ) { i . putExtra ( parentKey , parent . groupId ) ; }
protected void onResume ( ) { super . onResume ( ) ; checkShutdown ( ) ; }
public void run ( ) { mPD . setMessage ( mCtx . getString ( mResId ) ) ; }
public boolean Loaded ( ) { return loaded ; }
public void LoadData ( Context ctx , InputStream is , String password , InputStream keyInputStream ) throws IOException , InvalidDBException { LoadData ( ctx , is , password , keyInputStream , new UpdateStatus ( ) , ! Importer . DEBUG ) ; }
public void LoadData ( Context ctx , Uri uri , String password , Uri keyfile ) throws IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; }
public void LoadData ( Context ctx , Uri uri , String password , Uri keyfile , UpdateStatus status ) throws IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , status , ! Importer . DEBUG ) ; }
private void passUrisAsInputStreams ( Context ctx , Uri uri , String password , Uri keyfile , UpdateStatus status , boolean debug , long roundsFix ) throws IOException , FileNotFoundException , InvalidDBException { InputStream is , kfIs ; try { is = UriUtil . getUriInputStream ( ctx , uri ) ; } catch ( Exception e ) { Log . e ( " KPD " , " Database : : LoadData " , e ) ; throw ContentFileNotFoundException . getInstance ( uri ) ; } try { kfIs = UriUtil . getUriInputStream ( ctx , keyfile ) ; } catch ( Exception e ) { Log . e ( " KPD " , " Database : : LoadData " , e ) ; throw ContentFileNotFoundException . getInstance ( keyfile ) ; } LoadData ( ctx , is , password , kfIs , status , debug , roundsFix ) ; }
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , boolean debug ) throws IOException , InvalidDBException { LoadData ( ctx , is , password , kfIs , new UpdateStatus ( ) , debug ) ; }
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { LoadData ( ctx , is , password , kfIs , status , debug , 0 ) ; }
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug , long roundsFix ) throws IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark . " ) ; } bis . mark ( 10 ) ; Importer imp = ImporterFactory . createImporter ( bis , ctx . getFilesDir ( ) , debug ) ; bis . reset ( ) ; pm = imp . openDatabase ( bis , password , kfIs , status , roundsFix ) ; if ( pm ! = null ) { PwGroup root = pm . rootGroup ; pm . populateGlobals ( root ) ; LoadData ( ctx , pm , password , kfIs , status ) ; } loaded = true ; }
public void LoadData ( Context ctx , PwDatabase pm , String password , InputStream keyInputStream , UpdateStatus status ) { if ( pm ! = null ) { passwordEncodingError = ! pm . validatePasswordEncoding ( password ) ; } searchHelper = new SearchDbHelper ( ctx ) ; loaded = true ; }
public PwGroup Search ( String str ) { if ( searchHelper = = null ) { return null ; } return searchHelper . search ( this , str ) ; }
public void SaveData ( Context ctx ) throws IOException , FileUriException , PwDbOutputException { SaveData ( ctx , mUri ) ; }
public void clear ( Context context ) { dirty . clear ( ) ; drawFactory . clear ( ) ; if ( pm ! = null ) pm . clearCache ( ) ; try { FileUtils . cleanDirectory ( context . getFilesDir ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , " Unable to clear the directory cache . " , e ) ; } pm = null ; mUri = null ; loaded = false ; passwordEncodingError = false ; }
public void run ( ) { scroll . fullScroll ( ScrollView . FOCUS_DOWN ) ; }
protected void onResume ( ) { super . onResume ( ) ; TimeoutHelper . checkShutdown ( this ) ; }
protected PwGroupId retrieveGroupId ( Intent i ) { String uuid = i . getStringExtra ( KEY_ENTRY ) ; if ( uuid = = null | | uuid . length ( ) = = 0 ) { return null ; } return new PwGroupIdV4 ( UUID . fromString ( uuid ) ) ; }
protected void setupButtons ( ) { super . setupButtons ( ) ; addEntryEnabled = ! readOnly ; }
protected void onResume ( ) { super . onResume ( ) ; refreshIfDirty ( ) ; }
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { onListItemClick ( ( ListView ) parent , v , position , id ) ; }
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . group , menu ) ; return true ; }
public boolean onPrepareOptionsMenu ( Menu menu ) { if ( ! super . onPrepareOptionsMenu ( menu ) ) { return false ; } setSortMenuText ( menu ) ; return true ; }
protected void onPause ( ) { super . onPause ( ) ; TimeoutHelper . pause ( this ) ; }
protected void onResume ( ) { super . onResume ( ) ; TimeoutHelper . resume ( this ) ; }
public static void Launch ( Activity act , PwEntry pw , int pos ) { Intent i ; if ( pw instanceof PwEntryV4 ) { i = new Intent ( act , EntryActivityV4 . class ) ; } else { i = new Intent ( act , EntryActivity . class ) ; } i . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; i . putExtra ( KEY_REFRESH_POS , pos ) ; act . startActivityForResult ( i , 0 ) ; }
public void onClick ( View v ) { EntryEditActivity . Launch ( EntryActivity . this , mEntry ) ; }
protected void onDestroy ( ) { if ( mIntentReceiver ! = null ) { unregisterReceiver ( mIntentReceiver ) ; } if ( mNM ! = null ) { try { mNM . cancelAll ( ) ; } catch ( SecurityException e ) { } } super . onDestroy ( ) ; }
private void populateText ( int viewId , int resId ) { TextView tv = ( TextView ) findViewById ( viewId ) ; tv . setText ( resId ) ; }
private void populateText ( int viewId , String text ) { TextView tv = ( TextView ) findViewById ( viewId ) ; tv . setText ( text ) ; }
private void timeoutCopyToClipboard ( String label , String text ) { timeoutCopyToClipboard ( label , text , false ) ; }
public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; }
public static void Launch ( Activity act ) { Intent i = new Intent ( act , IconPickerActivity . class ) ; act . startActivityForResult ( i , 0 ) ; }
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { final Intent intent = new Intent ( ) ; intent . putExtra ( KEY_ICON_ID , position ) ; setResult ( EntryEditActivity . RESULT_OK_ICON_PICKER , intent ) ; finish ( ) ; }
public void run ( ) { Toast . makeText ( mCtx , mText , Toast . LENGTH_LONG ) . show ( ) ; }
public void cancel ( ) { super . cancel ( ) ; mCanceled = true ; }
public void onClick ( DialogInterface dialog , int which ) { pt . run ( ) ; }
public void run ( ) { if ( mSuccess ) { if ( mFinish ! = null ) { mFinish . setFilename ( mKeyfile ) ; } dismiss ( ) ; } else { displayMessage ( ( AppCompatActivity ) getOwnerActivity ( ) ) ; } super . run ( ) ; }
public void run ( ) { mPd . show ( ) ; Thread t = new Thread ( mTask ) ; t . start ( ) ; }
public void run ( ) { super . run ( ) ; mHandler . post ( new CloseProcessDialog ( ) ) ; }
public static void Launch ( Activity act ) { Launch ( act , null ) ; }
public static void Launch ( Activity act , PwGroup group ) { Intent i ; PwDatabase db = App . getDB ( ) . pm ; if ( db instanceof PwDatabaseV3 ) { i = new Intent ( act , GroupActivityV3 . class ) ; if ( group ! = null ) { PwGroupV3 g = ( PwGroupV3 ) group ; i . putExtra ( KEY_ENTRY , g . groupId ) ; } } else if ( db instanceof PwDatabaseV4 ) { i = new Intent ( act , GroupActivityV4 . class ) ; if ( group ! = null ) { PwGroupV4 g = ( PwGroupV4 ) group ; i . putExtra ( KEY_ENTRY , g . uuid . toString ( ) ) ; } } else { Log . d ( TAG , " Tried to launch with null db " ) ; return ; } act . startActivityForResult ( i , 0 ) ; }
protected void setupButtons ( ) { addGroupEnabled = ! readOnly ; }
public void onClick ( View v ) { GroupEditActivity . Launch ( GroupActivity . this ) ; }
public void onClick ( View v ) { EntryEditActivity . Launch ( GroupActivity . this , mGroup ) ; }
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { AdapterContextMenuInfo acmi = ( AdapterContextMenuInfo ) menuInfo ; ClickView cv = ( ClickView ) acmi . targetView ; cv . onCreateMenu ( menu , menuInfo ) ; }
public boolean onContextItemSelected ( MenuItem item ) { AdapterContextMenuInfo acmi = ( AdapterContextMenuInfo ) item . getMenuInfo ( ) ; ClickView cv = ( ClickView ) acmi . targetView ; return cv . onContextItemSelected ( item ) ; }
public static void Launch ( Activity act , String fileName ) throws FileNotFoundException { Launch ( act , fileName , " " ) ; }
protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . password_activity ) ; Toolbar toolbar = ( Toolbar ) findViewById ( R . id . toolbar ) ; setSupportActionBar ( toolbar ) ; }
public void notifyDataSetChanged ( ) { super . notifyDataSetChanged ( ) ; filterAndSort ( ) ; }
public void notifyDataSetInvalidated ( ) { super . notifyDataSetInvalidated ( ) ; filterAndSort ( ) ; }
private View createGroupView ( int position , View convertView ) { PwGroup group = groupsForViewing . get ( position ) ; PwGroupView gv ; if ( convertView = = null | | ! ( convertView instanceof PwGroupView ) ) { gv = PwGroupView . getInstance ( mAct , group ) ; } else { gv = ( PwGroupView ) convertView ; gv . convertView ( group ) ; } return gv ; }
private PwEntryView createEntryView ( int position , View convertView ) { PwEntry entry = entriesForViewing . get ( position ) ; PwEntryView ev ; if ( convertView = = null | | ! ( convertView instanceof PwEntryView ) ) { ev = PwEntryView . getInstance ( mAct , entry , position ) ; } else { ev = ( PwEntryView ) convertView ; ev . convertView ( entry , position ) ; } return ev ; }
public static void Launch ( Activity act , PwEntry pw ) { Intent i ; if ( pw instanceof PwEntryV3 ) { i = new Intent ( act , EntryEditActivityV3 . class ) ; } else if ( pw instanceof PwEntryV4 ) { i = new Intent ( act , EntryEditActivityV4 . class ) ; } else { throw new RuntimeException ( " Not yet implemented . " ) ; } i . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; act . startActivityForResult ( i , 0 ) ; }
public static void Launch ( Activity act , PwGroup pw ) { Intent i ; if ( pw instanceof PwGroupV3 ) { i = new Intent ( act , EntryEditActivityV3 . class ) ; EntryEditActivityV3 . putParentId ( i , KEY_PARENT , ( PwGroupV3 ) pw ) ; } else if ( pw instanceof PwGroupV4 ) { i = new Intent ( act , EntryEditActivityV4 . class ) ; EntryEditActivityV4 . putParentId ( i , KEY_PARENT , ( PwGroupV4 ) pw ) ; } else { throw new RuntimeException ( " Not yet implemented . " ) ; } act . startActivityForResult ( i , 0 ) ; }
public void onClick ( View v ) { IconPickerActivity . Launch ( EntryEditActivity . this ) ; }
public void onClick ( View v ) { GeneratePasswordActivity . Launch ( EntryEditActivity . this ) ; }
protected boolean validateBeforeSaving ( ) { String title = Util . getEditText ( this , R . id . entry_title ) ; if ( title . length ( ) = = 0 ) { Toast . makeText ( this , R . string . error_title_required , Toast . LENGTH_LONG ) . show ( ) ; return false ; } String pass = Util . getEditText ( this , R . id . entry_password ) ; String conf = Util . getEditText ( this , R . id . entry_confpassword ) ; if ( ! pass . equals ( conf ) ) { Toast . makeText ( this , R . string . error_pass_match , Toast . LENGTH_LONG ) . show ( ) ; return false ; } return true ; }
protected PwEntry populateNewEntry ( ) { return populateNewEntry ( null ) ; }
protected PwEntry populateNewEntry ( PwEntry entry ) { PwEntry newEntry ; if ( entry = = null ) { newEntry = mEntry . clone ( true ) ; } else { newEntry = entry ; } Date now = Calendar . getInstance ( ) . getTime ( ) ; newEntry . setLastAccessTime ( now ) ; newEntry . setLastModificationTime ( now ) ; PwDatabase db = App . getDB ( ) . pm ; newEntry . setTitle ( Util . getEditText ( this , R . id . entry_title ) , db ) ; newEntry . setUrl ( Util . getEditText ( this , R . id . entry_url ) , db ) ; newEntry . setUsername ( Util . getEditText ( this , R . id . entry_user_name ) , db ) ; newEntry . setNotes ( Util . getEditText ( this , R . id . entry_comment ) , db ) ; newEntry . setPassword ( Util . getEditText ( this , R . id . entry_password ) , db ) ; return newEntry ; }
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . entry_edit , menu ) ; MenuItem togglePassword = menu . findItem ( R . id . menu_toggle_pass ) ; if ( mShowPassword ) { togglePassword . setTitle ( R . string . menu_hide_password ) ; } else { togglePassword . setTitle ( R . string . menu_showpass ) ; } return true ; }
protected void fillData ( ) { ImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( currIconButton , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; }
public static void Launch ( Activity act ) { Intent i = new Intent ( act , GeneratePasswordActivity . class ) ; act . startActivityForResult ( i , 0 ) ; }
public void onClick ( View v ) { Button button = ( Button ) v ; EditText editText = ( EditText ) findViewById ( R . id . length ) ; editText . setText ( button . getText ( ) ) ; }
public void onClick ( View v ) { fillPassword ( ) ; }
public void onClick ( View v ) { EditText password = ( EditText ) findViewById ( R . id . password ) ; Intent intent = new Intent ( ) ; intent . putExtra ( " com . keepassdroid . password . generated_password " , password . getText ( ) . toString ( ) ) ; setResult ( EntryEditActivity . RESULT_OK_PASSWORD_GENERATOR , intent ) ; finish ( ) ; }
public void onClick ( View v ) { setResult ( RESULT_CANCELED ) ; finish ( ) ; }
private void fillPassword ( ) { EditText txtPassword = ( EditText ) findViewById ( R . id . password ) ; txtPassword . setText ( generatePassword ( ) ) ; }
public String generatePassword ( ) { String password = " " ; try { int length = Integer . valueOf ( ( ( EditText ) findViewById ( R . id . length ) ) . getText ( ) . toString ( ) ) ; ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) ; PasswordGenerator generator = new PasswordGenerator ( this ) ; password = generator . generatePassword ( length , ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_lowercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_digits ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_minus ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_underline ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_space ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_specials ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_brackets ) ) . isChecked ( ) ) ; } catch ( NumberFormatException e ) { Toast . makeText ( this , R . string . error_wrong_length , Toast . LENGTH_LONG ) . show ( ) ; } catch ( IllegalArgumentException e ) { Toast . makeText ( this , e . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; } return password ; }
public static void Launch ( Context ctx ) { Intent i = new Intent ( ctx , AppSettingsFragement . class ) ; ctx . startActivity ( i ) ; }
public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setRetainInstance ( true ) ; }
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Boolean value = ( Boolean ) newValue ; if ( ! value . booleanValue ( ) ) { App . getFileHistory ( ) . deleteAllKeys ( ) ; } return true ; }
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Boolean value = ( Boolean ) newValue ; if ( value = = null ) { value = true ; } if ( ! value ) { App . getFileHistory ( ) . deleteAll ( ) ; } return true ; }
public void onStop ( ) { backupManager . dataChanged ( ) ; super . onStop ( ) ; }
public static RoundsPreferenceFragment newInstance ( String key ) { final RoundsPreferenceFragment fragment = new RoundsPreferenceFragment ( ) ; final Bundle b = new Bundle ( 1 ) ; b . putString ( ARG_KEY , key ) ; fragment . setArguments ( b ) ; return fragment ; }
public void run ( ) { if ( mSuccess ) { Preference preference = getPreference ( ) ; Preference . OnPreferenceChangeListener listner = preference . getOnPreferenceChangeListener ( ) ; if ( listner ! = null ) { listner . onPreferenceChange ( preference , null ) ; } } else { displayMessage ( mCtx , mFm ) ; mPM . setNumRounds ( mOldRounds ) ; } super . run ( ) ; }
public Dialog onCreateDialog ( Bundle savedInstanceState ) { return super . onCreateDialog ( savedInstanceState ) ; }
public static void Launch ( Context ctx ) { Intent i = new Intent ( ctx , DBSettingsFragement . class ) ; ctx . startActivity ( i ) ; }
public boolean onPreferenceChange ( Preference preference , Object newValue ) { setRounds ( App . getDB ( ) , preference ) ; return true ; }
protected boolean persistString ( String value ) { try { return persistLong ( Long . valueOf ( value ) ) ; } catch ( NumberFormatException e ) { Toast . makeText ( getContext ( ) , R . string . error_rounds_not_number , Toast . LENGTH_LONG ) . show ( ) ; } return false ; }
public static void Launch ( Context ctx ) { Intent i = new Intent ( ctx , AppSettingsActivity . class ) ; ctx . startActivity ( i ) ; }
public static void Launch ( Context ctx ) { Intent i = new Intent ( ctx , MainSettingsFragement . class ) ; ctx . startActivity ( i ) ; }
protected SimpleDateFormat initialValue ( ) { SimpleDateFormat dateFormat ; dateFormat = new SimpleDateFormat ( " yyyy - MM - dd ' T ' HH : mm : ss ' Z ' " ) ; dateFormat . setTimeZone ( TimeZone . getTimeZone ( " UTC " ) ) ; return dateFormat ; }
protected boolean searchID ( PwEntry entry ) { return false ; }
public ProtectedBinary get ( int key ) { return pool . get ( key ) ; }
public ProtectedBinary put ( int key , ProtectedBinary value ) { return pool . put ( key , value ) ; }
public Set < Entry < Integer , ProtectedBinary > > entrySet ( ) { return pool . entrySet ( ) ; }
public void clear ( ) { for ( Entry < Integer , ProtectedBinary > entry : pool . entrySet ( ) ) entry . getValue ( ) . clear ( ) ; pool . clear ( ) ; }
public Collection < ProtectedBinary > binaries ( ) { return pool . values ( ) ; }
public boolean operate ( PwEntryV4 entry ) { for ( PwEntryV4 histEntry : entry . history ) { poolAdd ( histEntry . binaries ) ; } poolAdd ( entry . binaries ) ; return true ; }
public void poolAdd ( ProtectedBinary pb ) { assert ( pb ! = null ) ; if ( poolFind ( pb ) ! = - 1 ) return ; pool . put ( pool . size ( ) , pb ) ; }
public int findUnusedKey ( ) { int unusedKey = pool . size ( ) ; while ( get ( unusedKey ) ! = null ) unusedKey + + ; return unusedKey ; }
public int poolFind ( ProtectedBinary pb ) { for ( Entry < Integer , ProtectedBinary > pair : pool . entrySet ( ) ) { if ( pair . getValue ( ) . equals ( pb ) ) return pair . getKey ( ) ; } return - 1 ; }
private void build ( PwGroupV4 rootGroup ) { EntryHandler eh = new AddBinaries ( ) ; rootGroup . preOrderTraverseTree ( null , eh ) ; }
public static CrsAlgorithm fromId ( int num ) { for ( CrsAlgorithm e : CrsAlgorithm . values ( ) ) { if ( e . id = = num ) { return e ; } } return null ; }
public boolean isMetaStreamIcon ( ) { return iconId = = 0 ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + iconId ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwIconStandard other = ( PwIconStandard ) obj ; if ( iconId ! = other . iconId ) return false ; return true ; }
public PwGroupIdV3 newGroupId ( ) { PwGroupIdV3 newId = new PwGroupIdV3 ( 0 ) ; Random random = new Random ( ) ; while ( true ) { newId = new PwGroupIdV3 ( random . nextInt ( ) ) ; if ( ! isGroupIdUsed ( newId ) ) break ; } return newId ; }
protected byte [ ] loadXmlKeyFile ( InputStream keyInputStream ) { return null ; }
public boolean appSettingsEnabled ( ) { return true ; }
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { super . removeEntryFrom ( remove , parent ) ; entries . remove ( remove ) ; }
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { super . removeGroupFrom ( remove , parent ) ; groups . remove ( remove ) ; }
public PwGroup createGroup ( ) { return new PwGroupV3 ( ) ; }
public boolean isBackup ( PwGroup group ) { PwGroupV3 g = ( PwGroupV3 ) group ; while ( g ! = null ) { if ( g . level = = 0 & & g . name . equalsIgnoreCase ( " Backup " ) ) { return true ; } g = g . parent ; } return false ; }
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { if ( ! super . isGroupSearchable ( group , omitBackup ) ) { return false ; } return ! ( omitBackup & & isBackup ( group ) ) ; }
private void initAndAddGroup ( String name , int iconId , PwGroup parent ) { PwGroup group = createGroup ( ) ; group . initNewGroup ( name , newGroupId ( ) ) ; group . icon = iconFactory . getIcon ( iconId ) ; addGroupTo ( group , parent ) ; }
public void initNew ( String name ) { algorithm = PwEncryptionAlgorithm . Rjindal ; numKeyEncRounds = DEFAULT_ENCRYPTION_ROUNDS ; if ( EmptyUtils . isNullOrEmpty ( name ) ) { name = " KeePass Password Manager " ; } constructTree ( null ) ; initAndAddGroup ( " Internet " , 1 , rootGroup ) ; initAndAddGroup ( " eMail " , 19 , rootGroup ) ; }
public boolean isMetaStreamIcon ( ) { return false ; }
public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; }
public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; }
public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; }
public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; }
public boolean isContainedIn ( PwGroup container ) { PwGroup cur = this ; while ( cur ! = null ) { if ( cur = = container ) { return true ; } cur = cur . getParent ( ) ; } return false ; }
public int compare ( String lhs , String rhs ) { return lhs . length ( ) - rhs . length ( ) ; }
public boolean GetProtection ( String field ) { if ( field . equalsIgnoreCase ( PwDefsV4 . TITLE_FIELD ) ) return protectTitle ; if ( field . equalsIgnoreCase ( PwDefsV4 . USERNAME_FIELD ) ) return protectUserName ; if ( field . equalsIgnoreCase ( PwDefsV4 . PASSWORD_FIELD ) ) return protectPassword ; if ( field . equalsIgnoreCase ( PwDefsV4 . URL_FIELD ) ) return protectUrl ; if ( field . equalsIgnoreCase ( PwDefsV4 . NOTES_FIELD ) ) return protectNotes ; return false ; }
public void makeFinalKey ( byte [ ] masterSeed , KdfParameters kdfP ) throws IOException { makeFinalKey ( masterSeed , kdfP , 0 ) ; }
public boolean appSettingsEnabled ( ) { return false ; }
public PwGroupIdV4 newGroupId ( ) { PwGroupIdV4 id = new PwGroupIdV4 ( UUID_ZERO ) ; while ( true ) { id = new PwGroupIdV4 ( UUID . randomUUID ( ) ) ; if ( ! isGroupIdUsed ( id ) ) break ; } return id ; }
public PwGroup createGroup ( ) { return new PwGroupV4 ( ) ; }
public boolean isBackup ( PwGroup group ) { if ( ! recycleBinEnabled ) { return false ; } return group . isContainedIn ( getRecycleBin ( ) ) ; }
public void populateGlobals ( PwGroup currentGroup ) { groups . put ( rootGroup . getId ( ) , rootGroup ) ; super . populateGlobals ( currentGroup ) ; }
public boolean canRecycle ( PwGroup group ) { if ( ! recycleBinEnabled ) { return false ; } PwGroup recycle = getRecycleBin ( ) ; return ( recycle = = null ) | | ( ! group . isContainedIn ( recycle ) ) ; }
public boolean canRecycle ( PwEntry entry ) { if ( ! recycleBinEnabled ) { return false ; } PwGroup parent = entry . getParent ( ) ; return ( parent ! = null ) & & canRecycle ( parent ) ; }
public void recycle ( PwEntry entry ) { ensureRecycleBin ( ) ; PwGroup parent = entry . getParent ( ) ; removeEntryFrom ( entry , parent ) ; parent . touch ( false , true ) ; PwGroup recycleBin = getRecycleBin ( ) ; addEntryTo ( entry , recycleBin ) ; entry . touch ( false , true ) ; entry . touchLocation ( ) ; }
public void undoRecycle ( PwEntry entry , PwGroup origParent ) { PwGroup recycleBin = getRecycleBin ( ) ; removeEntryFrom ( entry , recycleBin ) ; addEntryTo ( entry , origParent ) ; }
public void deleteEntry ( PwEntry entry ) { super . deleteEntry ( entry ) ; deletedObjects . add ( new PwDeletedObject ( entry . getUUID ( ) ) ) ; }
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { super . undoDeleteEntry ( entry , origParent ) ; deletedObjects . remove ( new PwDeletedObject ( entry . getUUID ( ) ) ) ; }
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { if ( ! super . isGroupSearchable ( group , omitBackup ) ) { return false ; } PwGroupV4 g = ( PwGroupV4 ) group ; return g . isSearchEnabled ( ) ; }
public boolean validatePasswordEncoding ( String key ) { return true ; }
public void initNew ( String name ) { rootGroup = new PwGroupV4 ( true , true , name , iconFactory . getIcon ( PwIconStandard . FOLDER ) ) ; groups . put ( rootGroup . getId ( ) , rootGroup ) ; }
private String dbNameFromPath ( String dbPath ) { String filename = URLUtil . guessFileName ( dbPath , null , null ) ; if ( EmptyUtils . isNullOrEmpty ( filename ) ) { return " KeePass Database " ; } int lastExtDot = filename . lastIndexOf ( " . " ) ; if ( lastExtDot = = - 1 ) { return filename ; } return filename . substring ( 0 , lastExtDot ) ; }
public static PwCompressionAlgorithm fromId ( int num ) { for ( PwCompressionAlgorithm e : PwCompressionAlgorithm . values ( ) ) { if ( e . id = = num ) { return e ; } } return null ; }
private static boolean isKDBExtension ( String filename ) { if ( filename = = null ) { return false ; } int extIdx = filename . lastIndexOf ( " . " ) ; if ( extIdx = = - 1 ) return false ; return filename . substring ( extIdx , filename . length ( ) ) . equalsIgnoreCase ( " . kdb " ) ; }
public void makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , int numRounds ) throws IOException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( " SHA - 256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA - 256 not implemented here . " ) ; } NullOutputStream nos = new NullOutputStream ( ) ; DigestOutputStream dos = new DigestOutputStream ( nos , md ) ; byte [ ] transformedMasterKey = transformMasterKey ( masterSeed2 , masterKey , numRounds ) ; dos . write ( masterSeed ) ; dos . write ( transformedMasterKey ) ; finalKey = md . digest ( ) ; }
protected static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . transformMasterKey ( pKeySeed , pKey , rounds ) ; }
public void setMasterKey ( String key , InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( key ! = null ) ; masterKey = getMasterKey ( key , keyInputStream ) ; }
protected byte [ ] getCompositeKey ( String key , InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyInputStream ! = null ) ; byte [ ] fileKey = getFileKey ( keyInputStream ) ; byte [ ] passwordKey = getPasswordKey ( key ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA - 256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA - 256 not supported " ) ; } md . update ( passwordKey ) ; return md . digest ( fileKey ) ; }
protected byte [ ] getFileKey ( InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( keyInputStream ! = null ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Util . copyStream ( keyInputStream , bos ) ; byte [ ] keyData = bos . toByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( keyData ) ; byte [ ] key = loadXmlKeyFile ( bis ) ; if ( key ! = null ) { return key ; } long fileSize = keyData . length ; if ( fileSize = = 0 ) { throw new KeyFileEmptyException ( ) ; } else if ( fileSize = = 32 ) { return keyData ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; try { return hexStringToByteArray ( new String ( keyData ) ) ; } catch ( IndexOutOfBoundsException e ) { } } MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA - 256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA - 256 not supported " ) ; } byte [ ] buffer = new byte [ 2048 ] ; int offset = 0 ; try { md . update ( keyData ) ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; } return md . digest ( ) ; }
public boolean validatePasswordEncoding ( String key ) { String encoding = getPasswordEncoding ( ) ; byte [ ] bKey ; try { bKey = key . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException e ) { return false ; } String reencoded ; try { reencoded = new String ( bKey , encoding ) ; } catch ( UnsupportedEncodingException e ) { return false ; } return key . equals ( reencoded ) ; }
public byte [ ] getPasswordKey ( String key ) throws IOException { assert ( key ! = null ) ; if ( key . length ( ) = = 0 ) throw new IllegalArgumentException ( " Key cannot be empty . " ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA - 256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA - 256 not supported " ) ; } byte [ ] bKey ; try { bKey = key . getBytes ( getPasswordEncoding ( ) ) ; } catch ( UnsupportedEncodingException e ) { assert false ; bKey = key . getBytes ( ) ; } md . update ( bKey , 0 , bKey . length ) ; return md . digest ( ) ; }
public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { if ( parent = = null ) { parent = rootGroup ; } parent . childGroups . add ( newGroup ) ; newGroup . setParent ( parent ) ; groups . put ( newGroup . getId ( ) , newGroup ) ; parent . touch ( true , true ) ; }
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { parent . childGroups . remove ( remove ) ; groups . remove ( remove . getId ( ) ) ; }
public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { if ( parent ! = null ) { parent . childEntries . add ( newEntry ) ; } newEntry . setParent ( parent ) ; entries . put ( newEntry . getUUID ( ) , newEntry ) ; }
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { if ( parent ! = null ) { parent . childEntries . remove ( remove ) ; } entries . remove ( remove . getUUID ( ) ) ; }
public boolean canRecycle ( PwGroup group ) { return false ; }
public boolean canRecycle ( PwEntry entry ) { return false ; }
public void recycle ( PwEntry entry ) { throw new RuntimeException ( " Call not valid for . kdb databases . " ) ; }
public void undoRecycle ( PwEntry entry , PwGroup origParent ) { throw new RuntimeException ( " Call not valid for . kdb databases . " ) ; }
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { addEntryTo ( entry , origParent ) ; }
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { return group ! = null ; }
public boolean equals ( Object o ) { if ( this = = o ) { return true ; } else if ( o = = null ) { return false ; } else if ( ! ( o instanceof PwDeletedObject ) ) { return false ; } PwDeletedObject rhs = ( PwDeletedObject ) o ; return uuid . equals ( rhs . uuid ) ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( uuid = = null ) ? 0 : uuid . hashCode ( ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwIconCustom other = ( PwIconCustom ) obj ; if ( uuid = = null ) { if ( other . uuid ! = null ) return false ; } else if ( ! uuid . equals ( other . uuid ) ) return false ; return true ; }
public HeaderAndHash loadFromFile ( InputStream is ) throws IOException , InvalidDBVersionException { MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA - 256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " No SHA - 256 implementation " ) ; } ByteArrayOutputStream headerBOS = new ByteArrayOutputStream ( ) ; CopyInputStream cis = new CopyInputStream ( is , headerBOS ) ; DigestInputStream dis = new DigestInputStream ( cis , md ) ; LEDataInputStream lis = new LEDataInputStream ( dis ) ; int sig1 = lis . readInt ( ) ; int sig2 = lis . readInt ( ) ; if ( ! matchesHeader ( sig1 , sig2 ) ) { throw new InvalidDBVersionException ( ) ; } version = lis . readUInt ( ) ; if ( ! validVersion ( version ) ) { throw new InvalidDBVersionException ( ) ; } boolean done = false ; while ( ! done ) { done = readHeaderField ( lis ) ; } byte [ ] hash = md . digest ( ) ; return new HeaderAndHash ( headerBOS . toByteArray ( ) , hash ) ; }
private void setCipher ( byte [ ] pbId ) throws IOException { if ( pbId = = null | | pbId . length ! = 16 ) { throw new IOException ( " Invalid cipher ID . " ) ; } db . dataCipher = Types . bytestoUUID ( pbId ) ; }
public void setRandomStreamID ( byte [ ] streamID ) throws IOException { if ( streamID = = null | | streamID . length ! = 4 ) { throw new IOException ( " Invalid stream id . " ) ; } int id = LEDataInputStream . readInt ( streamID , 0 ) ; if ( id < 0 | | id > = CrsAlgorithm . count ) { throw new IOException ( " Invalid stream id . " ) ; } innerRandomStream = CrsAlgorithm . fromId ( id ) ; }
public static boolean matchesHeader ( int sig1 , int sig2 ) { return ( sig1 = = PWM_DBSIG_1 ) & & ( ( sig2 = = DBSIG_PRE2 ) | | ( sig2 = = DBSIG_2 ) ) ; }
public static byte [ ] computeHeaderHmac ( byte [ ] header , byte [ ] key ) throws IOException { byte [ ] headerHmac ; byte [ ] blockKey = HmacBlockStream . GetHmacKey64 ( key , Types . ULONG_MAX_VALUE ) ; Mac hmac ; try { hmac = Mac . getInstance ( " HmacSHA256 " ) ; SecretKeySpec signingKey = new SecretKeySpec ( blockKey , " HmacSHA256 " ) ; hmac . init ( signingKey ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " No HmacAlogirthm " ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " Invalid Hmac Key " ) ; } return hmac . doFinal ( header ) ; }
public void setupNone ( ) { super . setupNone ( ) ; searchInOther = false ; searchInUUIDs = false ; searchInTags = false ; }
public void put ( PwIconCustom icon ) { customCache . put ( icon . uuid , icon ) ; }
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { postHeader = new byte [ size ] ; System . arraycopy ( buf , offset , postHeader , 0 , size ) ; }
public void copyHeader ( PwDbHeaderV3 header ) { dbHeader = header ; }
public Object clone ( ) { PwDate copy = new PwDate ( ) ; if ( cDateBuilt ) { byte [ ] newC = new byte [ DATE_SIZE ] ; System . arraycopy ( cDate , 0 , newC , 0 , DATE_SIZE ) ; copy . cDate = newC ; copy . cDateBuilt = true ; } if ( jDateBuilt ) { copy . jDate = ( Date ) jDate . clone ( ) ; copy . jDateBuilt = true ; } return copy ; }
public static byte [ ] writeTime ( Date date ) { return writeTime ( date , null ) ; }
public String put ( String key , String value , Date last ) { lastMod . put ( key , last ) ; return put ( key , value ) ; }
public void AddGroup ( PwGroupV4 subGroup , boolean takeOwnership ) { AddGroup ( subGroup , takeOwnership , false ) ; }
public void AddEntry ( PwEntryV4 pe , boolean takeOwnership ) { AddEntry ( pe , takeOwnership , false ) ; }
public void AddEntry ( PwEntryV4 pe , boolean takeOwnership , boolean updateLocationChanged ) { assert ( pe ! = null ) ; childEntries . add ( pe ) ; if ( takeOwnership ) pe . parent = this ; if ( updateLocationChanged ) pe . setLocationChanged ( new Date ( System . currentTimeMillis ( ) ) ) ; }
public void initNewGroup ( String nm , PwGroupId newId ) { super . initNewGroup ( nm , newId ) ; lastAccess = lastMod = creation = parentGroupLastMod = new Date ( ) ; }
public boolean isSearchEnabled ( ) { PwGroupV4 group = this ; while ( group ! = null ) { Boolean search = group . enableSearching ; if ( search ! = null ) { return search ; } group = group . parent ; } return true ; }
public boolean equals ( Object compare ) { if ( ! ( compare instanceof PwGroupIdV3 ) ) { return false ; } PwGroupIdV3 cmp = ( PwGroupIdV3 ) compare ; return id = = cmp . id ; }
public int hashCode ( ) { Integer i = Integer . valueOf ( id ) ; return i . hashCode ( ) ; }
public static boolean IsNever ( Date date ) { return PwDate . IsSameDate ( NEVER_EXPIRE , date ) ; }
public boolean isMetaStream ( ) { if ( binaryData = = null ) return false ; if ( additional = = null | | additional . length ( ) = = 0 ) return false ; if ( ! binaryDesc . equals ( PMS_ID_BINDESC ) ) return false ; if ( title = = null ) return false ; if ( ! title . equals ( PMS_ID_TITLE ) ) return false ; if ( username = = null ) return false ; if ( ! username . equals ( PMS_ID_USER ) ) return false ; if ( url = = null ) return false ; if ( ! url . equals ( PMS_ID_URL ) ) return false ; if ( ! icon . isMetaStreamIcon ( ) ) return false ; return true ; }
public Object clone ( ) { PwEntryV3 newEntry = ( PwEntryV3 ) super . clone ( ) ; if ( password ! = null ) { int passLen = password . length ; password = new byte [ passLen ] ; System . arraycopy ( password , 0 , newEntry . password , 0 , passLen ) ; } newEntry . tCreation = ( PwDate ) tCreation . clone ( ) ; newEntry . tLastMod = ( PwDate ) tLastMod . clone ( ) ; newEntry . tLastAccess = ( PwDate ) tLastAccess . clone ( ) ; newEntry . tExpire = ( PwDate ) tExpire . clone ( ) ; newEntry . binaryDesc = binaryDesc ; if ( binaryData ! = null ) { int descLen = binaryData . length ; newEntry . binaryData = new byte [ descLen ] ; System . arraycopy ( binaryData , 0 , newEntry . binaryData , 0 , descLen ) ; } newEntry . parent = parent ; return newEntry ; }
public boolean expires ( ) { return ! IsNever ( tExpire . getJDate ( ) ) ; }
public void setupNone ( ) { searchInTitles = false ; searchInUserNames = false ; searchInPasswords = false ; searchInUrls = false ; searchInGroupNames = false ; searchInNotes = false ; }
public boolean equals ( Object id ) { if ( ! ( id instanceof PwGroupIdV4 ) ) { return false ; } PwGroupIdV4 v4 = ( PwGroupIdV4 ) id ; return uuid . equals ( v4 . uuid ) ; }
public void put ( String key , String value ) { windowSeqPairs . put ( key , value ) ; }
public Set < Entry < String , String > > entrySet ( ) { return windowSeqPairs . entrySet ( ) ; }
public PwEntry clone ( boolean deepStrings ) { PwEntryV4 entry = ( PwEntryV4 ) super . clone ( deepStrings ) ; if ( deepStrings ) { entry . strings = ( HashMap < String , ProtectedString > ) strings . clone ( ) ; } return entry ; }
public PwEntryV4 cloneDeep ( ) { PwEntryV4 entry = ( PwEntryV4 ) clone ( true ) ; entry . binaries = ( HashMap < String , ProtectedBinary > ) binaries . clone ( ) ; entry . history = ( ArrayList < PwEntryV4 > ) history . clone ( ) ; entry . autoType = ( AutoType ) autoType . clone ( ) ; return entry ; }
public void assign ( PwEntry source ) { if ( ! ( source instanceof PwEntryV4 ) ) { throw new RuntimeException ( " DB version mix . " ) ; } super . assign ( source ) ; PwEntryV4 src = ( PwEntryV4 ) source ; assign ( src ) ; }
public Object clone ( ) { PwEntryV4 newEntry = ( PwEntryV4 ) super . clone ( ) ; return newEntry ; }
private String decodeRefKey ( boolean decodeRef , String key , PwDatabase db ) { String text = getString ( key ) ; if ( decodeRef ) { text = decodeRef ( text , db ) ; } return text ; }
private String decodeRef ( String text , PwDatabase db ) { if ( db = = null ) { return text ; } SprEngine spr = SprEngine . getInstance ( db ) ; return spr . compile ( text , this , db ) ; }
public void createBackup ( PwDatabaseV4 db ) { PwEntryV4 copy = cloneDeep ( ) ; copy . history = new ArrayList < PwEntryV4 > ( ) ; history . add ( copy ) ; if ( db ! = null ) maintainBackups ( db ) ; }
public void touch ( boolean modified , boolean touchParents ) { super . touch ( modified , touchParents ) ; + + usageCount ; }
public void touchLocation ( ) { parentGroupLastMod = new Date ( ) ; }
public boolean isSearchingEnabled ( ) { if ( parent ! = null ) { return parent . isSearchEnabled ( ) ; } return PwGroupV4 . DEFAULT_SEARCHING_ENABLED ; }
public static boolean matchesHeader ( int sig1 , int sig2 ) { return ( sig1 = = PWM_DBSIG_1 ) & & ( sig2 = = DBSIG_2 ) ; }
public boolean matchesVersion ( ) { return compatibleHeaders ( version , DBVER_DW ) ; }
public static boolean compatibleHeaders ( int one , int two ) { return ( one & 0xFFFFFF00 ) = = ( two & 0xFFFFFF00 ) ; }
public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; }
public Object clone ( ) { PwEntry newEntry ; try { newEntry = ( PwEntry ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { assert ( false ) ; throw new RuntimeException ( " Clone should be supported " ) ; } return newEntry ; }
public PwEntry clone ( boolean deepStrings ) { return ( PwEntry ) clone ( ) ; }
public void assign ( PwEntry source ) { icon = source . icon ; }
public EntrySearchStringIterator stringIterator ( ) { return EntrySearchStringIterator . getInstance ( this ) ; }
public boolean isSearchingEnabled ( ) { return false ; }
public int length ( ) { if ( string = = null ) { return 0 ; } return string . length ( ) ; }
public Cipher initCipher ( int mode ) { Cipher cipher ; try { cipher = CipherFactory . getInstance ( " AES / CBC / PKCS5Padding " ) ; cipher . init ( mode , keySpec , ivSpec ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( e ) ; } catch ( InvalidKeyException e ) { throw new IllegalStateException ( e ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new IllegalStateException ( e ) ; } return cipher ; }
public void setupEnc ( File file ) { byte [ ] iv = new byte [ 16 ] ; byte [ ] key = new byte [ 32 ] ; secureRandom . nextBytes ( key ) ; secureRandom . nextBytes ( iv ) ; keySpec = new SecretKeySpec ( key , " AES " ) ; ivSpec = new IvParameterSpec ( ( iv ) ) ; Cipher cipherOut = initCipher ( Cipher . ENCRYPT_MODE ) ; FileOutputStream fos ; try { fos = new FileOutputStream ( file ) ; } catch ( FileNotFoundException e ) { throw new IllegalStateException ( e ) ; } cos = new CipherOutputStream ( fos , cipherOut ) ; }
public int length ( ) { if ( data ! = null ) return data . length ; if ( dataFile ! = null ) return size ; return 0 ; }
public void run ( ) { PwDatabase pm = mDb . pm ; mGroup = pm . createGroup ( ) ; mGroup . initNewGroup ( mName , pm . newGroupId ( ) ) ; mGroup . icon = mDb . pm . iconFactory . getIcon ( mIconID ) ; pm . addGroupTo ( mGroup , mParent ) ; SaveDB save = new SaveDB ( ctx , mDb , mFinish , mDontSave ) ; save . run ( ) ; }
public void run ( ) { PwDatabase pm = mDb . pm ; if ( mSuccess ) { mDb . dirty . add ( mParent ) ; } else { pm . removeGroupFrom ( mGroup , mParent ) ; } super . run ( ) ; }
public void run ( ) { try { mDb . LoadData ( mCtx , mUri , mPass , mKey , mStatus ) ; saveFileData ( mUri , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( ContentFileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . file_not_found_content ) ) ; return ; } catch ( FileNotFoundException e ) { if ( mUri ! = null & & Android11WarningFragment . showAndroid11Warning ( mUri ) ) { finish ( false , new Android11WarningFragment ( ) ) ; return ; } finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( true ) ; }
private void saveFileData ( Uri uri , Uri key ) { if ( ! mRememberKeyfile ) { key = null ; } App . getFileHistory ( ) . createFile ( uri , key ) ; }
public void run ( ) { Database db = new Database ( ) ; App . setDB ( db ) ; PwDatabase pm = PwDatabase . getNewDBInstance ( mFilename ) ; pm . initNew ( mDbName ) ; db . pm = pm ; Uri . Builder b = new Uri . Builder ( ) ; db . mUri = UriUtil . parseDefaultFile ( mFilename ) ; db . setLoaded ( ) ; App . clearShutdown ( ) ; SaveDB save = new SaveDB ( ctx , db , mFinish , mDontSave ) ; mFinish = null ; save . run ( ) ; }
public void run ( ) { mOldE . assign ( mNewE ) ; mOldE . touch ( true , true ) ; SaveDB save = new SaveDB ( ctx , mDb , mFinish ) ; save . run ( ) ; }
public boolean validatePassword ( Context ctx , DialogInterface . OnClickListener onclick ) { if ( ! mDb . pm . validatePasswordEncoding ( mPassword ) ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; dialog . show ( ctx , onclick , true ) ; return false ; } return true ; }
public void run ( ) { PwDatabase pm = mDb . pm ; byte [ ] backupKey = new byte [ pm . masterKey . length ] ; System . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; try { InputStream is = UriUtil . getUriInputStream ( ctx , mKeyfile ) ; pm . setMasterKey ( mPassword , is ) ; } catch ( InvalidKeyFileException e ) { erase ( backupKey ) ; finish ( false , e . getMessage ( ) ) ; return ; } catch ( IOException e ) { erase ( backupKey ) ; finish ( false , e . getMessage ( ) ) ; return ; } mFinish = new AfterSave ( backupKey , mFinish ) ; SaveDB save = new SaveDB ( ctx , mDb , mFinish , mDontSave ) ; save . run ( ) ; }
public void run ( ) { if ( ! mSuccess ) { erase ( mDb . pm . masterKey ) ; mDb . pm . masterKey = mBackup ; } super . run ( ) ; }
protected void displayMessage ( AppCompatActivity ctx ) { if ( ctx = = null ) { return ; } displayMessage ( ctx , ctx . getSupportFragmentManager ( ) ) ; }
public void run ( ) { if ( ! mDontSave ) { try { mDb . SaveData ( mCtx ) ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( FileUriException e ) { if ( Android11WarningFragment . showAndroid11WarningOnThisVersion ( ) ) { finish ( false , new Android11WarningFragment ( R . string . Android11SaveFailed ) ) ; } else { finish ( false , e . getMessage ( ) ) ; } return ; } catch ( PwDbOutputException e ) { throw new RuntimeException ( e ) ; } } finish ( true ) ; }
public void run ( ) { mDb . pm . addEntryTo ( mEntry , mEntry . getParent ( ) ) ; SaveDB save = new SaveDB ( ctx , mDb , mFinish ) ; save . run ( ) ; }
public void run ( ) { PwDatabase pm = mDb . pm ; if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; mDb . dirty . add ( parent ) ; } else { pm . removeEntryFrom ( mEntry , mEntry . getParent ( ) ) ; } super . run ( ) ; }
public boolean hasNext ( ) { return current ! = null ; }
public String next ( ) { if ( current = = null ) { throw new NoSuchElementException ( " Past the end of the list . " ) ; } String next = current ; advance ( ) ; return next ; }
private void advance ( ) { while ( setIterator . hasNext ( ) ) { Entry < String , ProtectedString > entry = setIterator . next ( ) ; String key = entry . getKey ( ) ; if ( searchInField ( key ) ) { current = entry . getValue ( ) . toString ( ) ; return ; } } current = null ; }
public String next ( ) { if ( current = = maxEntries ) { throw new NoSuchElementException ( " Past final string " ) ; } useSearchParameters ( ) ; String str = getCurrentString ( ) ; current + + ; return str ; }
protected PwDatabaseV3 createDB ( ) { return new PwDatabaseV3 ( ) ; }
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , InputStream kfIs ) throws IOException , InvalidDBException { return openDatabase ( inStream , password , kfIs , new UpdateStatus ( ) , 0 ) ; }
public static void bsw32 ( byte [ ] ary , int offset ) { byte t = ary [ offset ] ; ary [ offset ] = ary [ offset + 3 ] ; ary [ offset + 3 ] = t ; t = ary [ offset + 1 ] ; ary [ offset + 1 ] = ary [ offset + 2 ] ; ary [ offset + 2 ] = t ; }
protected PwDatabaseV4Debug createDB ( ) { return new PwDatabaseV4Debug ( ) ; }
public static Importer createImporter ( InputStream is , File streamDir ) throws InvalidDBSignatureException , IOException { return createImporter ( is , streamDir , false ) ; }
protected PwDatabaseV3Debug createDB ( ) { return new PwDatabaseV3Debug ( ) ; }
protected PwDatabaseV4 createDB ( ) { return new PwDatabaseV4 ( ) ; }
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream ) throws IOException , InvalidDBException { return openDatabase ( inStream , password , keyInputStream , new UpdateStatus ( ) , 0 ) ; }
private InputStream AttachCipherStream ( InputStream is , Cipher cipher ) { return new BetterCipherInputStream ( is , cipher , 50 * 1024 ) ; }
private static XmlPullParser CreatePullParser ( InputStream readerStream ) throws XmlPullParserException { XmlPullParserFactory xppf = XmlPullParserFactory . newInstance ( ) ; xppf . setNamespaceAware ( false ) ; XmlPullParser xpp = xppf . newPullParser ( ) ; xpp . setInput ( readerStream , null ) ; return xpp ; }
private UUID ReadUuid ( XmlPullParser xpp ) throws IOException , XmlPullParserException { String encoded = ReadString ( xpp ) ; if ( encoded = = null | | encoded . length ( ) = = 0 ) { return PwDatabaseV4 . UUID_ZERO ; } byte [ ] buf = Base64 . decode ( encoded , Base64 . NO_WRAP ) ; return Types . bytestoUUID ( buf ) ; }
private int ReadInt ( XmlPullParser xpp , int def ) throws IOException , XmlPullParserException { String str = ReadString ( xpp ) ; int u ; try { u = Integer . parseInt ( str ) ; } catch ( NumberFormatException e ) { u = def ; } return u ; }
private long ReadLong ( XmlPullParser xpp , long def ) throws IOException , XmlPullParserException { String str = ReadString ( xpp ) ; long u ; try { u = Long . parseLong ( str ) ; } catch ( NumberFormatException e ) { u = def ; } return u ; }
private ProtectedString ReadProtectedString ( XmlPullParser xpp ) throws XmlPullParserException , IOException { byte [ ] buf = ProcessNode ( xpp ) ; if ( buf ! = null ) { try { return new ProtectedString ( true , new String ( buf , " UTF - 8 " ) ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; throw new IOException ( e . getLocalizedMessage ( ) ) ; } } return new ProtectedString ( false , ReadString ( xpp ) ) ; }
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) throws XmlPullParserException , IOException { String ref = xpp . getAttributeValue ( null , AttrRef ) ; if ( ref ! = null ) { xpp . next ( ) ; int id = Integer . parseInt ( ref ) ; return db . binPool . get ( id ) ; } boolean compressed = false ; String comp = xpp . getAttributeValue ( null , AttrCompressed ) ; if ( comp ! = null ) { compressed = comp . equalsIgnoreCase ( ValTrue ) ; } byte [ ] buf = ProcessNode ( xpp ) ; if ( buf ! = null ) return new ProtectedBinary ( true , buf ) ; String base64 = ReadString ( xpp ) ; if ( base64 . length ( ) = = 0 ) return ProtectedBinary . EMPTY ; byte [ ] data = Base64 . decode ( base64 , Base64 . NO_WRAP ) ; if ( compressed ) { data = MemUtil . decompress ( data ) ; } return new ProtectedBinary ( false , data ) ; }
private String ReadStringRaw ( XmlPullParser xpp ) throws XmlPullParserException , IOException { return xpp . nextText ( ) ; }
private KdbContext SwitchContext ( KdbContext ctxCurrent , KdbContext ctxNew , XmlPullParser xpp ) throws XmlPullParserException , IOException { if ( xpp . isEmptyElementTag ( ) ) { xpp . next ( ) ; return ctxCurrent ; } return ctxNew ; }
public void outputStart ( ) throws IOException { mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature1 ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature2 ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . flags ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . version ) ) ; mOS . write ( mHeader . masterSeed ) ; mOS . write ( mHeader . encryptionIV ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numGroups ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numEntries ) ) ; }
public void outputContentHash ( ) throws IOException { mOS . write ( mHeader . contentsHash ) ; }
public void outputEnd ( ) throws IOException { mOS . write ( mHeader . transformSeed ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numKeyEncRounds ) ) ; }
public void output ( ) throws IOException { outputStart ( ) ; outputContentHash ( ) ; outputEnd ( ) ; }
public void close ( ) throws IOException { mOS . close ( ) ; }
public boolean operate ( PwEntry e ) { PwEntryV4 entry = ( PwEntryV4 ) e ; assert ( entry ! = null ) ; try { writeEntry ( entry , false ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } return true ; }
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) throws PwDbOutputException { Cipher cipher ; try { cipher = engine . getCipher ( Cipher . ENCRYPT_MODE , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { throw new PwDbOutputException ( " Invalid algorithm . " , e ) ; } CipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; return cos ; }
public PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException { PwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; header . version = mPM . getMinKdbxVersion ( ) ; setIVs ( header ) ; PwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; try { pho . output ( ) ; } catch ( IOException e ) { throw new PwDbOutputException ( " Failed to output the header . " , e ) ; } hashOfHeader = pho . getHashOfHeader ( ) ; headerHmac = pho . headerHmac ; return header ; }
private void endGroup ( ) throws IllegalArgumentException , IllegalStateException , IOException { xml . endTag ( null , ElemGroup ) ; }
private void writeObject ( String key , ProtectedBinary value , boolean allowRef ) throws IllegalArgumentException , IllegalStateException , IOException { assert ( key ! = null & & value ! = null ) ; xml . startTag ( null , ElemBinary ) ; xml . startTag ( null , ElemKey ) ; xml . text ( safeXmlString ( key ) ) ; xml . endTag ( null , ElemKey ) ; xml . startTag ( null , ElemValue ) ; String strRef = null ; if ( allowRef ) { int ref = mPM . binPool . poolFind ( value ) ; strRef = Integer . toString ( ref ) ; } if ( strRef ! = null ) { xml . attribute ( null , AttrRef , strRef ) ; } else { subWriteValue ( value ) ; } xml . endTag ( null , ElemValue ) ; xml . endTag ( null , ElemBinary ) ; }
private void writeObject ( String name , String value , boolean filterXmlChars ) throws IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & value ! = null ) ; xml . startTag ( null , name ) ; if ( filterXmlChars ) { value = safeXmlString ( value ) ; } xml . text ( value ) ; xml . endTag ( null , name ) ; }
private void writeObject ( String name , String value ) throws IllegalArgumentException , IllegalStateException , IOException { writeObject ( name , value , false ) ; }
private void writeObject ( String name , long value ) throws IllegalArgumentException , IllegalStateException , IOException { writeObject ( name , String . valueOf ( value ) ) ; }
private void writeObject ( String name , Boolean value ) throws IllegalArgumentException , IllegalStateException , IOException { String text ; if ( value = = null ) { text = " null " ; } else if ( value ) { text = ValTrue ; } else { text = ValFalse ; } writeObject ( name , text ) ; }
private void writeObject ( String name , UUID uuid ) throws IllegalArgumentException , IllegalStateException , IOException { byte [ ] data = Types . UUIDtoBytes ( uuid ) ; writeObject ( name , Base64 . encodeToString ( data , Base64 . NO_WRAP ) ) ; }
private void writeObject ( String name , String keyName , String keyValue , String valueName , String valueValue , Date lastMod ) throws IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , name ) ; xml . startTag ( null , keyName ) ; xml . text ( safeXmlString ( keyValue ) ) ; xml . endTag ( null , keyName ) ; xml . startTag ( null , valueName ) ; xml . text ( safeXmlString ( valueValue ) ) ; xml . endTag ( null , valueName ) ; if ( lastMod ! = null ) { writeObject ( ElemLastModTime , lastMod ) ; } xml . endTag ( null , name ) ; }
private void writeObject ( String name , PwDeletedObject value ) throws IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & value ! = null ) ; xml . startTag ( null , name ) ; writeObject ( ElemUuid , value . uuid ) ; writeObject ( ElemDeletionTime , value . getDeletionTime ( ) ) ; xml . endTag ( null , name ) ; }
private void writeList ( String name , ITimeLogger it ) throws IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & it ! = null ) ; xml . startTag ( null , name ) ; writeObject ( ElemLastModTime , it . getLastModificationTime ( ) ) ; writeObject ( ElemCreationTime , it . getCreationTime ( ) ) ; writeObject ( ElemLastAccessTime , it . getLastAccessTime ( ) ) ; writeObject ( ElemExpiryTime , it . getExpiryTime ( ) ) ; writeObject ( ElemExpires , it . expires ( ) ) ; writeObject ( ElemUsageCount , it . getUsageCount ( ) ) ; writeObject ( ElemLocationChanged , it . getLocationChanged ( ) ) ; xml . endTag ( null , name ) ; }
public void output ( ) throws IOException { mOS . write ( GROUPID_FIELD_TYPE ) ; mOS . write ( GROUPID_FIELD_SIZE ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mPG . groupId ) ) ; mOS . write ( NAME_FIELD_TYPE ) ; Types . writeCString ( mPG . name , mOS ) ; mOS . write ( CREATE_FIELD_TYPE ) ; mOS . write ( DATE_FIELD_SIZE ) ; mOS . write ( mPG . tCreation . getCDate ( ) ) ; mOS . write ( MOD_FIELD_TYPE ) ; mOS . write ( DATE_FIELD_SIZE ) ; mOS . write ( mPG . tLastMod . getCDate ( ) ) ; mOS . write ( ACCESS_FIELD_TYPE ) ; mOS . write ( DATE_FIELD_SIZE ) ; mOS . write ( mPG . tLastAccess . getCDate ( ) ) ; mOS . write ( EXPIRE_FIELD_TYPE ) ; mOS . write ( DATE_FIELD_SIZE ) ; mOS . write ( mPG . tExpire . getCDate ( ) ) ; mOS . write ( IMAGEID_FIELD_TYPE ) ; mOS . write ( IMAGEID_FIELD_SIZE ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mPG . icon . iconId ) ) ; mOS . write ( LEVEL_FIELD_TYPE ) ; mOS . write ( LEVEL_FIELD_SIZE ) ; mOS . write ( LEDataOutputStream . writeUShortBuf ( mPG . level ) ) ; mOS . write ( FLAGS_FIELD_TYPE ) ; mOS . write ( FLAGS_FIELD_SIZE ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mPG . flags ) ) ; mOS . write ( END_FIELD_TYPE ) ; mOS . write ( ZERO_FIELD_SIZE ) ; }
public void output ( ) throws IOException { los . write ( PwDbInnerHeaderV4Fields . InnerRandomStreamID ) ; los . writeInt ( 4 ) ; los . writeInt ( header . innerRandomStream . id ) ; int streamKeySize = header . innerRandomStreamKey . length ; los . write ( PwDbInnerHeaderV4Fields . InnerRandomstreamKey ) ; los . writeInt ( streamKeySize ) ; los . write ( header . innerRandomStreamKey ) ; for ( ProtectedBinary bin : db . binPool . binaries ( ) ) { byte flag = KdbxBinaryFlags . None ; if ( bin . isProtected ( ) ) { flag | = KdbxBinaryFlags . Protected ; } los . write ( PwDbInnerHeaderV4Fields . Binary ) ; los . writeInt ( ( int ) bin . length ( ) + 1 ) ; los . write ( flag ) ; InputStream inputStream = bin . getData ( ) ; int binLength = bin . length ( ) ; Util . copyStream ( inputStream , los ) ; } los . write ( PwDbInnerHeaderV4Fields . EndOfHeader ) ; los . writeInt ( 0 ) ; }
private void prepForOutput ( ) { sortGroupsForOutput ( ) ; }
protected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { SecureRandom random = super . setIVs ( header ) ; PwDbHeaderV3 h3 = ( PwDbHeaderV3 ) header ; random . nextBytes ( h3 . transformSeed ) ; return random ; }
protected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { SecureRandom random ; try { random = SecureRandom . getInstance ( " SHA1PRNG " ) ; } catch ( NoSuchAlgorithmException e ) { throw new PwDbOutputException ( " Does not support secure random number generation . " ) ; } random . nextBytes ( header . encryptionIV ) ; random . nextBytes ( header . masterSeed ) ; return random ; }
protected SecureRandom setIVs ( PwDbHeader h ) throws PwDbOutputException { PwDbHeaderV3 header = ( PwDbHeaderV3 ) h ; PwDbHeaderV3 origHeader = debugDb . dbHeader ; System . arraycopy ( origHeader . encryptionIV , 0 , header . encryptionIV , 0 , origHeader . encryptionIV . length ) ; System . arraycopy ( origHeader . masterSeed , 0 , header . masterSeed , 0 , origHeader . masterSeed . length ) ; System . arraycopy ( origHeader . transformSeed , 0 , header . transformSeed , 0 , origHeader . transformSeed . length ) ; return null ; }
protected boolean useHeaderHash ( ) { return ! noHeaderHash ; }
public void output ( ) throws IOException { outputBytes + = 134 ; mOS . write ( UUID_FIELD_TYPE ) ; mOS . write ( UUID_FIELD_SIZE ) ; mOS . write ( Types . UUIDtoBytes ( mPE . getUUID ( ) ) ) ; mOS . write ( GROUPID_FIELD_TYPE ) ; mOS . write ( LONG_FOUR ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mPE . groupId ) ) ; mOS . write ( IMAGEID_FIELD_TYPE ) ; mOS . write ( LONG_FOUR ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mPE . icon . iconId ) ) ; mOS . write ( TITLE_FIELD_TYPE ) ; int titleLen = Types . writeCString ( mPE . title , mOS ) ; outputBytes + = titleLen ; mOS . write ( URL_FIELD_TYPE ) ; int urlLen = Types . writeCString ( mPE . url , mOS ) ; outputBytes + = urlLen ; mOS . write ( USERNAME_FIELD_TYPE ) ; int userLen = Types . writeCString ( mPE . username , mOS ) ; outputBytes + = userLen ; byte [ ] password = mPE . getPasswordBytes ( ) ; mOS . write ( PASSWORD_FIELD_TYPE ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( password . length + 1 ) ) ; mOS . write ( password ) ; mOS . write ( 0 ) ; outputBytes + = password . length + 1 ; mOS . write ( ADDITIONAL_FIELD_TYPE ) ; int addlLen = Types . writeCString ( mPE . additional , mOS ) ; outputBytes + = addlLen ; writeDate ( CREATE_FIELD_TYPE , mPE . tCreation . getCDate ( ) ) ; writeDate ( MOD_FIELD_TYPE , mPE . tLastMod . getCDate ( ) ) ; writeDate ( ACCESS_FIELD_TYPE , mPE . tLastAccess . getCDate ( ) ) ; writeDate ( EXPIRE_FIELD_TYPE , mPE . tExpire . getCDate ( ) ) ; mOS . write ( BINARY_DESC_FIELD_TYPE ) ; int descLen = Types . writeCString ( mPE . binaryDesc , mOS ) ; outputBytes + = descLen ; int dataLen = writeByteArray ( mPE . getBinaryData ( ) ) ; outputBytes + = dataLen ; mOS . write ( END_FIELD_TYPE ) ; mOS . write ( ZERO_FIELD_SIZE ) ; }
public static byte [ ] hashSha256 ( byte [ ] data ) { return hashSha256 ( data , 0 , data . length ) ; }
public static byte [ ] hashSha256 ( byte [ ] data , int offset , int count ) { return hashGen ( " SHA - 256 " , data , offset , count ) ; }
public static byte [ ] hashSha512 ( byte [ ] data ) { return hashSha512 ( data , 0 , data . length ) ; }
public static byte [ ] hashSha512 ( byte [ ] data , int offset , int count ) { return hashGen ( " SHA - 512 " , data , offset , count ) ; }
public static byte [ ] hashGen ( String transform , byte [ ] data , int offset , int count ) { MessageDigest hash ; try { hash = MessageDigest . getInstance ( transform ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } NullOutputStream nos = new NullOutputStream ( ) ; DigestOutputStream dos = new DigestOutputStream ( nos , hash ) ; try { dos . write ( data , offset , count ) ; dos . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return hash . digest ( ) ; }
private static void staticInit ( ) { mIsStaticInit = true ; mQueue = new ReferenceQueue < NativeAESCipherSpi > ( ) ; ( new Thread ( new Cleanup ( ) ) ) . start ( ) ; }
private static void addToCleanupQueue ( NativeAESCipherSpi ref , long ptr ) { Log . d ( " KeepassDroid " , " queued cipher context : " + ptr ) ; mCleanup . put ( new PhantomReference < NativeAESCipherSpi > ( ref , mQueue ) , ptr ) ; }
protected int engineDoFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) throws ShortBufferException , IllegalBlockSizeException , BadPaddingException { int result = doFinal ( input , inputOffset , inputLen , output , outputOffset ) ; if ( result = = - 1 ) { throw new ShortBufferException ( ) ; } return result ; }
protected int engineGetBlockSize ( ) { return AES_BLOCK_SIZE ; }
protected byte [ ] engineGetIV ( ) { return mIV . clone ( ) ; }
protected int engineGetOutputSize ( int inputLen ) { return inputLen + nGetCacheSize ( mCtxPtr ) + AES_BLOCK_SIZE ; }
protected AlgorithmParameters engineGetParameters ( ) { return null ; }
protected void engineInit ( int opmode , Key key , SecureRandom random ) throws InvalidKeyException { byte [ ] ivArray = new byte [ 16 ] ; random . nextBytes ( ivArray ) ; init ( opmode , key , new IvParameterSpec ( ivArray ) ) ; }
protected void engineInit ( int opmode , Key key , AlgorithmParameterSpec params , SecureRandom random ) throws InvalidKeyException , InvalidAlgorithmParameterException { IvParameterSpec ivparam ; if ( params instanceof IvParameterSpec ) { ivparam = ( IvParameterSpec ) params ; } else { throw new InvalidAlgorithmParameterException ( " params must be an IvParameterSpec . " ) ; } init ( opmode , key , ivparam ) ; }
private void init ( int opmode , Key key , IvParameterSpec params ) { if ( mIsInited ) { assert ( true ) ; throw new RuntimeException ( " Don ' t allow multiple inits " ) ; } else { NativeLib . init ( ) ; mIsInited = true ; } mIV = params . getIV ( ) ; mEncrypting = opmode = = Cipher . ENCRYPT_MODE ; mCtxPtr = nInit ( mEncrypting , key . getEncoded ( ) , mIV ) ; addToCleanupQueue ( this , mCtxPtr ) ; }
public static Cipher getInstance ( String transformation ) throws NoSuchAlgorithmException , NoSuchPaddingException { return getInstance ( transformation , false ) ; }
public static boolean deviceBlacklisted ( ) { if ( ! blacklistInit ) { blacklistInit = true ; blacklisted = Build . MODEL . equals ( " A500 " ) ; } return blacklisted ; }
private static boolean hasNativeImplementation ( String transformation ) { return transformation . equals ( " AES / CBC / PKCS5Padding " ) ; }
public static CipherEngine getInstance ( UUID uuid ) throws NoSuchAlgorithmException { if ( uuid . equals ( AesEngine . CIPHER_UUID ) ) { return new AesEngine ( ) ; } else if ( uuid . equals ( TwofishEngine . CIPHER_UUID ) ) { return new TwofishEngine ( ) ; } else if ( uuid . equals ( ChaCha20Engine . CIPHER_UUID ) ) { return new ChaCha20Engine ( ) ; } throw new NoSuchAlgorithmException ( " UUID unrecognized . " ) ; }
public static FinalKey createFinalKey ( ) { return createFinalKey ( false ) ; }
public static boolean availble ( ) { return NativeLib . init ( ) ; }
public byte [ ] transform ( byte [ ] masterKey , KdfParameters p ) throws IOException { long rounds = p . getUInt64 ( ParamRounds ) ; byte [ ] seed = p . getByteArray ( ParamSeed ) ; if ( masterKey . length ! = 32 ) { masterKey = CryptoUtil . hashSha256 ( masterKey ) ; } if ( seed . length ! = 32 ) { seed = CryptoUtil . hashSha256 ( seed ) ; } FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . transformMasterKey ( seed , masterKey , rounds ) ; }
public void randomize ( KdfParameters p ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] seed = new byte [ 32 ] ; random . nextBytes ( seed ) ; p . setByteArray ( ParamSeed , seed ) ; }
int value ( ) { return type ; }
public void randomize ( KdfParameters p ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] salt = new byte [ 32 ] ; random . nextBytes ( salt ) ; p . setByteArray ( ParamSalt , salt ) ; }
public static byte [ ] transformKey ( byte [ ] password , byte [ ] salt , int parallelism , long memory , long iterations , byte [ ] secretKey , byte [ ] associatedData , long version , int type ) throws IOException { NativeLib . init ( ) ; return nTransformMasterKey ( password , salt , parallelism , memory , iterations , secretKey , associatedData , version , type ) ; }
public static byte [ ] serialize ( KdfParameters kdf ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; LEDataOutputStream los = new LEDataOutputStream ( bos ) ; KdfParameters . serialize ( kdf , los ) ; return bos . toByteArray ( ) ; }
public static KdfEngine get ( UUID uuid ) { for ( KdfEngine engine : kdfList ) { if ( engine . uuid . equals ( uuid ) ) { return engine ; } } return null ; }
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher = Cipher . getInstance ( " Chacha7539 " , new BouncyCastleProvider ( ) ) ; cipher . init ( opmode , new SecretKeySpec ( key , " ChaCha7539 " ) , new IvParameterSpec ( IV ) ) ; return cipher ; }
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher = CipherFactory . getInstance ( " AES / CBC / PKCS5Padding " , androidOverride ) ; cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; }
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher ; if ( opmode = = Cipher . ENCRYPT_MODE ) { cipher = CipherFactory . getInstance ( " Twofish / CBC / ZeroBytePadding " , androidOverride ) ; } else { cipher = CipherFactory . getInstance ( " Twofish / CBC / NoPadding " , androidOverride ) ; } cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; }
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { return getCipher ( opmode , key , IV , false ) ; }
protected byte [ ] engineGenerateSeed ( int size ) { byte [ ] seed = new byte [ size ] ; engineNextBytes ( seed ) ; return seed ; }
public static boolean useStorageFramework ( Context ctx ) { if ( ! supportsStorageFramework ( ) ) { return false ; } SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return prefs . getBoolean ( ctx . getString ( R . string . saf_key ) , ctx . getResources ( ) . getBoolean ( R . bool . saf_default ) ) ; }
public static boolean showAndroid11Warning ( String filename ) { if ( EmptyUtils . isNullOrEmpty ( filename ) ) { return false ; } Uri fileUri = Uri . parse ( filename ) ; return showAndroid11Warning ( fileUri ) ; }
public static boolean showAndroid11Warning ( Uri fileUri ) { if ( fileUri = = null ) { return false ; } String scheme = fileUri . getScheme ( ) ; if ( scheme = = null ) { return true ; } return scheme . equals ( " file " ) & & showAndroid11WarningOnThisVersion ( ) ; }
public void onClick ( DialogInterface dialogInterface , int i ) { dialogInterface . dismiss ( ) ; }
public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; setRetainInstance ( true ) ; afterOnCreateBeforeEndOfOnResume = true ; }
public View onCreateView ( @ NonNull LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { super . onCreateView ( inflater , container , savedInstanceState ) ; mView = inflater . inflate ( R . layout . password , container , false ) ; return mView ; }
public void onClick ( View v ) { biometricLogin ( ) ; }
public void onClick ( View v ) { clearStoredCredentials ( ) ; }
private void biometricLogin ( ) { if ( ! initDecryptData ( ) ) { return ; } biometricCheck . setChecked ( false ) ; Cipher cipher = biometricHelper . getCipher ( ) ; biometricMode = BIOMETRIC_LOAD ; biometricOpenPrompt . authenticate ( loadPrompt , new BiometricPrompt . CryptoObject ( cipher ) ) ; }
public void onCreateOptionsMenu ( @ NonNull Menu menu , @ NonNull MenuInflater inflater ) { super . onCreateOptionsMenu ( menu , inflater ) ; MenuInflater inflate = mActivity . getMenuInflater ( ) ; inflate . inflate ( R . menu . password , menu ) ; }
public void onDetach ( ) { super . onDetach ( ) ; mActivity = null ; }
public void onDestroy ( ) { super . onDestroy ( ) ; mActivity = null ; }
private boolean initDecryptData ( ) { final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; return biometricHelper . initDecryptData ( ivSpecValue ) ; }
public void onActivityCreated ( @ Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; Intent i = mActivity . getIntent ( ) ; InitTask task = new InitTask ( ) ; task . onPostExecute ( task . doInBackground ( i ) ) ; }
public void onResume ( ) { super . onResume ( ) ; if ( App . isShutdown ( ) ) { TextView password = ( TextView ) mView . findViewById ( R . id . password ) ; password . setText ( " " ) ; } App . clearShutdown ( ) ; BiometricManager biometricManager = BiometricManager . from ( mActivity ) ; int auth = biometricManager . canAuthenticate ( ) ; if ( auth = = BiometricManager . BIOMETRIC_SUCCESS ) { initBiometrics ( ) ; } else { biometricsAvailable = false ; setFingerPrintVisibilty ( ) ; } afterOnCreateBeforeEndOfOnResume = false ; }
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( mActivity ) ; diag . show ( ) ; }
private void populateView ( ) { String db = ( mDbUri = = null ) ? " " : mDbUri . toString ( ) ; setEditText ( R . id . filename , db ) ; String displayName = UriUtil . getFileName ( mDbUri , getContext ( ) ) ; TextView displayNameView = mView . findViewById ( R . id . filename_display ) ; if ( displayNameView ! = null ) { if ( EmptyUtils . isNullOrEmpty ( displayName ) ) { displayNameView . setVisibility ( View . GONE ) ; } else { displayNameView . setText ( UriUtil . getFileName ( mDbUri , getContext ( ) ) ) ; } } String key = ( mKeyUri = = null ) ? " " : mKeyUri . toString ( ) ; setEditText ( R . id . pass_keyfile , key ) ; }
private void errorMessage ( int resId ) { Toast . makeText ( mActivity , resId , Toast . LENGTH_LONG ) . show ( ) ; }
private void loadDatabaseWithPermission ( ) { String pass = storedPassword ; storedPassword = null ; Uri keyfile = storedKeyUri ; storedKeyUri = null ; Activity activity = mActivity ; Database db = App . getDB ( ) ; db . clear ( activity . getApplicationContext ( ) ) ; App . clearShutdown ( ) ; Handler handler = new Handler ( ) ; LoadDB task = new LoadDB ( db , activity , mDbUri , pass , keyfile , new PasswordFragment . AfterLoad ( handler , db ) ) ; ProgressTask pt = new ProgressTask ( activity , task , R . string . loading_database ) ; pt . run ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( mActivity ) ; }
public void onClick ( View view ) { String pass = getEditText ( R . id . password ) ; String key = getEditText ( R . id . pass_keyfile ) ; loadDatabase ( pass , key ) ; }
private void loadDatabase ( String pass , String keyfile ) { loadDatabase ( pass , UriUtil . parseDefaultFile ( keyfile ) ) ; }
private void clearStoredCredentials ( ) { prefsNoBackup . edit ( ) . remove ( getPreferenceKeyValue ( ) ) . remove ( getPreferenceKeyIvSpec ( ) ) . commit ( ) ; setFingerPrintVisibilty ( ) ; }
public void handleDecryptedResult ( String value ) { passwordView . setText ( value ) ; confirmButton . performClick ( ) ; }
public void onInvalidKeyException ( ) { Toast . makeText ( getContext ( ) , R . string . fingerprint_invalid_key , Toast . LENGTH_SHORT ) . show ( ) ; }
public void onException ( ) { onException ( true ) ; }
public void onException ( CharSequence message ) { Toast . makeText ( getContext ( ) , message , Toast . LENGTH_SHORT ) . show ( ) ; }
public void onException ( int resId ) { Toast . makeText ( getContext ( ) , resId , Toast . LENGTH_SHORT ) . show ( ) ; }
public void onKeyInvalidated ( ) { clearStoredCredentials ( ) ; Toast . makeText ( getContext ( ) , R . string . biometric_invalidated , Toast . LENGTH_LONG ) . show ( ) ; }
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = hasFileUri ( db ) | | hasFileUri ( keyfile ) ; if ( ! hasFileUri ) return true ; return PermissionUtil . checkAndRequest ( this . mActivity , PERMISSION_REQUEST_ID ) ; }
public static boolean isShutdown ( ) { return shutdown ; }
public static void clearShutdown ( ) { shutdown = false ; }
public void onCreate ( ) { super . onCreate ( ) ; fileHistory = new RecentFileHistory ( this ) ; PRNGFixes . apply ( ) ; mIntentReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( Intents . TIMEOUT ) ) { timeout ( context ) ; } } } ; IntentFilter filter = new IntentFilter ( ) ; filter . addAction ( Intents . TIMEOUT ) ; registerReceiver ( mIntentReceiver , filter ) ; }
private void timeout ( Context context ) { Log . d ( TAG , " Timeout " ) ; App . setShutdown ( ) ; NotificationManager nm = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; nm . cancelAll ( ) ; }
public void onTerminate ( ) { if ( db ! = null ) { db . clear ( getApplicationContext ( ) ) ; } unregisterReceiver ( mIntentReceiver ) ; super . onTerminate ( ) ; }
public void onClick ( View v ) { BrowserDialog . this . cancel ( ) ; }
public void onClick ( View v ) { Util . gotoUrl ( getContext ( ) , R . string . oi_filemanager_market ) ; BrowserDialog . this . cancel ( ) ; }
public void onClick ( View v ) { Util . gotoUrl ( getContext ( ) , R . string . oi_filemanager_web ) ; BrowserDialog . this . cancel ( ) ; }
public FileDbHelper open ( ) throws SQLException { mDbHelper = new DatabaseHelper ( mCtx ) ; mDb = mDbHelper . getWritableDatabase ( ) ; return this ; }
public void deleteAllKeys ( ) { ContentValues vals = new ContentValues ( ) ; vals . put ( KEY_FILE_KEYFILE , " " ) ; mDb . update ( FILE_TABLE , vals , null , null ) ; }
public void deleteFile ( String filename ) { mDb . delete ( FILE_TABLE , KEY_FILE_FILENAME + " = ? " , new String [ ] { filename } ) ; }
public Cursor fetchAllFiles ( ) { Cursor ret ; ret = mDb . query ( FILE_TABLE , new String [ ] { KEY_FILE_ID , KEY_FILE_FILENAME , KEY_FILE_KEYFILE } , null , null , null , null , KEY_FILE_UPDATED + " DESC " , Integer . toString ( MAX_FILES ) ) ; return ret ; }
public static boolean deleteDatabase ( Context ctx ) { File file = ctx . getDatabasePath ( DATABASE_NAME ) ; if ( file = = null ) { throw new IllegalArgumentException ( " file must not be null " ) ; } boolean deleted = false ; deleted | = file . delete ( ) ; deleted | = new File ( file . getPath ( ) + " - journal " ) . delete ( ) ; deleted | = new File ( file . getPath ( ) + " - shm " ) . delete ( ) ; deleted | = new File ( file . getPath ( ) + " - wal " ) . delete ( ) ; File dir = file . getParentFile ( ) ; if ( dir ! = null ) { final String prefix = file . getName ( ) + " - mj " ; final FileFilter filter = new FileFilter ( ) { @ Override public boolean accept ( File candidate ) { return candidate . getName ( ) . startsWith ( prefix ) ; } } ; for ( File masterJournal : dir . listFiles ( filter ) ) { deleted | = masterJournal . delete ( ) ; } } return deleted ; }
public boolean accept ( File candidate ) { return candidate . getName ( ) . startsWith ( prefix ) ; }
private void createFile ( String filename ) { File file = new File ( filename ) ; try { if ( file . exists ( ) ) { Toast . makeText ( FileSelectActivity . this , R . string . error_database_exists , Toast . LENGTH_LONG ) . show ( ) ; return ; } File parent = file . getParentFile ( ) ; if ( parent = = null | | ( parent . exists ( ) & & ! parent . isDirectory ( ) ) ) { Toast . makeText ( FileSelectActivity . this , R . string . error_invalid_path , Toast . LENGTH_LONG ) . show ( ) ; return ; } if ( ! parent . exists ( ) ) { if ( ! parent . mkdirs ( ) ) { Toast . makeText ( FileSelectActivity . this , R . string . error_could_not_create_parent , Toast . LENGTH_LONG ) . show ( ) ; return ; } } file . createNewFile ( ) ; } catch ( IOException e ) { Toast . makeText ( FileSelectActivity . this , getText ( R . string . error_file_not_create ) + " " + e . getLocalizedMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; return ; } createDB ( filename , file . getName ( ) ) ; }
private void createFile ( Uri fileURI ) { String filename = fileURI . toString ( ) ; createDB ( filename , UriUtil . getFileName ( fileURI , this ) ) ; }
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { onListItemClick ( ( ListView ) parent , v , position , id ) ; }
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( FileSelectActivity . this ) ; diag . show ( ) ; }
public void run ( ) { SetPasswordDialog password = new SetPasswordDialog ( FileSelectActivity . this , mOnFinish ) ; password . show ( ) ; }
private void fillData ( ) { if ( supportsDirectFile ) { EditText filename = ( EditText ) findViewById ( R . id . file_filename ) ; filename . setText ( Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + getString ( R . string . default_file_path ) ) ; } mAdapter = new ArrayAdapter < String > ( this , R . layout . file_row , R . id . file_filename , fileHistory . getDbList ( ) ) ; mList . setAdapter ( mAdapter ) ; }
protected Void doInBackground ( Integer . . . args ) { int position = args [ 0 ] ; fileName = fileHistory . getDatabaseAt ( position ) ; keyFile = fileHistory . getKeyfileAt ( position ) ; return null ; }
protected void onResume ( ) { super . onResume ( ) ; if ( fileHistory . hasRecentFiles ( ) ! = recentMode ) { Intent intent = getIntent ( ) ; startActivity ( intent ) ; finish ( ) ; } FileNameView fnv = ( FileNameView ) findViewById ( R . id . file_select ) ; fnv . updateExternalStorageWarning ( ) ; }
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . fileselect , menu ) ; return true ; }
private boolean launchUrl ( int resId ) { try { Util . gotoUrl ( this , resId ) ; } catch ( ActivityNotFoundException e ) { Toast . makeText ( this , R . string . error_failed_to_launch_link , Toast . LENGTH_LONG ) . show ( ) ; return false ; } return true ; }
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super . onCreateContextMenu ( menu , v , menuInfo ) ; menu . add ( 0 , CMENU_CLEAR , 0 , R . string . remove_from_filelist ) ; }
protected java . lang . Void doInBackground ( String . . . args ) { String filename = args [ 0 ] ; fileHistory . deleteFile ( Uri . parse ( args [ 0 ] ) ) ; return null ; }
protected void onPostExecute ( Void v ) { refreshList ( ) ; }
private void refreshList ( ) { ( ( BaseAdapter ) mAdapter ) . notifyDataSetChanged ( ) ; }
private boolean upgradeFromSQL ( ) { try { if ( ! sqlDatabaseExists ( ) ) { return false ; } databases . clear ( ) ; keyfiles . clear ( ) ; FileDbHelper helper = new FileDbHelper ( ctx ) ; helper . open ( ) ; Cursor cursor = helper . fetchAllFiles ( ) ; int dbIndex = cursor . getColumnIndex ( FileDbHelper . KEY_FILE_FILENAME ) ; int keyIndex = cursor . getColumnIndex ( FileDbHelper . KEY_FILE_KEYFILE ) ; if ( cursor . moveToFirst ( ) ) { while ( cursor . moveToNext ( ) ) { String filename = cursor . getString ( dbIndex ) ; String keyfile = cursor . getString ( keyIndex ) ; databases . add ( filename ) ; keyfiles . add ( keyfile ) ; } } savePrefs ( ) ; cursor . close ( ) ; helper . close ( ) ; } catch ( Exception e ) { } try { FileDbHelper . deleteDatabase ( ctx ) ; } catch ( Exception e ) { } return true ; }
private boolean sqlDatabaseExists ( ) { File db = ctx . getDatabasePath ( FileDbHelper . DATABASE_NAME ) ; return db . exists ( ) ; }
public void createFile ( Uri uri , Uri keyUri ) { if ( ! enabled | | uri = = null ) return ; init ( ) ; deleteFile ( uri , false ) ; databases . add ( 0 , uri . toString ( ) ) ; String key = ( keyUri = = null ) ? " " : keyUri . toString ( ) ; keyfiles . add ( 0 , key ) ; trimLists ( ) ; savePrefs ( ) ; }
private void loadPrefs ( ) { loadList ( databases , DB_KEY ) ; loadList ( keyfiles , KEYFILE_KEY ) ; }
private void savePrefs ( ) { saveList ( DB_KEY , databases ) ; saveList ( KEYFILE_KEY , keyfiles ) ; }
public void deleteFile ( Uri uri ) { deleteFile ( uri , true ) ; }
public void deleteAll ( ) { init ( ) ; databases . clear ( ) ; keyfiles . clear ( ) ; savePrefs ( ) ; }
public static void start ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; String sTimeout = prefs . getString ( ctx . getString ( R . string . app_timeout_key ) , ctx . getString ( R . string . clipboard_timeout_default ) ) ; long timeout ; try { timeout = Long . parseLong ( sTimeout ) ; } catch ( NumberFormatException e ) { timeout = DEFAULT_TIMEOUT ; } if ( timeout = = - 1 ) { return ; } long triggerTime = System . currentTimeMillis ( ) + timeout ; AlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; Log . d ( TAG , " Timeout start " ) ; am . set ( AlarmManager . RTC , triggerTime , buildIntent ( ctx ) ) ; }
public static void cancel ( Context ctx ) { AlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; Log . d ( TAG , " Timeout cancel " ) ; am . cancel ( buildIntent ( ctx ) ) ; }
public long readUInt ( ) throws IOException { return readUInt ( baseStream ) ; }
public int readInt ( ) throws IOException { return readInt ( baseStream ) ; }
public long readLong ( ) throws IOException { byte [ ] buf = readBytes ( 8 ) ; return readLong ( buf , 0 ) ; }
public int available ( ) throws IOException { return baseStream . available ( ) ; }
public void close ( ) throws IOException { baseStream . close ( ) ; }
public void mark ( int readlimit ) { baseStream . mark ( readlimit ) ; }
public boolean markSupported ( ) { return baseStream . markSupported ( ) ; }
public int read ( ) throws IOException { return baseStream . read ( ) ; }
public int read ( byte [ ] b , int offset , int length ) throws IOException { return baseStream . read ( b , offset , length ) ; }
public int read ( byte [ ] b ) throws IOException { return super . read ( b ) ; }
public synchronized void reset ( ) throws IOException { baseStream . reset ( ) ; }
public long skip ( long n ) throws IOException { return baseStream . skip ( n ) ; }
public byte [ ] readBytes ( int length ) throws IOException { return readBytes ( baseStream , length ) ; }
public static int readUShort ( InputStream is ) throws IOException { byte [ ] buf = readBytes ( is , 2 ) ; buf = padOut ( buf , 2 ) ; return readUShort ( buf , 0 ) ; }
public int readUShort ( ) throws IOException { return readUShort ( baseStream ) ; }
public static long readUInt ( byte buf [ ] , int offset ) { return ( readInt ( buf , offset ) & INT_TO_LONG_MASK ) ; }
public static int readInt ( InputStream is ) throws IOException { byte [ ] buf = readBytes ( is , 4 ) ; buf = padOut ( buf , 4 ) ; return readInt ( buf , 0 ) ; }
public static long readUInt ( InputStream is ) throws IOException { return ( readInt ( is ) & INT_TO_LONG_MASK ) ; }
public UUID readUUID ( ) throws IOException { byte [ ] buf = readBytes ( 16 ) ; return Types . bytestoUUID ( buf ) ; }
public void flush ( ) throws IOException { os . flush ( ) ; }
public void close ( ) throws IOException { os . close ( ) ; }
public void write ( int oneByte ) throws IOException { mac . update ( ( byte ) oneByte ) ; os . write ( oneByte ) ; }
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { mac . update ( buffer , offset , count ) ; os . write ( buffer , offset , count ) ; }
public void write ( byte [ ] buffer ) throws IOException { mac . update ( buffer , 0 , buffer . length ) ; os . write ( buffer ) ; }
public int read ( ) throws IOException { if ( endOfStream ) return - 1 ; if ( bufferPos = = buffer . length ) { if ( ! readSafeBlock ( ) ) return - 1 ; } int output = Types . readUByte ( buffer , bufferPos ) ; bufferPos + + ; return output ; }
public int read ( byte [ ] outBuffer ) throws IOException { return read ( outBuffer , 0 , outBuffer . length ) ; }
public boolean markSupported ( ) { return false ; }
public void close ( ) throws IOException { baseStream . close ( ) ; }
public long skip ( long byteCount ) throws IOException { return 0 ; }
public int available ( ) throws IOException { return buffer . length - bufferPos ; }
public int available ( ) throws IOException { return is . available ( ) ; }
public void close ( ) throws IOException { is . close ( ) ; }
public void mark ( int readlimit ) { is . mark ( readlimit ) ; }
public boolean markSupported ( ) { return is . markSupported ( ) ; }
public int read ( ) throws IOException { bytes + + ; return is . read ( ) ; }
public int read ( byte [ ] buffer , int offset , int length ) throws IOException { bytes + = length ; return is . read ( buffer , offset , length ) ; }
public int read ( byte [ ] buffer ) throws IOException { bytes + = buffer . length ; return is . read ( buffer ) ; }
public synchronized void reset ( ) throws IOException { is . reset ( ) ; }
public long skip ( long byteCount ) throws IOException { bytes + = byteCount ; return is . skip ( byteCount ) ; }
public void close ( ) throws IOException { super . close ( ) ; mFile . close ( ) ; }
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { super . write ( buffer , offset , count ) ; mFile . write ( buffer , offset , count ) ; }
public void write ( byte [ ] buffer ) throws IOException { super . write ( buffer ) ; mFile . write ( buffer ) ; }
public void write ( int oneByte ) throws IOException { mFile . write ( oneByte ) ; }
public void seek ( long pos ) throws IOException { mFile . seek ( pos ) ; }
public void write ( int oneByte ) throws IOException { byte [ ] buf = new byte [ 1 ] ; buf [ 0 ] = ( byte ) oneByte ; write ( buf , 0 , 1 ) ; }
public void close ( ) throws IOException { if ( bufferPos ! = 0 ) { WriteHashedBlock ( ) ; } WriteHashedBlock ( ) ; flush ( ) ; baseStream . close ( ) ; }
public void flush ( ) throws IOException { baseStream . flush ( ) ; }
public void write ( byte [ ] buffer ) throws IOException { write ( buffer , 0 , buffer . length ) ; }
public int read ( byte [ ] b ) throws IOException { return read ( b , 0 , b . length ) ; }
public long skip ( long n ) throws IOException { return 0 ; }
public int read ( ) throws IOException { if ( atEnd ) return - 1 ; if ( bufferPos = = buffer . length ) { if ( ! ReadHashedBlock ( ) ) return - 1 ; } int output = Types . readUByte ( buffer , bufferPos ) ; bufferPos + + ; return output ; }
public void writeUInt ( long uint ) throws IOException { baseStream . write ( LEDataOutputStream . writeIntBuf ( ( int ) uint ) ) ; }
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { baseStream . write ( buffer , offset , count ) ; }
public void write ( byte [ ] buffer ) throws IOException { baseStream . write ( buffer ) ; }
public void write ( int oneByte ) throws IOException { baseStream . write ( oneByte ) ; }
public void writeLong ( long val ) throws IOException { byte [ ] buf = new byte [ 8 ] ; writeLong ( val , buf , 0 ) ; baseStream . write ( buf ) ; }
public void writeInt ( int val ) throws IOException { byte [ ] buf = new byte [ 4 ] ; writeInt ( val , buf , 0 ) ; baseStream . write ( buf ) ; }
public void writeUShort ( int val ) throws IOException { byte [ ] buf = new byte [ 2 ] ; writeUShort ( val , buf , 0 ) ; baseStream . write ( buf ) ; }
public static byte [ ] writeIntBuf ( int val ) { byte [ ] buf = new byte [ 4 ] ; writeInt ( val , buf , 0 ) ; return buf ; }
public static byte [ ] writeUShortBuf ( int val ) { byte [ ] buf = new byte [ 2 ] ; writeUShort ( val , buf , 0 ) ; return buf ; }
public static byte [ ] writeLongBuf ( long val ) { byte [ ] buf = new byte [ 8 ] ; writeLong ( val , buf , 0 ) ; return buf ; }
public void close ( ) throws IOException { super . close ( ) ; }
public void flush ( ) throws IOException { super . flush ( ) ; }
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { super . write ( buffer , offset , count ) ; }
public void write ( byte [ ] buffer ) throws IOException { super . write ( buffer ) ; }
public void close ( ) throws IOException { is . close ( ) ; os . close ( ) ; }
public int read ( ) throws IOException { int data = is . read ( ) ; if ( data ! = - 1 ) { os . write ( data ) ; } return data ; }
public int read ( byte [ ] b , int offset , int length ) throws IOException { int len = is . read ( b , offset , length ) ; if ( len ! = - 1 ) { os . write ( b , offset , len ) ; } return len ; }
public int read ( byte [ ] b ) throws IOException { int len = is . read ( b ) ; if ( len ! = - 1 ) { os . write ( b , 0 , len ) ; } return len ; }
public long skip ( long byteCount ) throws IOException { return is . skip ( byteCount ) ; }
public void close ( ) throws IOException { os . close ( ) ; }
public void flush ( ) throws IOException { os . flush ( ) ; }
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { bytes + = count ; os . write ( buffer , offset , count ) ; }
public void write ( byte [ ] buffer ) throws IOException { bytes + = buffer . length ; os . write ( buffer ) ; }
public void write ( int oneByte ) throws IOException { bytes + + ; os . write ( oneByte ) ; }
public int read ( byte [ ] b ) throws IOException { return read ( b , 0 , b . length ) ; }
public int available ( ) throws IOException { return 0 ; }
public void close ( ) throws IOException { if ( bufferPos = = 0 ) { WriteSafeBlock ( ) ; } else { WriteSafeBlock ( ) ; WriteSafeBlock ( ) ; } baseStream . flush ( ) ; ; baseStream . close ( ) ; }
public void flush ( ) throws IOException { baseStream . flush ( ) ; }
public void write ( byte [ ] outBuffer ) throws IOException { write ( outBuffer , 0 , outBuffer . length ) ; }
public void write ( int oneByte ) throws IOException { byte [ ] outByte = new byte [ 1 ] ; write ( outByte , 0 , 1 ) ; }
public static byte [ ] GetHmacKey64 ( byte [ ] key , long blockIndex ) { MessageDigest hash ; try { hash = MessageDigest . getInstance ( " SHA - 512 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } NullOutputStream nos = new NullOutputStream ( ) ; DigestOutputStream dos = new DigestOutputStream ( nos , hash ) ; LEDataOutputStream leos = new LEDataOutputStream ( dos ) ; try { leos . writeLong ( blockIndex ) ; leos . write ( key ) ; leos . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } byte [ ] hashKey = hash . digest ( ) ; assert ( hashKey . length = = 64 ) ; return hashKey ; }
public static boolean checkAndRequest ( Activity act , int reqId ) { boolean hasRead = ContextCompat . checkSelfPermission ( act , Manifest . permission . READ_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; boolean hasWrite = ContextCompat . checkSelfPermission ( act , Manifest . permission . WRITE_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; if ( ! hasRead | | ! hasWrite ) { ActivityCompat . requestPermissions ( act , READ_WRITE_PERMISSIONS , reqId ) ; return false ; } return true ; }
public static void copyToClipboard ( Context context , String label , String text ) throws SamsungClipboardException { copyToClipboard ( context , label , text , false ) ; }
public static void gotoUrl ( Context context , int resId ) throws ActivityNotFoundException { gotoUrl ( context , context . getString ( resId ) ) ; }
public static boolean isNullOrEmpty ( String str ) { return ( str = = null ) | | ( str . length ( ) = = 0 ) ; }
public static boolean isNullOrEmpty ( byte [ ] buf ) { return ( buf = = null ) | | ( buf . length = = 0 ) ; }
public static boolean isNullOrEmpty ( PwDate date ) { return ( date = = null ) | | date . equals ( PwEntryV3 . DEFAULT_PWDATE ) ; }
public static boolean isNullOrEmpty ( Uri uri ) { return ( uri = = null ) | | ( uri . toString ( ) . length ( ) = = 0 ) ; }
public static byte [ ] decompress ( byte [ ] input ) throws IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; GZIPInputStream gzis = new GZIPInputStream ( bais ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; Util . copyStream ( gzis , baos ) ; return baos . toByteArray ( ) ; }
public static byte [ ] compress ( byte [ ] input ) throws IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gzos = new GZIPOutputStream ( baos ) ; Util . copyStream ( bais , gzos ) ; gzos . close ( ) ; return baos . toByteArray ( ) ; }
public static Date convertKDBX4Time ( long seconds ) { DateTime dt = dotNetEpoch . plus ( seconds * 1000L ) ; if ( dt . isBefore ( javaEpoch ) ) { return javaEpoch . toDate ( ) ; } return dt . toDate ( ) ; }
public static int readUByte ( byte [ ] buf , int offset ) { return ( ( int ) buf [ offset ] & 0xFF ) ; }
public static void writeUByte ( int val , byte [ ] buf , int offset ) { buf [ offset ] = ( byte ) ( val & 0xFF ) ; }
public static byte writeUByte ( int val ) { byte [ ] buf = new byte [ 1 ] ; writeUByte ( val , buf , 0 ) ; return buf [ 0 ] ; }
public static int strlen ( byte [ ] buf , int offset ) { int len = 0 ; while ( buf [ offset + len ] ! = 0 ) len + + ; return len ; }
public static byte [ ] extract ( byte [ ] b , int offset , int len ) { byte [ ] b2 = new byte [ len ] ; System . arraycopy ( b , offset , b2 , 0 , len ) ; return b2 ; }
public static String readCString ( byte [ ] buf , int offset ) throws UnsupportedEncodingException { String jstring = new String ( buf , offset , strlen ( buf , offset ) , " UTF - 8 " ) ; if ( REPLACE ) { jstring = jstring . replace ( CRLF , SEP ) ; } return jstring ; }
public static int writeCString ( String str , OutputStream os ) throws IOException { if ( str = = null ) { os . write ( LEDataOutputStream . writeIntBuf ( 1 ) ) ; os . write ( 0x00 ) ; return 0 ; } if ( REPLACE ) { str = str . replace ( SEP , CRLF ) ; } byte [ ] initial = str . getBytes ( " UTF - 8 " ) ; int length = initial . length + 1 ; os . write ( LEDataOutputStream . writeIntBuf ( length ) ) ; os . write ( initial ) ; os . write ( 0x00 ) ; return length ; }
public static UUID bytestoUUID ( byte [ ] buf ) { return bytestoUUID ( buf , 0 ) ; }
public static byte [ ] UUIDtoBytes ( UUID uuid ) { byte [ ] buf = new byte [ 16 ] ; LEDataOutputStream . writeLong ( uuid . getMostSignificantBits ( ) , buf , 0 ) ; LEDataOutputStream . writeLong ( uuid . getLeastSignificantBits ( ) , buf , 8 ) ; return buf ; }
public static int indexOfIgnoreCase ( String text , String search , int start , Locale locale ) { if ( text = = null | | search = = null ) return - 1 ; return text . toLowerCase ( locale ) . indexOf ( search . toLowerCase ( locale ) , start ) ; }
public static int indexOfIgnoreCase ( String text , String search , Locale locale ) { return indexOfIgnoreCase ( text , search , 0 , locale ) ; }
public String compile ( String text , PwEntry entry , PwDatabase database ) { return text ; }
public static boolean equalsDefaultfile ( Uri left , String right ) { if ( left = = null | | right = = null ) { return false ; } left = parseDefaultFile ( left ) ; Uri uriRight = parseDefaultFile ( right ) ; return left . equals ( uriRight ) ; }
public static Uri translate ( Context ctx , Uri uri ) { if ( StorageAF . useStorageFramework ( ctx ) | | hasWritableContentUri ( uri ) ) { return uri ; } String scheme = uri . getScheme ( ) ; if ( EmptyUtils . isNullOrEmpty ( scheme ) ) { return uri ; } String filepath = null ; try { if ( scheme . equalsIgnoreCase ( " content " ) ) { Cursor cursor = ctx . getContentResolver ( ) . query ( uri , new String [ ] { android . provider . MediaStore . Images . ImageColumns . DATA } , null , null , null ) ; cursor . moveToFirst ( ) ; if ( cursor ! = null ) { filepath = cursor . getString ( 0 ) ; cursor . close ( ) ; if ( ! isValidFilePath ( filepath ) ) { filepath = null ; } } } if ( EmptyUtils . isNullOrEmpty ( filepath ) ) { filepath = uri . getEncodedPath ( ) ; if ( ! isValidFilePath ( filepath ) ) { filepath = null ; } } } catch ( Exception e ) { filepath = null ; } if ( ! EmptyUtils . isNullOrEmpty ( filepath ) ) { Uri . Builder b = new Uri . Builder ( ) ; uri = b . scheme ( " file " ) . authority ( " " ) . path ( filepath ) . build ( ) ; } return uri ; }
private static boolean isValidFilePath ( String filepath ) { if ( EmptyUtils . isNullOrEmpty ( filepath ) ) { return false ; } File file = new File ( filepath ) ; return file . exists ( ) & & file . canRead ( ) ; }
public String compile ( String text , PwEntry entry , PwDatabase database ) { SprContextV4 ctx = new SprContextV4 ( ( PwDatabaseV4 ) database , ( PwEntryV4 ) entry ) ; return compileInternal ( text , ctx , 0 ) ; }
public PwGroup search ( Database db , String qStr ) { PwDatabase pm = db . pm ; PwGroup group ; if ( pm instanceof PwDatabaseV3 ) { group = new PwGroupV3 ( ) ; } else if ( pm instanceof PwDatabaseV4 ) { group = new PwGroupV4 ( ) ; } else { Log . d ( " SearchDbHelper " , " Tried to search with unknown db " ) ; return null ; } group . name = mCtx . getString ( R . string . search_results ) ; group . childEntries = new ArrayList < PwEntry > ( ) ; Locale loc = Locale . getDefault ( ) ; qStr = qStr . toLowerCase ( loc ) ; boolean isOmitBackup = omitBackup ( ) ; Queue < PwGroup > worklist = new LinkedList < PwGroup > ( ) ; if ( pm . rootGroup ! = null ) { worklist . add ( pm . rootGroup ) ; } while ( worklist . size ( ) ! = 0 ) { PwGroup top = worklist . remove ( ) ; if ( pm . isGroupSearchable ( top , isOmitBackup ) ) { for ( PwEntry entry : top . childEntries ) { processEntries ( entry , group . childEntries , qStr , loc ) ; } for ( PwGroup childGroup : top . childGroups ) { if ( childGroup ! = null ) { worklist . add ( childGroup ) ; } } } } return group ; }
private void performSearch ( String query ) { query ( query . trim ( ) ) ; }
public void show ( Context ctx , DialogInterface . OnClickListener onclick ) { show ( ctx , onclick , false ) ; }
public void onClick ( DialogInterface dialog , int which ) { dialog . cancel ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { dismiss ( ) ; }
public void onClick ( DialogInterface dialog , int which ) { Context ctx = getContext ( ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor edit = prefs . edit ( ) ; edit . putBoolean ( ctx . getString ( showKey ) , false ) ; edit . commit ( ) ; dismiss ( ) ; }
public boolean isFingerprintInitialized ( ) { return initOk ; }
public boolean initEncryptData ( ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( biometricCallback ! = null ) { biometricCallback . onException ( ) ; } return false ; } try { initEncryptKey ( false ) ; return true ; } catch ( final InvalidKeyException invalidKeyException ) { try { biometricCallback . onKeyInvalidated ( ) ; initEncryptKey ( true ) ; } catch ( InvalidKeyException e ) { biometricCallback . onInvalidKeyException ( ) ; } catch ( Exception e ) { biometricCallback . onException ( ) ; ; } } catch ( final Exception e ) { biometricCallback . onException ( ) ; } return false ; }
public boolean initDecryptData ( final String ivSpecValue ) { cryptoInitOk = false ; try { initDecryptKey ( ivSpecValue , false ) ; return true ; } catch ( final InvalidKeyException invalidKeyException ) { try { biometricCallback . onKeyInvalidated ( ) ; initDecryptKey ( ivSpecValue , true ) ; } catch ( InvalidKeyException e ) { biometricCallback . onInvalidKeyException ( ) ; } catch ( Exception e ) { biometricCallback . onException ( ) ; } } catch ( final Exception e ) { biometricCallback . onException ( ) ; } return false ; }
public void assignDrawableTo ( ImageView iv , Resources res , PwIcon icon ) { Drawable draw = getIconDrawable ( res , icon ) ; iv . setImageDrawable ( draw ) ; }
private Bitmap resize ( Bitmap bitmap ) { int width = bitmap . getWidth ( ) ; int height = bitmap . getHeight ( ) ; if ( width = = blankWidth & & height = = blankHeight ) { return bitmap ; } return Bitmap . createScaledBitmap ( bitmap , blankWidth , blankHeight , true ) ; }
public void clear ( ) { standardIconMap . clear ( ) ; customIconMap . clear ( ) ; }
public static int iconToResId ( int iconId ) { buildList ( ) ; return icons . get ( iconId , R . drawable . ic99_blank ) ; }
public static int count ( ) { buildList ( ) ; return icons . size ( ) ; }
protected void inflate ( LayoutInflater inflater , Context context , String title , String value ) { inflater . inflate ( getLayout ( ) , this ) ; setText ( R . id . title , title ) ; setText ( R . id . value , value ) ; }
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . file_selection_filename , this ) ; }
public void updateExternalStorageWarning ( ) { int warning = - 1 ; String state = Environment . getExternalStorageState ( ) ; if ( state . equals ( Environment . MEDIA_MOUNTED_READ_ONLY ) ) { warning = R . string . warning_read_only ; } else if ( ! state . equals ( Environment . MEDIA_MOUNTED ) ) { warning = R . string . warning_unmounted ; } TextView tv = ( TextView ) findViewById ( R . id . label_warning ) ; TextView label = ( TextView ) findViewById ( R . id . label_open_by_filename ) ; RelativeLayout . LayoutParams lp = new RelativeLayout . LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ; if ( warning ! = - 1 ) { tv . setText ( warning ) ; tv . setVisibility ( VISIBLE ) ; lp . addRule ( RelativeLayout . BELOW , R . id . label_warning ) ; } else { tv . setVisibility ( INVISIBLE ) ; } label . setLayoutParams ( lp ) ; }
private void populateView ( View ev , PwEntry pw , int pos ) { mPw = pw ; mPos = pos ; ImageView iv = ( ImageView ) ev . findViewById ( R . id . entry_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , pw . getIcon ( ) ) ; mTv . setText ( mPw . getDisplayTitle ( ) ) ; }
public void convertView ( PwEntry pw , int pos ) { populateView ( this , pw , pos ) ; }
public void refreshTitle ( ) { mTv . setText ( mPw . getDisplayTitle ( ) ) ; }
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . entry_view_contents , this ) ; }
protected LayoutParams generateDefaultLayoutParams ( ) { return new LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ; }
private void populateView ( View gv , PwGroup pw ) { mPw = pw ; ImageView iv = ( ImageView ) gv . findViewById ( R . id . group_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , pw . getIcon ( ) ) ; mTv . setText ( pw . getName ( ) ) ; }
public void convertView ( PwGroup pw ) { populateView ( this , pw ) ; }
private void launchGroup ( ) { GroupActivity . Launch ( mAct , mPw ) ; }
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { menu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; }
public void onCreate ( ) { String defaultPrefs = this . getPackageName ( ) + " _preferences " ; SharedPreferencesBackupHelper prefHelper = new SharedPreferencesBackupHelper ( this , defaultPrefs ) ; addHelper ( PREFS_BACKUP_KEY , prefHelper ) ; }
private void putType ( byte type , String name , Object value ) { dict . put ( name , new VdType ( type , value ) ) ; }
public int size ( ) { return dict . size ( ) ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; }
protected void onStart ( ) { super . onStart ( ) ; startFileSelect ( ) ; }
private void startFileSelect ( ) { Intent intent = new Intent ( this , FileSelectActivity . class ) ; startActivityForResult ( intent , 0 ) ; }
public void setup ( ) { context = Context . enter ( ) ; tz = TimeZone . getDefault ( ) ; TimeZone . setDefault ( TimeZone . getTimeZone ( " Europe / London " ) ) ; }
public void teardown ( ) { TimeZone . setDefault ( tz ) ; Context . exit ( ) ; }
public void testSingleDocumentReturn ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { return new Document ( ) ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . get ( " _id " ) , is ( " hello " ) ) ; }
public void testMultipleDocumentReturn ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { var ret = new Array ( ) ; ret . push ( new Document ( ) ) ; ret . push ( new Document ( ) ) ; return ret ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 2 ) ) ; assertThat ( result . iterator ( ) . next ( ) . get ( " _id " ) , is ( " hello " ) ) ; }
public void testAdd ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { var ret = new Document ( ) ; ret . add ( doc . key ) ; return ret ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " , key : \ " value \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . get ( Constants . DEFAULT_FIELD ) , is ( " value " ) ) ; }
public void testForLoopOverObject ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { var ret = new Document ( ) ; for ( var key in doc ) { ret . add ( doc [ key ] ) ; } return ret ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " , key : \ " value \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . get ( " _id " ) , is ( " hello " ) ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( Constants . DEFAULT_FIELD ) [ 0 ] , is ( " hello " ) ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( Constants . DEFAULT_FIELD ) [ 1 ] , is ( " value " ) ) ; }
public void testForLoopOverArray ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { var ret = new Document ( ) ; for ( var key in doc . arr ) { ret . add ( doc . arr [ key ] ) ; } return ret ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " , arr : [ 0 , 1 , 2 , 3 ] } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . get ( " _id " ) , is ( " hello " ) ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( Constants . DEFAULT_FIELD ) [ 0 ] , is ( " 0 " ) ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( Constants . DEFAULT_FIELD ) [ 1 ] , is ( " 1 " ) ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( Constants . DEFAULT_FIELD ) [ 2 ] , is ( " 2 " ) ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( Constants . DEFAULT_FIELD ) [ 3 ] , is ( " 3 " ) ) ; }
public void testForEverything ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { var ret = new Document ( ) ; " + " function idx ( obj ) { for ( var key in obj ) " + " { switch ( typeof obj [ key ] ) { case ' object ' : idx ( obj [ key ] ) ; break ; " + " case ' function ' : break ; default : ret . add ( obj [ key ] ) ; break ; } } } ; idx ( doc ) ; return ret ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " , l1 : { l2 : { l3 : [ \ " v3 \ " , \ " v4 \ " ] } } } " ) , settings ( ) , null ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( Constants . DEFAULT_FIELD ) , hasItemInArray ( " hello " ) ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( Constants . DEFAULT_FIELD ) , hasItemInArray ( " v3 " ) ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( Constants . DEFAULT_FIELD ) , hasItemInArray ( " v4 " ) ) ; }
public void testNullReturn ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { return null ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 0 ) ) ; }
public void testUndefinedReturn ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { return doc . nope ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 0 ) ) ; }
public void testRuntimeException ( ) throws Exception { LOG . warn ( " You can ignore the following exception stack trace . " ) ; final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { throw { bad : \ " stuff \ " } } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " } " ) , settings ( ) , null ) ; LOG . warn ( " You can ignore the preceding exception stack trace . " ) ; assertThat ( result . size ( ) , is ( 0 ) ) ; }
public void testJSONStringify ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { var ret = new Document ( ) ; " + " ret . add ( JSON . stringify ( { \ " foo \ " : \ " bar \ " } ) , { \ " field \ " : \ " s \ " , \ " store \ " : \ " yes \ " } ) ; return ret ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . getValues ( " s " ) [ 0 ] , is ( " { \ " foo \ " : \ " bar \ " } " ) ) ; }
public void testBadCode ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { if ( doc . ) return null ; } " ) ) ; converter . convert ( doc ( " { _id : \ " hello \ " } " ) , settings ( ) , null ) ; }
public void testNullAddsAreIgnored ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " function ( doc ) { var ret = new Document ( ) ; ret . add ( doc . nope ) ; return ret ; } " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; }
public void testQuoteRemoval ( ) throws Exception { final DocumentConverter converter = new DocumentConverter ( context , view ( " \ " function ( doc ) { return new Document ( ) ; } \ " " ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hello \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . get ( " _id " ) , is ( " hello " ) ) ; }
public void testNoReturnValue ( ) throws Exception { final String fun = " function ( doc ) { } " ; final DocumentConverter converter = new DocumentConverter ( context , view ( fun ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hi \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 0 ) ) ; }
public void testDefaultValue ( ) throws Exception { final String fun = " function ( doc ) { var ret = new Document ( ) ; ret . add ( doc [ ' arr ' ] . join ( ' ' ) ) ; return ret ; } " ; final DocumentConverter converter = new DocumentConverter ( context , view ( fun ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hi \ " , arr : [ \ " 1 \ " , \ " 2 \ " ] } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . get ( " default " ) , is ( " 1 2 " ) ) ; }
public void testNullValue ( ) throws Exception { final String fun = " function ( doc ) { var ret = new Document ( ) ; ret . add ( doc . foo ) ; return ret ; } " ; final DocumentConverter converter = new DocumentConverter ( context , view ( fun ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hi \ " , foo : null } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . get ( " foo " ) , is ( nullValue ( ) ) ) ; }
public void testLongValue ( ) throws Exception { final String fun = " function ( doc ) { var ret = new Document ( ) ; ret . add ( 12 , { type : \ " long \ " , field : \ " num \ " } ) ; return ret ; } " ; final DocumentConverter converter = new DocumentConverter ( context , view ( fun ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hi \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . getField ( " num " ) , is ( LongPoint . class ) ) ; }
public void testDateString ( ) throws Exception { final String fun = " function ( doc ) { var ret = new Document ( ) ; ret . add ( \ " 2009 - 01 - 01 \ " , { type : \ " date \ " , field : \ " num \ " } ) ; return ret ; } " ; final DocumentConverter converter = new DocumentConverter ( context , view ( fun ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hi \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . getField ( " num " ) , is ( LongPoint . class ) ) ; }
public void testDateObject ( ) throws Exception { final String fun = " function ( doc ) { var ret = new Document ( ) ; ret . add ( new Date ( 2010 , 8 , 13 ) , { type : \ " date \ " , field : \ " num \ " } ) ; return ret ; } " ; final DocumentConverter converter = new DocumentConverter ( context , view ( fun ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hi \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . getField ( " num " ) , is ( LongPoint . class ) ) ; assertThat ( ( Long ) ( result . iterator ( ) . next ( ) . getField ( " num " ) ) . numericValue ( ) , is ( 1284332400000L ) ) ; }
public void testDateObject2 ( ) throws Exception { final String fun = " function ( doc ) { var ret = new Document ( ) ; ret . add ( new Date ( \ " January 6 , 1972 16 : 05 : 00 \ " ) , { type : \ " date \ " , field : \ " num \ " } ) ; return ret ; } " ; final DocumentConverter converter = new DocumentConverter ( context , view ( fun ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hi \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . getField ( " num " ) , is ( LongPoint . class ) ) ; assertThat ( ( Long ) ( result . iterator ( ) . next ( ) . getField ( " num " ) ) . numericValue ( ) , is ( 63561900000L ) ) ; }
public void testParseInt ( ) throws Exception { final String fun = " function ( doc ) { var ret = new Document ( ) ; ret . add ( parseInt ( \ " 12 . 5 \ " ) , { type : \ " int \ " , field : \ " num \ " } ) ; return ret ; } " ; final DocumentConverter converter = new DocumentConverter ( context , view ( fun ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hi \ " } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 1 ) ) ; assertThat ( result . iterator ( ) . next ( ) . getField ( " num " ) , is ( IntPoint . class ) ) ; }
public void testConditionalOnNulls ( ) throws Exception { final String fun = " function ( doc ) { if ( doc . foo & & doc . bar ) { return new Document ( ) ; } ; return null ; } " ; final DocumentConverter converter = new DocumentConverter ( context , view ( fun ) ) ; final Collection < Document > result = converter . convert ( doc ( " { _id : \ " hi \ " , foo : null , bar : null } " ) , settings ( ) , null ) ; assertThat ( result . size ( ) , is ( 0 ) ) ; }
private CouchDocument doc ( final String json ) throws JSONException { return new CouchDocument ( new JSONObject ( json ) ) ; }
private ViewSettings settings ( ) { return ViewSettings . getDefaultSettings ( ) ; }
private View view ( final String fun ) throws JSONException { final JSONObject json = new JSONObject ( ) ; json . put ( " index " , fun ) ; return new View ( null , json ) ; }
public void setup ( ) { parser = new CustomQueryParser ( " default " , new StandardAnalyzer ( ) ) ; }
public void integerRangeQuery ( ) throws Exception { final Query q = parser . parse ( " blah < int > : [ 0 TO 123 ] " ) ; assertRange ( q , Integer . class , 0 , 123 ) ; }
public void longRangeQuery ( ) throws Exception { final Query q = parser . parse ( " blah < long > : [ 0 TO 123 ] " ) ; assertRange ( q , Long . class , 0L , 123L ) ; }
public void floatRangeQuery ( ) throws Exception { final Query q = parser . parse ( " blah < float > : [ 0 . 0 TO 123 . 5 ] " ) ; assertRange ( q , Float . class , 0 . 0f , 123 . 5f ) ; }
public void doubleRangeQuery ( ) throws Exception { final Query q = parser . parse ( " blah < double > : [ 0 . 0 TO 123 . 0 ] " ) ; assertRange ( q , Double . class , 0 . 0 , 123 . 0 ) ; }
public void dateRangeQuery ( ) throws Exception { final Query q = parser . parse ( " blah < date > : [ 2000 - 01 - 01 TO 2010 - 02 - 04 ] " ) ; assertRange ( q , Long . class , time ( " 2000 - 01 - 01 " ) , time ( " 2010 - 02 - 04 " ) ) ; }
public void dateTimeRangeQuery ( ) throws Exception { final Query q = parser . parse ( " blah < date > : [ 2000 - 01 - 01T00 : 00 : 01 TO 2010 - 02 - 04T00 : 00 : 01 ] " ) ; assertRange ( q , Long . class , time ( " 2000 - 01 - 01T00 : 00 : 01 " ) , time ( " 2010 - 02 - 04T00 : 00 : 01 " ) ) ; }
public void dateTimeZoneRangeQuery ( ) throws Exception { final Query q = parser . parse ( " blah < date > : [ 2000 - 01 - 01 - 0100 TO 2010 - 02 - 04 - 0100 ] " ) ; assertRange ( q , Long . class , time ( " 2000 - 01 - 01 - 0100 " ) , time ( " 2010 - 02 - 04 - 0100 " ) ) ; }
public void dateTimeTimeZoneRangeQuery ( ) throws Exception { final Query q = parser . parse ( " blah < date > : [ 2000 - 01 - 01T00 : 00 : 00 - 0100 TO 2010 - 02 - 04T00 : 00 : 00 - 0100 ] " ) ; assertRange ( q , Long . class , time ( " 2000 - 01 - 01T00 : 00 : 00 - 0100 " ) , time ( " 2010 - 02 - 04T00 : 00 : 00 - 0100 " ) ) ; }
public void fieldNameWithDashes ( ) throws Exception { final Query q = parser . parse ( " foo - bar : baz " ) ; assertThat ( q , is ( TermQuery . class ) ) ; }
public void fieldNameWithEscapedSpaces ( ) throws Exception { final Query q = parser . parse ( " foo \ \ bar : baz " ) ; assertThat ( q , is ( TermQuery . class ) ) ; }
private long time ( final String str ) throws ParseException { return FieldType . toDate ( str ) ; }
private void assertRange ( final Query q , final Class < ? > type , final Number min , final Number max ) { assertThat ( q , is ( PointRangeQuery . class ) ) ; }
public void testSearchPath ( ) { final PathParts parts = new PathParts ( " / local / db1 / _design / foo / by_subject " ) ; assertThat ( parts . getKey ( ) , is ( " local " ) ) ; assertThat ( parts . getDatabaseName ( ) , is ( " db1 " ) ) ; assertThat ( parts . getDesignDocumentName ( ) , is ( " _design / foo " ) ) ; assertThat ( parts . getViewName ( ) , is ( " by_subject " ) ) ; assertThat ( parts . getCommand ( ) , is ( nullValue ( ) ) ) ; }
public void testCommandPath ( ) { final PathParts parts = new PathParts ( " / local / db1 / _design / foo / by_subject / _expunge " ) ; assertThat ( parts . getKey ( ) , is ( " local " ) ) ; assertThat ( parts . getDatabaseName ( ) , is ( " db1 " ) ) ; assertThat ( parts . getDesignDocumentName ( ) , is ( " _design / foo " ) ) ; assertThat ( parts . getViewName ( ) , is ( " by_subject " ) ) ; assertThat ( parts . getCommand ( ) , is ( " _expunge " ) ) ; }
public void testCleanupPath ( ) { final PathParts parts = new PathParts ( " / local / db1 / _cleanup " ) ; assertThat ( parts . getKey ( ) , is ( " local " ) ) ; assertThat ( parts . getDatabaseName ( ) , is ( " db1 " ) ) ; assertThat ( parts . getCommand ( ) , is ( " _cleanup " ) ) ; }
public void testEscapedChars ( ) throws Exception { final String str = " { \ " seq \ " : 1503 , \ " id \ " : \ " 11dca825e8b19e40bd675345e05afa24 \ " , \ " changes \ " : [ { \ " rev \ " : \ " 2 - bb1fba3e33ed2e8b78412fe27c8c6474 \ " } ] , \ " doc \ " : { \ " _id \ " : \ " 11dca825e8b19e40bd675345e05afa24 \ " , \ " _rev \ " : \ " 2 - bb1fba3e33ed2e8b78412fe27c8c6474 \ " , \ " query_params \ " : { \ " { \ \ \ " action \ \ \ " : \ \ \ " answer \ \ \ " , \ \ \ " session - id \ \ \ " : 41 , \ \ \ " answer \ \ \ " : 5 } \ " : \ " \ " } , \ " stack_trace \ " : \ " File \ \ \ " / usr / local / lib / python2 . 6 / dist - packages / Django - 1 . 2 . 1 - py2 . 6 . egg / django / core / handlers / base . py \ \ \ " , line 95 , in get_response \ \ n response = middleware_method ( request , callback , callback_args , callback_kwargs ) \ \ n File \ \ \ " / var / src / bhoma / bhoma / middleware . py \ \ \ " , line 37 , in process_view \ \ n return login_required ( view_func ) ( request , * view_args , * * view_kwargs ) \ \ n File \ \ \ " / usr / local / lib / python2 . 6 / dist - packages / Django - 1 . 2 . 1 - py2 . 6 . egg / django / contrib / auth / decorators . py \ \ \ " , line 25 , in _wrapped_view \ \ n return view_func ( request , * args , * * kwargs ) \ \ n File \ \ \ " / var / src / bhoma / bhoma / apps / xforms / views . py \ \ \ " , line 74 , in player_proxy \ \ n response , errors = post_data ( data , settings . XFORMS_PLAYER_URL , content_type = \ \ \ " text / json \ \ \ " ) \ \ n File \ \ \ " / var / src / bhoma / bhoma / utils / post . py \ \ \ " , line 34 , in post_data \ \ n \ " , \ " doc_type \ " : \ " ExceptionRecord \ " , \ " url \ " : \ " http : / / 10 . 10 . 10 . 10 / xforms / player_proxy \ " , \ " clinic_id \ " : \ " 5010110 \ " , \ " date \ " : \ " 2010 - 09 - 08T14 : 39 : 11Z \ " , \ " message \ " : \ " [ Errno 24 ] Too many open files : ' / tmp / tmp8xIQb7 ' \ " , \ " type \ " : \ " < type ' exceptions . IOError ' > \ " } } " ; new JSONObject ( str ) ; }
public void setup ( ) { doc = new Document ( ) ; }
public void testPDF ( ) throws IOException { parse ( " paxos - simple . pdf " , " application / pdf " , " foo " ) ; assertThat ( doc . getField ( " foo " ) , not ( nullValue ( ) ) ) ; }
public void testXML ( ) throws IOException { parse ( " example . xml " , " text / xml " , " bar " ) ; assertThat ( doc . getField ( " bar " ) , not ( nullValue ( ) ) ) ; }
public void testWord ( ) throws IOException { parse ( " example . doc " , " application / msword " , " bar " ) ; assertThat ( doc . getField ( " bar " ) , not ( nullValue ( ) ) ) ; assertThat ( doc . get ( " bar " ) , containsString ( " The express mission of the organization " ) ) ; }
public void couchdbSequence ( ) { assertThat ( UpdateSequence . parseUpdateSequence ( " 1234 " ) , notNullValue ( ) ) ; }
public void noIndex ( ) throws Exception { new View ( null , new JSONObject ( " { } " ) ) ; }
public void index ( ) throws Exception { final JSONObject json = new JSONObject ( ) ; json . put ( " index " , " function ( doc ) { return null ; } " ) ; new View ( null , json ) ; }
public void notValidDocument ( ) throws Exception { new CouchDocument ( new JSONObject ( " { } " ) ) ; }
public void validDocument ( ) throws Exception { final CouchDocument doc = new CouchDocument ( new JSONObject ( " { _id : \ " hello \ " } " ) ) ; assertThat ( doc . getId ( ) , is ( " hello " ) ) ; }
public void asJson ( ) throws Exception { final JSONObject json = new JSONObject ( " { _id : \ " hello \ " } " ) ; final CouchDocument doc = new CouchDocument ( json ) ; assertThat ( doc . asJson ( ) , is ( json ) ) ; }
public void notDesignDocument ( ) throws Exception { new DesignDocument ( new JSONObject ( " { _id : \ " hello \ " } " ) ) ; }
public void noViews ( ) throws Exception { final DesignDocument ddoc = new DesignDocument ( new JSONObject ( " { _id : \ " _design / hello \ " } " ) ) ; assertThat ( ddoc . getAllViews ( ) . size ( ) , is ( 0 ) ) ; }
public void views ( ) throws Exception { final JSONObject view = new JSONObject ( ) ; view . put ( " index " , " function ( doc ) { return null ; } " ) ; final JSONObject fulltext = new JSONObject ( ) ; fulltext . put ( " foo " , view ) ; final JSONObject json = new JSONObject ( ) ; json . put ( " _id " , " _design / hello " ) ; json . put ( " fulltext " , fulltext ) ; final DesignDocument ddoc = new DesignDocument ( json ) ; assertThat ( ddoc . getView ( " foo " ) , notNullValue ( ) ) ; assertThat ( ddoc . getAllViews ( ) . size ( ) , is ( 1 ) ) ; }
public void testSplitOnCommas ( ) { assertArrayEquals ( new String [ ] { " foo " , " bar " } , Utils . splitOnCommas ( " foo , bar " ) ) ; }
public void testSplitOnCommasWithEmbeddedCommas ( ) { assertArrayEquals ( new String [ ] { " \ " fo , o \ " " , " bar " } , Utils . splitOnCommas ( " \ " fo , o \ " , bar " ) ) ; }
public void testStandard ( ) throws Exception { assertThat ( Analyzers . getAnalyzer ( " standard " ) , is ( StandardAnalyzer . class ) ) ; }
public void testFrench ( ) throws Exception { assertThat ( Analyzers . getAnalyzer ( " french " ) , is ( FrenchAnalyzer . class ) ) ; }
public void testWhitespace ( ) throws Exception { assertThat ( Analyzers . getAnalyzer ( " whitespace " ) , is ( WhitespaceAnalyzer . class ) ) ; }
public void testPerField ( ) throws Exception { final Analyzer analyzer = Analyzers . getAnalyzer ( " perfield : { name : \ " standard \ " , age : \ " keyword \ " } " ) ; assertThat ( analyzer , is ( PerFieldAnalyzerWrapper . class ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " default = org . apache . lucene . analysis . standard . StandardAnalyzer " ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " name = org . apache . lucene . analysis . standard . StandardAnalyzer " ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " age = org . apache . lucene . analysis . core . KeywordAnalyzer " ) ) ; }
public void testPerFieldDefault ( ) throws Exception { final Analyzer analyzer = Analyzers . getAnalyzer ( " perfield : { default : \ " keyword \ " } " ) ; assertThat ( analyzer , is ( PerFieldAnalyzerWrapper . class ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " default = org . apache . lucene . analysis . core . KeywordAnalyzer " ) ) ; }
public void testNGramInstance ( ) throws Exception { final Analyzer analyzer = Analyzers . getAnalyzer ( " ngram " ) ; assertThat ( analyzer . toString ( ) , containsString ( " NGramAnalyzer " ) ) ; }
public void testClassInstance ( ) throws Exception { final JSONObject obj = new JSONObject ( " { \ " class \ " : \ " org . apache . lucene . analysis . core . KeywordAnalyzer \ " } " ) ; final Analyzer analyzer = Analyzers . getAnalyzer ( obj ) ; assertThat ( analyzer , is ( KeywordAnalyzer . class ) ) ; }
public void testClassInstance2 ( ) throws Exception { final JSONObject obj = new JSONObject ( " { \ " class \ " : \ " org . apache . lucene . analysis . nl . DutchAnalyzer \ " , \ " params \ " : [ ] } " ) ; final Analyzer analyzer = Analyzers . getAnalyzer ( obj ) ; assertThat ( analyzer , is ( org . apache . lucene . analysis . nl . DutchAnalyzer . class ) ) ; }
public void testClassInstance3 ( ) throws Exception { final JSONObject obj = new JSONObject ( " { \ " class \ " : \ " org . apache . lucene . analysis . cn . smart . SmartChineseAnalyzer \ " , \ " params \ " : [ { \ " name \ " : \ " useDefaultStopWords \ " , \ " type \ " : \ " boolean \ " , \ " value \ " : true } ] } " ) ; final Analyzer analyzer = Analyzers . getAnalyzer ( obj ) ; assertThat ( analyzer , is ( org . apache . lucene . analysis . cn . smart . SmartChineseAnalyzer . class ) ) ; }
public void testClassInstance4 ( ) throws Exception { final JSONObject obj = new JSONObject ( " { \ " german \ " : { } } " ) ; final Analyzer analyzer = Analyzers . getAnalyzer ( obj ) ; assertThat ( analyzer , is ( org . apache . lucene . analysis . de . GermanAnalyzer . class ) ) ; }
public void testClassInstance5 ( ) throws Exception { final JSONObject obj = new JSONObject ( " { \ " cjk \ " : \ " \ " } " ) ; final Analyzer analyzer = Analyzers . getAnalyzer ( obj ) ; assertThat ( analyzer , is ( org . apache . lucene . analysis . cjk . CJKAnalyzer . class ) ) ; }
public void testClassInstance6 ( ) throws Exception { final JSONObject obj = new JSONObject ( " { \ " ngram \ " : { \ " analyzer \ " : \ " simple \ " , \ " min \ " : 2 , \ " max \ " : 3 } } " ) ; final Analyzer analyzer = Analyzers . getAnalyzer ( obj ) ; assertThat ( analyzer . toString ( ) , containsString ( " NGramAnalyzer " ) ) ; }
public void testClassInstance7 ( ) throws Exception { final Analyzer analyzer = Analyzers . getAnalyzer ( " perfield : { default : \ " keyword \ " , lang_bo : { \ " class \ " : \ " org . apache . lucene . analysis . core . WhitespaceAnalyzer \ " } , lang_sa : { \ " class \ " : \ " org . apache . lucene . analysis . hi . HindiAnalyzer \ " } } " ) ; assertThat ( analyzer , is ( PerFieldAnalyzerWrapper . class ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " default = org . apache . lucene . analysis . core . KeywordAnalyzer " ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " lang_bo = org . apache . lucene . analysis . core . WhitespaceAnalyzer " ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " lang_sa = org . apache . lucene . analysis . hi . HindiAnalyzer " ) ) ; }
public void testClassInstance8 ( ) throws Exception { final Analyzer analyzer = Analyzers . fromSpec ( " { \ " perfield \ " : { \ " default \ " : \ " keyword \ " , \ " lang_bo \ " : { \ " class \ " : \ " org . apache . lucene . analysis . core . WhitespaceAnalyzer \ " } , \ " lang_sa \ " : { \ " class \ " : \ " org . apache . lucene . analysis . hi . HindiAnalyzer \ " } } } " ) ; assertThat ( analyzer , is ( PerFieldAnalyzerWrapper . class ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " default = org . apache . lucene . analysis . core . KeywordAnalyzer " ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " lang_bo = org . apache . lucene . analysis . core . WhitespaceAnalyzer " ) ) ; assertThat ( analyzer . toString ( ) , containsString ( " lang_sa = org . apache . lucene . analysis . hi . HindiAnalyzer " ) ) ; }
public void testNGramTokens ( ) throws Exception { assertThat ( analyze ( " ngram : { \ " analyzer \ " : \ " simple \ " } " , " hey there " ) , is ( new String [ ] { " h " , " he " , " e " , " ey " , " y " , " t " , " th " , " h " , " he " , " e " , " er " , " r " , " re " , " e " } ) ) ; }
public void testNGramMinMax ( ) throws Exception { assertThat ( analyze ( " ngram : { \ " analyzer \ " : \ " simple \ " , \ " min \ " : 2 , \ " max \ " : 3 } " , " hello there " ) , is ( new String [ ] { " he " , " hel " , " el " , " ell " , " ll " , " llo " , " lo " , " th " , " the " , " he " , " her " , " er " , " ere " , " re " } ) ) ; }
public void testEmailAddresses ( ) throws Exception { assertThat ( analyze ( " standard " , " foo @ bar . com " ) , is ( new String [ ] { " foo " , " bar . com " } ) ) ; assertThat ( analyze ( " classic " , " foo @ bar . com " ) , is ( new String [ ] { " foo @ bar . com " } ) ) ; }
private String [ ] analyze ( final String analyzerName , final String text ) throws Exception { final Analyzer analyzer = Analyzers . getAnalyzer ( analyzerName ) ; final TokenStream stream = analyzer . tokenStream ( " default " , new StringReader ( text ) ) ; stream . reset ( ) ; final List < String > result = new ArrayList < String > ( ) ; while ( stream . incrementToken ( ) ) { final CharTermAttribute c = stream . getAttribute ( CharTermAttribute . class ) ; result . add ( c . toString ( ) ) ; } return result . toArray ( new String [ 0 ] ) ; }
public SortField . Type toSortField ( ) { return type . toType ( ) ; }
public Query toRangeQuery ( final String lower , final String upper , final boolean lowerInclusive , final boolean upperInclusive ) throws ParseException { return type . toRangeQuery ( name , lower , upper , lowerInclusive , upperInclusive ) ; }
public Query toTermQuery ( final String text ) throws ParseException { return type . toTermQuery ( name , text ) ; }
public String toString ( ) { return String . format ( " % s < % s > " , name , type . toString ( ) . toLowerCase ( ) ) ; }
public synchronized DirectoryReader borrowReader ( final boolean staleOk ) throws IOException , JSONException { blockForLatest ( staleOk ) ; if ( reader = = null ) { etag = newEtag ( ) ; } if ( reader ! = null ) { reader . decRef ( ) ; } reader = DirectoryReader . open ( writer , ! staleOk , false ) ; if ( readerDirty ) { etag = newEtag ( ) ; readerDirty = false ; } reader . incRef ( ) ; return reader ; }
public IndexSearcher borrowSearcher ( final boolean staleOk ) throws IOException , JSONException { return new IndexSearcher ( borrowReader ( staleOk ) ) ; }
public void returnReader ( final IndexReader reader ) throws IOException { reader . decRef ( ) ; }
public void returnSearcher ( final IndexSearcher searcher ) throws IOException { returnReader ( searcher . getIndexReader ( ) ) ; }
public Query parse ( final String query , final Operator operator , final Analyzer analyzer ) throws ParseException , JSONException { final QueryParser parser = new CustomQueryParser ( Constants . DEFAULT_FIELD , analyzer ) ; parser . setDefaultOperator ( operator ) ; parser . setAllowLeadingWildcard ( ini . getBoolean ( " lucene . allowLeadingWildcard " , false ) ) ; parser . setLowercaseExpandedTerms ( ini . getBoolean ( " lucene . lowercaseExpandedTerms " , true ) ) ; return parser . parse ( query ) ; }
public Analyzer analyzer ( final String spec ) throws JSONException { return spec = = null ? this . analyzer : Analyzers . fromSpec ( spec ) ; }
public UUID getUuid ( ) throws JSONException , IOException { return database . getUuid ( ) ; }
private String newEtag ( ) { return Long . toHexString ( now ( ) ) ; }
private synchronized boolean notModified ( final HttpServletRequest req ) { return etag ! = null & & etag . equals ( req . getHeader ( " If - None - Match " ) ) ; }
public String toString ( ) { return writer . getDirectory ( ) . toString ( ) ; }
public boolean visibleToScripts ( final String fullClassName ) { return false ; }
public static File uuidDir ( final File root , final UUID uuid ) { return new File ( root , uuid . toString ( ) ) ; }
public static File viewDir ( final File root , final UUID uuid , final String digest , final boolean mkdirs ) throws IOException { final File uuidDir = uuidDir ( root , uuid ) ; final File viewDir = new File ( uuidDir , digest ) ; if ( mkdirs ) { viewDir . mkdirs ( ) ; } return viewDir ; }
private static long now ( ) { return System . nanoTime ( ) ; }
public void admin ( final HttpServletRequest req , final HttpServletResponse resp ) throws IOException , JSONException { final IndexState state = getState ( req , resp ) ; if ( state = = null ) return ; final String command = new PathParts ( req ) . getCommand ( ) ; if ( " _expunge " . equals ( command ) ) { logger . info ( " Expunging deletes from " + state ) ; state . writer . forceMergeDeletes ( false ) ; resp . setStatus ( 202 ) ; ServletUtils . sendJsonSuccess ( req , resp ) ; return ; } if ( " _optimize " . equals ( command ) ) { logger . info ( " Optimizing " + state ) ; state . writer . forceMerge ( 1 , false ) ; resp . setStatus ( 202 ) ; ServletUtils . sendJsonSuccess ( req , resp ) ; return ; } ServletUtils . sendJsonError ( req , resp , 400 , " bad_request " ) ; }
private void close ( ) { this . closed = true ; for ( final IndexState state : states . values ( ) ) { try { state . close ( ) ; } catch ( final IOException e ) { logger . warn ( " Error while closing . " , e ) ; } } states . clear ( ) ; if ( context ! = null ) { Context . exit ( ) ; context = null ; } latch . countDown ( ) ; }
public boolean isClosed ( ) { return closed ; }
private static boolean getBooleanParameter ( final HttpServletRequest req , final String parameterName ) { return Boolean . parseBoolean ( req . getParameter ( parameterName ) ) ; }
private static int getIntParameter ( final HttpServletRequest req , final String parameterName , final int defaultValue ) { final String result = req . getParameter ( parameterName ) ; return result ! = null ? Integer . parseInt ( result ) : defaultValue ; }
private IndexState getState ( final HttpServletRequest req , final HttpServletResponse resp ) throws IOException , JSONException { final View view = paths . get ( toPath ( req ) ) ; if ( view = = null ) { ServletUtils . sendJsonError ( req , resp , 400 , " no_such_view " ) ; return null ; } final IndexState result = states . get ( view ) ; if ( result = = null ) { ServletUtils . sendJsonError ( req , resp , 400 , " no_such_state " ) ; } return result ; }
private UpdateSequence getUpdateSequence ( final Directory dir ) throws IOException { if ( ! DirectoryReader . indexExists ( dir ) ) { return UpdateSequence . START ; } final List < IndexCommit > commits = DirectoryReader . listCommits ( dir ) ; final IndexCommit latest = commits . get ( commits . size ( ) - 1 ) ; return getUpdateSequence ( latest . getUserData ( ) ) ; }
private UpdateSequence getUpdateSequence ( final IndexWriter writer ) throws IOException { return getUpdateSequence ( writer . getDirectory ( ) ) ; }
private static boolean isStaleOk ( final HttpServletRequest req ) { return " ok " . equals ( req . getParameter ( " stale " ) ) ; }
private IndexWriter newWriter ( final Directory dir , final Analyzer analyzer ) throws IOException { final IndexWriterConfig config = new IndexWriterConfig ( analyzer ) ; config . setUseCompoundFile ( ini . getBoolean ( " lucene . useCompoundFile " , false ) ) ; config . setRAMBufferSizeMB ( ini . getDouble ( " lucene . ramBufferSizeMB " , IndexWriterConfig . DEFAULT_RAM_BUFFER_SIZE_MB ) ) ; return new IndexWriter ( dir , config ) ; }
private File viewDir ( final View view , final boolean mkdirs ) throws IOException { return viewDir ( root , uuid , view . getDigest ( ) , mkdirs ) ; }
private String toPath ( final HttpServletRequest req ) { final PathParts parts = new PathParts ( req ) ; return toPath ( parts . getDesignDocumentName ( ) , parts . getViewName ( ) ) ; }
private static String toPath ( final String ddoc , final String view ) { return ddoc + " / " + view ; }
public void closeExpiredConnections ( ) { delegate . closeExpiredConnections ( ) ; }
public void closeIdleConnections ( final long idletime , final TimeUnit tunit ) { delegate . closeIdleConnections ( idletime , tunit ) ; }
public void releaseConnection ( final ManagedClientConnection conn , final long validDuration , final TimeUnit timeUnit ) { delegate . releaseConnection ( conn , validDuration , timeUnit ) ; }
public ClientConnectionRequest requestConnection ( final HttpRoute route , final Object state ) { return delegate . requestConnection ( route , state ) ; }
private Scriptable convertObject ( final JSONObject obj ) throws JSONException { if ( obj = = JSONObject . NULL ) { return null ; } final Scriptable result = context . newObject ( scope ) ; final Iterator < ? > it = obj . keys ( ) ; while ( it . hasNext ( ) ) { final String key = ( String ) it . next ( ) ; final Object value = obj . get ( key ) ; ScriptableObject . putProperty ( result , key , convert ( value ) ) ; } return result ; }
private Couch getCouch ( final HttpServletRequest req ) throws IOException { final String sectionName = new PathParts ( req ) . getKey ( ) ; final Configuration section = ini . getSection ( sectionName ) ; if ( ! section . containsKey ( " url " ) ) { throw new FileNotFoundException ( sectionName + " is missing or has no url parameter . " ) ; } return new Couch ( client , section . getString ( " url " ) ) ; }
private synchronized DatabaseIndexer getIndexer ( final Database database ) throws IOException , JSONException { DatabaseIndexer result = indexers . get ( database ) ; Thread thread = threads . get ( database ) ; if ( result = = null | | thread = = null | | ! thread . isAlive ( ) ) { result = new DatabaseIndexer ( client , root , database , ini ) ; thread = new Thread ( result ) ; thread . start ( ) ; result . awaitInitialization ( ) ; if ( result . isClosed ( ) ) { return null ; } else { indexers . put ( database , result ) ; threads . put ( database , thread ) ; } } return result ; }
private DatabaseIndexer getIndexer ( final HttpServletRequest req ) throws IOException , JSONException { final Couch couch = getCouch ( req ) ; final Database database = couch . getDatabase ( new PathParts ( req ) . getDatabaseName ( ) ) ; return getIndexer ( database ) ; }
private void handleWelcomeReq ( final HttpServletRequest req , final HttpServletResponse resp ) throws ServletException , IOException , JSONException { final Package p = this . getClass ( ) . getPackage ( ) ; final JSONObject welcome = new JSONObject ( ) ; welcome . put ( " couchdb - lucene " , " Welcome " ) ; welcome . put ( " version " , p . getImplementationVersion ( ) ) ; ServletUtils . sendJson ( req , resp , welcome ) ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( database = = null ) ? 0 : database . hashCode ( ) ) ; result = prime * result + ( ( ddoc = = null ) ? 0 : ddoc . hashCode ( ) ) ; result = prime * result + ( ( key = = null ) ? 0 : key . hashCode ( ) ) ; result = prime * result + ( ( view = = null ) ? 0 : view . hashCode ( ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; IndexKey other = ( IndexKey ) obj ; if ( database = = null ) { if ( other . database ! = null ) return false ; } else if ( ! database . equals ( other . database ) ) return false ; if ( ddoc = = null ) { if ( other . ddoc ! = null ) return false ; } else if ( ! ddoc . equals ( other . ddoc ) ) return false ; if ( key = = null ) { if ( other . key ! = null ) return false ; } else if ( ! key . equals ( other . key ) ) return false ; if ( view = = null ) { if ( other . view ! = null ) return false ; } else if ( ! view . equals ( other . view ) ) return false ; return true ; }
public static void main ( String [ ] args ) throws Exception { final Config config = new Config ( ) ; final File dir = config . getDir ( ) ; final Server server = new Server ( ) ; final ServerConnector connector = new ServerConnector ( server ) ; connector . setHost ( config . getConfiguration ( ) . getString ( " lucene . host " , " localhost " ) ) ; connector . setPort ( config . getConfiguration ( ) . getInt ( " lucene . port " , 5985 ) ) ; LOG . info ( " Accepting connections with " + connector ) ; server . addConnector ( connector ) ; server . setStopAtShutdown ( true ) ; final LuceneServlet servlet = new LuceneServlet ( config . getClient ( ) , dir , config . getConfiguration ( ) ) ; final ServletContextHandler context = new ServletContextHandler ( server , " / " , ServletContextHandler . NO_SESSIONS | ServletContextHandler . NO_SECURITY ) ; context . addServlet ( new ServletHolder ( servlet ) , " / * " ) ; context . setErrorHandler ( new JSONErrorHandler ( ) ) ; context . setGzipHandler ( new GzipHandler ( ) ) ; server . setHandler ( context ) ; server . start ( ) ; server . join ( ) ; }
public final File getDir ( ) throws IOException { final File dir = new File ( this . configuration . getString ( LUCENE_DIR , DEFAULT_DIR ) ) ; if ( ! dir . exists ( ) & & ! dir . mkdir ( ) ) { throw new IOException ( " Could not create " + dir . getCanonicalPath ( ) ) ; } if ( ! dir . canRead ( ) ) { throw new IOException ( dir + " is not readable . " ) ; } if ( ! dir . canWrite ( ) ) { throw new IOException ( dir + " is not writable . " ) ; } LOG . info ( " Index output goes to : " + dir . getCanonicalPath ( ) ) ; return dir ; }
public final HttpClient getClient ( ) throws MalformedURLException { HttpClientFactory . setIni ( this . configuration ) ; return HttpClientFactory . getInstance ( ) ; }
public static String toPlan ( final Query query ) { final StringBuilder builder = new StringBuilder ( 300 ) ; toPlan ( builder , query ) ; return builder . toString ( ) ; }
private static void planFuzzyQuery ( final StringBuilder builder , final FuzzyQuery query ) { builder . append ( query . getTerm ( ) ) ; builder . append ( " , prefixLength = " ) ; builder . append ( query . getPrefixLength ( ) ) ; builder . append ( " , maxEdits = " ) ; builder . append ( query . getMaxEdits ( ) ) ; }
private static void planPrefixQuery ( final StringBuilder builder , final PrefixQuery query ) { builder . append ( query . getPrefix ( ) ) ; }
private static void planTermQuery ( final StringBuilder builder , final TermQuery query ) { builder . append ( query . getTerm ( ) ) ; }
private static void planTermRangeQuery ( final StringBuilder builder , final TermRangeQuery query ) { builder . append ( query . getLowerTerm ( ) . utf8ToString ( ) ) ; builder . append ( " TO " ) ; builder . append ( query . getUpperTerm ( ) . utf8ToString ( ) ) ; }
private static void planWildcardQuery ( final StringBuilder builder , final WildcardQuery query ) { builder . append ( query . getTerm ( ) ) ; }
private static void toPlan ( final StringBuilder builder , final Query query ) { builder . append ( query . getClass ( ) . getSimpleName ( ) ) ; builder . append ( " ( " ) ; if ( query instanceof TermQuery ) { planTermQuery ( builder , ( TermQuery ) query ) ; } else if ( query instanceof BooleanQuery ) { planBooleanQuery ( builder , ( BooleanQuery ) query ) ; } else if ( query instanceof TermRangeQuery ) { planTermRangeQuery ( builder , ( TermRangeQuery ) query ) ; } else if ( query instanceof PrefixQuery ) { planPrefixQuery ( builder , ( PrefixQuery ) query ) ; } else if ( query instanceof WildcardQuery ) { planWildcardQuery ( builder , ( WildcardQuery ) query ) ; } else if ( query instanceof FuzzyQuery ) { planFuzzyQuery ( builder , ( FuzzyQuery ) query ) ; } else if ( query instanceof BoostQuery ) { planBoostQuery ( builder , ( BoostQuery ) query ) ; } else { builder . append ( query . getClass ( ) ) ; builder . append ( " @ " ) ; builder . append ( query ) ; } builder . append ( " ) " ) ; }
public void parse ( final InputStream in , final String contentType , final String fieldName , final Document doc ) throws IOException { final Metadata md = new Metadata ( ) ; md . set ( HttpHeaders . CONTENT_TYPE , contentType ) ; try { doc . add ( text ( fieldName , tika . parseToString ( in , md ) , false ) ) ; } catch ( final IOException e ) { log . warn ( " Failed to index an attachment . " , e ) ; return ; } catch ( final TikaException e ) { log . warn ( " Failed to parse an attachment . " , e ) ; return ; } addDublinCoreAttributes ( md , doc ) ; }
private void addDublinCoreAttributes ( final Metadata md , final Document doc ) { addAttribute ( DC , DublinCore . CONTRIBUTOR , md , doc ) ; addAttribute ( DC , DublinCore . COVERAGE , md , doc ) ; addAttribute ( DC , DublinCore . CREATOR , md , doc ) ; addAttribute ( DC , DublinCore . DATE , md , doc ) ; addAttribute ( DC , DublinCore . DESCRIPTION , md , doc ) ; addAttribute ( DC , DublinCore . FORMAT , md , doc ) ; addAttribute ( DC , DublinCore . IDENTIFIER , md , doc ) ; addAttribute ( DC , DublinCore . LANGUAGE , md , doc ) ; addAttribute ( DC , DublinCore . MODIFIED , md , doc ) ; addAttribute ( DC , DublinCore . PUBLISHER , md , doc ) ; addAttribute ( DC , DublinCore . RELATION , md , doc ) ; addAttribute ( DC , DublinCore . RIGHTS , md , doc ) ; addAttribute ( DC , DublinCore . SOURCE , md , doc ) ; addAttribute ( DC , DublinCore . SUBJECT , md , doc ) ; addAttribute ( DC , DublinCore . TITLE , md , doc ) ; addAttribute ( DC , DublinCore . TYPE , md , doc ) ; }
protected Query getRangeQuery ( final String field , final String lower , final String upper , final boolean lowerInclusive , final boolean upperInclusive ) throws ParseException { return new TypedField ( field ) . toRangeQuery ( lower , upper , lowerInclusive , upperInclusive ) ; }
private static String get ( final NativeObject obj , final String key ) { return obj = = null ? null : obj . has ( key , null ) ? obj . get ( key , null ) . toString ( ) : null ; }
public static CouchDocument deletedDocument ( final String id ) throws JSONException { final JSONObject json = new JSONObject ( ) ; json . put ( ID , id ) ; json . put ( DELETED , true ) ; return new CouchDocument ( json ) ; }
public String getId ( ) throws JSONException { return json . getString ( ID ) ; }
public boolean isDeleted ( ) { return json . optBoolean ( DELETED , false ) ; }
public JSONObject asJson ( ) { return json ; }
public boolean create ( ) throws IOException { return HttpUtils . put ( httpClient , url , null ) = = 201 ; }
public boolean delete ( ) throws IOException { return HttpUtils . delete ( httpClient , url ) = = 200 ; }
public List < DesignDocument > getAllDesignDocuments ( ) throws IOException , JSONException { final String body = HttpUtils . get ( httpClient , String . format ( " % s_all_docs ? startkey = % s & endkey = % s & include_docs = true " , url , Utils . urlEncode ( " \ " _design \ " " ) , Utils . urlEncode ( " \ " _design0 \ " " ) ) ) ; final JSONObject json = new JSONObject ( body ) ; return toDesignDocuments ( json ) ; }
public CouchDocument getDocument ( final String id ) throws IOException , JSONException { final String response = HttpUtils . get ( httpClient , url + Utils . urlEncode ( id ) ) ; return new CouchDocument ( new JSONObject ( response ) ) ; }
public DesignDocument getDesignDocument ( final String id ) throws IOException , JSONException { final String response = HttpUtils . get ( httpClient , url + Utils . urlEncode ( id ) ) ; return new DesignDocument ( new JSONObject ( response ) ) ; }
public List < CouchDocument > getDocuments ( final String . . . ids ) throws IOException , JSONException { if ( ids . length = = 0 ) { return Collections . emptyList ( ) ; } final JSONArray keys = new JSONArray ( ) ; for ( final String id : ids ) { assert id ! = null ; keys . put ( id ) ; } final JSONObject req = new JSONObject ( ) ; req . put ( " keys " , keys ) ; final String body = HttpUtils . post ( httpClient , url + " _all_docs ? include_docs = true " , req ) ; return toDocuments ( new JSONObject ( body ) ) ; }
public UpdateSequence getLastSequence ( ) throws IOException , JSONException { final JSONObject result = new JSONObject ( HttpUtils . get ( httpClient , url + " _changes ? limit = 0 & descending = true " ) ) ; return UpdateSequence . parseUpdateSequence ( result . getString ( " last_seq " ) ) ; }
public < T > T handleAttachment ( final String doc , final String att , final ResponseHandler < T > handler ) throws IOException { final HttpGet get = new HttpGet ( url + " / " + Utils . urlEncode ( doc ) + " / " + Utils . urlEncode ( att ) ) ; return httpClient . execute ( get , handler ) ; }
public boolean saveDocument ( final String id , final String body ) throws IOException { return HttpUtils . put ( httpClient , url + Utils . urlEncode ( id ) , body ) = = 201 ; }
public void createUuid ( ) throws IOException { final UUID uuid = UUID . randomUUID ( ) ; saveDocument ( " _local / lucene " , String . format ( " { \ " uuid \ " : \ " % s \ " } " , uuid ) ) ; }
public UUID getOrCreateUuid ( ) throws IOException , JSONException { final UUID result = getUuid ( ) ; if ( result ! = null ) { return result ; } createUuid ( ) ; return getUuid ( ) ; }
private List < DesignDocument > toDesignDocuments ( final JSONObject json ) throws JSONException { final List < DesignDocument > result = new ArrayList < > ( ) ; for ( final JSONObject doc : rows ( json ) ) { result . add ( new DesignDocument ( doc ) ) ; } return result ; }
private List < CouchDocument > toDocuments ( final JSONObject json ) throws JSONException { final List < CouchDocument > result = new ArrayList < > ( ) ; for ( final JSONObject doc : rows ( json ) ) { result . add ( doc = = null ? null : new CouchDocument ( doc ) ) ; } return result ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( url = = null ) ? 0 : url . hashCode ( ) ) ; return result ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; Database other = ( Database ) obj ; if ( url = = null ) { if ( other . url ! = null ) return false ; } else if ( ! url . equals ( other . url ) ) return false ; return true ; }
public String toString ( ) { return " Database [ url = " + url + " ] " ; }
public String toString ( ) { return since ; }
public String appendSince ( final String url ) { return url + " & since = " + seq ; }
public String toString ( ) { return Long . toString ( seq ) ; }
public String appendSince ( final String url ) { return url ; }
public boolean isEarlierThan ( final UpdateSequence other ) { return true ; }
public boolean isLaterThan ( final UpdateSequence other ) { return false ; }
public String toString ( ) { return " start " ; }
public static UpdateSequence parseUpdateSequence ( final String str ) { if ( str . matches ( " [ 0 - 9 ] + " ) ) { return new CouchDbUpdateSequence ( str ) ; } String packedSeqs ; if ( ( packedSeqs = extractPackedSeqs ( BC3 , str ) ) ! = null ) { return new BigCouchUpdateSequence ( str , packedSeqs ) ; } if ( ( packedSeqs = extractPackedSeqs ( BC4 , str ) ) ! = null ) { return new BigCouchUpdateSequence ( str , packedSeqs ) ; } throw new IllegalArgumentException ( str + " not recognized . " ) ; }
private static String extractPackedSeqs ( final Pattern p , final String str ) { final Matcher m = p . matcher ( str ) ; if ( m . matches ( ) ) { return m . group ( 1 ) ; } return null ; }
public void addFields ( final String name , final Object value , final ViewSettings settings , final Document to ) throws ParseException { to . add ( boost ( new LongPoint ( name , toDate ( value ) ) , settings ) ) ; to . add ( new NumericDocValuesField ( name , toDate ( value ) ) ) ; }
public Query toTermQuery ( final String name , final String text ) throws ParseException { return LongPoint . newExactQuery ( name , toDate ( text ) ) ; }
public void addFields ( final String name , final Object value , final ViewSettings settings , final Document to ) { to . add ( boost ( new DoublePoint ( name , toDouble ( value ) ) , settings ) ) ; to . add ( new DoubleDocValuesField ( name , toDouble ( value ) ) ) ; }
public Query toTermQuery ( final String name , final String text ) { return DoublePoint . newExactQuery ( name , toDouble ( text ) ) ; }
private double toDouble ( final Object obj ) { if ( obj instanceof Number ) { return ( ( Number ) obj ) . doubleValue ( ) ; } return Double . parseDouble ( obj . toString ( ) ) ; }
public void addFields ( final String name , final Object value , final ViewSettings settings , final Document to ) { to . add ( boost ( new FloatPoint ( name , toFloat ( value ) ) , settings ) ) ; to . add ( new FloatDocValuesField ( name , toFloat ( value ) ) ) ; }
public Query toTermQuery ( final String name , final String text ) { return FloatPoint . newExactQuery ( name , toFloat ( text ) ) ; }
private float toFloat ( final Object obj ) { if ( obj instanceof Number ) { return ( ( Number ) obj ) . floatValue ( ) ; } return Float . parseFloat ( obj . toString ( ) ) ; }
public void addFields ( final String name , final Object value , final ViewSettings settings , final Document to ) { to . add ( boost ( new IntPoint ( name , toInt ( value ) ) , settings ) ) ; to . add ( new NumericDocValuesField ( name , toInt ( value ) ) ) ; }
public Query toTermQuery ( final String name , final String text ) { return IntPoint . newExactQuery ( name , toInt ( text ) ) ; }
private int toInt ( final Object obj ) { if ( obj instanceof Number ) { return ( ( Number ) obj ) . intValue ( ) ; } return Integer . parseInt ( obj . toString ( ) ) ; }
public void addFields ( final String name , final Object value , final ViewSettings settings , final Document to ) { to . add ( boost ( new LongPoint ( name , toLong ( value ) ) , settings ) ) ; to . add ( new NumericDocValuesField ( name , toLong ( value ) ) ) ; }
public Query toTermQuery ( final String name , final String text ) { return LongPoint . newExactQuery ( name , toLong ( text ) ) ; }
private long toLong ( final Object obj ) { if ( obj instanceof Number ) { return ( ( Number ) obj ) . longValue ( ) ; } return Long . parseLong ( obj . toString ( ) ) ; }
public void addFields ( final String name , final Object value , final ViewSettings settings , final Document to ) { to . add ( boost ( new StringField ( name , value . toString ( ) , settings . getStore ( ) ) , settings ) ) ; to . add ( new SortedDocValuesField ( name , new BytesRef ( value . toString ( ) ) ) ) ; }
public Query toTermQuery ( String name , String text ) { throw new UnsupportedOperationException ( " toTermQuery is not supported for FieldType . String . " ) ; }
public void addFields ( final String name , final Object value , final ViewSettings settings , final Document to ) { to . add ( boost ( new TextField ( name , value . toString ( ) , settings . getStore ( ) ) , settings ) ) ; }
public Query toRangeQuery ( final String name , final String lower , final String upper , final boolean lowerInclusive , final boolean upperInclusive ) { throw new UnsupportedOperationException ( " toRangeQuery is not supported for TEXT " ) ; }
public Query toTermQuery ( String name , String text ) { throw new UnsupportedOperationException ( " toTermQuery is not supported for TEXT " ) ; }
private static < T extends Field > T boost ( final T field , final ViewSettings settings ) { field . setBoost ( settings . getBoost ( ) ) ; return field ; }
public final SortField . Type toType ( ) { return type ; }
public final JSONArray getAllDatabases ( ) throws IOException , JSONException { final String response = HttpUtils . get ( httpClient , url + " _all_dbs " ) ; return new JSONArray ( response ) ; }
public final JSONObject getInfo ( ) throws IOException , JSONException { return new JSONObject ( HttpUtils . get ( httpClient , url ) ) ; }
public Database getDatabase ( final String dbname ) throws IOException { return new Database ( httpClient , url + dbname ) ; }
public View getView ( final String name ) throws JSONException { if ( fulltext = = null ) return null ; final JSONObject json = fulltext . optJSONObject ( name ) ; return json = = null ? null : new View ( getId ( ) + " / " + name , json ) ; }
public Map < String , View > getAllViews ( ) throws JSONException { if ( fulltext = = null ) return Collections . emptyMap ( ) ; final Map < String , View > result = new HashMap < > ( ) ; final Iterator < ? > it = fulltext . keys ( ) ; while ( it . hasNext ( ) ) { final Object key = it . next ( ) ; final String name = ( String ) key ; final View view = getView ( name ) ; if ( view ! = null ) { result . put ( name , view ) ; } } return result ; }
public Analyzer getAnalyzer ( ) throws JSONException { return Analyzers . fromSpec ( json ) ; }
public String getFunction ( ) throws JSONException { return trim ( json . getString ( Constants . INDEX ) ) ; }
public Function compileFunction ( final Context context , ScriptableObject scope ) throws JSONException { return context . compileFunction ( scope , getFunction ( ) , null , 0 , null ) ; }
private static String trim ( final String fun ) { String result = fun ; result = StringUtils . trim ( result ) ; result = StringUtils . removeStart ( result , " \ " " ) ; result = StringUtils . removeEnd ( result , " \ " " ) ; return result ; }
public int hashCode ( ) { return getDigest ( ) . hashCode ( ) ; }
public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( ! ( obj instanceof View ) ) { return false ; } View other = ( View ) obj ; return getDigest ( ) . equals ( other . getDigest ( ) ) ; }
public String toString ( ) { return String . format ( " View [ name = % s , digest = % s ] " , name , getDigest ( ) ) ; }
public UpdateSequence getUpdateSequence ( ) throws JSONException { return UpdateSequence . parseUpdateSequence ( json . getString ( " update_seq " ) ) ; }
public String getName ( ) throws JSONException { return json . getString ( " db_name " ) ; }
public static final int delete ( final HttpClient httpClient , final String url ) throws IOException { return httpClient . execute ( new HttpDelete ( url ) , new StatusCodeResponseHandler ( ) ) ; }
public static final String execute ( final HttpClient httpClient , final HttpUriRequest request ) throws IOException { return httpClient . execute ( request , new ErrorPreservingResponseHandler ( ) ) ; }
public static final String get ( final HttpClient httpClient , final String url ) throws IOException { return execute ( httpClient , new HttpGet ( url ) ) ; }
public static final String post ( final HttpClient httpClient , final String url , final JSONObject body ) throws IOException { final HttpPost post = new HttpPost ( url ) ; post . setHeader ( " Content - Type " , Constants . APPLICATION_JSON ) ; post . setEntity ( new StringEntity ( body . toString ( ) , " UTF - 8 " ) ) ; return execute ( httpClient , post ) ; }
public static final int put ( final HttpClient httpClient , final String url , final String body ) throws IOException { final HttpPut put = new HttpPut ( url ) ; if ( body ! = null ) { put . setHeader ( " Content - Type " , Constants . APPLICATION_JSON ) ; put . setEntity ( new StringEntity ( body , " UTF - 8 " ) ) ; } return httpClient . execute ( put , new StatusCodeResponseHandler ( ) ) ; }
public Integer handleResponse ( final HttpResponse response ) throws ClientProtocolException , IOException { return response . getStatusLine ( ) . getStatusCode ( ) ; }
public void lap ( final String name ) { final long now = System . nanoTime ( ) ; elapsed . put ( name , now - start ) ; start = now ; }
public static void sendJsonError ( final HttpServletRequest request , final HttpServletResponse response , final int code , final String reason ) throws IOException , JSONException { final JSONObject obj = new JSONObject ( ) ; obj . put ( " reason " , reason ) ; sendJsonError ( request , response , code , obj ) ; }
public static Field text ( final String name , final String value , final boolean store ) { return new TextField ( name , value , store ? Store . YES : Store . NO ) ; }
public static Field token ( final String name , final String value , final boolean store ) { return new StringField ( name , value , store ? Store . YES : Store . NO ) ; }
public static long directorySize ( final Directory dir ) throws IOException { long result = 0 ; for ( final String name : dir . listAll ( ) ) { result + = dir . fileLength ( name ) ; } return result ; }
public static String [ ] splitOnCommas ( final String str ) { return str . split ( " , ( ? = ( [ ^ \ " ] * \ " [ ^ \ " ] * \ " ) * [ ^ \ " ] * $ ) " ) ; }
public Analyzer newAnalyzer ( final String args ) { return new BrazilianAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new BrazilianAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new SmartChineseAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new SmartChineseAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new CJKAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new CJKAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new ClassicAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new ClassicAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new CzechAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new CzechAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new DutchAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new DutchAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new StandardAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new StandardAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new FrenchAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new FrenchAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new GermanAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new GermanAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new KeywordAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new KeywordAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) throws JSONException { final JSONObject json = new JSONObject ( args = = null ? " { } " : args ) ; return PERFIELD . newAnalyzer ( json ) ; }
public Analyzer newAnalyzer ( final JSONObject json ) throws JSONException { final Analyzer defaultAnalyzer = fromSpec ( json , Constants . DEFAULT_FIELD ) ; final Map < String , Analyzer > analyzers = new HashMap < > ( ) ; final Iterator < ? > it = json . keys ( ) ; while ( it . hasNext ( ) ) { final String key = it . next ( ) . toString ( ) ; if ( Constants . DEFAULT_FIELD . equals ( key ) ) continue ; analyzers . put ( key , fromSpec ( json , key ) ) ; } return new PerFieldAnalyzerWrapper ( defaultAnalyzer , analyzers ) ; }
public Analyzer newAnalyzer ( final String args ) { return new RussianAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new RussianAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new SimpleAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new SimpleAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new ThaiAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new ThaiAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) { return new WhitespaceAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final JSONObject args ) { return new WhitespaceAnalyzer ( ) ; }
public Analyzer newAnalyzer ( final String args ) throws JSONException { final JSONObject json = new JSONObject ( args = = null ? " { } " : args ) ; return NGRAM . newAnalyzer ( json ) ; }
public Analyzer newAnalyzer ( final JSONObject json ) throws JSONException { Analyzer analyzer = fromSpec ( json ) ; int min = json . optInt ( " min " , NGramTokenFilter . DEFAULT_MIN_NGRAM_SIZE ) ; int max = json . optInt ( " max " , NGramTokenFilter . DEFAULT_MAX_NGRAM_SIZE ) ; return new NGramAnalyzer ( analyzer , min , max ) ; }
public static Analyzer fromSpec ( final JSONObject json ) throws JSONException { return fromSpec ( json , Constants . ANALYZER ) ; }
public static Analyzer getAnalyzer ( final String str ) throws JSONException { final String [ ] parts = str . split ( " : " , 2 ) ; final String name = parts [ 0 ] . toUpperCase ( ) ; final String args = parts . length = = 2 ? parts [ 1 ] : null ; return Analyzers . valueOf ( name ) . newAnalyzer ( args ) ; }
private static Analyzer newAnalyzer ( Class < ? > clazz , Class < ? > [ ] paramClasses , Object [ ] paramValues ) { String className = clazz . getName ( ) ; try { final Constructor < ? > cstr = clazz . getDeclaredConstructor ( paramClasses ) ; return ( Analyzer ) cstr . newInstance ( paramValues ) ; } catch ( IllegalArgumentException | IllegalAccessException | InstantiationException | InvocationTargetException | SecurityException e ) { logger . error ( " Exception while instantiating analyzer class " + className + " . " + e . getMessage ( ) , e ) ; } catch ( NoSuchMethodException ex ) { logger . error ( " Could not find matching analyzer class constructor for " + className + " " + ex . getMessage ( ) , ex ) ; } return null ; }
public void error ( String mesg ) { logger . error ( mesg ) ; }
public void warn ( String mesg ) { logger . warn ( mesg ) ; }
public void info ( String mesg ) { logger . info ( mesg ) ; }
public void debug ( String mesg ) { logger . debug ( mesg ) ; }
public void trace ( String mesg ) { logger . trace ( mesg ) ; }
public static void jsFunction_add ( final Context cx , final Scriptable thisObj , final Object [ ] args , final Function funObj ) { final RhinoDocument doc = checkInstance ( thisObj ) ; if ( args . length < 1 | | args . length > 2 ) { throw Context . reportRuntimeError ( " Invalid number of arguments . " ) ; } if ( args [ 0 ] = = null ) { return ; } if ( args [ 0 ] instanceof Undefined ) { return ; } final String className = args [ 0 ] . getClass ( ) . getName ( ) ; if ( className . equals ( " org . mozilla . javascript . NativeDate " ) ) { args [ 0 ] = ( Date ) Context . jsToJava ( args [ 0 ] , Date . class ) ; } if ( ! className . startsWith ( " java . lang . " ) & & ! className . equals ( " org . mozilla . javascript . NativeObject " ) & & ! className . equals ( " org . mozilla . javascript . NativeDate " ) ) { throw Context . reportRuntimeError ( className + " is not supported . " ) ; } if ( args . length = = 2 & & ( args [ 1 ] = = null | | args [ 1 ] instanceof NativeObject = = false ) ) { throw Context . reportRuntimeError ( " second argument must be an object . " ) ; } final RhinoField field = new RhinoField ( ) ; field . value = args [ 0 ] ; if ( args . length = = 2 ) { field . settings = ( NativeObject ) args [ 1 ] ; } doc . fields . add ( field ) ; }
private static RhinoDocument checkInstance ( final Scriptable obj ) { if ( obj = = null | | ! ( obj instanceof RhinoDocument ) ) { throw Context . reportRuntimeError ( " called on incompatible object . " ) ; } return ( RhinoDocument ) obj ; }
public Document toDocument ( final String id , final ViewSettings defaults , final Database database ) throws IOException , ParseException { final Document result = new Document ( ) ; result . add ( Utils . token ( " _id " , id , true ) ) ; for ( final RhinoField field : fields ) { addField ( field , defaults , result ) ; } for ( final RhinoAttachment attachment : attachments ) { addAttachment ( attachment , id , database , result ) ; } return result ; }
private void addAttachment ( final RhinoAttachment attachment , final String id , final Database database , final Document out ) throws IOException { final ResponseHandler < Void > handler = new ResponseHandler < Void > ( ) { public Void handleResponse ( final HttpResponse response ) throws ClientProtocolException , IOException { final HttpEntity entity = response . getEntity ( ) ; try { Tika . INSTANCE . parse ( entity . getContent ( ) , entity . getContentType ( ) . getValue ( ) , attachment . fieldName , out ) ; } finally { entity . consumeContent ( ) ; } return null ; } } ; database . handleAttachment ( id , attachment . attachmentName , handler ) ; }
public Void handleResponse ( final HttpResponse response ) throws ClientProtocolException , IOException { final HttpEntity entity = response . getEntity ( ) ; try { Tika . INSTANCE . parse ( entity . getContent ( ) , entity . getContentType ( ) . getValue ( ) , attachment . fieldName , out ) ; } finally { entity . consumeContent ( ) ; } return null ; }
private void addField ( final RhinoField field , final ViewSettings defaults , final Document out ) throws ParseException { final ViewSettings settings = new ViewSettings ( field . settings , defaults ) ; final FieldType type = settings . getFieldType ( ) ; type . addFields ( settings . getField ( ) , field . value , settings , out ) ; }
public void setupBenchmark ( ) { hashes = new GeoHash [ NUMBER_OF_HASHES ] ; }
public void testIssue3WithCircleQuery ( ) throws Exception { WGS84Point center = new WGS84Point ( 39 . 86391280373075 , 116 . 37356590048701 ) ; GeoHashCircleQuery query = new GeoHashCircleQuery ( center , 589 ) ; WGS84Point test1 = new WGS84Point ( 39 . 8648866576058 , 116 . 378465869303 ) ; WGS84Point test2 = new WGS84Point ( 39 . 8664787092599 , 116 . 378552856158 ) ; WGS84Point test3 = new WGS84Point ( 39 . 8786787092599 , 116 . 378552856158 ) ; assertTrue ( query . contains ( test1 ) ) ; assertTrue ( query . contains ( test2 ) ) ; assertFalse ( query . contains ( test3 ) ) ; }
public void test180MeridianCircleQuery ( ) throws Exception { WGS84Point center = new WGS84Point ( 39 . 86391280373075 , 179 . 98356590048701 ) ; GeoHashCircleQuery query = new GeoHashCircleQuery ( center , 3000 ) ; WGS84Point test1 = new WGS84Point ( 39 . 8648866576058 , 180 ) ; WGS84Point test2 = new WGS84Point ( 39 . 8664787092599 , - 180 ) ; WGS84Point test3 = new WGS84Point ( 39 . 8686787092599 , - 179 . 9957861565146 ) ; WGS84Point test4 = new WGS84Point ( 39 . 8686787092599 , 179 . 0057861565146 ) ; WGS84Point test5 = new WGS84Point ( 39 . 8686787092599 , - 179 . 0 ) ; assertTrue ( query . contains ( test1 ) ) ; assertTrue ( query . contains ( test2 ) ) ; assertTrue ( query . contains ( test3 ) ) ; assertFalse ( query . contains ( test4 ) ) ; assertFalse ( query . contains ( test5 ) ) ; }
public void testVincenty ( ) { WGS84Point startPoint = new WGS84Point ( 40 , 40 ) ; int distanceInMeters = 10000 ; WGS84Point result = VincentyGeodesy . moveInDirection ( startPoint , 120 , distanceInMeters ) ; assertEquals ( 40 . 10134882 , result . getLongitude ( ) , DELTA ) ; assertEquals ( 39 . 9549245 , result . getLatitude ( ) , DELTA ) ; assertEquals ( distanceInMeters , VincentyGeodesy . distanceInMeters ( startPoint , result ) , DELTA ) ; WGS84Point p1 = new WGS84Point ( 1 , 1 ) ; int tenThousandKilometers = 10000000 ; WGS84Point p2 = VincentyGeodesy . moveInDirection ( p1 , 270 , tenThousandKilometers ) ; System . out . println ( p2 ) ; assertEquals ( tenThousandKilometers , VincentyGeodesy . distanceInMeters ( p1 , p2 ) , DELTA ) ; }
public void testEquals ( ) { assertEquals ( a , a ) ; assertEquals ( a , b ) ; assertEquals ( b , a ) ; assertNotSame ( a , b ) ; assertFalse ( a . equals ( c ) ) ; assertFalse ( c . equals ( a ) ) ; assertFalse ( d . equals ( c ) ) ; assertFalse ( d . equals ( a ) ) ; assertFalse ( d . equals ( new Integer ( 10 ) ) ) ; }
public void testHashCode ( ) { assertEquals ( a . hashCode ( ) , a . hashCode ( ) ) ; assertEquals ( a . hashCode ( ) , b . hashCode ( ) ) ; assertFalse ( a . hashCode ( ) = = c . hashCode ( ) ) ; assertFalse ( d . hashCode ( ) = = c . hashCode ( ) ) ; assertFalse ( d . hashCode ( ) = = new Integer ( 10 ) . hashCode ( ) ) ; }
public void testRangeCheck ( ) { new WGS84Point ( 180 , 240 ) ; }
public void testAddingOnes ( ) { hash . addOnBitToEnd ( ) ; assertEquals ( 0x1l , hash . bits ) ; assertEquals ( 1 , hash . significantBits ( ) ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; assertEquals ( 0xfl , hash . bits ) ; assertEquals ( 4 , hash . significantBits ( ) ) ; }
public void testAddingZeroes ( ) { hash . addOnBitToEnd ( ) ; assertEquals ( 0x1l , hash . bits ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; assertEquals ( 0x10l , hash . bits ) ; assertEquals ( 5 , hash . significantBits ( ) ) ; }
public void testToBase32 ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; String base32 = hash . toBase32 ( ) ; assertEquals ( " ezs42 " , base32 ) ; }
public void toBase32ShouldThrowWhenPrecisionIsNotAMultipleOf5 ( ) { hash . bits = 0x6ff0413000000000l ; hash . significantBits = 24 ; hash . toBase32 ( ) ; }
public void testWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; System . out . println ( hash . toBase32 ( ) ) ; assertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6ff0000000000000l ; bbox . significantBits = 12 ; assertWithin ( hash , bbox ) ; }
private void assertWithin ( GeoHash hash , GeoHash bbox ) { assertTrue ( hash + " should be within " + bbox , hash . within ( bbox ) ) ; }
public void itShouldCreateAHashWithMinimumPrecisionOf0Bits ( ) { GeoHash geoHash = GeoHash . withBitPrecision ( 10 . 0 , 10 . 0 , 0 ) ; assertEquals ( 0 , geoHash . significantBits ( ) ) ; assertEquals ( 0 , geoHash . longValue ( ) ) ; assertEquals ( new WGS84Point ( 10 . 0 , 10 . 0 ) , geoHash . getOriginatingPoint ( ) ) ; }
public void itShouldCreateAHashWithMaximumPrecisionOf64Bits ( ) { GeoHash geoHash = GeoHash . withBitPrecision ( 10 . 0 , 10 . 0 , 64 ) ; assertEquals ( 64 , geoHash . significantBits ( ) ) ; assertEquals ( 0xc07e07e07e07e07eL , geoHash . longValue ( ) ) ; assertEquals ( new WGS84Point ( 10 . 0 , 10 . 0 ) , geoHash . getOriginatingPoint ( ) ) ; }
public void itShouldThrowWhenTheBitPrecisionIsLessThan0Bits ( ) { GeoHash . withBitPrecision ( 46 . 0 , 8 . 0 , - 1 ) ; }
public void itShouldThrowWhenTheBitPrecisionIsMoreThan64Bits ( ) { GeoHash . withBitPrecision ( 46 . 0 , 8 . 0 , 70 ) ; }
public void itShouldThrowWhenTheCharacterPrecisionIsTooBig ( ) { GeoHash . withCharacterPrecision ( 10 . 0 , 120 . 0 , 14 ) ; }
public void testNotWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; assertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6fc0000000000000l ; bbox . significantBits = 12 ; assertFalse ( hash + " should NOT be within " + bbox , hash . within ( bbox ) ) ; }
public void testConstructorWithBitPrecision ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 45 , 120 , 20 ) ; assertEquals ( hash1 . significantBits , 20 ) ; System . out . println ( hash1 ) ; System . out . println ( hash1 . toBase32 ( ) ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 45 , 120 , 55 ) ; assertEquals ( hash2 . significantBits , 55 ) ; System . out . println ( hash2 ) ; System . out . println ( hash2 . toBase32 ( ) ) ; assertTrue ( hash2 . within ( hash1 ) ) ; GeoHash hash3 = GeoHash . withBitPrecision ( 20 , 31 , 60 ) ; assertEquals ( " sew1c2vs2q5r " , hash3 . toBase32 ( ) ) ; }
public void testLatLonBoundingBoxes ( ) { hash = GeoHash . withBitPrecision ( 40 , 120 , 10 ) ; System . out . println ( hash . toBase32 ( ) ) ; printBoundingBox ( hash ) ; }
private void assertEncodingWithCharacterPrecision ( WGS84Point point , int numberOfCharacters , String stringValue ) { GeoHash hash = GeoHash . withCharacterPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , numberOfCharacters ) ; assertEquals ( stringValue , hash . toBase32 ( ) ) ; }
public void testGetLatitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] latitudeBits = hash . getRightAlignedLatitudeBits ( ) ; assertEquals ( 0xaal , latitudeBits [ 0 ] ) ; assertEquals ( 8 , latitudeBits [ 1 ] ) ; }
public void testGetLongitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] longitudeBits = hash . getRightAlignedLongitudeBits ( ) ; assertEquals ( 0x95l , longitudeBits [ 0 ] ) ; assertEquals ( 8 , longitudeBits [ 1 ] ) ; }
public void testEqualsAndHashCode ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash3 = GeoHash . withBitPrecision ( 30 , 30 , 10 ) ; assertTrue ( hash1 . equals ( hash2 ) & & hash2 . equals ( hash1 ) ) ; assertFalse ( hash1 . equals ( hash3 ) & & hash3 . equals ( hash1 ) ) ; assertEquals ( hash1 . hashCode ( ) , hash2 . hashCode ( ) ) ; assertFalse ( hash1 . hashCode ( ) = = hash3 . hashCode ( ) ) ; }
public void testAdjacentHashes ( ) { GeoHash [ ] adjacent = GeoHash . fromGeohashString ( " dqcw4 " ) . getAdjacent ( ) ; assertEquals ( 8 , adjacent . length ) ; }
public void testMovingInCircle ( ) { checkMovingInCircle ( 34 . 2 , - 45 . 123 ) ; checkMovingInCircle ( 45 , 180 ) ; checkMovingInCircle ( 90 , 180 ) ; checkMovingInCircle ( 0 , - 180 ) ; }
private void checkMovingInCircle ( double latitude , double longitude ) { GeoHash start ; GeoHash end ; start = GeoHash . withCharacterPrecision ( latitude , longitude , 12 ) ; end = start . getEasternNeighbour ( ) ; end = end . getSouthernNeighbour ( ) ; end = end . getWesternNeighbour ( ) ; end = end . getNorthernNeighbour ( ) ; assertEquals ( start , end ) ; assertEquals ( start . getBoundingBox ( ) , end . getBoundingBox ( ) ) ; }
public void testKnownNeighbouringHashes ( ) { GeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; assertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " sp2j " , GeoHash . withCharacterPrecision ( 41 . 7 , 0 . 08 , 4 ) . toBase32 ( ) ) ; }
public void testKnownAdjacentNeighbours ( ) { String center = " dqcjqc " ; String [ ] adjacent = new String [ ] { " dqcjqf " , " dqcjqb " , " dqcjr1 " , " dqcjq9 " , " dqcjqd " , " dqcjr4 " , " dqcjr0 " , " dqcjq8 " } ; assertAdjacentHashesAre ( center , adjacent ) ; center = " u1x0dfg " ; adjacent = new String [ ] { " u1x0dg4 " , " u1x0dg5 " , " u1x0dgh " , " u1x0dfu " , " u1x0dfs " , " u1x0dfe " , " u1x0dfd " , " u1x0dff " } ; assertAdjacentHashesAre ( center , adjacent ) ; center = " sp2j " ; adjacent = new String [ ] { " ezry " , " sp2n " , " sp2q " , " sp2m " , " sp2k " , " sp2h " , " ezru " , " ezrv " } ; assertAdjacentHashesAre ( center , adjacent ) ; }
private void assertArrayContainsGeoHash ( String check , GeoHash [ ] hashes ) { boolean found = false ; for ( GeoHash hash : hashes ) { if ( hash . toBase32 ( ) . equals ( check ) ) { found = true ; break ; } } assertTrue ( " Array should contain " + check , found ) ; }
public void testNeibouringHashesNearMeridian ( ) { GeoHash hash = GeoHash . fromGeohashString ( " sp2j " ) ; GeoHash west = hash . getWesternNeighbour ( ) ; assertEquals ( " ezrv " , west . toBase32 ( ) ) ; west = west . getWesternNeighbour ( ) ; assertEquals ( " ezrt " , west . toBase32 ( ) ) ; }
public void testIssue1 ( ) { double lat = 40 . 390943 ; double lon = - 75 . 9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; String base32 = " dr4jb0bn2180 " ; GeoHash fromRef = GeoHash . fromGeohashString ( base32 ) ; assertEquals ( hash , fromRef ) ; assertEquals ( base32 , hash . toBase32 ( ) ) ; assertEquals ( base32 , fromRef . toBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; assertEquals ( " dr4jb0bn21 " , hash . toBase32 ( ) ) ; }
public void testSimpleWithin ( ) { GeoHash hash = GeoHash . withBitPrecision ( 70 , - 120 , 8 ) ; GeoHash inside = GeoHash . withBitPrecision ( 74 , - 130 , 64 ) ; assertWithin ( inside , hash ) ; }
private void printBoundingBox ( GeoHash hash ) { System . out . println ( " Bounding Box : \ ncenter = " + hash . getBoundingBoxCenter ( ) ) ; System . out . print ( " corners = " ) ; System . out . println ( hash . getBoundingBox ( ) ) ; }
public void testGetCharacterPrecisionThrows ( ) throws Exception { GeoHash hash = GeoHash . withBitPrecision ( 37 . 7 , - 122 . 52 , 32 ) ; hash . getCharacterPrecision ( ) ; }
public void itShouldThrowANiceExceptionOnIllegalCharacters ( ) { GeoHash . fromGeohashString ( " abba " ) ; }
public void testGetCharacterPrecisionWorksWhenPrecisionIsMultipleOfFive ( ) throws Exception { GeoHash hash = GeoHash . withBitPrecision ( 37 . 7 , - 122 . 52 , 60 ) ; int precision = hash . getCharacterPrecision ( ) ; assertEquals ( precision , 12 ) ; }
public void testSeveralBoundingBoxes ( ) { checkSearchYieldsCorrectNumberOfHashes ( 40 . 2090980098 , 40 . 21982983232432 , - 22 . 523432424324 , - 22 . 494234232442 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40 . 09872762 , 41 . 23452234 , 30 . 0113312322 , 31 . 23432 ) ; checkSearchYieldsCorrectHashes ( 47 . 300200 , 47 . 447907 , 8 . 471276 , 8 . 760941 , " u0qj " ) ; checkSearchYieldsCorrectHashes ( 47 . 157502 , 47 . 329727 , 8 . 562244 , 8 . 859215 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; checkSearchYieldsCorrectNumberOfHashes ( 40 . 2090980098 , 40 . 21982983232432 , 170 . 523432424324 , - 170 . 494234232442 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40 . 2090980098 , 40 . 21982983232432 , 170 . 523432424324 , 160 . 494234232442 ) ; checkSearchYieldsCorrectHashes ( 40 . 2090980098 , 40 . 21982983232432 , 170 . 523432424324 , - 170 . 494234232442 , " xz " , " 8p " ) ; checkSearchYieldsCorrectBinaryHashes ( 47 . 157502 , 47 . 329727 , 179 . 062244 , - 179 . 859215 , " 1111101010101111 " , " 010100000000010100000 " , " 010100000000010100010 " ) ; checkSearchYieldsCorrectBinaryHashes ( 47 . 157502 , 47 . 329727 , 179 . 062244 , 160 , " " ) ; checkSearchYieldsCorrectBinaryHashes ( 47 . 157502 , 47 . 329727 , 179 . 062244 , - 1 , " 01 " , " 1111101010101111 " ) ; }
private void checkSearchYieldsCorrectNumberOfHashes ( double southLat , double northLat , double westLon , double eastLon ) { GeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( southLat , northLat , westLon , eastLon ) ) ; assertRightNumberOfSearchHashes ( search ) ; }
private void assertRightNumberOfSearchHashes ( GeoHashQuery search ) { int size = search . getSearchHashes ( ) . size ( ) ; assertTrue ( size < = 8 & & size > 0 ) ; }
public void testHashCode ( ) { assertEquals ( a . hashCode ( ) , b . hashCode ( ) ) ; assertFalse ( a . hashCode ( ) = = c . hashCode ( ) ) ; }
public void testEqualsObject ( ) { assertEquals ( a , b ) ; assertEquals ( b , a ) ; assertFalse ( a . equals ( c ) ) ; assertEquals ( d , e ) ; assertEquals ( e , d ) ; assertFalse ( c . equals ( d ) ) ; assertFalse ( c . equals ( a ) ) ; }
public void testContains ( ) { BoundingBox bbox = new BoundingBox ( 45 , 46 , 120 , 121 ) ; assertContains ( bbox , new WGS84Point ( 45 . 5 , 120 . 5 ) ) ; assertNotContains ( bbox , new WGS84Point ( 90 , 90 ) ) ; bbox = new BoundingBox ( 45 , 46 , 170 , - 170 ) ; assertContains ( bbox , new WGS84Point ( 45 . 5 , 175 ) ) ; assertContains ( bbox , new WGS84Point ( 45 . 5 , - 175 ) ) ; assertNotContains ( bbox , new WGS84Point ( 45 . 5 , - 165 ) ) ; assertNotContains ( bbox , new WGS84Point ( 45 . 5 , 165 ) ) ; }
public void testSize ( ) { BoundingBox bbox = new BoundingBox ( 45 , 90 , 0 , 30 ) ; assertHeightIs ( bbox , 45 ) ; assertWidthIs ( bbox , 30 ) ; bbox = new BoundingBox ( - 45 , 45 , - 22 . 5 , 30 ) ; assertHeightIs ( bbox , 90 ) ; assertWidthIs ( bbox , 52 . 5 ) ; bbox = new BoundingBox ( - 46 . 1 , - 44 , - 128 , - 127 . 2 ) ; assertHeightIs ( bbox , 2 . 1 ) ; assertWidthIs ( bbox , 0 . 8 ) ; bbox = new BoundingBox ( 45 , 90 , 170 , - 170 ) ; assertHeightIs ( bbox , 45 ) ; assertWidthIs ( bbox , 20 ) ; }
private void assertWidthIs ( BoundingBox bbox , double width ) { assertEquals ( width , bbox . getLongitudeSize ( ) , DELTA ) ; }
private void assertHeightIs ( BoundingBox bbox , double height ) { assertEquals ( height , bbox . getLatitudeSize ( ) , DELTA ) ; }
public void testIntersects ( ) { BoundingBox bbox = new BoundingBox ( - 10 , 10 , 40 , 41 ) ; assertIntersects ( bbox , new BoundingBox ( - 15 , 5 , 40 . 5 , 43 ) ) ; assertDoesNotIntersect ( bbox , new BoundingBox ( - 15 , 5 , 42 , 43 ) ) ; bbox = new BoundingBox ( 45 , 90 , 170 , - 170 ) ; assertIntersects ( bbox , new BoundingBox ( 50 , 55 , 175 , 176 ) ) ; assertIntersects ( bbox , new BoundingBox ( 50 , 55 , 160 , 176 ) ) ; assertIntersects ( bbox , new BoundingBox ( 50 , 55 , - 175 , - 176 ) ) ; assertIntersects ( bbox , new BoundingBox ( 50 , 55 , - 160 , - 176 ) ) ; assertIntersects ( bbox , new BoundingBox ( 50 , 55 , 175 , - 175 ) ) ; assertIntersects ( bbox , new BoundingBox ( 50 , 55 , - 175 , 175 ) ) ; assertDoesNotIntersect ( bbox , new BoundingBox ( - 15 , 5 , 42 , 43 ) ) ; assertDoesNotIntersect ( bbox , new BoundingBox ( - 15 , 5 , 175 , 176 ) ) ; assertDoesNotIntersect ( bbox , new BoundingBox ( - 15 , 5 , 175 , - 175 ) ) ; assertDoesNotIntersect ( bbox , new BoundingBox ( 50 , 55 , 160 , 169 ) ) ; assertDoesNotIntersect ( bbox , new BoundingBox ( 50 , 55 , - 169 , - 160 ) ) ; }
public void testExpandToIncludePoint ( ) { BoundingBox bbox = new BoundingBox ( - 10 , 10 , 40 , 41 ) ; WGS84Point point = new WGS84Point ( 0 , 45 ) ; bbox . expandToInclude ( point ) ; assertContains ( bbox , point ) ; assertExpandToInclude ( bbox , - 10 , 10 , 40 , 45 ) ; bbox = new BoundingBox ( - 10 , 10 , 40 , 41 ) ; point = new WGS84Point ( 0 , - 140 ) ; bbox . expandToInclude ( point ) ; assertContains ( bbox , point ) ; assertExpandToInclude ( bbox , - 10 , 10 , 40 , - 140 ) ; assertEquals ( true , bbox . intersects180Meridian ( ) ) ; bbox = new BoundingBox ( - 10 , 10 , 40 , 41 ) ; point = new WGS84Point ( 0 , 35 ) ; bbox . expandToInclude ( point ) ; assertContains ( bbox , point ) ; assertExpandToInclude ( bbox , - 10 , 10 , 35 , 41 ) ; bbox = new BoundingBox ( - 10 , 10 , 40 , 41 ) ; point = new WGS84Point ( 0 , - 139 ) ; bbox . expandToInclude ( point ) ; assertContains ( bbox , point ) ; assertExpandToInclude ( bbox , - 10 , 10 , - 139 , 41 ) ; assertEquals ( false , bbox . intersects180Meridian ( ) ) ; bbox = new BoundingBox ( - 10 , 10 , 40 , 41 ) ; point = new WGS84Point ( - 20 , 40 ) ; bbox . expandToInclude ( point ) ; assertContains ( bbox , point ) ; assertExpandToInclude ( bbox , - 20 , 10 , 40 , 41 ) ; bbox = new BoundingBox ( - 10 , 10 , 40 , 41 ) ; point = new WGS84Point ( 20 , 40 ) ; bbox . expandToInclude ( point ) ; assertContains ( bbox , point ) ; assertExpandToInclude ( bbox , - 10 , 20 , 40 , 41 ) ; }
private void assertExpandToInclude ( BoundingBox bbox , double southLatitude , double northLatitude , double westLongitude , double eastLongitude ) { assertEquals ( southLatitude , bbox . getSouthLatitude ( ) , DELTA ) ; assertEquals ( northLatitude , bbox . getNorthLatitude ( ) , DELTA ) ; assertEquals ( westLongitude , bbox . getWestLongitude ( ) , DELTA ) ; assertEquals ( eastLongitude , bbox . getEastLongitude ( ) , DELTA ) ; }
private void assertDoesNotIntersect ( BoundingBox bbox , BoundingBox boundingBox ) { assertFalse ( bbox + " should NOT intersect " + boundingBox , bbox . intersects ( boundingBox ) ) ; assertFalse ( boundingBox + " should NOT intersect " + bbox , boundingBox . intersects ( bbox ) ) ; }
private void assertIntersects ( BoundingBox bbox , BoundingBox boundingBox ) { assertTrue ( bbox + " should intersect " + boundingBox , bbox . intersects ( boundingBox ) ) ; assertTrue ( boundingBox + " should intersect " + bbox , boundingBox . intersects ( bbox ) ) ; }
private void assertContains ( BoundingBox box , WGS84Point p ) { assertTrue ( p + " should be in " + box , box . contains ( p ) ) ; }
private void assertNotContains ( BoundingBox box , WGS84Point p ) { assertFalse ( p + " should NOT be in " + box , box . contains ( p ) ) ; }
public void testPositiveValue ( ) { assertEquals ( 58 . 1541 , DoubleUtil . remainderWithFix ( 58 . 1541 , 360 ) , 0 . 00001 ) ; assertEquals ( 93 . 1541 , DoubleUtil . remainderWithFix ( 453 . 1541 , 360 ) , 0 . 00001 ) ; }
public void testNegativeValue ( ) { assertEquals ( 301 . 8459 , DoubleUtil . remainderWithFix ( - 58 . 1541 , 360 ) , 0 . 00001 ) ; assertEquals ( 266 . 8459 , DoubleUtil . remainderWithFix ( - 453 . 1541 , 360 ) , 0 . 00001 ) ; }
public void testDLat ( ) { assertDLatIs ( 180d , 0 ) ; assertDLatIs ( 180d , 1 ) ; assertDLatIs ( 90d , 2 ) ; assertDLatIs ( 0 . 3515625 , 18 ) ; assertDLatIs ( 0 . 3515625 , 19 ) ; }
private void assertDLatIs ( double d , int i ) { assertEquals ( d , GeoHashSizeTable . dLat ( i ) , 0 ) ; }
public void testDLon ( ) { assertDLonIs ( 360 , 0 ) ; assertDLonIs ( 180 , 1 ) ; assertDLonIs ( 0 . 0439453125 , 25 ) ; assertDLonIs ( 0 . 0439453125 , 26 ) ; }
private void assertDLonIs ( double d , int i ) { assertEquals ( d , GeoHashSizeTable . dLon ( i ) , 1 - 128 ) ; }
public BoundingBox generate ( int bits ) { double dLat = GeoHashSizeTable . dLat ( bits ) - DELTA ; double dLon = GeoHashSizeTable . dLon ( bits ) - DELTA ; return new BoundingBox ( 45 - dLat , 45 , 30 - dLon , 30 ) ; }
public BoundingBox generate ( int bits ) { double dLat = GeoHashSizeTable . dLat ( bits ) ; double dLon = GeoHashSizeTable . dLon ( bits ) ; return new BoundingBox ( 0 , dLat + DELTA , 0 , dLon + DELTA ) ; }
public BoundingBox generate ( int bits ) { double dLat = GeoHashSizeTable . dLat ( bits ) ; double dLon = GeoHashSizeTable . dLon ( bits ) ; if ( latitudeAffected = rand . nextBoolean ( ) ) { dLat + = DELTA ; } else { dLon + = DELTA ; } return new BoundingBox ( 0 , dLat , 0 , dLon ) ; }
public void testKnownSmallerBoundingBoxSizes ( ) { checkWithGenerator ( new ALittleTooSmallVerifier ( ) ) ; }
public void testKnownLargerBoundingBoxSizes ( ) { checkWithGenerator ( new BothALittleTooLargeVerifier ( ) ) ; }
public void testKnownOneBitLargerBoxSizes ( ) { checkWithGenerator ( new OnlyOneALittleTooLargeVerifier ( ) ) ; }
public void testIter ( ) { BoundingBox box = new BoundingBox ( 37 . 7 , 37 . 84 , - 122 . 52 , - 122 . 35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 10 ) ) ; checkIterator ( iter ) ; }
public void testIter2 ( ) { BoundingBox box = new BoundingBox ( 37 . 7 , 37 . 84 , - 122 . 52 , - 122 . 35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 35 ) ) ; checkIterator ( iter ) ; }
public void testIter3 ( ) { BoundingBox box = new BoundingBox ( 28 . 5 , 67 . 15 , - 33 . 2 , 44 . 5 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withCharacterPrecision ( box , 2 ) ) ; List < GeoHash > hashes = checkIterator ( iter ) ; assertThat ( hashes . size ( ) , is ( 49 ) ) ; }
public void testAllCells ( ) { BoundingBox box = new BoundingBox ( - 90 , 90 , - 180 , 180 ) ; TwoGeoHashBoundingBox twoGeoHashBoundingBox = TwoGeoHashBoundingBox . withCharacterPrecision ( box , 2 ) ; BoundingBoxGeoHashIterator iterator = new BoundingBoxGeoHashIterator ( twoGeoHashBoundingBox ) ; Set < GeoHash > hashes = new HashSet < > ( ) ; while ( iterator . hasNext ( ) ) { GeoHash hash = iterator . next ( ) ; hashes . add ( hash ) ; } assertThat ( hashes . size ( ) , is ( 1024 ) ) ; }
public static GeoHash create ( ) { return GeoHash . withBitPrecision ( randomLatitude ( ) , randomLongitude ( ) , randomPrecision ( ) ) ; }
public static GeoHash createWith5BitsPrecision ( ) { return GeoHash . withCharacterPrecision ( randomLatitude ( ) , randomLongitude ( ) , randomCharacterPrecision ( ) ) ; }
public static GeoHash createWithPrecision ( int precision ) { return GeoHash . withBitPrecision ( randomLatitude ( ) , randomLongitude ( ) , precision ) ; }
private static double randomLatitude ( ) { return ( rand . nextDouble ( ) - 0 . 5 ) * 180 ; }
private static double randomLongitude ( ) { return ( rand . nextDouble ( ) - 0 . 5 ) * 360 ; }
private static int randomPrecision ( ) { return rand . nextInt ( 60 ) + 5 ; }
private static int randomCharacterPrecision ( ) { return rand . nextInt ( 12 ) + 1 ; }
public void testSampler ( ) { BoundingBox bbox = new BoundingBox ( 37 . 7 , 37 . 84 , - 122 . 52 , - 122 . 35 ) ; BoundingBoxSampler sampler = new BoundingBoxSampler ( TwoGeoHashBoundingBox . withBitPrecision ( bbox , 35 ) , 1179 ) ; bbox = sampler . getBoundingBox ( ) . getBoundingBox ( ) ; GeoHash gh = sampler . next ( ) ; Set < String > hashes = new HashSet < > ( ) ; int sumOfComp = 0 ; int crossingZero = 0 ; GeoHash prev = null ; while ( gh ! = null ) { assertTrue ( bbox . contains ( gh . getOriginatingPoint ( ) ) ) ; assertFalse ( hashes . contains ( gh . toBase32 ( ) ) ) ; hashes . add ( gh . toBase32 ( ) ) ; if ( prev ! = null ) { sumOfComp + = prev . compareTo ( gh ) ; } prev = gh ; if ( sumOfComp = = 0 ) { crossingZero + + ; } gh = sampler . next ( ) ; } assertEquals ( 12875 , hashes . size ( ) ) ; assertEquals ( - 40 , sumOfComp ) ; assertEquals ( 123 , crossingZero ) ; }
public void testKnownPrefixLenghts ( ) { long a = 0x8f00000000000000l ; long b = 0x8000000000000000l ; long c = 0x8800000000000000l ; assertPrefixLength ( 4 , a , b ) ; assertPrefixLength ( 4 , b , c ) ; assertPrefixLength ( 5 , a , c ) ; assertPrefixLength ( 0 , 0x0 , a ) ; assertPrefixLength ( 16 , 0x8888300000000000l , 0x8888c00000000000l ) ; }
private void assertPrefixLength ( int length , long a , long b ) { assertEquals ( length , LongUtil . commonPrefixLength ( a , b ) ) ; }
public int hashCode ( ) { int result = 17 ; result = 37 * result + hashCode ( southLatitude ) ; result = 37 * result + hashCode ( northLatitude ) ; result = 37 * result + hashCode ( westLongitude ) ; result = 37 * result + hashCode ( eastLongitude ) ; return result ; }
public boolean contains ( WGS84Point point ) { return containsLatitude ( point . getLatitude ( ) ) & & containsLongitude ( point . getLongitude ( ) ) ; }
public boolean intersects180Meridian ( ) { return intersects180Meridian ; }
public String toString ( ) { return String . format ( " ( " + latitude + " , " + longitude + " ) " ) ; }
public boolean equals ( Object obj ) { if ( obj instanceof WGS84Point ) { WGS84Point other = ( WGS84Point ) obj ; return latitude = = other . latitude & & longitude = = other . longitude ; } return false ; }
public static String geoHashStringWithCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { GeoHash hash = withCharacterPrecision ( latitude , longitude , numberOfCharacters ) ; return hash . toBase32 ( ) ; }
public GeoHash next ( int step ) { return fromOrd ( ord ( ) + step , significantBits ) ; }
public static long stepsBetween ( GeoHash one , GeoHash two ) { if ( one . significantBits ( ) ! = two . significantBits ( ) ) { throw new IllegalArgumentException ( " It is only valid to compare the number of steps between two hashes if they have the same number of significant bits " ) ; } return two . ord ( ) - one . ord ( ) ; }
public int significantBits ( ) { return significantBits ; }
public boolean within ( GeoHash boundingBox ) { return ( bits & boundingBox . mask ( ) ) = = boundingBox . bits ; }
public boolean contains ( WGS84Point point ) { return boundingBox . contains ( point ) ; }
public boolean enclosesCircleAroundPoint ( WGS84Point point , double radius ) { return false ; }
private static String padLeft ( String s , int n , String pad ) { return String . format ( " % " + n + " s " , s ) . replace ( " " , pad ) ; }
public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj instanceof GeoHash ) { GeoHash other = ( GeoHash ) obj ; if ( other . significantBits = = significantBits & & other . bits = = bits ) { return true ; } } return false ; }
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash southWestCorner = GeoHash . withCharacterPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfCharacters ) ; GeoHash northEastCorner = GeoHash . withCharacterPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfCharacters ) ; return new TwoGeoHashBoundingBox ( southWestCorner , northEastCorner ) ; }
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash southWestCorner = GeoHash . withBitPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfBits ) ; GeoHash northEastCorner = GeoHash . withBitPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfBits ) ; return new TwoGeoHashBoundingBox ( southWestCorner , northEastCorner ) ; }
public String toBase32 ( ) { return southWestCorner . toBase32 ( ) + northEastCorner . toBase32 ( ) ; }
public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
protected static final double dLat ( int bits ) { return 180d / Math . pow ( 2 , bits / 2 ) ; }
protected static final double dLon ( int bits ) { return 360d / Math . pow ( 2 , ( bits + 1 ) / 2 ) ; }
public boolean contains ( GeoHash hash ) { return query . contains ( hash ) ; }
public String toString ( ) { return " Cicle Query [ center = " + center + " , radius = " + getRadiusString ( ) + " ] " ; }
public boolean contains ( WGS84Point point ) { return query . contains ( point ) ; }
private boolean hashContainsBoundingBox ( GeoHash hash , BoundingBox bbox ) { return hash . contains ( bbox . getNorthWestCorner ( ) ) & & hash . contains ( bbox . getSouthEastCorner ( ) ) ; }
public boolean contains ( GeoHash hash ) { for ( GeoHash searchHash : searchHashes ) { if ( hash . within ( searchHash ) ) { return true ; } } return false ; }
public boolean contains ( WGS84Point point ) { return contains ( GeoHash . withBitPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , 64 ) ) ; }
public String toString ( ) { StringBuilder bui = new StringBuilder ( ) ; for ( GeoHash hash : searchHashes ) { bui . append ( hash ) . append ( " \ n " ) ; } return bui . toString ( ) ; }
public String hello ( ) { return " Have a cuke , Duke " ; }
public void iHaveNCukes ( int n , String color ) { this . cukes . put ( color , n ) ; }
public void aTable ( Table table ) { assertEquals ( 1 , table . hashes ( ) . size ( ) ) ; }
public void shouldCreateEnglishLocale ( ) { assertEquals ( Locale . ENGLISH , Utils . localeFor ( " en " ) ) ; }
public void shouldCreateUSLocale ( ) { assertEquals ( Locale . US , Utils . localeFor ( " en - US " ) ) ; }
public void shouldFormatLolcatDoubles ( ) throws ParseException { assertEquals ( 10 . 4 , NumberFormat . getInstance ( Utils . localeFor ( " en - LOL " ) ) . parse ( " 10 . 4 " ) . doubleValue ( ) , 0 . 0 ) ; }
public void shouldFormatEnglishDoubles ( ) throws ParseException { assertEquals ( 10 . 4 , NumberFormat . getInstance ( Utils . localeFor ( " en - US " ) ) . parse ( " 10 . 4 " ) . doubleValue ( ) , 0 . 0 ) ; }
public void shouldFormatNorwegianDoubles ( ) throws ParseException { assertEquals ( 10 . 4 , NumberFormat . getInstance ( Utils . localeFor ( " no " ) ) . parse ( " 10 , 4 " ) . doubleValue ( ) , 0 . 0 ) ; }
public void shouldFormatNorwegianDoublesWithEnglishLocaleDifferently ( ) throws ParseException { assertEquals ( 104 . 0 , NumberFormat . getInstance ( Utils . localeFor ( " en - US " ) ) . parse ( " 10 , 4 " ) . doubleValue ( ) , 0 . 0 ) ; }
public void createLanguage ( ) throws Throwable { language = new ClassLanguage ( mock ( ClassLanguageMixin . class ) , mock ( ExceptionFactory . class ) , mock ( StepMother . class ) , Collections . < ClassAnalyzer > emptyList ( ) ) ; }
public void shouldLoadExistingClassFromJavaFileName ( ) throws Throwable { language . load_code_file ( " foo / java / lang / String . class " ) ; }
public void shouldFailToLoadMissingClassFromJavaFileName ( ) throws Throwable { language . load_code_file ( " foo / java / lang / Strix . class " ) ; }
public void doA ( ) { assertEquals ( " Heldlo from B " , b . message ) ; }
public void doB ( ) { message = " Hello from B " ; }
public void shouldRunBeforeHooksInOrderOfDependencies ( ) throws Throwable { ObjectFactory objectFactory = new PicoFactory ( ) ; ClassLanguageMixin languageMixin = mock ( ClassLanguageMixin . class ) ; language = new ClassLanguage ( languageMixin , mock ( ExceptionFactory . class ) , mock ( StepMother . class ) , Collections . < ClassAnalyzer > singletonList ( new JavaAnalyzer ( ) ) , objectFactory ) ; language . addClass ( A . class ) ; language . addClass ( B . class ) ; language . begin_scenario ( null ) ; InOrder order = inOrder ( languageMixin ) ; order . verify ( languageMixin ) . add_hook ( eq ( " before " ) , argThat ( isHook ( " doA " ) ) ) ; order . verify ( languageMixin ) . add_hook ( eq ( " before " ) , argThat ( isHook ( " doB " ) ) ) ; }
private Matcher < JavaHook > isHook ( String methodName ) { return new HookMatcher ( methodName ) ; }
public void describeTo ( Description description ) { description . appendText ( " Expected " + methodName + " , but got " + actualMethodName ) ; }
public boolean matches ( Object o ) { JavaHook hook = ( JavaHook ) o ; actualMethodName = hook . getMethod ( ) . getName ( ) ; return methodName . equals ( actualMethodName ) ; }
public void setUp ( ) throws Throwable { guiceFactory = new GuiceFactory ( " cuke4duke . internal . jvmclass . SomeModule " ) ; }
protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable { return null ; }
public void shouldConvertFromStringToObject ( ) throws Throwable { assertEquals ( " An Object " , p . transformOne ( " An Object " , Object . class , Locale . getDefault ( ) ) ) ; }
public void shouldConvertFromStringToInt ( ) throws Throwable { assertEquals ( 3 , p . transformOne ( " 3 " , Integer . TYPE , Locale . getDefault ( ) ) ) ; }
public void shouldConvertFromStringToInteger ( ) throws Throwable { assertEquals ( 4 , p . transformOne ( " 4 " , Integer . class , Locale . getDefault ( ) ) ) ; }
public void shouldConvertFromStringToLongPrimitive ( ) throws Throwable { assertEquals ( 3L , p . transformOne ( " 3 " , Long . TYPE , Locale . getDefault ( ) ) ) ; }
public void shouldConvertFromStringToLong ( ) throws Throwable { assertEquals ( 4L , p . transformOne ( " 4 " , Long . class , Locale . getDefault ( ) ) ) ; }
public Class whereIsDino ( ) { return getClass ( ) ; }
public void shouldAllowOneInheritedSubclass ( ) throws Throwable { ClassLanguage classLanguage = new ClassLanguage ( languageMixin , mock ( ExceptionFactory . class ) , stepMother , Arrays . < ClassAnalyzer > asList ( new JavaAnalyzer ( ) ) ) ; classLanguage . addClass ( FlintStone . class ) ; classLanguage . addClass ( Fred . class ) ; classLanguage . begin_scenario ( null ) ; List < StepDefinition > stepDefinitions = classLanguage . getStepDefinitions ( ) ; assertEquals ( 1 , stepDefinitions . size ( ) ) ; assertEquals ( Fred . class , ( ( AbstractStepDefinition ) stepDefinitions . get ( 0 ) ) . invokeWithArgs ( new Object [ 0 ] ) ) ; }
public void shouldFailWithTwoInheritedSubclass ( ) throws Throwable { ClassLanguage classLanguage = new ClassLanguage ( languageMixin , mock ( ExceptionFactory . class ) , stepMother , Arrays . < ClassAnalyzer > asList ( new JavaAnalyzer ( ) ) ) ; classLanguage . addClass ( FlintStone . class ) ; classLanguage . addClass ( Fred . class ) ; classLanguage . addClass ( Wilma . class ) ; classLanguage . begin_scenario ( null ) ; List < StepDefinition > stepDefinitions = classLanguage . getStepDefinitions ( ) ; assertEquals ( 1 , stepDefinitions . size ( ) ) ; assertEquals ( Fred . class , ( ( AbstractStepDefinition ) stepDefinitions . get ( 0 ) ) . invokeWithArgs ( new Object [ 0 ] ) ) ; }
public List methodWithArgsAndException ( String foo , Map bar ) throws IllegalArgumentException , IOException { return null ; }
public void lookupMethod ( ) throws NoSuchMethodException { this . methodWithoutArgs = this . getClass ( ) . getMethod ( " methodWithoutArgs " ) ; this . methodWithArgsAndException = this . getClass ( ) . getMethod ( " methodWithArgsAndException " , String . class , Map . class ) ; }
public void shouldUseSimpleFormatWhenMethodHasException ( ) { assertEquals ( " MethodFormatTest . methodWithArgsAndException ( String , Map ) " , new MethodFormat ( " % c . % m ( % a ) " ) . format ( methodWithArgsAndException ) ) ; }
public void shouldUseSimpleFormatWhenMethodHasNoException ( ) { assertEquals ( " MethodFormatTest . methodWithoutArgs ( ) " , new MethodFormat ( " % c . % m ( % a ) " ) . format ( methodWithoutArgs ) ) ; }
public void dontExecuteMe ( ) { throw new RuntimeException ( " Shouldn ' t be executed " ) ; }
public void shouldRaiseCucumberPendingWhenAnnotatedWithPending ( ) throws Throwable { Method dontExecuteMe = SomethingWithPending . class . getDeclaredMethod ( " dontExecuteMe " ) ; MethodInvoker mi = new MethodInvoker ( new JRubyExceptionFactory ( ) ) ; mi . invoke ( dontExecuteMe , new SomethingWithPending ( ) , new Object [ 0 ] ) ; }
public void shouldDealWithOnlyAscii ( ) throws UnsupportedEncodingException { assertVariables ( " Ja ( . + ) elsker ( . + ) landet " , " Ja vi elsker dette landet " , " vi " , 3 , " dette " , 13 ) ; }
private void assertVariables ( String regex , String string , String v1 , int pos1 , String v2 , int pos2 ) throws UnsupportedEncodingException { List < StepArgument > args = JdkPatternArgumentMatcher . argumentsFrom ( Pattern . compile ( regex ) , string ) ; assertEquals ( 2 , args . size ( ) ) ; assertEquals ( v1 , args . get ( 0 ) . getVal ( ) ) ; assertEquals ( pos1 , args . get ( 0 ) . getByteOffset ( ) ) ; assertEquals ( v2 , args . get ( 1 ) . getVal ( ) ) ; assertEquals ( pos2 , args . get ( 1 ) . getByteOffset ( ) ) ; }
protected String ask ( String question , int timeoutSecs ) { return stepMother . ask ( question , timeoutSecs ) ; }
protected void announce ( String message ) { stepMother . announce ( message ) ; }
protected void embed ( String file , String mimeType ) { stepMother . embed ( file , mimeType ) ; }
public void Given ( String step ) { stepMother . invoke ( step ) ; }
public void Given ( String step , Table table ) { stepMother . invoke ( step , table ) ; }
public void Given ( String step , String multilineString ) { stepMother . invoke ( step , multilineString ) ; }
public void When ( String step ) { Given ( step ) ; }
public void When ( String step , Table table ) { Given ( step , table ) ; }
public void When ( String step , String multilineString ) { Given ( step , multilineString ) ; }
public void Then ( String step ) { Given ( step ) ; }
public void Then ( String step , Table table ) { Given ( step , table ) ; }
public void Then ( String step , String multilineString ) { Given ( step , multilineString ) ; }
public static void World ( Closure body ) { groovyLanguage . registerWorldFactory ( body ) ; }
public static void Before ( Object . . . tagsAndBody ) { addHook ( " before " , tagsAndBody ) ; }
public static void After ( Object . . . tagsAndBody ) { addHook ( " after " , tagsAndBody ) ; }
private static void addHook ( String phase , Object [ ] tagsAndBody ) { if ( tagsAndBody . length = = 0 ) return ; String [ ] tagNames = new String [ tagsAndBody . length - 1 ] ; System . arraycopy ( tagsAndBody , 0 , tagNames , 0 , tagNames . length ) ; Closure body = ( Closure ) tagsAndBody [ tagsAndBody . length - 1 ] ; languageMixin . add_hook ( phase , new GroovyHook ( Arrays . asList ( tagNames ) , body , groovyLanguage ) ) ; }
public static void Given ( Pattern regexp , Closure body ) throws Throwable { registerStepDefinition ( regexp , body ) ; }
public static void When ( Pattern regexp , Closure body ) throws Throwable { registerStepDefinition ( regexp , body ) ; }
public static void Then ( Pattern regexp , Closure body ) throws Throwable { registerStepDefinition ( regexp , body ) ; }
private static void registerStepDefinition ( Pattern regexp , Closure body ) throws Throwable { groovyLanguage . addStepDefinition ( new GroovyStepDefinition ( groovyLanguage , regexp , body ) ) ; }
public void execute ( ) throws BuildException { createArg ( ) . setFile ( getCuke4dukeBinFile ( ) ) ; getCommandLine ( ) . createArgument ( ) . setLine ( args ) ; super . execute ( ) ; }
public void execute ( ) throws BuildException { setClassname ( " org . jruby . Main " ) ; setClasspath ( getJrubyClasspath ( ) ) ; ensureJrubyHomeExists ( ) ; setJRubyHome ( ) ; super . execute ( ) ; }
private void ensureJrubyHomeExists ( ) { getJrubyHome ( ) . mkdirs ( ) ; }
public static String join ( Object [ ] objects , String separator ) { StringBuilder sb = new StringBuilder ( ) ; int i = 0 ; for ( Object o : objects ) { if ( i ! = 0 ) sb . append ( separator ) ; sb . append ( o ) ; i + + ; } return sb . toString ( ) ; }
public void addTransform ( Class < ? > returnType , Transformable javaTransform ) { transformers . put ( returnType , javaTransform ) ; }
protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable { Transformable transformer = transformers . get ( parameterType ) ; return transformer = = null ? null : transformer . transform ( arg , locale ) ; }
public void load_code_file ( String classFile ) throws Throwable { Class < ? > clazz = loadClass ( classFile ) ; addClass ( clazz ) ; }
public void end_scenario ( ) throws Throwable { objectFactory . disposeObjects ( ) ; }
public Object invoke ( Method method , Object [ ] args , Locale locale ) throws Throwable { Object target = objectFactory . getComponent ( method . getDeclaringClass ( ) ) ; Object [ ] transformedArgs = transform ( args , method . getParameterTypes ( ) , locale ) ; return methodInvoker . invoke ( method , target , transformedArgs ) ; }
public void addClass ( Class < ? > clazz ) { classes . add ( clazz ) ; }
public void addStepMother ( StepMother stepMother ) { modules . add ( new StepMotherModule ( stepMother ) ) ; }
public void disposeObjects ( ) { instances . clear ( ) ; }
protected void configure ( ) { bind ( StepMother . class ) . toProvider ( stepMotherProvider ) ; }
public StepMother get ( ) { return stepMother ; }
public void createObjects ( ) { appContext . refresh ( ) ; }
public boolean canHandle ( Class < ? > clazz ) { return true ; }
public void afterPropertiesSet ( ) throws Exception { this . mother = SpringFactory . mother . get ( ) ; SpringFactory . mother . set ( null ) ; }
public Object getObject ( ) throws Exception { return mother ; }
public boolean isSingleton ( ) { return true ; }
public void createObjects ( ) { pico = new PicoBuilder ( ) . withCaching ( ) . build ( ) ; for ( Class < ? > clazz : classes ) { pico . addComponent ( clazz ) ; } for ( Object instance : instances ) { pico . addComponent ( instance ) ; } pico . start ( ) ; }
public void disposeObjects ( ) { pico . stop ( ) ; pico . dispose ( ) ; }
public void addStepMother ( StepMother instance ) { instances . add ( instance ) ; }
public static Object transformStringToObject ( String argument , Locale locale ) { return argument ; }
public static int transformStringToInt ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . intValue ( ) ; }
public static Integer transformStringToInteger ( String argument , Locale locale ) throws ParseException { return transformStringToInt ( argument , locale ) ; }
public static long transformStringToLongPrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . longValue ( ) ; }
public static Long transformStringToLong ( String argument , Locale locale ) throws ParseException { return transformStringToLongPrimitive ( argument , locale ) ; }
public static double transformStringToDoublePrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . doubleValue ( ) ; }
public static Double transformStringToDouble ( String argument , Locale locale ) throws ParseException { return transformStringToDoublePrimitive ( argument , locale ) ; }
public static float transformStringToFloatPrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . floatValue ( ) ; }
public static Float transformStringToFloat ( String argument , Locale locale ) throws ParseException { return transformStringToFloatPrimitive ( argument , locale ) ; }
public static short transformStringToShortPrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . shortValue ( ) ; }
public static Short transformStringToShort ( String argument , Locale locale ) throws ParseException { return transformStringToShortPrimitive ( argument , locale ) ; }
public static byte transformStringToBytePrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . byteValue ( ) ; }
public static Byte transformStringToByte ( String argument , Locale locale ) throws ParseException { return transformStringToBytePrimitive ( argument , locale ) ; }
public static char transformStringToChar ( String argument , Locale locale ) { return argument . charAt ( 0 ) ; }
public static Character transformStringToCharacters ( String argument , Locale locale ) { return argument . charAt ( 0 ) ; }
public static BigDecimal transformStringToBigDecimal ( String argument , Locale locale ) throws ParseException { return BigDecimal . valueOf ( transformStringToDoublePrimitive ( argument , locale ) ) ; }
public static BigInteger transformStringToBigInteger ( String argument , Locale locale ) throws ParseException { return BigInteger . valueOf ( transformStringToLongPrimitive ( argument , locale ) ) ; }
public static boolean transformStringToBooleanPrimitive ( String argument , Locale locale ) { return Boolean . valueOf ( argument ) ; }
public static Boolean transformStringToBoolean ( String argument , Locale locale ) { return Boolean . valueOf ( argument ) ; }
public String regexp_source ( ) { return regexp . toString ( ) ; }
public String file_colon_line ( ) { return regexp_source ( ) ; }
public Object invokeWithArgs ( Object [ ] args ) throws Throwable { return closure . call ( cx , scope , scope , args ) ; }
public List < StepArgument > arguments_from ( String stepName ) { arguments = null ; argumentsFrom . call ( cx , scope , jsStepDefinition , new Object [ ] { stepName , this } ) ; return arguments ; }
public void addArguments ( List < StepArgument > arguments ) { this . arguments = arguments ; }
public void load_code_file ( String jsFile ) throws Throwable { jsFiles . add ( jsFile ) ; }
public void addStepDefinition ( Global jsStepDefinition , NativeFunction argumentsFrom , NativeRegExp regexp , NativeFunction closure ) throws Throwable { addStepDefinition ( new JsStepDefinition ( this , cx , scope , jsStepDefinition , argumentsFrom , regexp , closure ) ) ; }
protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; }
public < T > T transform ( Object arg , Locale locale ) throws Throwable { return ( T ) classLanguage . invoke ( method , new Object [ ] { arg } , locale ) ; }
public String regexp_source ( ) { return regexp . pattern ( ) ; }
public List < StepArgument > arguments_from ( String stepName ) throws UnsupportedEncodingException { return JdkPatternArgumentMatcher . argumentsFrom ( regexp , stepName ) ; }
public String file_colon_line ( ) { return methodFormat . format ( method ) ; }
public Object invokeWithArgs ( Object [ ] args ) throws Throwable { return classLanguage . invoke ( method , args , locale ) ; }
public Class < ? > [ ] alwaysLoad ( ) { return new Class < ? > [ 0 ] ; }
public int compare ( Method m1 , Method m2 ) { return order ( m1 ) - order ( m2 ) ; }
private int order ( Method m ) { Order order = m . getAnnotation ( Order . class ) ; return ( order = = null ) ? Integer . MAX_VALUE : order . value ( ) ; }
public void invoke ( String location , Scenario scenario ) throws Throwable { classLanguage . invokeHook ( method , scenario ) ; }
protected void register ( ) throws Throwable { programmingLanguage . availableStepDefinition ( regexp_source ( ) , file_colon_line ( ) ) ; }
public final void invoke ( List < Object > arguments ) throws Throwable { programmingLanguage . invoked ( regexp_source ( ) , file_colon_line ( ) ) ; invokeWithArgs ( arguments . toArray ( ) ) ; }
final public List < StepMatch > step_matches ( String step_name , String formatted_step_name ) throws Throwable { return step_match_list ( step_name , formatted_step_name ) ; }
public final List < StepMatch > step_match_list ( String step_name , String formatted_step_name ) throws Throwable { List < StepMatch > matches = new ArrayList < StepMatch > ( ) ; for ( StepDefinition stepDefinition : stepDefinitions ) { List < StepArgument > arguments = stepDefinition . arguments_from ( step_name ) ; if ( arguments ! = null ) { matches . add ( languageMixin . create_step_match ( stepDefinition , step_name , formatted_step_name , arguments ) ) ; } } return matches ; }
protected void clearHooksAndStepDefinitions ( ) { languageMixin . clear_hooks ( ) ; stepDefinitions = new ArrayList < StepDefinition > ( ) ; }
public void addBeforeHook ( Hook before ) { languageMixin . add_hook ( " before " , before ) ; }
public void addStepDefinition ( StepDefinition stepDefinition ) { stepDefinitions . add ( stepDefinition ) ; }
public void addAfterHook ( Hook after ) { languageMixin . add_hook ( " after " , after ) ; }
public void availableStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . available_step_definition ( regexp_source , file_colon_line ) ; }
public void invoked ( String regexp_source , String file_colon_line ) { languageMixin . invoked_step_definition ( regexp_source , file_colon_line ) ; }
private Object defaultTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable { Method transformMethod = transformMethods . get ( parameterType ) ; if ( transformMethod = = null ) { throw new CantTransform ( arg , parameterType ) ; } return methodInvoker . invoke ( transformMethod , null , new Object [ ] { arg , locale } ) ; }
public Exception cucumberArityMismatchError ( String message ) { return exceptionFactory . cucumberArityMismatchError ( message ) ; }
public Exception cucumberPending ( String message ) { return exceptionFactory . cucumberPending ( message ) ; }
public Exception error ( String type , String message ) { return exceptionFactory . error ( type , message ) ; }
Object invokeClosure ( Closure body , Object [ ] args , Locale locale ) throws Throwable { body . setDelegate ( currentWorld ) ; Class [ ] classes = body . getParameterTypes ( ) ; Object [ ] transformedArgs = transform ( args , classes , locale ) ; return body . call ( transformedArgs ) ; }
public void begin_scenario ( Scenario scenario ) throws IOException { clearHooksAndStepDefinitions ( ) ; worldFactory = null ; GroovyShell shell = new GroovyShell ( new Binding ( ) ) ; for ( String groovyFile : groovyFiles ) { shell . evaluate ( new File ( groovyFile ) ) ; } currentWorld = worldFactory = = null ? new Object ( ) : worldFactory . call ( ) ; }
public void load_code_file ( String groovyFile ) throws ClassNotFoundException , IOException { groovyFiles . add ( groovyFile ) ; }
public void registerWorldFactory ( Closure worldFactory ) { if ( this . worldFactory ! = null ) { throw new RuntimeException ( " You can only define one World closure " ) ; } this . worldFactory = worldFactory ; }
public void invoke ( String location , Scenario scenario ) throws Throwable { groovyLanguage . invokeClosure ( body , new Object [ ] { scenario } , Locale . getDefault ( ) ) ; }
public String file_colon_line ( ) { return body . toString ( ) ; }
public Object invokeWithArgs ( Object [ ] args ) throws Throwable { return groovyLanguage . invokeClosure ( body , args , Locale . getDefault ( ) ) ; }
public void addIokeStepDefinition ( Object iokeStepDefObject ) throws Throwable { addStepDefinition ( new IkStepDefinition ( this , ioke , ( IokeObject ) iokeStepDefObject ) ) ; }
public void load_code_file ( String ikFile ) throws Throwable { this . ioke . evaluateString ( " use ( \ " " + ikFile + " \ " ) " ) ; }
public String regexp_source ( ) throws Throwable { if ( regexpSource = = null ) findRegexpSource ( ) ; return regexpSource ; }
public String file_colon_line ( ) throws Throwable { return regexp_source ( ) ; }
private void findRegexpSource ( ) throws ControlFlow { IokeObject msg = ioke . newMessage ( " regexp_source " ) ; Message regexp_source = ( Message ) IokeObject . data ( msg ) ; regexpSource = regexp_source . sendTo ( msg , iokeStepDefObject , iokeStepDefObject ) . toString ( ) ; }
public static void addCljStepDefinition ( Pattern regexp , AFunction closure ) throws Throwable { instance . addStepDefinition ( new CljStepDefinition ( instance , regexp , closure ) ) ; }
public static void addCljBeforeHook ( AFunction closure ) { instance . addBeforeHook ( new CljHook ( Collections . < String > emptyList ( ) , closure ) ) ; }
public static void addCljAfterHook ( AFunction closure ) { instance . addAfterHook ( new CljHook ( Collections . < String > emptyList ( ) , closure ) ) ; }
public void load_code_file ( String cljFile ) throws Throwable { Compiler . loadFile ( cljFile ) ; }
private Method lookupInvokeMethod ( Object [ ] args ) throws NoSuchMethodException { return AFunction . class . getMethod ( " invoke " , Utils . objectClassArray ( args . length ) ) ; }
public void invoke ( String location , Scenario scenario ) throws Throwable { closure . call ( ) ; }
public Exception cucumberPending ( String message ) { return error ( " Pending " , message ) ; }
public Exception cucumberArityMismatchError ( String message ) { return error ( " ArityMismatchError " , message ) ; }
public static RubyArray newArray ( Collection < ? > collection ) { RubyArray result = RubyArray . newArray ( getRuntime ( ) ) ; for ( Object o : collection ) { result . add ( o ) ; } return result ; }
public void shouldAddCucumberArgs ( ) { String cucumberArg = " testArg " ; mojo . cucumberArgs = new ArrayList < String > ( ) ; mojo . cucumberArgs . add ( cucumberArg ) ; assertTrue ( mojo . allCucumberArgs ( ) . contains ( cucumberArg ) ) ; }
public void shouldAllowZeroAddCucumberArgs ( ) { mojo . extraCucumberArgs = null ; mojo . allCucumberArgs ( ) ; }
public void shouldSplitAddCucumberArgsIntoRealCucumberArgs ( ) { mojo . extraCucumberArgs = " arg1 arg2 arg3 " ; assertEquals ( " arg1 arg2 arg3 features " , mojo . allCucumberArgs ( ) ) ; }
public void shouldIgnoreNullJvmArg ( ) throws MojoExecutionException { mojo . jvmArgs = Arrays . asList ( " - Dfoo = bar " , null , " " ) ; assertEquals ( Arrays . asList ( " - Dfoo = bar " , " " ) , Arrays . asList ( mojo . cucumber ( " " ) . getCommandLine ( ) . getVmCommand ( ) . getArguments ( ) ) ) ; }
protected void installGem ( String gemArgs ) throws MojoExecutionException { GemTask gem = new GemTask ( ) ; if ( gemDirectory ! = null & & gemDirectory . exists ( ) ) { gem . setDir ( gemDirectory ) ; } gem . setProject ( getProject ( ) ) ; gem . setArgs ( gemArgs + getProxyArg ( ) ) ; gem . execute ( ) ; }
protected File jrubyHome ( ) { return new File ( localRepository . getBasedir ( ) , " . jruby " ) ; }
protected void append ( Path classPath , List < ? > artifacts ) throws DependencyResolutionRequiredException { List < String > list = new ArrayList < String > ( artifacts . size ( ) ) ; for ( Object elem : artifacts ) { String path ; if ( elem instanceof Artifact ) { Artifact a = ( Artifact ) elem ; File file = a . getFile ( ) ; if ( file = = null ) { throw new DependencyResolutionRequiredException ( a ) ; } path = file . getPath ( ) ; } else { path = elem . toString ( ) ; } list . add ( path ) ; } Path p = new Path ( classPath . getProject ( ) ) ; p . setPath ( StringUtils . join ( list . iterator ( ) , File . pathSeparator ) ) ; classPath . append ( p ) ; }
public void buildStarted ( BuildEvent event ) { log ( event ) ; }
public void buildFinished ( BuildEvent event ) { log ( event ) ; }
public void targetStarted ( BuildEvent event ) { log ( event ) ; }
public void targetFinished ( BuildEvent event ) { log ( event ) ; }
public void taskStarted ( BuildEvent event ) { log ( event ) ; }
public void taskFinished ( BuildEvent event ) { log ( event ) ; }
public void messageLogged ( BuildEvent event ) { log ( event ) ; }
String allCucumberArgs ( ) { List < String > allCucumberArgs = new ArrayList < String > ( ) ; if ( cucumberArgs ! = null ) allCucumberArgs . addAll ( cucumberArgs ) ; if ( extraCucumberArgs ! = null ) allCucumberArgs . add ( extraCucumberArgs ) ; allCucumberArgs . add ( features ) ; return Utils . join ( allCucumberArgs . toArray ( ) , " " ) ; }
public void iHaveATransaction ( ) { if ( transaction ! = null ) { throw new RuntimeException ( " Wait what ? The instance is shared across scenarios ? " ) ; } transaction = new Transaction ( " 12345678 " , new BigDecimal ( " 50 . 00 " ) ) ; }
public void iSendTheTransactionToBilling ( ) { response = billingService . sendTransactionToBilling ( transaction ) ; }
public void theResponseShouldBeOK ( ) { assertTrue ( response . isOK ( ) ) ; }
public void iCallAnotherStep ( ) { Given ( " it is magic " ) ; }
public void magicShouldHappen ( ) { assertTrue ( magic ) ; }
public CreateTransactionResponse sendTransactionToBilling ( Transaction transaction ) { Status status = database . createTransaction ( transaction ) ; return new CreateTransactionResponse ( status , " OK " ) ; }
public boolean isOK ( ) { return Status . OK . equals ( status ) ; }
protected void configure ( ) { bind ( BillingDatabase . class ) . toInstance ( simpleBillingDatabase ) ; }
public Status createTransaction ( Transaction transaction ) { return Status . OK ; }
public String toString ( ) { return " Transaction [ amount = " + amount + " , customerId = " + customerId + " ] " ; }
public void checkoutCart ( ) throws Exception { cartManager . checkout ( ) ; }
public void checkOrderCreationAndPrice ( double price ) { List < Order > orders = orderDao . getOrders ( ) ; assertEquals ( 1 , orders . size ( ) ) ; Order order = orders . get ( 0 ) ; assertEquals ( price , order . getPrice ( ) , 0 ) ; }
public void theOrderStateShouldBe ( String state ) { Order . Status status = Order . Status . valueOf ( state ) ; List < Order > orders = orderDao . getOrders ( ) ; assertEquals ( 1 , orders . size ( ) ) ; Order order = orders . get ( 0 ) ; assertEquals ( status , order . getStatus ( ) ) ; }
public void init ( ) { bookQuery = new BookQuery ( ) ; }
public void shutdown ( ) throws NamingException { context . close ( ) ; }
public void searchForAuthor ( String author ) { bookQuery . setAuthor ( author ) ; }
public void searchForTitle ( String title ) { bookQuery . setTitle ( title ) ; }
public void searchForPublisher ( String publisher ) { bookQuery . setPublisher ( publisher ) ; }
public void checkSearchResultCount ( int count ) throws Exception { foundBooks = catalogManager . searchBooks ( bookQuery ) ; assertEquals ( " Result contains wrong count . " , count , foundBooks . size ( ) ) ; }
public void shutdown ( ) throws Exception { context . close ( ) ; }
public void createNewOrder ( ) throws Exception { List < LineItem > lineItems = new ArrayList < LineItem > ( ) ; orderManager . createOrder ( lineItems , null , null ) ; }
public void wait ( int seconds ) throws Exception { Thread . sleep ( seconds * 1000 ) ; }
public void iPutABookIntoMyShoppingCart ( double price ) { Book book = new Book ( ) ; book . setPrice ( price ) ; cartManager . AddBook ( book , 1 ) ; }
public void myShoppingCartShouldContainLineItems ( int count ) { assertEquals ( " Shopping cart contains wrong count . " , count , cartManager . getLineItems ( ) . size ( ) ) ; }
public void theTotalPriceShouldBe ( double price ) { assertEquals ( " Shopping cart contains wrong count . " , price , cartManager . getTotalPrice ( ) , 0 ) ; }
public void createOrder ( List < LineItem > lineItems , Address address , PaymentInfo paymentInfo ) throws Exception { double price = priceCalculator . getTotalPrice ( lineItems , address , paymentInfo ) ; Order order = new Order ( ) ; for ( LineItem lineItem : lineItems ) { order . getLineItems ( ) . add ( lineItem ) ; } order . setPrice ( price ) ; orderDao . addOrder ( order ) ; sendOrder ( order . getId ( ) ) ; }
public void closeOrder ( Timer timer ) throws EJBException { String msg = ( String ) timer . getInfo ( ) ; Order order = entityManager . find ( Order . class , Long . parseLong ( msg ) ) ; order . setStatus ( Order . Status . Closed ) ; }
public void AddBook ( Book book , int quantity ) { LineItem lineItem = new LineItem ( ) ; lineItem . setBook ( book ) ; lineItem . setQuantity ( quantity ) ; lineItems . add ( lineItem ) ; }
public void checkout ( ) throws Exception { orderManager . createOrder ( lineItems , null , null ) ; }
public void addBook ( Book book ) throws Exception { entityManager . persist ( book ) ; }
public void deleteBook ( Book book ) throws Exception { entityManager . remove ( book ) ; }
public void addOrder ( Order order ) throws Exception { entityManager . persist ( order ) ; }
public void deleteOrder ( Order order ) throws Exception { entityManager . remove ( order ) ; }
public void numberShouldBeParserCorrectly ( Double d ) { assertEquals ( 10 . 4 , d , 0 . 0 ) ; }
public void cryWolf ( ) { throw new RuntimeException ( " CRY WOLF " ) ; }
public void thenB4 ( String b4Value ) { assertEquals ( b4Value , b4 ) ; }
public void thenB4AndForever ( String b4AndForeverValue ) { assertEquals ( b4AndForeverValue , b4AndForever ) ; }
public void staticShouldBe ( String expected ) { assertEquals ( expected , myStatic ) ; }
public void checkThatRubyBeforeSetsFlag ( ) { assertTrue ( flag ) ; }
public void intentionallyPending ( ) { throw new RuntimeException ( " We shouldn ' t get here because we are @ Pending " ) ; }
public void intentionallyFailing ( ) { throw new RuntimeException ( " We shouldn ' t get here either because the previous one is pending " ) ; }
public void iAddATable ( Table table ) { List < List < String > > diffList = new ArrayList < List < String > > ( ) ; diffList . add ( Arrays . asList ( " a " , " b " ) ) ; diffList . add ( Arrays . asList ( " 1 " , " 2 " ) ) ; table . diffLists ( diffList ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( ) ; hashes . add ( hash ( " a " , " 1 " , " b " , " 2 " ) ) ; hashes . add ( hash ( " a " , " 1 " , " b " , " 2 " ) ) ; Map < String , Boolean > options = new HashMap < String , Boolean > ( ) ; options . put ( " surplus_row " , false ) ; table . diffHashes ( hashes , options ) ; }
public void iAddAString ( String s ) { assertEquals ( " Hello \ nWorld " , s ) ; }
public void iShouldHaveNCukes ( int n , String color ) { int number = cukes . get ( color ) ! = null ? cukes . get ( color ) : 0 ; assertEquals ( n , number ) ; }
public void convertTable ( Table t ) { t . mapColumn ( " b " , new CellConverter ( ) { public String convertCell ( String cellValue ) { return " converted_ " + cellValue ; } } ) ; t . mapHeaders ( new HashMap < Object , String > ( ) { { put ( " a " , " A " ) ; } } ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( ) ; hashes . add ( hash ( " A " , " eenie " , " b " , " converted_meenie " ) ) ; hashes . add ( hash ( " A " , " miney " , " b " , " converted_moe " ) ) ; assertEquals ( hashes , t . hashes ( ) ) ; }
public String convertCell ( String cellValue ) { return " converted_ " + cellValue ; }
public User transformStringToUserWithAge ( String age ) { return new User ( Integer . valueOf ( age ) ) ; }
public boolean overrideBooleanPrimitiveTransform ( String boolValue ) { return boolValue . equals ( " yes " ) ; }
public void transformToA ( int value ) { assertEquals ( 10 , value ) ; }
public void transformToA ( User user ) { this . user = user ; }
public void iPassYesToAMethodWithBooleanAsParameter ( boolean yes ) { this . yes = yes ; }
public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; }
public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; }
public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; }
public void theParameterIsTrue ( ) { assertTrue ( yes ) ; }
public void visit ( ) { d . get ( " http : / / google . com / " ) ; }
public void search ( String query ) { WebElement searchField = d . findElement ( By . name ( " q " ) ) ; searchField . sendKeys ( query ) ; searchField . submit ( ) ; }
public void letsDebug ( ) throws InvocationTargetException , InstantiationException , IllegalAccessException { WebDriverFacade wdf = new WebDriverFacade ( ) ; ResultsPage rp = new ResultsPage ( wdf ) ; SearchPage sp = new SearchPage ( wdf ) ; sp . visit ( ) ; sp . search ( " cucumber github " ) ; rp . shouldSee ( " < em > Cucumber < / em > itself is written in Ruby " ) ; }
public WebDriver getWebDriver ( ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( browser = = null ) { browser = driverConstructor . newInstance ( ) ; } return browser ; }
public void shouldSee ( String results ) { assertThat ( d . getPageSource ( ) , containsString ( results ) ) ; }
public void push ( double arg ) { stack . add ( arg ) ; }
public double divide ( ) { return stack . get ( 0 ) / stack . get ( 1 ) ; }
public void itIsMagic ( ) { this . magic = true ; }
public void iHaveAGreeter ( ) { assertNotNull ( greeter ) ; }
public void iAskTheWorldForHello ( ) { helloResponse = greeter . hello ( ) ; }
public void theResponseShouldBe ( String response ) { assertEquals ( response , helloResponse ) ; }
public String hello ( ) { return " Have a cuke , Duke ! " ; }
private Field getField ( final Class < ? > clazz , final String name ) throws NoSuchFieldException { final Field field = clazz . getDeclaredField ( name ) ; field . setAccessible ( true ) ; return field ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( _gender = = null ) ? 0 : _gender . hashCode ( ) ) ; result = prime * result + ( ( _name = = null ) ? 0 : _name . hashCode ( ) ) ; result = prime * result + ( ( _props = = null ) ? 0 : _props . hashCode ( ) ) ; return result ; }
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final Person other = ( Person ) obj ; if ( _gender = = null ) { if ( other . _gender ! = null ) return false ; } else if ( ! _gender . equals ( other . _gender ) ) return false ; if ( _name = = null ) { if ( other . _name ! = null ) return false ; } else if ( ! _name . equals ( other . _name ) ) return false ; if ( _props = = null ) { if ( other . _props ! = null ) return false ; } else if ( ! _props . equals ( other . _props ) ) return false ; return true ; }
public String toString ( ) { return " Person [ _gender = " + _gender + " , _name = " + _name + " , _props = " + _props + " ] " ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( _email = = null ) ? 0 : _email . hashCode ( ) ) ; result = prime * result + ( ( _name = = null ) ? 0 : _name . hashCode ( ) ) ; return result ; }
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final Email other = ( Email ) obj ; if ( _email = = null ) { if ( other . _email ! = null ) return false ; } else if ( ! _email . equals ( other . _email ) ) return false ; if ( _name = = null ) { if ( other . _name ! = null ) return false ; } else if ( ! _name . equals ( other . _name ) ) return false ; return true ; }
public String toString ( ) { return " Email [ _email = " + _email + " , _name = " + _name + " ] " ; }
public SessionAttributesTranscoder createTranscoder ( SessionManager manager ) { return getTranscoder ( manager ) ; }
private JSONTranscoder getTranscoder ( final Manager manager ) { if ( transcoder = = null ) { transcoder = new JSONTranscoder ( manager ) ; } return transcoder ; }
protected GenericPrincipal createPrincipal ( ) { return new GenericPrincipal ( null , " foo " , " bar " ) ; }
protected void setupGetResponseSetCookieHeadersExpectations ( final Response response , final String [ ] result ) { when ( response . getHeaderValues ( eq ( " Set - Cookie " ) ) ) . thenReturn ( result ) ; }
protected SessionManager createSessionManager ( Context context ) { MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( context ) ; return manager ; }
protected void startInternal ( final SessionManager manager , final MemcachedClient memcachedMock ) throws LifecycleException { ( ( MemcachedBackupSessionManager ) manager ) . startInternal ( new MemcachedStorageClient ( memcachedMock ) ) ; } ;
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { super . testSessionsRefCountHandlingIssue111 ( ) ; }
protected SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return new JavaSerializationTranscoder ( manager ) ; }
public Tomcat6Builder tomcatBuilder ( ) { return new Tomcat6Builder ( ) ; }
public Tomcat6Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; }
public void stop ( ) throws Exception { tomcat . stop ( ) ; }
protected Context createContext ( @ Nonnull final Embedded catalina , @ Nonnull final String contextPath , @ Nonnull final String docBase ) { return catalina . createContext ( contextPath , docBase ) ; }
protected SessionManager createSessionManager ( ) { return new MemcachedBackupSessionManager ( ) ; }
private static SecurityConstraint createSecurityConstraint ( final String pattern , final String role ) { final SecurityConstraint constraint = new SecurityConstraint ( ) ; final SecurityCollection securityCollection = new SecurityCollection ( ) ; securityCollection . addPattern ( pattern ) ; constraint . addCollection ( securityCollection ) ; if ( role ! = null ) { constraint . addAuthRole ( role ) ; } return constraint ; }
protected void startInternal ( final StorageClient storageClient ) throws LifecycleException { _msm . setStorageClient ( storageClient ) ; _msm . startInternal ( ) ; }
public String generateSessionId ( ) { return _msm . newSessionId ( super . generateSessionId ( ) ) ; }
public void expireSession ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " expireSession invoked : " + sessionId ) ; } super . expireSession ( sessionId ) ; _msm . deleteFromMemcached ( sessionId ) ; }
public void remove ( final Session session ) { remove ( session , session . getNote ( MemcachedSessionService . NODE_FAILURE ) ! = Boolean . TRUE ) ; }
public void removeInternal ( final Session session , final boolean update ) { super . remove ( session ) ; }
private void remove ( final Session session , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked , removeFromMemcached : " + removeFromMemcached + " , id : " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session ) ; _msm . sessionRemoved ( ( MemcachedBackupSession ) session ) ; }
public Session findSession ( final String id ) throws IOException { return _msm . findSession ( id ) ; }
public MemcachedBackupSession createSession ( final String sessionId ) { return _msm . createSession ( sessionId ) ; }
public MemcachedBackupSession createEmptySession ( ) { return _msm . createEmptySession ( ) ; }
public MemcachedBackupSession newMemcachedBackupSession ( ) { return new MemcachedBackupSession ( this ) ; }
public void changeSessionId ( final Session session ) { super . changeSessionId ( session ) ; ( ( MemcachedBackupSession ) session ) . setSessionIdChanged ( true ) ; }
public boolean isMaxInactiveIntervalSet ( ) { return _maxInactiveInterval ! = null ; }
public void setEnabled ( final boolean enabled ) throws IllegalStateException { _msm . setEnabled ( enabled ) ; }
public boolean isEnabled ( ) { return _msm . isEnabled ( ) ; }
public boolean isSticky ( ) { return _msm . isSticky ( ) ; }
public void addLifecycleListener ( final LifecycleListener arg0 ) { _lifecycle . addLifecycleListener ( arg0 ) ; }
public LifecycleListener [ ] findLifecycleListeners ( ) { return _lifecycle . findLifecycleListeners ( ) ; }
public void removeLifecycleListener ( final LifecycleListener arg0 ) { _lifecycle . removeLifecycleListener ( arg0 ) ; }
public void start ( ) throws LifecycleException { if ( ! initialized ) { init ( ) ; } if ( _started ) { return ; } _lifecycle . fireLifecycleEvent ( START_EVENT , null ) ; _started = true ; if ( log . isDebugEnabled ( ) ) { log . debug ( " Force random number initialization starting " ) ; } super . generateSessionId ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( " Force random number initialization completed " ) ; } startInternal ( null ) ; }
private void swapOut ( @ Nonnull final StandardSession session ) { if ( ! session . isValid ( ) ) { return ; } session . passivate ( ) ; remove ( session , false ) ; session . recycle ( ) ; }
public void backgroundProcess ( ) { _msm . updateExpirationInMemcached ( ) ; super . backgroundProcess ( ) ; }
public boolean isSessionBackupAsync ( ) { return _msm . isSessionBackupAsync ( ) ; }
public void incrementSessionCounter ( ) { sessionCounter + + ; }
public void incrementRejectedSessions ( ) { _rejectedSessions + + ; }
public boolean isInitialized ( ) { return initialized ; }
public void writePrincipal ( @ Nonnull Principal principal , @ Nonnull ObjectOutputStream oos ) throws IOException { SerializablePrincipal . writePrincipal ( ( GenericPrincipal ) principal , oos ) ; }
public Principal readPrincipal ( final ObjectInputStream ois ) throws ClassNotFoundException , IOException { return SerializablePrincipal . readPrincipal ( ois , getContainer ( ) . getRealm ( ) ) ; }
protected SessionManager createSessionManager ( Context context ) { MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContext ( context ) ; return manager ; }
protected void startInternal ( final SessionManager manager , final MemcachedClient memcachedMock ) throws LifecycleException { manager . getMemcachedSessionService ( ) . setStorageClient ( new MemcachedStorageClient ( memcachedMock ) ) ; ( ( MemcachedBackupSessionManager ) manager ) . start ( ) ; }
protected void setupGetResponseSetCookieHeadersExpectations ( Response response , String [ ] result ) { when ( response . getHeaders ( eq ( " Set - Cookie " ) ) ) . thenReturn ( Arrays . asList ( result ) ) ; }
protected String generateCookieString ( javax . servlet . http . Cookie cookie ) { return COOKIE_PROCESSOR . generateHeader ( cookie ) ; }
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { super . setup ( ) ; final Context context = ( Context ) _manager . getContext ( ) ; when ( _manager . getContext ( ) ) . thenReturn ( context ) ; }
protected GenericPrincipal createPrincipal ( ) { return new GenericPrincipal ( " foo " , " bar " , new ArrayList < String > ( ) ) ; }
public Tomcat8Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; }
public Tomcat8Builder tomcatBuilder ( ) { return new Tomcat8Builder ( ) ; }
protected RequestTrackingContextValve createRequestTrackingContextValve ( final String sessionCookieName ) { final RequestTrackingContextValve result = super . createRequestTrackingContextValve ( sessionCookieName ) ; result . setAsyncSupported ( true ) ; return result ; }
protected RequestTrackingHostValve createRequestTrackingHostValve ( final String sessionCookieName , final CurrentRequest currentRequest ) { final RequestTrackingHostValve result = super . createRequestTrackingHostValve ( sessionCookieName , currentRequest ) ; result . setAsyncSupported ( true ) ; return result ; }
public MemcachedBackupSession createSession ( final String sessionId ) { return _msm . createSession ( sessionId ) ; }
public void expireSession ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " expireSession invoked : " + sessionId ) ; } super . expireSession ( sessionId ) ; _msm . deleteFromMemcached ( sessionId ) ; }
public void remove ( final Session session , final boolean update ) { removeInternal ( session , update , session . getNote ( MemcachedSessionService . NODE_FAILURE ) ! = Boolean . TRUE ) ; }
public void removeInternal ( final Session session , final boolean update ) { super . remove ( session , update ) ; }
private void removeInternal ( final Session session , final boolean update , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked , removeFromMemcached : " + removeFromMemcached + " , id : " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session , update ) ; _msm . sessionRemoved ( ( MemcachedBackupSession ) session ) ; }
public void changeSessionId ( final Session session ) { super . changeSessionId ( session ) ; ( ( MemcachedBackupSession ) session ) . setSessionIdChanged ( true ) ; }
public void startInternal ( ) throws LifecycleException { super . startInternal ( ) ; _msm . startInternal ( ) ; setState ( LifecycleState . STARTING ) ; }
public void stopInternal ( ) throws LifecycleException { setState ( LifecycleState . STOPPING ) ; if ( _msm . isSticky ( ) ) { _log . info ( " Removing sessions from local session map . " ) ; for ( final Session session : sessions . values ( ) ) { swapOut ( ( StandardSession ) session ) ; } } _msm . shutdown ( ) ; super . stopInternal ( ) ; }
private void swapOut ( @ Nonnull final StandardSession session ) { if ( ! session . isValid ( ) ) { return ; } session . passivate ( ) ; removeInternal ( session , true ) ; session . recycle ( ) ; }
public void incrementRejectedSessions ( ) { rejectedSessions + + ; }
public boolean isInitialized ( ) { return getState ( ) = = LifecycleState . INITIALIZED | | getState ( ) = = LifecycleState . STARTED ; }
public void writePrincipal ( @ Nonnull Principal principal , @ Nonnull ObjectOutputStream oos ) throws IOException { oos . writeObject ( principal ) ; }
public Principal readPrincipal ( final ObjectInputStream ois ) throws ClassNotFoundException , IOException { return ( Principal ) ois . readObject ( ) ; }
public void testCreateSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo - n " , cut . createSessionId ( " foo " , " n " ) ) ; assertEquals ( " foo - n . jvm1 " , cut . createSessionId ( " foo . jvm1 " , " n " ) ) ; assertEquals ( " foo - n . j - v - m1 " , cut . createSessionId ( " foo . j - v - m1 " , " n " ) ) ; }
public void testExtractMemcachedId ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " n " , cut . extractMemcachedId ( " foo - n " ) ) ; assertEquals ( " n " , cut . extractMemcachedId ( " foo - n . jvm1 " ) ) ; assertEquals ( " n " , cut . extractMemcachedId ( " foo - n . j - v - m1 " ) ) ; assertEquals ( null , cut . extractMemcachedId ( " foo . j - v - m1 " ) ) ; }
public void testIsValid ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertFalse ( cut . isValid ( " foo " ) ) ; assertFalse ( cut . isValid ( " foo . jvm1 - n " ) ) ; assertFalse ( cut . isValid ( " foo . n . jvm1 " ) ) ; assertFalse ( cut . isValid ( " foo . n . j - v - m1 " ) ) ; assertTrue ( cut . isValid ( " foo - n " ) ) ; assertTrue ( cut . isValid ( " foo - n . jvm1 " ) ) ; assertTrue ( cut . isValid ( " foo - n . j - v - m1 " ) ) ; }
public void testCreateBackupKey ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertEquals ( cut . createBackupKey ( " foo " ) , " bak : localhost_foo " ) ; }
public void testIsBackupKey ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertTrue ( cut . isBackupKey ( " bak : localhost_foo " ) ) ; }
public void testCreateLockName ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertEquals ( cut . createLockName ( " foo " ) , " lock : localhost_foo " ) ; }
public void testCreateValidityInfoKeyName ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertEquals ( cut . createValidityInfoKeyName ( " foo " ) , " validity : localhost_foo " ) ; }
public void testRemove ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 3 ) ; cut . put ( " foo " , " bar " ) ; assertTrue ( cut . containsKey ( " foo " ) ) ; assertEquals ( cut . remove ( " foo " ) , " bar " ) ; assertFalse ( cut . containsKey ( " foo " ) ) ; }
public void testCacheSize ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; cut . put ( " bar " , " baz " ) ; Assert . assertEquals ( " baz " , cut . get ( " bar " ) ) ; Assert . assertNull ( cut . get ( " foo " ) , " old key still existing , unexpected cache size " ) ; }
public void testCacheTTL ( ) throws InterruptedException { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 , 100 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; Thread . sleep ( 120 ) ; Assert . assertNull ( cut . get ( " foo " ) , " expired key still existing , unexpected cache size " ) ; }
public int compare ( final Integer o1 , final Integer o2 ) { return o1 . compareTo ( o2 ) ; }
public void testClear ( ) { final LRUCache < String , Integer > cut = new LRUCache < String , Integer > ( 3 ) ; cut . put ( " foo " , 1 ) ; cut . clear ( ) ; assertNull ( cut . get ( " foo " ) ) ; }
public static void main ( final String [ ] args ) { System . out . println ( System . currentTimeMillis ( ) / 1000 + TimeUnit . DAYS . toSeconds ( 1000 ) ) ; System . out . println ( Integer . MAX_VALUE ) ; }
public void testToMemcachedExpiration ( ) throws Exception { assertEquals ( toMemcachedExpiration ( 60 * 60 * 24 * 30 ) , 60 * 60 * 24 * 30 ) ; assertEquals ( toMemcachedExpiration ( 60 * 60 * 24 * 30 + 1 ) , System . currentTimeMillis ( ) / 1000 + 60 * 60 * 24 * 30 + 1 ) ; }
public byte [ ] get ( final String key ) { return _memcached . get ( key , ByteArrayTranscoder . INSTANCE ) ; }
public void setUp ( final Method testMethod ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? _memcachedNodeId + " : " : " " ; _memcachedNodes = nodePrefix + " localhost : " + _memcachedPort ; try { System . setProperty ( " org . apache . catalina . startup . EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = tcBuilder ( ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } _memcached = createMemcachedClient ( _memcachedNodes , address ) ; _httpClient = new DefaultHttpClient ( ) ; }
private TomcatBuilder < ? > tcBuilder ( ) { return getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( _memcachedNodes ) . sticky ( true ) . jvmRoute ( " app1 " ) ; }
private MemcachedClient createMemcachedClient ( final String memcachedNodes , final InetSocketAddress address ) throws IOException , InterruptedException { final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( memcachedNodes , null , null , _storageClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; final MemcachedClient result = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; Thread . sleep ( 100 ) ; return result ; }
public void tearDown ( ) throws Exception { _memcached . shutdown ( ) ; _tomcat1 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _daemon . stop ( ) ; }
public void testContextReload ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = post ( _httpClient , _portTomcat1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created . " ) ; _tomcat1 . getContext ( ) . reload ( ) ; final Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; final String actualValue = response . get ( " foo " ) ; assertEquals ( " bar " , actualValue ) ; }
public void testConfiguredMemcachedNodeId ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; final String nodeId = sessionId1 . substring ( sessionId1 . indexOf ( ' - ' ) + 1 , sessionId1 . indexOf ( ' . ' ) ) ; assertEquals ( _memcachedNodeId , nodeId , " Invalid memcached node id " ) ; }
public void testSessionIdIsNotChangedIfSingleNodeWithNoMemcachedNodeIdConfigured ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; assertTrue ( sessionId1 . indexOf ( ' - ' ) = = - 1 ) ; }
public void testSessionFoundIfSingleNodeWithNoMemcachedNodeIdConfigured ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , _portTomcat1 , null , key , value ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created . " ) ; final Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; final String sessionId2 = response . getSessionId ( ) ; assertEquals ( sessionId2 , sessionId1 ) ; final String actualValue = response . get ( key ) ; assertEquals ( value , actualValue ) ; }
public void testSessionAvailableInMemcached ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; Thread . sleep ( 50 ) ; assertNotNull ( _memcached . get ( sessionId1 ) , " Session not available in memcached . " ) ; }
public void testSessionAvailableInMemcachedWithCookiesDisabled ( final SessionAffinityMode sessionAffinity ) throws Exception { _tomcat1 . stop ( ) ; _tomcat1 = tcBuilder ( ) . sticky ( sessionAffinity . isSticky ( ) ) . cookies ( false ) . jvmRoute ( " app1 " ) . buildAndStart ( ) ; final Response response = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response . get ( TestServlet . ID ) ; assertNotNull ( sessionId , " No session created . " ) ; Thread . sleep ( 50 ) ; assertNotNull ( _memcached . get ( sessionId ) , " Session not available in memcached . " ) ; }
public void testExpiredSessionRemovedFromMemcached ( @ Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; waitForSessionExpiration ( sessionAffinity . isSticky ( ) ) ; assertNull ( _memcached . get ( sessionId1 ) , " Expired session still existing in memcached " ) ; }
public Object call ( ) throws Exception { return _memcached . get ( new SessionIdFormat ( ) . createValidityInfoKeyName ( sessionId1 ) ) ; }
public void testInvalidSessionNotFound ( @ Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId1 , sessionId2 , " Expired session returned . " ) ; }
public void testDisableMsmAtRuntime ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setSticky ( true ) ; manager . setEnabled ( false ) ; _memcached . shutdown ( ) ; _daemon . stop ( ) ; checkSessionFunctionalityWithMsmDisabled ( ) ; }
private void checkSessionFunctionalityWithMsmDisabled ( ) throws IOException , HttpException , InterruptedException { assertTrue ( _tomcat1 . getManager ( ) . getMemcachedSessionService ( ) . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; assertNull ( new SessionIdFormat ( ) . extractMemcachedId ( sessionId1 ) , " Got a memcached node id , even with msm disabled . " ) ; waitForSessionExpiration ( true ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId2 , sessionId1 , " SessionId not changed . " ) ; }
private void waitForSessionExpiration ( final boolean sticky ) throws InterruptedException { final SessionManager manager = _tomcat1 . getManager ( ) ; assertEquals ( manager . getMemcachedSessionService ( ) . isSticky ( ) , sticky ) ; final Container container = manager . getContext ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( sticky ? container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) : 2 * manager . getMaxInactiveInterval ( ) ) + 1000 ; Thread . sleep ( timeout ) ; }
public void setUp ( final Method testMethod ) throws Throwable { couchbaseProvided = Boolean . parseBoolean ( System . getProperty ( " couchbase . provided " , " false " ) ) ; final int couchbasePort = Integer . parseInt ( System . getProperty ( " couchbase . port " , " 18091 " ) ) ; if ( ! couchbaseProvided ) { cluster . add ( setupCouchbase ( couchbasePort ) ) ; } try { System . setProperty ( " org . apache . catalina . startup . EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( " http : / / localhost : " + couchbasePort + " / pools " ) . sticky ( true ) . memcachedProtocol ( " binary " ) . username ( " default " ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } setupCouchbaseClient ( ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _tomcat1 . getManager ( ) ) ) ; }
public void tearDown ( ) throws Exception { mc . shutdown ( ) ; mc = null ; if ( ! couchbaseProvided ) { tearDownCouchbase ( ) ; } _tomcat1 . stop ( ) ; }
public void testBackupSessionInCouchbase ( ) throws InterruptedException , ExecutionException { final MemcachedSessionService service = _tomcat1 . getService ( ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( mc . get ( sessionId , ByteArrayTranscoder . INSTANCE ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; }
public void testBackupSessionInCouchbaseCluster ( ) throws Exception { final MemcachedSessionService service = _tomcat1 . getService ( ) ; cluster . add ( setupCouchbase ( getMaxCouchbasePort ( ) + 1 ) ) ; service . setMemcachedNodes ( getMemcachedNodesConfig ( getURIs ( ) ) ) ; setupCouchbaseClient ( ) ; waitForReconnect ( service . getStorageClient ( ) , cluster . size ( ) , 1000 ) ; waitForReconnect ( mc , cluster . size ( ) , 1000 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( mc . get ( sessionId , ByteArrayTranscoder . INSTANCE ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; }
private void checkSession ( final MemcachedBackupSession actual , final MemcachedBackupSession expected ) { assertNotNull ( actual ) ; assertEquals ( actual . getId ( ) , expected . getId ( ) ) ; assertEquals ( actual . getAttributesInternal ( ) , expected . getAttributesInternal ( ) ) ; }
private void waitForReconnect ( final StorageClient client , final int expectedServers , final long timeToWait ) throws InterruptedException , RuntimeException { waitForReconnect ( ( ( MemcachedStorageClient ) client ) . getMemcachedClient ( ) , expectedServers , timeToWait ) ; }
private void setupCouchbaseClient ( ) throws URISyntaxException , IOException { if ( mc ! = null ) { LOG . info ( " Closing existing couchbase client . " ) ; mc . shutdown ( ) ; } final List < URI > uris = getURIs ( ) ; LOG . info ( " Creating new couchbase client with uris " + uris ) ; mc = new CouchbaseClient ( uris , " default " , " " ) ; }
private List < URI > getURIs ( ) throws URISyntaxException { final List < URI > uris = new ArrayList < URI > ( cluster . size ( ) ) ; for ( final CouchbaseMock server : cluster ) { uris . add ( new URI ( " http : / / localhost : " + server . getHttpPort ( ) + " / pools " ) ) ; } return uris ; }
private CouchbaseMock setupCouchbase ( final int couchbasePort ) throws IOException { final CouchbaseMock couchbase = new CouchbaseMock ( " localhost " , couchbasePort , 1 , 1 ) ; couchbase . start ( ) ; return couchbase ; }
private void tearDownCouchbase ( ) throws InterruptedException { for ( final CouchbaseMock server : cluster ) { server . stop ( ) ; } cluster . clear ( ) ; }
public void testCounts ( final String getterMethod , final String updateMethod ) throws Exception { final Statistics cut = Statistics . create ( ) ; final Method getMethod = Statistics . class . getMethod ( getterMethod ) ; assertEquals ( ( ( Long ) getMethod . invoke ( cut ) ) . longValue ( ) , 0 ) ; Statistics . class . getMethod ( updateMethod ) . invoke ( cut ) ; assertEquals ( ( ( Long ) getMethod . invoke ( cut ) ) . longValue ( ) , 1 ) ; }
public void testDisabledRequestWithBackup ( ) { final Statistics cut = Statistics . create ( false ) ; assertEquals ( cut . getRequestsWithBackupFailure ( ) , 0 ) ; cut . requestWithBackupFailure ( ) ; assertEquals ( cut . getRequestsWithBackupFailure ( ) , 0 ) ; }
public void testMinMaxAvgProbe ( ) { final MinMaxAvgProbe cut = new MinMaxAvgProbe ( ) ; assertValues ( cut , 0 , 0 , 0 , 0 ) ; cut . register ( 1 ) ; assertValues ( cut , 1 , 1 , 1 , 1 ) ; cut . register ( 1 ) ; assertValues ( cut , 2 , 1 , 1 , 1 ) ; cut . register ( 4 ) ; assertValues ( cut , 3 , 1 , 4 , 2 ) ; cut . register ( 0 ) ; assertValues ( cut , 4 , 0 , 4 , 1 . 5 ) ; }
private void assertValues ( final MinMaxAvgProbe cut , final int count , final int min , final int max , final double avg ) { assertEquals ( cut . getCount ( ) , count ) ; assertEquals ( cut . getMin ( ) , min ) ; assertEquals ( cut . getMax ( ) , max ) ; assertEquals ( cut . getAvg ( ) , avg ) ; }
private void readOnlyRequestsShouldContain ( final ReadOnlyRequestsCache cut , final String key , final boolean shouldBeContained ) { assertEquals ( cut . isReadOnlyRequest ( key ) , shouldBeContained ) ; assertEquals ( cut . getReadOnlyRequests ( ) . contains ( key ) , shouldBeContained ) ; assertEquals ( cut . getReadOnlyRequestsByFrequency ( ) . contains ( key ) , shouldBeContained ) ; }
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; final Context _contextContainer = mock ( Context . class ) ; final Host _hostContainer = mock ( Host . class ) ; final SessionManager _manager = mock ( SessionManager . class ) ; when ( _service . getManager ( ) ) . thenReturn ( _manager ) ; when ( _manager . getContext ( ) ) . thenReturn ( _contextContainer ) ; when ( _contextContainer . getParent ( ) ) . thenReturn ( _hostContainer ) ; when ( _contextContainer . getPath ( ) ) . thenReturn ( " / " ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _sessionTrackerValve . setContainer ( _hostContainer ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " / someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; when ( _request . getContext ( ) ) . thenReturn ( _contextContainer ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . FALSE ) ; }
public final void testProcessRequestNotePresent ( ) throws IOException , ServletException { _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service , never ( ) ) . backupSession ( anyString ( ) , anyBoolean ( ) , anyString ( ) ) ; verify ( _request ) . setNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESS ) , eq ( Boolean . TRUE ) ) ; }
public final void testBackupSessionNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; when ( _response . getHeader ( eq ( " Set - Cookie " ) ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service , never ( ) ) . backupSession ( anyString ( ) , anyBoolean ( ) , anyString ( ) ) ; }
public final void testRequestFinishedShouldBeInvokedForIgnoredResources ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( " foo " ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " / pixel . gif " ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . requestFinished ( eq ( " foo " ) , anyString ( ) ) ; }
protected String generateCookieString ( final Cookie cookie ) { final StringBuffer sb = new StringBuffer ( ) ; ServerCookie . appendCookieValue ( sb , cookie . getVersion ( ) , cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) , true ) ; final String setSessionCookieHeader = sb . toString ( ) ; return setSessionCookieHeader ; }
public MemcachedBackupSession answer ( final InvocationOnMock invocation ) throws Throwable { return newMemcachedBackupSession ( _manager ) ; }
public MemcachedBackupSession answer ( final InvocationOnMock invocation ) throws Throwable { return createSession ( service ) ; }
protected MemcachedBackupSession newMemcachedBackupSession ( @ Nullable final SessionManager manager ) { return new MemcachedBackupSession ( manager ) ; }
public void testSerializeSessionFieldsIncludesFormPrincipalNote ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final Principal saved = createPrincipal ( ) ; session . setNote ( Constants . FORM_PRINCIPAL_NOTE , saved ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; final Principal actual = ( Principal ) deserialized . getNote ( Constants . FORM_PRINCIPAL_NOTE ) ; assertNotNull ( actual ) ; assertDeepEquals ( actual , saved ) ; }
public void testSerializeSessionFieldsIncludesFormRequestNote ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final SavedRequest saved = new SavedRequest ( ) ; saved . setQueryString ( " foo = bar " ) ; saved . setRequestURI ( " http : / / www . foo . org " ) ; session . setNote ( Constants . FORM_REQUEST_NOTE , saved ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; final SavedRequest actual = ( SavedRequest ) deserialized . getNote ( Constants . FORM_REQUEST_NOTE ) ; assertNotNull ( actual ) ; assertDeepEquals ( actual , saved ) ; }
public void testVersionUpgrade ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session , TranscoderService . VERSION_1 ) ; final byte [ ] attributesData = TranscoderService . deserializeSessionFields ( data , _manager ) . getAttributesData ( ) ; assertEquals ( attributesData . length , 0 ) ; }
public void testSerializeSessionFields ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; }
public void testSerializeSessionFieldsWithAuthenticatedPrincipal ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAuthType ( HttpServletRequest . FORM_AUTH ) ; session . setPrincipal ( createPrincipal ( ) ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; }
public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; }
private void assertSessionFields ( final MemcachedBackupSession session , final MemcachedBackupSession deserialized ) { Assert . assertEquals ( session . getCreationTimeInternal ( ) , deserialized . getCreationTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastAccessedTimeInternal ( ) , deserialized . getLastAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getMaxInactiveInterval ( ) , deserialized . getMaxInactiveInterval ( ) ) ; Assert . assertEquals ( session . isNewInternal ( ) , deserialized . isNewInternal ( ) ) ; Assert . assertEquals ( session . isValidInternal ( ) , deserialized . isValidInternal ( ) ) ; Assert . assertEquals ( session . getThisAccessedTimeInternal ( ) , deserialized . getThisAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastBackupTime ( ) , deserialized . getLastBackupTime ( ) ) ; Assert . assertEquals ( session . getIdInternal ( ) , deserialized . getIdInternal ( ) ) ; Assert . assertEquals ( session . getAuthType ( ) , deserialized . getAuthType ( ) ) ; assertDeepEquals ( session . getPrincipal ( ) , deserialized . getPrincipal ( ) ) ; }
public void setUp ( final Method testMethod ) throws Throwable { redisProvided = Boolean . parseBoolean ( System . getProperty ( " redis . provided " , " false " ) ) ; final int redisPort = Integer . parseInt ( System . getProperty ( " redis . port " , " 16379 " ) ) ; if ( ! redisProvided ) { embeddedRedisServer = new RedisServer ( redisPort ) ; embeddedRedisServer . start ( ) ; } try { System . setProperty ( " org . apache . catalina . startup . EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( " redis : / / localhost : " + redisPort ) . sticky ( true ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } redisClient = new BinaryJedis ( " localhost " , redisPort ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _tomcat1 . getManager ( ) ) ) ; }
public void tearDown ( ) throws Exception { if ( redisClient ! = null ) { redisClient . close ( ) ; redisClient = null ; } if ( embeddedRedisServer ! = null ) { embeddedRedisServer . stop ( ) ; embeddedRedisServer = null ; } _tomcat1 . stop ( ) ; }
public void testBackupSessionInRedis ( ) throws InterruptedException , ExecutionException , UnsupportedEncodingException , ClassNotFoundException , IOException { final MemcachedSessionService service = _tomcat1 . getService ( ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( redisClient . get ( sessionId . getBytes ( " UTF - 8 " ) ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; }
public boolean isNodeAvailable ( final String key ) { return true ; }
public final void testGetNextNodeId_SingleNode ( ) { final CacheLoader < String > cacheLoader = new DummyCacheLoader ( null ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( " n1 " ) , null ) ; final String actual = cut . getAvailableNodeId ( " n1 " ) ; assertNull ( actual , " For a sole existing node we cannot get a next node " ) ; }
public final void testGetNextNodeId_TwoNodes ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final CacheLoader < String > cacheLoader = new DummyCacheLoader ( null ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( nodeId1 , nodeId2 ) , null ) ; String actual = cut . getAvailableNodeId ( nodeId1 ) ; assertEquals ( nodeId2 , actual ) ; actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId1 , actual ) ; }
public final void testGetNextNodeId_TwoNodes_NoNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final CacheLoader < String > cacheLoader = new DummyCacheLoader ( Arrays . asList ( nodeId1 ) ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( nodeId1 , nodeId2 ) , null ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertNull ( actual ) ; }
public final void testGetNextNodeId_RegularNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId1 ) ; assertEquals ( nodeId2 , actual , " The failover node is not chosen " ) ; }
public final void testGetNextNodeId_FailoverNode_RegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId1 , actual , " The regular node is not chosen " ) ; }
public final void testGetNextNodeId_FailoverNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( nodeId1 ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertNull ( actual ) ; }
public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( nodeId1 ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 , nodeId3 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId3 , actual , " The second failover node is not chosen " ) ; }
private NodeAvailabilityCache < String > createNodeAvailabilityCache ( final String . . . unavailableNodes ) { final List < String > unavailable = unavailableNodes ! = null ? Arrays . asList ( unavailableNodes ) : null ; return new NodeAvailabilityCache < String > ( 10 , 100 , new DummyCacheLoader ( unavailable ) ) ; }
public boolean isNodeAvailable ( final String key ) { return _unavailable = = null | | ! _unavailable . contains ( key ) ; }
public void beforeClass ( ) { _mcc = mock ( StorageClientCallback . class ) ; }
public void testParseWithNullShouldThrowException ( ) { createFor ( null , null , null , _mcc ) ; }
public void testParseWithEmptyStringShouldThrowException ( ) { createFor ( " " , null , null , _mcc ) ; }
public void testSingleSimpleNodeAndFailoverNodeShouldThrowException ( ) { createFor ( " localhost : 11211 " , " n1 " , null , _mcc ) ; }
public void testSingleNodeAndFailoverNodeShouldThrowException ( ) { createFor ( " n1 : localhost : 11211 " , " n1 " , null , _mcc ) ; }
public void testCouchbaseNodesAndFailoverNodeShouldThrowException ( ) { createFor ( " http : / / localhost : 8091 / pools " , " n1 " , null , _mcc ) ; }
public void testCountNodes ( final String memcachedNodes , final int expectedCount ) { final MemcachedNodesManager result = createFor ( memcachedNodes , null , null , _mcc ) ; assertNotNull ( result ) ; assertEquals ( result . getCountNodes ( ) , expectedCount ) ; }
public void testPrimaryNodes ( final String memcachedNodes , final String failoverNodes , final NodeIdList expectedPrimaryNodeIds ) { final MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; assertNotNull ( result ) ; assertEquals ( result . getPrimaryNodeIds ( ) , expectedPrimaryNodeIds ) ; }
public void testFailoverNodes ( final String memcachedNodes , final String failoverNodes , final List < String > expectedFailoverNodeIds ) { final MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; assertNotNull ( result ) ; assertEquals ( result . getFailoverNodeIds ( ) , expectedFailoverNodeIds ) ; }
public void testIsEncodeNodeIdInSessionId ( final String memcachedNodes , final String failoverNodes , final boolean expectedIsEncodeNodeIdInSessionId ) { final MemcachedNodesManager result = createFor ( memcachedNodes , null , null , _mcc ) ; assertNotNull ( result ) ; assertEquals ( result . isEncodeNodeIdInSessionId ( ) , expectedIsEncodeNodeIdInSessionId ) ; }
public void testGetNodeIdShouldThrowExceptionForNullArgument ( ) { final MemcachedNodesManager result = createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) ; result . getNodeId ( null ) ; }
public void testGetNodeId ( final String memcachedNodes , final String failoverNodes , final InetSocketAddress socketAddress , final String expectedNodeId ) { final MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; assertEquals ( result . getNodeId ( socketAddress ) , expectedNodeId ) ; }
public void testGetNextPrimaryNodeId ( ) { assertNull ( createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) . getNextPrimaryNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 " , null , null , _mcc ) . getNextPrimaryNodeId ( " n1 " ) , " n2 " ) ; }
public void testGetNextAvailableNodeId ( ) throws IOException { assertNull ( createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) , " n2 " ) ; final StorageClientCallback mcc = mock ( StorageClientCallback . class ) ; when ( mcc . get ( anyString ( ) ) ) . thenReturn ( null ) ; when ( mcc . get ( endsWith ( " n2 " ) ) ) . thenThrow ( new OperationTimeoutException ( " SimulatedException " ) ) ; assertNull ( createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 , n3 : localhost : 11213 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) , " n3 " ) ; }
public void testGetAllMemcachedAddresses ( final String memcachedNodes , final String failoverNodes , final Collection < InetSocketAddress > expectedSocketAddresses ) { final MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; assertEquals ( result . getAllMemcachedAddresses ( ) , expectedSocketAddresses ) ; }
public void testGetSessionIdFormat ( ) { final SessionIdFormat sessionIdFormat = createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) . getSessionIdFormat ( ) ; assertNotNull ( sessionIdFormat ) ; }
public void testSessionIdFormatForSingleNodeSetupShouldSupportLocking ( ) { final SessionIdFormat sessionIdFormat = createFor ( " localhost : 11211 " , null , StorageKeyFormat . EMPTY , _mcc ) . getSessionIdFormat ( ) ; assertNotNull ( sessionIdFormat ) ; final String sessionId = " 12345678 " ; assertEquals ( sessionIdFormat . createLockName ( sessionId ) , " lock : " + sessionId ) ; }
public void testCreateSessionIdShouldOnlyAddNodeIdIfPresent ( ) { assertEquals ( createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) . createSessionId ( " foo " ) , " foo - n1 " ) ; assertEquals ( createFor ( " localhost : 11211 " , null , null , _mcc ) . createSessionId ( " foo " ) , " foo " ) ; }
public void testSetNodeAvailable ( ) { final MemcachedNodesManager cut = createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 " , null , null , _mcc ) ; assertTrue ( cut . isNodeAvailable ( " n1 " ) ) ; assertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; cut . setNodeAvailable ( " n1 " , false ) ; assertFalse ( cut . isNodeAvailable ( " n1 " ) ) ; assertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; }
public void testIsCouchbaseBucketConfig ( ) { assertTrue ( createFor ( " http : / / 10 . 10 . 0 . 1 : 8091 / pools " , null , null , _mcc ) . isCouchbaseBucketConfig ( ) ) ; assertTrue ( createFor ( " http : / / 10 . 10 . 0 . 1 : 8091 / pools , http : / / 10 . 10 . 0 . 2 : 8091 / pools " , null , null , _mcc ) . isCouchbaseBucketConfig ( ) ) ; }
private static String sessionId ( final String plainId , final String memcachedId , final String jvmRoute ) { final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final String withMemcachedId = sessionIdFormat . createSessionId ( plainId , memcachedId ) ; return jvmRoute ! = null ? sessionIdFormat . changeJvmRoute ( withMemcachedId , jvmRoute ) : withMemcachedId ; }
public void testBlankValue ( ) { assertEquals ( StorageKeyFormat . of ( null , null , null , null ) . format ( " foo " ) , " foo " ) ; assertEquals ( StorageKeyFormat . of ( " " , null , null , null ) . format ( " foo " ) , " foo " ) ; }
public void testPrefixBuilderFactory ( ) { final String prefix = PrefixTokenFactory . parse ( " static : foo " , null , null , null ) ; assertEquals ( prefix , " foo " ) ; }
public void testStaticValue ( ) { final StorageKeyFormat cut = StorageKeyFormat . of ( " static : x " , null , null , null ) ; assertNotNull ( cut ) ; assertEquals ( cut . format ( " foo " ) , " x_foo " ) ; }
public void testHost ( ) { final StorageKeyFormat cut = StorageKeyFormat . of ( " host " , " hst " , null , null ) ; assertNotNull ( cut ) ; assertEquals ( cut . format ( " foo " ) , " hst_foo " ) ; }
public void testHostHash ( ) { final StorageKeyFormat cut = StorageKeyFormat . of ( " host . hash " , " hst " , null , null ) ; assertNotNull ( cut ) ; assertEquals ( cut . format ( " foo " ) , hashString ( " hst " ) + " _foo " ) ; }
public void testContext ( ) { assertEquals ( StorageKeyFormat . of ( " context " , null , " ctxt " , null ) . format ( " foo " ) , " ctxt_foo " ) ; assertEquals ( StorageKeyFormat . of ( " context " , null , null , null ) . format ( " foo " ) , " foo " ) ; assertEquals ( StorageKeyFormat . of ( " context " , null , " " , null ) . format ( " foo " ) , " foo " ) ; }
public void testContextHash ( ) { assertEquals ( StorageKeyFormat . of ( " context . hash " , null , " ctxt " , null ) . format ( " foo " ) , hashString ( " ctxt " ) + " _foo " ) ; }
public void testWebappVersion ( ) { assertEquals ( StorageKeyFormat . of ( " webappVersion " , null , null , " 001 " ) . format ( " foo " ) , " 001_foo " ) ; assertEquals ( StorageKeyFormat . of ( " webappVersion " , null , null , null ) . format ( " foo " ) , " foo " ) ; assertEquals ( StorageKeyFormat . of ( " webappVersion " , null , null , " " ) . format ( " foo " ) , " foo " ) ; }
public void testHostAndContext ( ) { assertEquals ( StorageKeyFormat . of ( " host , context " , " hst " , " ctxt " , null ) . format ( " foo " ) , " hst : ctxt_foo " ) ; assertEquals ( StorageKeyFormat . of ( " host , context " , " hst " , " " , null ) . format ( " foo " ) , " hst_foo " ) ; }
public void testHostAndContextHashesWithWebappVersion ( ) { final StorageKeyFormat cut = StorageKeyFormat . of ( " host . hash , context . hash , webappVersion " , " hst " , " ctxt " , " 001 " ) ; assertNotNull ( cut ) ; assertEquals ( cut . format ( " foo " ) , hashString ( " hst " ) + " : " + hashString ( " ctxt " ) + " : 001_foo " ) ; }
public void beforeMethod ( ) { cut = new MemcachedBackupSession ( ) ; executor = Executors . newCachedThreadPool ( ) ; alternateExecutor = Executors . newCachedThreadPool ( ) ; }
public void afterMethod ( ) { executor . shutdown ( ) ; alternateExecutor . shutdown ( ) ; }
public void testRefCount ( ) throws InterruptedException , ExecutionException { assertEquals ( cut . getRefCount ( ) , 0 ) ; cut . registerReference ( ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; cut . releaseReference ( ) ; assertEquals ( cut . getRefCount ( ) , 0 ) ; final Runnable registerReference = new Runnable ( ) { @ Override public void run ( ) { cut . registerReference ( ) ; } } ; executor . submit ( registerReference ) . get ( ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; alternateExecutor . submit ( registerReference ) . get ( ) ; assertEquals ( cut . getRefCount ( ) , 2 ) ; cut . releaseReference ( ) ; assertEquals ( cut . getRefCount ( ) , 2 ) ; }
public void afterMethod ( ) { _executor . shutdown ( ) ; }
protected void startInternal ( @ Nonnull final SessionManager manager , @ Nonnull final MemcachedClient memcachedMock ) throws LifecycleException { throw new UnsupportedOperationException ( ) ; }
public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 , n2 : 127 . 0 . 0 . 1 : 11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; }
public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 n3 : 127 . 0 . 0 . 1 : 11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 n3 : 127 . 0 . 0 . 1 : 11213 " ) ; _service . setFailoverNodes ( " n1 , n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; }
public void testConfigurationFormatMemcachedNodesFeature105 ( ) throws LifecycleException { _service . setMemcachedNodes ( " 127 . 0 . 0 . 1 : 11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . getCountNodes ( ) , 1 ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isEncodeNodeIdInSessionId ( ) , false ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 " ) , true ) ; _service . shutdown ( ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . getCountNodes ( ) , 1 ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isEncodeNodeIdInSessionId ( ) , true ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 " ) , false ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 - n1 " ) , true ) ; }
public void testBackupSessionFailureWithoutMemcachedNodeIdConfigured105 ( ) throws Exception { _service . setMemcachedNodes ( " 127 . 0 . 0 . 1 : 11211 " ) ; _service . setSessionBackupAsync ( false ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; final MemcachedBackupSession session = createSession ( _service ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; @ SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > futureMock = mock ( OperationFuture . class ) ; when ( futureMock . get ( ) ) . thenThrow ( new ExecutionException ( new RuntimeException ( " Simulated exception . " ) ) ) ; when ( futureMock . get ( anyInt ( ) , any ( TimeUnit . class ) ) ) . thenThrow ( new ExecutionException ( new RuntimeException ( " Simulated exception . " ) ) ) ; when ( _memcachedMock . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ) . thenReturn ( futureMock ) ; final BackupResult backupResult = _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . FAILURE ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ; }
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; final String sessionId = " someSessionNotLoaded - n1 " ; final String validityKey = new SessionIdFormat ( ) . createValidityInfoKeyName ( sessionId ) ; final byte [ ] validityData = encode ( - 1 , System . currentTimeMillis ( ) , System . currentTimeMillis ( ) ) ; when ( _memcachedMock . get ( eq ( validityKey ) , any ( Transcoder . class ) ) ) . thenReturn ( validityData ) ; @ SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > futureMock = mock ( OperationFuture . class ) ; when ( futureMock . get ( ) ) . thenReturn ( Boolean . FALSE ) ; when ( futureMock . get ( anyInt ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( Boolean . FALSE ) ; when ( _memcachedMock . add ( any ( String . class ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ) . thenReturn ( futureMock ) ; _service . backupSession ( sessionId , false , " unused " ) . get ( ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( validityKey ) , eq ( 0 ) , any ( ) , any ( Transcoder . class ) ) ; _service . getLockingStrategy ( ) . getExecutorService ( ) . shutdown ( ) ; Thread . sleep ( 15 ) ; verify ( _memcachedMock , times ( 1 ) ) . add ( eq ( sessionId ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ; final String backupSessionKey = new SessionIdFormat ( ) . createBackupKey ( sessionId ) ; verify ( _memcachedMock , times ( 1 ) ) . add ( eq ( backupSessionKey ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ; final String backupValidityKey = new SessionIdFormat ( ) . createBackupKey ( validityKey ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( backupValidityKey ) , eq ( 0 ) , any ( ) , any ( Transcoder . class ) ) ; }
public BackupResult call ( ) throws Exception { final MemcachedBackupSession session3 = _service . findSession ( session . getId ( ) ) ; assertSame ( session3 , session2 ) ; assertEquals ( session3 . getRefCount ( ) , 2 ) ; barrier . await ( ) ; barrier . await ( ) ; final Future < BackupResult > result = _service . backupSession ( session . getId ( ) , false , " unused " ) ; _service . getTrackingHostValve ( ) . resetRequestThreadLocal ( ) ; assertEquals ( result . get ( ) . getStatus ( ) , BackupResultStatus . SUCCESS ) ; assertFalse ( _service . getManager ( ) . getSessionsInternal ( ) . containsKey ( session . getId ( ) ) ) ; assertEquals ( session2 . getRefCount ( ) , 0 ) ; return result . get ( ) ; }
public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137 ( ) throws Exception { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; final String sessionId = " nonStickySessionToTimeOut - n1 " ; final Request requestMock = mock ( Request . class ) ; when ( requestMock . getNote ( eq ( RequestTrackingContextValve . INVOKED ) ) ) . thenReturn ( Boolean . TRUE ) ; _service . getTrackingHostValve ( ) . storeRequestThreadLocal ( requestMock ) ; final MemcachedBackupSession session = _service . findSession ( sessionId ) ; assertNull ( session ) ; _service . backupSession ( sessionId , false , null ) . get ( ) ; final String validityKey = new SessionIdFormat ( ) . createValidityInfoKeyName ( sessionId ) ; verify ( _memcachedMock , times ( 0 ) ) . get ( eq ( validityKey ) ) ; }
public void testDecodeEncodedData ( ) { final byte [ ] encoded = SessionValidityInfo . encode ( 23 , 42 , 4711 ) ; final SessionValidityInfo decoded = SessionValidityInfo . decode ( encoded ) ; assertEquals ( decoded . getMaxInactiveInterval ( ) , 23 ) ; assertEquals ( decoded . getLastAccessedTime ( ) , 42 ) ; assertEquals ( decoded . getThisAccessedTime ( ) , 4711 ) ; }
public void negativeInactivityAlwaysValid ( ) { final SessionValidityInfo info = new SessionValidityInfo ( - 1 , 0 , 0 ) ; assertTrue ( info . isValid ( ) ) ; }
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESS ) ) ) . thenReturn ( Boolean . TRUE ) ; }
protected RequestTrackingContextValve createSessionTrackerValve ( ) { return new RequestTrackingContextValve ( " foo " , _service ) ; }
public final void testGetSessionCookieName ( ) throws IOException , ServletException { final RequestTrackingContextValve cut = new RequestTrackingContextValve ( " foo " , _service ) ; assertEquals ( cut . getSessionCookieName ( ) , " foo " ) ; }
public final void testRequestIsMarkedAsProcessed ( ) throws IOException , ServletException { _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _request ) . setNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) , eq ( Boolean . TRUE ) ) ; }
protected void beforeTest ( ) { Configuration configuration = new Configuration ( ) . addAnnotatedClass ( Person . class ) . addAnnotatedClass ( Animal . class ) . configure ( ) ; StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder ( ) . applySettings ( configuration . getProperties ( ) ) . build ( ) ; _sessionFactory = configuration . buildSessionFactory ( serviceRegistry ) ; }
private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @ Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @ SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; }
public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @ SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; }
private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @ Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; }
public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; }
public String toString ( ) { return " Person [ id = " + id + " , name = " + name + " , animals = " + animals + " ] " ; }
public String toString ( ) { return " Animal [ id = " + id + " , name = " + name + " ] " ; }
protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; final StandardContext context = createContext ( ) ; when ( manager . getContext ( ) ) . thenReturn ( context ) ; when ( manager . getContainer ( ) ) . thenReturn ( context ) ; when ( manager . getMemcachedSessionService ( ) ) . thenReturn ( newMemcachedSessionService ( manager ) ) ; when ( manager . newMemcachedBackupSession ( ) ) . thenReturn ( new MemcachedBackupSession ( manager ) ) ; when ( manager . willAttributeDistribute ( anyString ( ) , anyObject ( ) ) ) . thenReturn ( true ) ; return manager ; }
protected MemcachedSessionService newMemcachedSessionService ( final SessionManager manager ) { return new MemcachedSessionService ( manager ) ; }
private static MemcachedBackupSession createSession ( final SessionManager manager , final String id ) { final MemcachedBackupSession session = manager . getMemcachedSessionService ( ) . createEmptySession ( ) ; session . setId ( id ) ; session . setValid ( true ) ; return session ; }
public static String loginWithForm ( final DefaultHttpClient client , final int tcPort ) throws IOException , HttpException { final Response tc1Response1 = get ( client , tcPort , null ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( tc1Response1 . getContent ( ) . contains ( " j_security_check " ) , " / j_security_check not found , app is not properly initialized " ) ; final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( LoginServlet . J_USERNAME , TestUtils . USER_NAME ) ; params . put ( LoginServlet . J_PASSWORD , TestUtils . PASSWORD ) ; final Response tc1Response2 = post ( client , tcPort , " / j_security_check " , sessionId , params ) ; assertEquals ( tc1Response2 . getSessionId ( ) , sessionId ) ; assertEquals ( tc1Response2 . get ( TestServlet . ID ) , sessionId ) ; return tc1Response2 . getSessionId ( ) ; }
public static Response get ( final DefaultHttpClient client , final int port , final String rsessionId ) throws IOException , HttpException { return get ( client , port , null , rsessionId ) ; }
public static Response get ( final DefaultHttpClient client , final int port , final String rsessionId , final Credentials credentials ) throws IOException , HttpException { return get ( client , port , null , rsessionId , null , null , credentials ) ; }
public static Response get ( final DefaultHttpClient client , final int port , final String path , final String rsessionId ) throws IOException , HttpException { return get ( client , port , path , rsessionId , null , null , null ) ; }
public static Response get ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { return get ( client , port , path , rsessionId , null , params , null ) ; }
private static String getUrl ( final int port , String path ) throws IllegalArgumentException { if ( path ! = null & & ! path . startsWith ( " / " ) ) { path = CONTEXT_PATH + path ; } return " http : / / " + DEFAULT_HOST + " : " + port + ( path ! = null ? path : CONTEXT_PATH ) ; }
private static String toQueryString ( final Map < String , String > params ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " ? " ) ; for ( final Iterator < Entry < String , String > > iterator = params . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { final Entry < String , String > entry = iterator . next ( ) ; sb . append ( entry . getKey ( ) ) . append ( " = " ) . append ( entry . getValue ( ) ) ; if ( iterator . hasNext ( ) ) { sb . append ( " & " ) ; } } final String qs = sb . toString ( ) ; return qs ; }
private static HttpResponse executeRequestWithAuth ( final DefaultHttpClient client , final HttpUriRequest method , final Credentials credentials ) throws IOException , ClientProtocolException { client . getCredentialsProvider ( ) . setCredentials ( AuthScope . ANY , credentials ) ; final BasicHttpContext localcontext = new BasicHttpContext ( ) ; final BasicScheme basicAuth = new BasicScheme ( ) ; localcontext . setAttribute ( " preemptive - auth " , basicAuth ) ; return client . execute ( method , localcontext ) ; }
public static Response post ( final DefaultHttpClient client , final int port , final String rsessionId , final String paramName , final String paramValue ) throws IOException , HttpException { final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( paramName , paramValue ) ; return post ( client , port , null , rsessionId , params ) ; }
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { return post ( client , port , path , rsessionId , params , null , true ) ; }
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params , @ Nullable final Credentials credentials , final boolean followRedirects ) throws IOException , HttpException { final String baseUri = " http : / / " + DEFAULT_HOST + " : " + port ; final String url = getUrl ( port , path ) ; final HttpPost method = new HttpPost ( url ) ; if ( rsessionId ! = null ) { method . setHeader ( " Cookie " , " JSESSIONID = " + rsessionId ) ; } method . setEntity ( createFormEntity ( params ) ) ; if ( ! followRedirects ) { HttpClientParams . setRedirecting ( method . getParams ( ) , false ) ; } final HttpResponse response = credentials = = null ? client . execute ( method ) : executeRequestWithAuth ( client , method , credentials ) ; final int statusCode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( followRedirects & & isRedirect ( statusCode ) ) { return redirect ( response , client , port , rsessionId , baseUri ) ; } if ( statusCode ! = 200 & & ! ( ! followRedirects & & isRedirect ( statusCode ) ) ) { throw new RuntimeException ( " POST " + ( path ! = null ? " " + path : " " ) + " did not return status 200 , but " + response . getStatusLine ( ) + " \ n " + toString ( response . getEntity ( ) . getContent ( ) ) ) ; } return readResponse ( rsessionId , response ) ; }
public static boolean isRedirect ( final int statusCode ) { return statusCode = = 302 | | statusCode = = 303 ; }
public static String toString ( final InputStream in ) { final StringBuilder sb = new StringBuilder ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) ! = null ) { sb . append ( line ) ; } } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader ! = null ) { try { reader . close ( ) ; } catch ( final IOException e ) { } } } return sb . toString ( ) ; }
private static Response redirect ( final HttpResponse response , final DefaultHttpClient client , final int port , final String rsessionId , final String baseUri ) throws IOException , HttpException { EntityUtils . consume ( response . getEntity ( ) ) ; final String location = response . getFirstHeader ( " Location " ) . getValue ( ) ; final String redirectPath = location . startsWith ( baseUri ) ? location . substring ( baseUri . length ( ) , location . length ( ) ) : location ; return get ( client , port , redirectPath , rsessionId ) ; }
private static UrlEncodedFormEntity createFormEntity ( final Map < String , String > params ) throws UnsupportedEncodingException { final List < NameValuePair > parameters = new ArrayList < NameValuePair > ( ) ; for ( final Map . Entry < String , String > param : params . entrySet ( ) ) { parameters . add ( new BasicNameValuePair ( param . getKey ( ) , param . getValue ( ) ) ) ; } final UrlEncodedFormEntity entity = new UrlEncodedFormEntity ( parameters , HTTP . UTF_8 ) ; return entity ; }
public static MemCacheDaemon < ? extends CacheElement > createDaemon ( final InetSocketAddress address ) throws IOException { final MemCacheDaemon < LocalCacheElement > daemon = new MemCacheDaemon < LocalCacheElement > ( ) ; final ConcurrentLinkedHashMap < Key , LocalCacheElement > cacheStorage = ConcurrentLinkedHashMap . create ( EvictionPolicy . LRU , 100000 , 1024 * 1024 ) ; daemon . setCache ( new CacheImpl ( cacheStorage ) ) ; daemon . setAddr ( address ) ; daemon . setVerbose ( true ) ; return daemon ; }
public String get ( final String key ) { return _keyValues . get ( key ) ; }
public static void assertDeepEquals ( final Object one , final Object another ) { assertDeepEquals ( one , another , new IdentityHashMap < Object , Object > ( ) ) ; }
public void sessionDidActivate ( final HttpSessionEvent se ) { _sessionDidActivate = se . getSession ( ) . getId ( ) ; }
public static Key key ( @ Nonnull final String value ) { return new Key ( ChannelBuffers . wrappedBuffer ( value . getBytes ( ) ) ) ; }
public static MemcachedBackupSession createSession ( @ Nonnull final MemcachedSessionService service ) { final MemcachedBackupSession session = service . createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( 23 ) ; session . setId ( " foo - n1 " ) ; return session ; }
public static void waitForReconnect ( final StorageClient client , final int expectedNumServers , final long timeToWait ) throws InterruptedException { waitForReconnect ( ( ( MemcachedStorageClient ) client ) . getMemcachedClient ( ) , expectedNumServers , timeToWait ) ; }
public static < T , V > T assertNotNullElementWaitingWithProxy ( final int elementIndex , final long maxTimeToWait , final T objectToProxy ) { return assertWaitingWithProxy ( elementAt ( elementIndex , notNull ( ) ) , maxTimeToWait , objectToProxy ) ; }
public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { return assertPredicateWaiting ( predicate , maxTimeToWait , objectToProxy , method , args ) ; }
public boolean apply ( final Object input ) { return input ! = null ; }
public boolean apply ( final Object input ) { return input = = null ; }
public static < T > Predicate < T > notNull ( ) { return ( Predicate < T > ) NOT_NULL ; }
public static < T > Predicate < T > isNull ( ) { return ( Predicate < T > ) IS_NULL ; }
public boolean apply ( final T input ) { return target . equals ( input ) ; }
public byte [ ] get ( final String key ) { return _client . get ( key , ByteArrayTranscoder . INSTANCE ) ; }
public void setUp ( ) throws Throwable { final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_1 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_2 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( MEMCACHED_NODES , null , null , _storageClientCallback ) ; _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) , Arrays . asList ( address1 , address2 ) ) ; final SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ; schemeRegistry . register ( new Scheme ( " http " , 80 , PlainSocketFactory . getSocketFactory ( ) ) ) ; _httpClient = new DefaultHttpClient ( new ThreadSafeClientConnManager ( schemeRegistry ) ) ; _executor = Executors . newCachedThreadPool ( ) ; }
private TomcatBuilder < ? > startTomcat ( final int port ) throws Exception { return startTomcat ( port , MEMCACHED_NODES , null ) ; }
public void tearDown ( ) throws Exception { _client . shutdown ( 10 , SECONDS ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; if ( _daemon3 ! = null & & _daemon3 . isRunning ( ) ) { _daemon3 . stop ( ) ; } _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _executor . shutdownNow ( ) ; }
public void testLoadBackupSessionShouldWorkWithInfiniteSessionTimeoutIssue120 ( @ Nonnull final LockingMode lockingMode , @ Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( - 1 ) ; setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Thread . sleep ( 200 ) ; Response response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; final SessionIdFormat fmt = new SessionIdFormat ( ) ; final String nodeId = fmt . extractMemcachedId ( sessionId ) ; final MemCacheDaemon < ? > primary = NODE_ID_1 . equals ( nodeId ) ? _daemon1 : _daemon2 ; primary . stop ( ) ; Thread . sleep ( 200 ) ; response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( fmt . createNewSessionId ( response . getSessionId ( ) , nodeId ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; }
public void testLoadBackupSessionShouldWorkWithHighSessionTimeoutIssue104 ( @ Nonnull final LockingMode lockingMode , @ Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 60 * 60 * 24 * 30 / 2 + 1 ) ; setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Thread . sleep ( 200 ) ; Response response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; final SessionIdFormat fmt = new SessionIdFormat ( ) ; final String nodeId = fmt . extractMemcachedId ( sessionId ) ; final MemCacheDaemon < ? > primary = NODE_ID_1 . equals ( nodeId ) ? _daemon1 : _daemon2 ; primary . stop ( ) ; Thread . sleep ( 200 ) ; response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( fmt . createNewSessionId ( response . getSessionId ( ) , nodeId ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; }
public void testSessionLockingSupportedWithSingleNodeSetup ( @ Nonnull final LockingMode lockingMode , @ Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMemcachedNodes ( " localhost : " + MEMCACHED_PORT_1 ) ; _tomcat1 . getManager ( ) . setLockingMode ( lockingMode , uriPattern , false ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Response response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; post ( _httpClient , TC_PORT_1 , sessionId , " k2 " , " v2 " ) ; response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; assertEquals ( response . get ( " k2 " ) , " v2 " ) ; }
public void testParallelRequestsToSameTomcatInstanceIssue111 ( @ Nonnull final LockingMode lockingMode , @ Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; final Future < Response > response2 = _executor . submit ( new Callable < Response > ( ) { @ Override public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , " k2 " , " v2 " ) ) ; } } ) ; Thread . sleep ( 200 ) ; post ( _httpClient , TC_PORT_1 , sessionId , " k3 " , " v3 " ) ; final Response finalResponse = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( finalResponse . getSessionId ( ) , sessionId ) ; assertEquals ( response2 . get ( ) . getSessionId ( ) , sessionId ) ; assertEquals ( finalResponse . get ( " k1 " ) , " v1 " ) ; assertEquals ( finalResponse . get ( " k2 " ) , " v2 " ) ; assertEquals ( finalResponse . get ( " k3 " ) , " v3 " ) ; }
public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , " k2 " , " v2 " ) ) ; }
public Object call ( ) throws Exception { return _client . get ( sessionId1 ) ; }
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , paramsWait ) ; }
public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , " foo " , " bar " ) ) ; }
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_1 , " / pathNotMatchingLockUriPattern " , sessionId , paramsWait ) ; }
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_1 , pathToLock , sessionId , paramsWait ) ; }
public void testSessionNotLoadedForNoSessionAccess ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setMemcachedNodes ( NODE_ID_1 + " : localhost : " + MEMCACHED_PORT_1 ) ; waitForReconnect ( _tomcat1 . getService ( ) . getStorageClient ( ) , 1 , 1000 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; assertWaitingWithProxy ( equalTo ( 2 ) , 1000 , _daemon1 . getCache ( ) ) . getSetCmds ( ) ; assertEquals ( _daemon1 . getCache ( ) . getGetHits ( ) , 0 ) ; get ( _httpClient , TC_PORT_1 , PATH_NO_SESSION_ACCESS , sessionId1 ) ; assertWaitingWithProxy ( equalTo ( 3 ) , 1000 , _daemon1 . getCache ( ) ) . getSetCmds ( ) ; assertEquals ( _daemon1 . getCache ( ) . getGetHits ( ) , getExpectedHitsForNoSessionAccess ( ) ) ; }
public void testInvalidateSessionShouldReleaseLockIssue144 ( ) throws IOException , InterruptedException , HttpException { _tomcat1 . getManager ( ) . setLockingMode ( LockingMode . AUTO . name ( ) ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created . " ) ; final Response response = get ( _httpClient , TC_PORT_1 , PATH_INVALIDATE , sessionId1 ) ; assertNull ( response . getResponseSessionId ( ) ) ; assertNull ( _client . get ( sessionId1 ) , " Invalidated session should be removed from memcached " ) ; assertNull ( _client . get ( new SessionIdFormat ( ) . createLockName ( sessionId1 ) ) , " Lock should be released . " ) ; }
private TomcatBuilder < ? > startTomcatWithAuth ( final int port , @ Nonnull final LockingMode lockingMode ) throws Exception { return startTomcatWithAuth ( port , MEMCACHED_NODES , lockingMode , LoginType . BASIC ) ; }
public void setUp ( final Method testMethod ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? NODE_ID + " : " : " " ; _memcachedNodes = nodePrefix + " localhost : " + MEMCACHED_PORT ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( _memcachedNodes , null , null , _storageClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; _client = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; }
private TomcatBuilder < ? > startTomcat ( final int port , final String jvmRoute ) throws Exception { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; }
public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute ( ) throws Exception { final SessionManager manager1 = _tomcat1 . getManager ( ) ; final SessionManager manager2 = _tomcat2 . getManager ( ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertEquals ( format . extractJvmRoute ( sessionId1 ) , JVM_ROUTE_1 ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( format . stripJvmRoute ( sessionId2 ) , format . stripJvmRoute ( sessionId1 ) ) ; assertEquals ( format . extractJvmRoute ( sessionId2 ) , JVM_ROUTE_2 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; }
public void testHttpSessionActivationListenersNotifiedOnLoadWithoutJvmRoute ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , null ) ; _tomcat2 = startTomcat ( TC_PORT_2 , null ) ; final SessionManager manager1 = _tomcat1 . getManager ( ) ; final SessionManager manager2 = _tomcat2 . getManager ( ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNull ( format . extractJvmRoute ( sessionId1 ) ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( sessionId2 , sessionId1 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; }
public void testTomcatFailoverWithSingleNodeWithoutConfiguredNodeId ( ) throws IOException , InterruptedException , HttpException { testTomcatFailover ( ) ; }
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_2 , sessionId1 ) ; }
public boolean matchesSafely ( Response response ) { final String sessionId2 = response . getSessionId ( ) ; return format . extractMemcachedId ( sessionId2 ) . equals ( " n1 " ) ; }
private MemCacheDaemon < ? > startMemcached ( final int memcachedPort ) throws IOException { final InetSocketAddress address = new InetSocketAddress ( " localhost " , memcachedPort ) ; final MemCacheDaemon < ? > daemon2 = createDaemon ( address ) ; daemon2 . start ( ) ; return daemon2 ; }
public void init ( final ServletConfig config ) throws ServletException { super . init ( config ) ; defaultServlet = new DefaultServlet ( ) ; defaultServlet . init ( config ) ; }
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . sessionTimeout ( 10 ) . memcachedNodes ( memcachedNodes ) . sticky ( true ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } _httpClient = new DefaultHttpClient ( ) ; }
private String toString ( final String nodeId , final InetSocketAddress address ) { return nodeId + " : " + address . getHostName ( ) + " : " + address . getPort ( ) ; }
public void tearDown ( ) throws Exception { if ( _daemon1 . isRunning ( ) ) { _daemon1 . stop ( ) ; } if ( _daemon2 . isRunning ( ) ) { _daemon2 . stop ( ) ; } if ( _daemon3 . isRunning ( ) ) { _daemon3 . stop ( ) ; } _tomcat1 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; }
private void waitForReconnect ( final MemcachedSessionService service , final MemCacheDaemon < ? > value , final long timeToWait ) throws InterruptedException { MemcachedClient client ; InetSocketAddress serverAddress ; try { final Method m = MemcachedSessionService . class . getDeclaredMethod ( " getStorageClient " ) ; m . setAccessible ( true ) ; client = ( ( MemcachedStorageClient ) m . invoke ( service ) ) . getMemcachedClient ( ) ; final Field field = MemCacheDaemon . class . getDeclaredField ( " addr " ) ; field . setAccessible ( true ) ; serverAddress = ( InetSocketAddress ) field . get ( value ) ; } catch ( final Exception e ) { throw new RuntimeException ( e ) ; } waitForReconnect ( client , serverAddress , timeToWait ) ; }
private Set < String > toArray ( final Iterator < String > noteNames ) { final Set < String > result = new HashSet < String > ( ) ; while ( noteNames . hasNext ( ) ) { result . add ( noteNames . next ( ) ) ; } return result ; }
private void restartTomcat ( final String memcachedNodes , final String failoverNodes ) throws Exception { _tomcat1 . stop ( ) ; Thread . sleep ( 500 ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . sessionTimeout ( 10 ) . memcachedNodes ( memcachedNodes ) . failoverNodes ( failoverNodes ) . buildAndStart ( ) ; }
private Map < String , Session > getSessions ( ) throws NoSuchFieldException , IllegalAccessException { final Field field = ManagerBase . class . getDeclaredField ( " sessions " ) ; field . setAccessible ( true ) ; @ SuppressWarnings ( " unchecked " ) final Map < String , Session > sessions = ( Map < String , Session > ) field . get ( _tomcat1 . getManager ( ) ) ; return sessions ; }
private Map < String , MemCacheDaemon < ? > > asMap ( final String nodeId1 , final MemCacheDaemon < ? > daemon1 , final String nodeId2 , final MemCacheDaemon < ? > daemon2 ) { final Map < String , MemCacheDaemon < ? > > result = new LinkedHashMap < String , MemCacheDaemon < ? > > ( 2 ) ; result . put ( nodeId1 , daemon1 ) ; result . put ( nodeId2 , daemon2 ) ; return result ; }
public Entry < String , MemCacheDaemon < ? > > nextNode ( ) { return otherNodes . entrySet ( ) . iterator ( ) . next ( ) ; }
public Entry < String , MemCacheDaemon < ? > > previousNode ( ) { Entry < String , MemCacheDaemon < ? > > last = null ; for ( final Entry < String , MemCacheDaemon < ? > > entry : otherNodes . entrySet ( ) ) { last = entry ; } return last ; }
public TomcatBuilder < T > port ( final int port ) { this . port = port ; return this ; }
public TomcatBuilder < T > sessionTimeout ( final int sessionTimeout ) { this . sessionTimeout = sessionTimeout ; return this ; }
public TomcatBuilder < T > cookies ( final boolean cookies ) { this . cookies = cookies ; return this ; }
public TomcatBuilder < T > memcachedNodes ( final String memcachedNodes ) { this . memcachedNodes = memcachedNodes ; return this ; }
public TomcatBuilder < T > failoverNodes ( final String failoverNodes ) { this . failoverNodes = failoverNodes ; return this ; }
public TomcatBuilder < T > storageKeyPrefix ( final String storageKeyPrefix ) { this . storageKeyPrefix = storageKeyPrefix ; return this ; }
public TomcatBuilder < T > enabled ( final boolean enabled ) { this . enabled = enabled ; return this ; }
public TomcatBuilder < T > sticky ( final boolean sticky ) { this . sticky = sticky ; return this ; }
public TomcatBuilder < T > lockingMode ( final LockingMode lockingMode ) { this . lockingMode = lockingMode ; return this ; }
public TomcatBuilder < T > lockExpire ( final int lockExpire ) { this . lockExpire = lockExpire ; return this ; }
public TomcatBuilder < T > memcachedProtocol ( final String memcachedProtocol ) { this . memcachedProtocol = memcachedProtocol ; return this ; }
public TomcatBuilder < T > username ( final String memcachedUsername ) { this . username = memcachedUsername ; return this ; }
public TomcatBuilder < T > jvmRoute ( final String jvmRoute ) { this . jvmRoute = jvmRoute ; return this ; }
public TomcatBuilder < T > loginType ( final LoginType loginType ) { this . loginType = loginType ; return this ; }
public TomcatBuilder < T > transcoderFactoryClassName ( final String transcoderFactoryClassName ) { this . transcoderFactoryClassName = transcoderFactoryClassName ; return this ; }
protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; }
public void testFunctions ( ) throws Exception { RedisStorageClient client = createClient ( ) ; assertTrue ( client . add ( " key1 " , 0 , toBytes ( " foo " ) ) . get ( ) ) ; assertTrue ( client . add ( " key2 " , 0 , toBytes ( " bar " ) ) . get ( ) ) ; assertEquals ( " foo " , toString ( client . get ( " key1 " ) ) ) ; assertEquals ( " bar " , toString ( client . get ( " key2 " ) ) ) ; assertTrue ( client . set ( " key1 " , 0 , toBytes ( " baz " ) ) . get ( ) ) ; assertFalse ( client . add ( " key2 " , 0 , toBytes ( " zoom " ) ) . get ( ) ) ; assertEquals ( " baz " , toString ( client . get ( " key1 " ) ) ) ; assertEquals ( " bar " , toString ( client . get ( " key2 " ) ) ) ; assertTrue ( client . delete ( " key1 " ) . get ( ) ) ; assertNull ( client . get ( " key1 " ) ) ; assertEquals ( " bar " , toString ( client . get ( " key2 " ) ) ) ; client . shutdown ( ) ; }
public void testExpirationSeconds ( ) throws Exception { RedisStorageClient client = createClient ( ) ; assertTrue ( client . add ( " exp " , 2 , toBytes ( " foo " ) ) . get ( ) ) ; Thread . sleep ( 1000 ) ; assertEquals ( " foo " , toString ( client . get ( " exp " ) ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " exp " ) ) ; client . shutdown ( ) ; }
public void testExpirationTime ( ) throws Exception { RedisStorageClient client = createClient ( ) ; assertTrue ( client . add ( " exp " , ( int ) ( 2 + ( System . currentTimeMillis ( ) / 1000 ) ) , toBytes ( " foo " ) ) . get ( ) ) ; assertEquals ( " foo " , toString ( client . get ( " exp " ) ) ) ; Thread . sleep ( 1000 ) ; assertEquals ( " foo " , toString ( client . get ( " exp " ) ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " exp " ) ) ; client . shutdown ( ) ; }
public void testAutoReconnect ( ) throws Exception { RedisStorageClient client = createClient ( ) ; assertTrue ( client . add ( " key1 " , 0 , toBytes ( " foo " ) ) . get ( ) ) ; assertEquals ( " foo " , toString ( client . get ( " key1 " ) ) ) ; if ( ! redisProvided ) { embeddedRedisServer . stop ( ) ; embeddedRedisServer . start ( ) ; } assertTrue ( client . add ( " key1 " , 0 , toBytes ( " foo " ) ) . get ( ) ) ; assertEquals ( " foo " , toString ( client . get ( " key1 " ) ) ) ; client . shutdown ( ) ; }
public void testCreateUri01 ( ) throws Exception { RedisStorageClient client = createClient ( ) ; URI uri = client . createURI ( " redis : / / user : pwd @ localhost " ) ; assertEquals ( uri . getScheme ( ) , " redis " ) ; assertEquals ( uri . getUserInfo ( ) , " user : pwd " ) ; assertEquals ( uri . getHost ( ) , " localhost " ) ; assertTrue ( uri . getPort ( ) = = 6379 ) ; uri = client . createURI ( " rediss : / / : pwd @ localhost : 9999 " ) ; assertEquals ( uri . getScheme ( ) , " rediss " ) ; assertEquals ( uri . getUserInfo ( ) , " : pwd " ) ; assertTrue ( uri . getPort ( ) = = 9999 ) ; uri = client . createURI ( " redis : / / localhost " ) ; assertEquals ( uri . getScheme ( ) , " redis " ) ; assertNull ( uri . getUserInfo ( ) ) ; assertTrue ( uri . getPort ( ) = = 6379 ) ; }
private RedisStorageClient createClient ( ) { return new RedisStorageClient ( " redis : / / localhost : " + redisPort , 1000 ) ; }
private byte [ ] toBytes ( String s ) { return s . getBytes ( StandardCharsets . UTF_8 ) ; }
private String toString ( byte [ ] bytes ) { return new String ( bytes , StandardCharsets . UTF_8 ) ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Key key1 = ( Key ) o ; bytes . readerIndex ( 0 ) ; key1 . bytes . readerIndex ( 0 ) ; if ( ! bytes . equals ( key1 . bytes ) ) return false ; return true ; }
public int hashCode ( ) { return hashCode ; }
public String toString ( ) { return new String ( bytes . toByteBuffer ( ) . array ( ) ) ; }
public boolean wasInvokedWith ( final Request currentRequest ) { return currentRequest ! = null & & currentRequest . getNote ( INVOKED ) = = Boolean . TRUE ; }
public void shutdown ( ) { _log . info ( " Stopping services . " ) ; _manager . getContext ( ) . getParent ( ) . getPipeline ( ) . removeValve ( _trackingHostValve ) ; _manager . getContext ( ) . getPipeline ( ) . removeValve ( _trackingContextValve ) ; _backupSessionService . shutdown ( ) ; if ( _lockingStrategy ! = null ) { _lockingStrategy . shutdown ( ) ; } if ( _storage ! = null ) { _storage . shutdown ( ) ; _storage = null ; } _transcoderFactory = null ; _invalidSessionsCache . clear ( ) ; }
void startInternal ( final StorageClient storage ) throws LifecycleException { if ( storage = = null ) _storage = null ; else _storage = storage ; startInternal ( ) ; }
protected RequestTrackingContextValve createRequestTrackingContextValve ( final String sessionCookieName ) { return new RequestTrackingContextValve ( sessionCookieName , this ) ; }
public byte [ ] get ( final String key ) { return _storage . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( key ) ) ; }
protected MemcachedNodesManager createMemcachedNodesManager ( final String memcachedNodes , final String failoverNodes ) { final Context context = _manager . getContext ( ) ; final String webappVersion = Reflections . invoke ( context , " getWebappVersion " , null ) ; final StorageKeyFormat storageKeyFormat = StorageKeyFormat . of ( _storageKeyPrefix , context . getParent ( ) . getName ( ) , context . getName ( ) , webappVersion ) ; return MemcachedNodesManager . createFor ( memcachedNodes , failoverNodes , storageKeyFormat , _storageClientCallback ) ; }
private TranscoderService createTranscoderService ( final Statistics statistics ) { return new TranscoderService ( getTranscoderFactory ( ) . createTranscoder ( _manager ) ) ; }
private TranscoderFactory createTranscoderFactory ( ) throws InstantiationException , IllegalAccessException , ClassNotFoundException { _log . info ( " Creating transcoder factory " + _transcoderFactoryClassName ) ; final Class < ? extends TranscoderFactory > transcoderFactoryClass = loadTranscoderFactoryClass ( ) ; final TranscoderFactory transcoderFactory = transcoderFactoryClass . newInstance ( ) ; transcoderFactory . setCopyCollectionsForSerialization ( _copyCollectionsForSerialization ) ; if ( _customConverterClassNames ! = null ) { _log . info ( " Found configured custom converter classes , setting on transcoder factory : " + _customConverterClassNames ) ; transcoderFactory . setCustomConverterClassNames ( _customConverterClassNames . split ( " , \ \ s * " ) ) ; } return transcoderFactory ; }
private Class < ? extends TranscoderFactory > loadTranscoderFactoryClass ( ) throws ClassNotFoundException { Class < ? extends TranscoderFactory > transcoderFactoryClass ; final ClassLoader classLoader = _manager . getContainerClassLoader ( ) ; try { _log . debug ( " Loading transcoder factory class " + _transcoderFactoryClassName + " using classloader " + classLoader ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , classLoader ) . asSubclass ( TranscoderFactory . class ) ; } catch ( final ClassNotFoundException e ) { _log . info ( " Could not load transcoderfactory class with classloader " + classLoader + " , trying " + getClass ( ) . getClassLoader ( ) ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , getClass ( ) . getClassLoader ( ) ) . asSubclass ( TranscoderFactory . class ) ; } return transcoderFactoryClass ; }
public String newSessionId ( @ Nonnull final String sessionId ) { return _memcachedNodesManager . createSessionId ( sessionId ) ; }
private boolean isContainerSessionLookup ( ) { return ! _trackingContextValve . wasInvokedWith ( _currentRequest . get ( ) ) ; }
private boolean isConnectorSessionLookup ( ) { return _currentRequest . get ( ) = = null ; }
private void addValidLoadedSession ( final MemcachedBackupSession result ) { String jvmRoute ; final boolean sessionIdWillBeChanged = _sticky & & ( jvmRoute = _manager . getJvmRoute ( ) ) ! = null & & ! jvmRoute . equals ( getSessionIdFormat ( ) . extractJvmRoute ( result . getId ( ) ) ) ; final boolean activate = ! sessionIdWillBeChanged ; addValidLoadedSession ( result , activate ) ; }
private void addValidLoadedSession ( final StandardSession session , final boolean activate ) { if ( session . isNew ( ) ) { session . tellNew ( ) ; } _manager . add ( session ) ; if ( activate ) { session . activate ( ) ; } session . access ( ) ; session . endAccess ( ) ; }
public MemcachedBackupSession createEmptySession ( ) { final MemcachedBackupSession result = _manager . newMemcachedBackupSession ( ) ; result . setSticky ( _sticky ) ; return result ; }
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { if ( ! _memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ) { return null ; } try { if ( _sticky ) { final MemcachedBackupSession session = _manager . getSessionInternal ( requestedSessionId ) ; if ( session ! = null & & session . isValid ( ) ) { final String newSessionId = _memcachedNodesManager . getNewSessionIdIfNodeFromSessionIdUnavailable ( session . getId ( ) ) ; if ( newSessionId ! = null ) { _log . debug ( " Session needs to be relocated , setting new id on session . . . " ) ; session . setIdForRelocate ( newSessionId ) ; _statistics . requestWithMemcachedFailover ( ) ; return newSessionId ; } } } else { final String nodeId = getSessionIdFormat ( ) . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _memcachedNodesManager . isNodeAvailable ( nodeId ) ) { return null ; } _log . info ( " Session needs to be relocated as node " + nodeId + " is not available , loading backup session for " + requestedSessionId ) ; final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { _log . debug ( " Loaded backup session for " + requestedSessionId + " , adding locally with " + backupSession . getIdInternal ( ) + " . " ) ; addValidLoadedSession ( backupSession , true ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final RuntimeException e ) { _log . warn ( " Could not find session in local session map . " , e ) ; } return null ; }
private MemcachedBackupSession loadBackupSession ( @ Nonnull final String requestedSessionId ) { final String nodeId = getSessionIdFormat ( ) . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null ) { _log . info ( " Cannot load backupSession for sessionId without nodeId : " + requestedSessionId ) ; return null ; } final String newNodeId = _memcachedNodesManager . getNextAvailableNodeId ( nodeId ) ; if ( newNodeId = = null ) { _log . info ( " No next available node found for nodeId " + nodeId ) ; return null ; } MemcachedBackupSession result = loadBackupSession ( requestedSessionId , newNodeId ) ; String nextNodeId = nodeId ; while ( result = = null & & ( nextNodeId = _memcachedNodesManager . getNextAvailableNodeId ( nextNodeId ) ) ! = null & & ! nextNodeId . equals ( nodeId ) ) { final String newSessionId = getSessionIdFormat ( ) . createNewSessionId ( requestedSessionId , nextNodeId ) ; result = loadBackupSession ( newSessionId , newNodeId ) ; } if ( result = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } return result ; }
byte [ ] serialize ( @ Nonnull final MemcachedBackupSession session ) { return _transcoderService . serialize ( session ) ; }
protected MemcachedBackupSession loadFromMemcachedWithCheck ( final String sessionId ) { if ( ! canHitMemcached ( sessionId ) | | _invalidSessionsCache . get ( sessionId ) ! = null ) { return null ; } return loadFromMemcached ( sessionId ) ; }
private boolean canHitMemcached ( @ Nonnull final String sessionId ) { return _enabled . get ( ) & & _memcachedNodesManager . canHitMemcached ( sessionId ) ; }
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached : " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final byte [ ] object = _storage . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _memcachedNodesManager . onLoadFromMemcachedSuccess ( sessionId ) ; if ( object ! = null ) { final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { releaseIfLocked ( sessionId , lockStatus ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached . " ) ; } return null ; } } catch ( final TranscoderDeserializationException e ) { _log . warn ( " Could not deserialize session with id " + sessionId + " from memcached , session will be purged from storage . " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; _storage . delete ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached . " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; } finally { } return null ; }
private MemcachedNodesManager reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { final MemcachedNodesManager memcachedNodesManager = createMemcachedNodesManager ( memcachedNodes , failoverNodes ) ; final StorageClient storage = createStorageClient ( memcachedNodesManager , _statistics ) ; final BackupSessionService backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , storage , memcachedNodesManager , _statistics ) ; if ( _storage ! = null ) { _storage . shutdown ( ) ; } _storage = storage ; _memcachedNodesManager = memcachedNodesManager ; _backupSessionService = backupSessionService ; initNonStickyLockingMode ( memcachedNodesManager ) ; return memcachedNodesManager ; }
public boolean isEnabled ( ) { return _enabled . get ( ) ; }
public boolean isSticky ( ) { return _sticky ; }
public boolean isSessionBackupAsync ( ) { return _sessionBackupAsync ; }
public Request get ( ) { return _requestsThreadLocal . get ( ) ; }
public void set ( final Request request ) { _requestsThreadLocal . set ( request ) ; }
public void reset ( ) { _requestsThreadLocal . set ( null ) ; }
public Thread newThread ( final Runnable runnable ) { final Thread t = new Thread ( group , runnable , namePrefix + threadNumber . getAndIncrement ( ) ) ; if ( t . isDaemon ( ) ) t . setDaemon ( false ) ; if ( t . getPriority ( ) ! = Thread . NORM_PRIORITY ) t . setPriority ( Thread . NORM_PRIORITY ) ; return t ; }
public static NodeIdList create ( @ Nonnull final String . . . nodeIds ) { return new NodeIdList ( nodeIds ) ; }
protected CouchbaseConnectionFactoryBuilder newCouchbaseConnectionFactoryBuilder ( ) { return new CouchbaseConnectionFactoryBuilder ( ) ; }
public boolean isNodeAvailable ( @ Nonnull final String nodeId ) { return _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ; }
public String getNextNodeId ( @ Nonnull final String nodeId ) throws IllegalArgumentException { return _nodeIds . getNextNodeId ( nodeId ) ; }
public NodeLocator createLocator ( final List < MemcachedNode > nodes ) { return new SuffixBasedNodeLocator ( nodes , _memcachedNodesManager , _sessionIdFormat ) ; }
public static < A , B > Pair < A , B > of ( final A first , final B second ) { return new Pair < A , B > ( first , second ) ; }
public byte [ ] serialize ( final MemcachedBackupSession session ) { final byte [ ] attributesData = serializeAttributes ( session , session . getAttributesInternal ( ) ) ; return serialize ( session , attributesData ) ; }
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { return _attributesTranscoder . serializeAttributes ( session , attributes ) ; }
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] data ) { return _attributesTranscoder . deserializeAttributes ( data ) ; }
public byte [ ] serialize ( final MemcachedBackupSession session , final byte [ ] attributesData ) { final byte [ ] sessionData = serializeSessionFields ( session ) ; final byte [ ] result = new byte [ sessionData . length + attributesData . length ] ; System . arraycopy ( sessionData , 0 , result , 0 , sessionData . length ) ; System . arraycopy ( attributesData , 0 , result , sessionData . length , attributesData . length ) ; return result ; }
static byte [ ] serializeSessionFields ( final MemcachedBackupSession session ) { return serializeSessionFields ( session , VERSION_2 ) ; }
private static < T > List < T > newArrayList ( final Iterator < T > iter ) { if ( ! iter . hasNext ( ) ) { return Collections . emptyList ( ) ; } final List < T > result = new ArrayList < T > ( ) ; while ( iter . hasNext ( ) ) { result . add ( iter . next ( ) ) ; } return result ; }
private static int encodeBoolean ( final boolean b , final byte [ ] data , final int index ) { data [ index ] = ( byte ) ( b ? ' 1 ' : ' 0 ' ) ; return index + 1 ; }
private static boolean decodeBoolean ( final byte [ ] in , final int index ) { return in [ index ] = = ' 1 ' ; }
protected static int copy ( final byte [ ] src , final byte [ ] dest , final int destBeginIndex ) { if ( src = = null ) { return destBeginIndex ; } System . arraycopy ( src , 0 , dest , destBeginIndex , src . length ) ; return destBeginIndex + src . length ; }
static AuthType valueOfId ( final short id ) { for ( final AuthType authType : values ( ) ) { if ( id = = authType . _id ) { return authType ; } } throw new IllegalArgumentException ( " No AuthType found for id " + id ) ; }
static AuthType valueOfValue ( final String value ) { for ( final AuthType authType : values ( ) ) { if ( value = = null & & authType . _value = = null | | value ! = null & & value . equals ( authType . _value ) ) { return authType ; } } throw new IllegalArgumentException ( " No AuthType found for value " + value ) ; }
public boolean isIgnoredRequest ( ) { final Request request = _currentRequest . get ( ) ; return request ! = null & & request . getNote ( REQUEST_IGNORED ) = = Boolean . TRUE ; }
protected static boolean isPostMethod ( final Request request ) { final String method = request . getMethod ( ) ; if ( method = = null & & _log . isDebugEnabled ( ) ) { _log . debug ( " No method set for request " + request . getRequestURI ( ) + ( request . getQueryString ( ) ! = null ? " ? " + request . getQueryString ( ) : " " ) ) ; } return method ! = null ? method . toLowerCase ( ) . equals ( " post " ) : false ; }
void resetRequestThreadLocal ( ) { _currentRequest . reset ( ) ; }
void storeRequestThreadLocal ( @ Nonnull final Request request ) { _currentRequest . set ( request ) ; }
public int compare ( final Entry < K , ManagedItem < V > > o1 , final Entry < K , ManagedItem < V > > o2 ) { return comparator . compare ( o1 . getValue ( ) . _value , o2 . getValue ( ) . _value ) ; }
public int size ( ) { return a . length ; }
public < T > T [ ] toArray ( final T [ ] a ) { throw new UnsupportedOperationException ( " Not implemented . " ) ; }
public E get ( final int index ) { return a [ index ] . getKey ( ) ; }
public E set ( final int index , final E element ) { throw new UnsupportedOperationException ( " Not implemented . " ) ; }
public boolean contains ( final Object o ) { return indexOf ( o ) ! = - 1 ; }
public void registerReadonlyRequest ( final String requestId ) { _readOnlyRequestCache . readOnlyRequest ( requestId ) ; }
protected void onBackupWithoutLoadedSession ( @ Nonnull final String sessionId , @ Nonnull final String requestId , @ Nonnull final BackupSessionService backupSessionService ) { if ( ! _sessionIdFormat . isValid ( sessionId ) ) { return ; } super . onBackupWithoutLoadedSession ( sessionId , requestId , backupSessionService ) ; _readOnlyRequestCache . readOnlyRequest ( requestId ) ; }
public String changeJvmRoute ( @ Nonnull final String sessionId , @ Nonnull final String newJvmRoute ) { return stripJvmRoute ( sessionId ) + " . " + newJvmRoute ; }
public boolean isValid ( @ Nullable final String sessionId ) { return sessionId ! = null & & _pattern . matcher ( sessionId ) . matches ( ) ; }
public String createLockName ( @ Nonnull final String sessionId ) { if ( sessionId = = null ) { throw new IllegalArgumentException ( " The sessionId must not be null . " ) ; } return " lock : " + _storageKeyFormat . format ( sessionId ) ; }
public String createValidityInfoKeyName ( @ Nonnull final String origKey ) { if ( origKey = = null ) { throw new IllegalArgumentException ( " The sessionId must not be null . " ) ; } return " validity : " + _storageKeyFormat . format ( origKey ) ; }
public String createBackupKey ( @ Nonnull final String origKey ) { if ( origKey = = null ) { throw new IllegalArgumentException ( " The origKey must not be null . " ) ; } return BACKUP_PREFIX + _storageKeyFormat . format ( origKey ) ; }
public boolean isBackupKey ( @ Nonnull final String key ) { return key . startsWith ( BACKUP_PREFIX ) ; }
protected LockStatus onBeforeLoadFromMemcached ( @ Nonnull final String sessionId ) throws InterruptedException , ExecutionException { return lock ( sessionId ) ; }
public static Builder node ( final String id , final InetSocketAddress address ) { return new Builder ( ) . node ( id , address ) ; }
public Builder node ( final String id , final InetSocketAddress address ) { final String previous = _address2Ids . put ( address , id ) ; if ( previous ! = null ) { throw new IllegalArgumentException ( " There ' s already an address bound to id " + previous ) ; } return this ; }
public NodeIdResolver build ( ) { return new MapBasedResolver ( _address2Ids ) ; }
public boolean readOnlyRequest ( final String requestId ) { if ( ! _blacklist . containsKey ( requestId ) ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Registering readonly request : " + requestId ) ; } incrementOrPut ( _readOnlyRequests , requestId ) ; return true ; } return false ; }
public void modifyingRequest ( final String requestId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Registering modifying request : " + requestId ) ; } incrementOrPut ( _blacklist , requestId ) ; _readOnlyRequests . remove ( requestId ) ; }
public boolean isReadOnlyRequest ( final String requestId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Asked for readonly request : " + requestId + " ( " + _readOnlyRequests . containsKey ( requestId ) + " ) " ) ; } return _readOnlyRequests . containsKey ( requestId ) ; }
public static Statistics create ( ) { return create ( true ) ; }
public static Statistics create ( final boolean enabled ) { return enabled ? new Statistics ( ) : DISABLED_STATS ; }
public void registerSince ( @ Nonnull final StatsType statsType , final long startInMillis ) { register ( statsType , System . currentTimeMillis ( ) - startInMillis ) ; }
public void register ( @ Nonnull final StatsType statsType , final long value ) { _probes . get ( statsType ) . register ( value ) ; }
public void requestWithoutSession ( ) { _numRequestsWithoutSession . incrementAndGet ( ) ; }
public void requestWithSession ( ) { _numRequestsWithSession . incrementAndGet ( ) ; }
public void requestWithTomcatFailover ( ) { _numRequestsWithTomcatFailover . incrementAndGet ( ) ; }
public void requestWithMemcachedFailover ( ) { _numRequestsWithMemcachedFailover . incrementAndGet ( ) ; }
public void requestWithBackupFailure ( ) { _numRequestsWithBackupFailure . incrementAndGet ( ) ; }
public void requestWithoutSessionAccess ( ) { _numRequestsWithoutSessionAccess . incrementAndGet ( ) ; }
public void requestWithoutAttributesAccess ( ) { _numRequestsWithoutAttributesAccess . incrementAndGet ( ) ; }
public void requestWithoutSessionModification ( ) { _numRequestsWithoutSessionModification . incrementAndGet ( ) ; }
public void nonStickySessionsPingFailed ( ) { _numNonStickySessionsPingFailed . incrementAndGet ( ) ; }
public void nonStickySessionsReadOnlyRequest ( ) { _numNonStickySessionsReadOnlyRequest . incrementAndGet ( ) ; }
public void registerSince ( final long startInMillis ) { register ( System . currentTimeMillis ( ) - startInMillis ) ; }
public void shutdown ( ) { _executor . shutdown ( ) ; }
protected LockStatus lock ( final String sessionId ) { return lock ( sessionId , _manager . getOperationTimeout ( ) , TimeUnit . MILLISECONDS ) ; }
protected SessionValidityInfo loadSessionValidityInfo ( @ Nonnull final String sessionId ) { return loadSessionValidityInfoForValidityKey ( _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ) ; }
protected SessionValidityInfo loadSessionValidityInfoForValidityKey ( @ Nonnull final String validityInfoKey ) { final byte [ ] validityInfo = _storage . get ( validityInfoKey ) ; return validityInfo ! = null ? decode ( validityInfo ) : null ; }
protected SessionValidityInfo loadBackupSessionValidityInfo ( @ Nonnull final String sessionId ) { final String key = _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ; final String backupKey = _sessionIdFormat . createBackupKey ( key ) ; return loadSessionValidityInfoForValidityKey ( backupKey ) ; }
protected void onAfterDeleteFromMemcached ( @ Nonnull final String sessionId ) { final long start = System . currentTimeMillis ( ) ; final String validityInfoKey = _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ; _storage . delete ( validityInfoKey ) ; if ( _storeSecondaryBackup ) { try { _storage . delete ( _sessionIdFormat . createBackupKey ( sessionId ) ) ; _storage . delete ( _sessionIdFormat . createBackupKey ( validityInfoKey ) ) ; } catch ( Exception e ) { _log . info ( " Could not delete backup data for session " + sessionId + " ( not critical , data will be evicted by memcached automatically ) . " , e ) ; } } _stats . registerSince ( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED , start ) ; }
public static StorageKeyFormat ofHost ( final String host ) { return of ( HOST , host , null , null ) ; }
public String format ( final String input ) { if ( prefix = = null ) { return input ; } return prefix + input ; }
static String parse ( final String configToken , final String host , final String context , final String webappVersion ) { final Matcher staticMatcher = STATIC_PATTERN . matcher ( configToken ) ; if ( staticMatcher . matches ( ) ) return staticMatcher . group ( 1 ) ; if ( HOST . equals ( configToken ) ) return host ; if ( HOST_HASH . equals ( configToken ) ) return hashString ( host ) ; if ( CONTEXT . equals ( configToken ) ) return context ; if ( CONTEXT_HASH . equals ( configToken ) ) return hashString ( context ) ; if ( WEBAPP_VERSION . equals ( configToken ) ) return webappVersion ; throw new IllegalArgumentException ( " Unsupported config token " + configToken ) ; }
static String hashString ( final String s ) { return hashString ( s , 8 ) ; }
public String toString ( ) { return " StorageKeyFormat [ prefix = " + prefix + " , config = " + config + " ] " ; }
protected StorageClient createStorageClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { return null ; }
public byte [ ] get ( final String key ) { return null ; }
public Future < BackupResult > backupSession ( final String sessionId , final boolean sessionIdChanged , final String requestId ) { final MemcachedBackupSession session = _manager . getSessionInternal ( sessionId ) ; if ( session = = null ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( " No session found in session map for " + sessionId ) ; return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } _log . info ( " Serializing session data for session " + session . getIdInternal ( ) ) ; final long startSerialization = System . currentTimeMillis ( ) ; final byte [ ] data = _transcoderService . serializeAttributes ( ( MemcachedBackupSession ) session , ( ( MemcachedBackupSession ) session ) . getAttributesFiltered ( ) ) ; _log . info ( String . format ( " Serializing % 1 $ , . 3f kb session data for session % 2 $ s took % 3 $ d ms . " , ( double ) data . length / 1000 , session . getIdInternal ( ) , System . currentTimeMillis ( ) - startSerialization ) ) ; _sessionData . put ( session . getIdInternal ( ) , data ) ; _statistics . registerSince ( ATTRIBUTES_SERIALIZATION , startSerialization ) ; _statistics . register ( CACHED_DATA_SIZE , data . length ) ; return new SimpleFuture < BackupResult > ( new BackupResult ( BackupResultStatus . SUCCESS ) ) ; }
public MemcachedBackupSession findSession ( final String id ) throws IOException { final MemcachedBackupSession result = super . findSession ( id ) ; if ( result ! = null ) { final byte [ ] data = _sessionData . remove ( id ) ; if ( data ! = null ) { _executorService . submit ( new SessionDeserialization ( id , data ) ) ; } } return result ; }
protected MemcachedBackupSession loadFromMemcachedWithCheck ( final String sessionId ) { return null ; }
public Void call ( ) throws Exception { _log . info ( String . format ( " Deserializing % 1 $ , . 3f kb session data for session % 2 $ s ( asynchronously ) . " , ( double ) _data . length / 1000 , _id ) ) ; final long startDeserialization = System . currentTimeMillis ( ) ; try { _transcoderService . deserializeAttributes ( _data ) ; } catch ( final Exception e ) { _log . warn ( " Could not deserialize session data . " , e ) ; } _log . info ( String . format ( " Deserializing % 1 $ , . 3f kb session data for session % 2 $ s took % 3 $ d ms . " , ( double ) _data . length / 1000 , _id , System . currentTimeMillis ( ) - startDeserialization ) ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , startDeserialization ) ; return null ; }
public void updateLocator ( final List < MemcachedNode > nodes ) { throw new UnsupportedOperationException ( " Not yet supported . " ) ; }
public String toString ( ) { return root . toString ( ) ; }
public void addOp ( final Operation op ) { throw new UnsupportedOperationException ( ) ; }
public void insertOp ( final Operation op ) { throw new UnsupportedOperationException ( ) ; }
public void connected ( ) { throw new UnsupportedOperationException ( ) ; }
public void copyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; }
public void fillWriteBuffer ( final boolean optimizeGets ) { throw new UnsupportedOperationException ( ) ; }
public void fixupOps ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean hasReadOp ( ) { return root . hasReadOp ( ) ; }
public boolean hasWriteOp ( ) { return root . hasReadOp ( ) ; }
public boolean isActive ( ) { return root . isActive ( ) ; }
public void reconnecting ( ) { throw new UnsupportedOperationException ( ) ; }
public void registerChannel ( final SocketChannel ch , final SelectionKey selectionKey ) { throw new UnsupportedOperationException ( ) ; }
public Operation removeCurrentReadOp ( ) { throw new UnsupportedOperationException ( ) ; }
public Operation removeCurrentWriteOp ( ) { throw new UnsupportedOperationException ( ) ; }
public void setupResend ( ) { throw new UnsupportedOperationException ( ) ; }
public void transitionWriteItem ( ) { throw new UnsupportedOperationException ( ) ; }
public int writeSome ( ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public Collection < Operation > destroyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; }
public void authComplete ( ) { throw new UnsupportedOperationException ( ) ; }
public void setupForAuth ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean isAuthenticated ( ) { throw new UnsupportedOperationException ( ) ; }
public long lastReadDelta ( ) { throw new UnsupportedOperationException ( ) ; }
public void completedRead ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean isValid ( final String sessionId ) { return sessionId ! = null ; }
public String createBackupKey ( final String origKey ) { throw new UnsupportedOperationException ( " Not supported for single node configuration without node id . " ) ; }
public String createSessionId ( final String sessionId , final String memcachedId ) { return sessionId ; }
public String extractMemcachedId ( final String sessionId ) { throw new UnsupportedOperationException ( " Not supported for single node configuration without node id . " ) ; }
private boolean isCouchbaseConfig ( final String memcachedNodes ) { return memcachedNodes . startsWith ( " http : / / " ) ; }
private static List < String > initFailoverNodes ( final String failoverNodes , final Collection < String > allNodeIds ) { final List < String > failoverNodeIds = new ArrayList < String > ( ) ; if ( failoverNodes ! = null & & failoverNodes . trim ( ) . length ( ) ! = 0 ) { final String [ ] failoverNodesArray = failoverNodes . split ( " | , " ) ; for ( final String failoverNodeId : failoverNodesArray ) { final String failoverNodeIdTrimmed = failoverNodeId . trim ( ) ; if ( ! allNodeIds . contains ( failoverNodeIdTrimmed ) ) { throw new IllegalArgumentException ( " Invalid failover node id " + failoverNodeIdTrimmed + " : " + " not existing in memcachedNodes ' " + allNodeIds + " ' . " ) ; } failoverNodeIds . add ( failoverNodeIdTrimmed ) ; } } return failoverNodeIds ; }
public boolean isEncodeNodeIdInSessionId ( ) { return _encodeNodeIdInSessionId ; }
public String getNodeId ( final InetSocketAddress socketAddress ) throws IllegalArgumentException { if ( socketAddress = = null ) { throw new IllegalArgumentException ( " SocketAddress must not be null . " ) ; } final String result = _address2Ids . get ( socketAddress ) ; if ( result = = null ) { throw new IllegalArgumentException ( " SocketAddress " + socketAddress + " not known ( registered addresses : " + _address2Ids . keySet ( ) + " ) . " ) ; } return result ; }
public String createSessionId ( @ Nonnull final String sessionId ) { return isEncodeNodeIdInSessionId ( ) ? _sessionIdFormat . createSessionId ( sessionId , _nodeIdService . getMemcachedNodeId ( ) ) : sessionId ; }
public boolean isNodeAvailable ( final String nodeId ) { return _nodeIdService . isNodeAvailable ( nodeId ) ; }
public boolean isValidForMemcached ( final String sessionId ) { if ( isEncodeNodeIdInSessionId ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( nodeId = = null ) { LOG . debug ( " The sessionId does not contain a nodeId so that the memcached node could not be identified . " ) ; return false ; } } return true ; }
public boolean canHitMemcached ( final String sessionId ) { if ( isEncodeNodeIdInSessionId ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( nodeId = = null ) { LOG . debug ( " The sessionId does not contain a nodeId so that the memcached node could not be identified . " ) ; return false ; } if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { LOG . debug ( " The node " + nodeId + " is not available , therefore " + sessionId + " cannot be loaded from this memcached . " ) ; return false ; } } return true ; }
public void onLoadFromMemcachedSuccess ( final String sessionId ) { setNodeAvailableForSessionId ( sessionId , true ) ; }
public void onLoadFromMemcachedFailure ( final String sessionId ) { setNodeAvailableForSessionId ( sessionId , false ) ; }
public String changeSessionIdForTomcatFailover ( @ Nonnull final String sessionId , final String jvmRoute ) { final String newSessionId = jvmRoute ! = null & & ! jvmRoute . trim ( ) . isEmpty ( ) ? _sessionIdFormat . changeJvmRoute ( sessionId , jvmRoute ) : _sessionIdFormat . stripJvmRoute ( sessionId ) ; if ( isEncodeNodeIdInSessionId ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( newSessionId ) ; if ( _failoverNodeIds ! = null & & _failoverNodeIds . contains ( nodeId ) ) { final String newNodeId = _nodeIdService . getAvailableNodeId ( nodeId ) ; if ( newNodeId ! = null ) { return _sessionIdFormat . createNewSessionId ( newSessionId , newNodeId ) ; } } } return newSessionId ; }
public boolean isCouchbaseBucketConfig ( ) { return COUCHBASE_BUCKET_NODES_PATTERN . matcher ( _memcachedNodes ) . matches ( ) ; }
public boolean isRedisConfig ( ) { return _memcachedNodes . startsWith ( " redis : / / " ) | | _memcachedNodes . startsWith ( " rediss : / / " ) ; }
private byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { final long start = System . currentTimeMillis ( ) ; final byte [ ] attributesData = _transcoderService . serializeAttributes ( session , attributes ) ; _statistics . registerSince ( ATTRIBUTES_SERIALIZATION , start ) ; return attributesData ; }
private void handleException ( final MemcachedBackupSession session , final Exception e ) { String msg = " Could not store session " + session . getId ( ) + " in memcached . " ; if ( _force ) { msg + = " \ nNote that this session was relocated to this node because the " + " original node was not available . " ; } _log . warn ( msg , e ) ; _memcachedNodesManager . setNodeAvailableForSessionId ( session . getId ( ) , false ) ; }
public boolean isSuccess ( ) { return _status = = BackupResultStatus . SUCCESS ; }
public static ConnectionType valueOf ( final boolean couchbaseBucketConfig , final String username , final String password ) { return new ConnectionType ( couchbaseBucketConfig , username , password ) ; }
boolean isCouchbaseBucketConfig ( ) { return couchbaseBucketConfig ; }
boolean isSASL ( ) { return ! couchbaseBucketConfig & & ! isBlank ( username ) & & ! isBlank ( password ) ; }
boolean isDefault ( ) { return ! isCouchbaseBucketConfig ( ) & & ! isSASL ( ) ; }
boolean isBlank ( final String value ) { return value = = null | | value . trim ( ) . length ( ) = = 0 ; }
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return new JavaSerializationTranscoder ( manager ) ; }
public void shutdown ( ) { _executorService . shutdown ( ) ; }
public boolean awaitTermination ( final long timeout , final TimeUnit unit ) throws InterruptedException { return true ; }
public < T > List < Future < T > > invokeAll ( final Collection < ? extends Callable < T > > tasks ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; }
public < T > List < Future < T > > invokeAll ( final Collection < ? extends Callable < T > > tasks , final long timeout , final TimeUnit unit ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; }
public < T > T invokeAny ( final Collection < ? extends Callable < T > > tasks ) throws InterruptedException , ExecutionException { throw new UnsupportedOperationException ( ) ; }
public < T > T invokeAny ( final Collection < ? extends Callable < T > > tasks , final long timeout , final TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { throw new UnsupportedOperationException ( ) ; }
public boolean isShutdown ( ) { return _shutdown ; }
public boolean isTerminated ( ) { return _shutdown ; }
public void shutdown ( ) { _shutdown = true ; }
public List < Runnable > shutdownNow ( ) { shutdown ( ) ; return null ; }
public void execute ( final Runnable command ) { command . run ( ) ; }
public boolean cancel ( final boolean mayInterruptIfRunning ) { return true ; }
public T get ( ) throws InterruptedException , ExecutionException { if ( _e ! = null ) { throw _e ; } return _result ; }
public T get ( final long timeout , final TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( _e ! = null ) { throw _e ; } return _result ; }
public boolean isCancelled ( ) { return false ; }
public boolean isDone ( ) { return true ; }
private boolean updateIsNodeAvailable ( final K key ) { final Boolean result = Boolean . valueOf ( _cacheLoader . isNodeAvailable ( key ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " CacheLoader returned node availability ' " + result + " ' for node ' " + key + " ' . " ) ; } _map . put ( key , new ManagedItem < Boolean > ( result , System . currentTimeMillis ( ) ) ) ; return result ; }
public boolean asyncDecode ( final CachedData cachedData ) { return _delegate . asyncDecode ( cachedData ) ; }
public Object decode ( final CachedData cachedData ) { return _delegate . decode ( cachedData ) ; }
public CachedData encode ( final Object object ) { final CachedData result = _delegate . encode ( object ) ; _statistics . register ( StatsType . CACHED_DATA_SIZE , result . getData ( ) . length ) ; return result ; }
protected LockStatus onBeforeLoadFromMemcached ( @ Nonnull final String sessionId ) throws InterruptedException , ExecutionException { return LockStatus . LOCK_NOT_REQUIRED ; }
public ConcurrentMap < String , Object > get ( MemcachedBackupSession session ) { return session . attributes ; }
public void set ( MemcachedBackupSession session , ConcurrentMap < String , Object > attributes ) { session . attributes = attributes ; }
public void removeAttribute ( final String name ) { if ( filterAttribute ( name ) ) { _attributesAccessed = true ; } super . removeAttribute ( name ) ; }
public void recycle ( ) { super . recycle ( ) ; _attributesAccessed = false ; _dataHashCode = 0 ; _expirationUpdateRunning = false ; _backupRunning = false ; _lockStatus = null ; }
private boolean filterAttribute ( final String name ) { if ( this . manager = = null ) { throw new IllegalStateException ( " There ' s no manager set . " ) ; } final Pattern pattern = ( ( SessionManager ) manager ) . getMemcachedSessionService ( ) . getSessionAttributePattern ( ) ; if ( pattern = = null ) { return true ; } return pattern . matcher ( name ) . matches ( ) ; }
void storeThisAccessedTimeFromLastBackupCheck ( ) { _thisAccessedTimeFromLastBackupCheck = this . thisAccessedTime ; }
boolean wasAccessedSinceLastBackupCheck ( ) { return _thisAccessedTimeFromLastBackupCheck ! = this . thisAccessedTime ; }
boolean attributesAccessedSinceLastBackup ( ) { return _attributesAccessed ; }
boolean isExpirationUpdateRunning ( ) { return _expirationUpdateRunning ; }
boolean isBackupRunning ( ) { return _backupRunning ; }
boolean isNewInternal ( ) { return this . isNew ; }
public boolean isValidInternal ( ) { return this . isValid ; }
boolean isExpiring ( ) { return this . expiring ; }
public void removeAttributeInternal ( final String name , final boolean notify ) { super . removeAttributeInternal ( name , notify ) ; }
boolean authenticationChanged ( ) { return _authenticationChanged | | getNote ( Constants . FORM_PRINCIPAL_NOTE ) ! = null ; }
private static boolean equals ( final Object one , final Object another ) { return one = = null & & another = = null | | one ! = null & & one . equals ( another ) ; }
public void backupFinished ( ) { _authenticationChanged = false ; _attributesAccessed = false ; _sessionIdChanged = false ; }
public boolean isSessionIdChanged ( ) { return _sessionIdChanged ; }
public void backupFailed ( ) { _lastBackupTime = _previousLastBackupTime ; }
public synchronized boolean isLocked ( ) { return _lockStatus = = LockStatus . LOCKED ; }
public void releaseLock ( ) { _lockStatus = null ; }
public synchronized boolean registerReference ( ) { return _refCount . add ( Thread . currentThread ( ) . getId ( ) ) ; }
public synchronized int releaseReference ( ) { _refCount . remove ( Thread . currentThread ( ) . getId ( ) ) ; return _refCount . size ( ) ; }
public static byte [ ] encode ( final long maxInactiveInterval , final long lastAccessedTime , final long thisAccessedTime ) { int idx = 0 ; final byte [ ] data = new byte [ 4 + 2 * 8 ] ; encodeNum ( maxInactiveInterval , data , idx , 4 ) ; encodeNum ( lastAccessedTime , data , idx + = 4 , 8 ) ; encodeNum ( thisAccessedTime , data , idx + = 8 , 8 ) ; return data ; }
public static SessionValidityInfo decode ( @ Nonnull final byte [ ] data ) { int idx = 0 ; final int maxInactiveInterval = ( int ) decodeNum ( data , idx , 4 ) ; final long lastAccessedTime = decodeNum ( data , idx + = 4 , 8 ) ; final long thisAccessedTime = decodeNum ( data , idx + = 8 , 8 ) ; return new SessionValidityInfo ( maxInactiveInterval , lastAccessedTime , thisAccessedTime ) ; }
@ Override protected byte [ ] execute ( BinaryJedis jedis ) throws Exception { return jedis . get ( keyBytes ( key ) ) ; }
@ Override protected Boolean execute ( BinaryJedis jedis ) throws Exception { return jedis . del ( keyBytes ( key ) ) = = 1 ; }
public void shutdown ( ) { _pool . shutdown ( ) ; }
private BinaryJedis createJedisInstance ( ) { BinaryJedis binaryJedis = new BinaryJedis ( _uri ) ; binaryJedis . getClient ( ) . setConnectionTimeout ( _timeout ) ; binaryJedis . getClient ( ) . setSoTimeout ( _timeout ) ; return binaryJedis ; }
public Future < Boolean > add ( String key , int exp , byte [ ] o ) { return _memcached . add ( key , exp , o , ByteArrayTranscoder . INSTANCE ) ; }
public Future < Boolean > set ( String key , int exp , byte [ ] o ) { return _memcached . set ( key , exp , o , ByteArrayTranscoder . INSTANCE ) ; }
public byte [ ] get ( String key ) { return _memcached . get ( key , ByteArrayTranscoder . INSTANCE ) ; }
public Future < Boolean > delete ( String key ) { return _memcached . delete ( key ) ; }
public void shutdown ( ) { _memcached . shutdown ( ) ; }
public boolean asyncDecode ( CachedData d ) { return false ; }
public byte [ ] decode ( CachedData d ) { return d . getData ( ) ; }
public CachedData encode ( byte [ ] o ) { return new CachedData ( 0 , o , getMaxSize ( ) ) ; }
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { super . setup ( ) ; final Context context = _manager . getContext ( ) ; when ( _manager . getContext ( ) ) . thenReturn ( context ) ; }
public Tomcat9Builder tomcatBuilder ( ) { return new Tomcat9Builder ( ) ; }
public Tomcat9Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; }
protected GenericPrincipal createPrincipal ( ) { return new GenericPrincipal ( " foo " , " bar " , null ) ; }
protected void setupGetResponseSetCookieHeadersExpectations ( final Response response , final String [ ] result ) { when ( response . getHeaders ( eq ( " Set - Cookie " ) ) ) . thenReturn ( Arrays . asList ( result ) ) ; }
public Tomcat7Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; }
public Tomcat7Builder tomcatBuilder ( ) { return new Tomcat7Builder ( ) ; }
public void remove ( final Session session , final boolean update ) { removeInternal ( session , update , session . getNote ( MemcachedSessionService . NODE_FAILURE ) ! = Boolean . TRUE ) ; }
public void removeInternal ( final Session session , final boolean update ) { super . remove ( session , update ) ; }
private void swapOut ( @ Nonnull final StandardSession session ) { if ( ! session . isValid ( ) ) { return ; } session . passivate ( ) ; removeInternal ( session , true ) ; session . recycle ( ) ; }
public Principal readPrincipal ( final ObjectInputStream ois ) throws ClassNotFoundException , IOException { return SerializablePrincipal . readPrincipal ( ois ) ; }
protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { HttpSession session = req . getSession ( ) ; Integer counter = ( Integer ) session . getAttribute ( COUNTER ) ; int iTmp = 0 ; if ( counter ! = null ) { iTmp = counter + 1 ; } String sTmp = Integer . toString ( iTmp ) ; resp . getOutputStream ( ) . println ( sTmp ) ; session . setAttribute ( COUNTER , iTmp ) ; resp . flushBuffer ( ) ; }
public Object put ( final String key , final Object value ) { return _map . put ( key , value ) ; }
public Object get ( final String key ) { return _map . get ( key ) ; }
public Set < Entry < String , Object > > entrySet ( ) { return _map . entrySet ( ) ; }
private static void benchmark ( final MemcachedBackupSessionManager manager , final int rounds , final int countPersons , final int nodesPerEdge ) throws InterruptedException { final Stats kryoSerStats = new Stats ( ) ; final Stats kryoDeSerStats = new Stats ( ) ; benchmark ( manager , new KryoTranscoder ( ) , kryoSerStats , kryoDeSerStats , rounds , countPersons , nodesPerEdge ) ; final Stats javaSerStats = new Stats ( ) ; final Stats javaDeSerStats = new Stats ( ) ; benchmark ( manager , new JavaSerializationTranscoder ( ) , javaSerStats , javaDeSerStats , rounds , countPersons , nodesPerEdge ) ; recover ( ) ; final Stats javolutionSerStats = new Stats ( ) ; final Stats javolutionDeSerStats = new Stats ( ) ; benchmark ( manager , new JavolutionTranscoder ( Thread . currentThread ( ) . getContextClassLoader ( ) , false ) , javolutionSerStats , javolutionDeSerStats , rounds , countPersons , nodesPerEdge ) ; recover ( ) ; System . out . println ( " Serialization , Size , Ser - Min , Ser - Avg , Ser - Max , Deser - Min , Deser - Avg , Deser - Max " ) ; System . out . println ( toCSV ( " Java " , javaSerStats , javaDeSerStats ) ) ; System . out . println ( toCSV ( " Javolution " , javolutionSerStats , javolutionDeSerStats ) ) ; System . out . println ( toCSV ( " Kryo " , kryoSerStats , kryoDeSerStats ) ) ; }
private static String toCSV ( final String name , final Stats serStats , final Stats deSerStats ) { return name + " , " + serStats . size + " , " + minAvgMax ( serStats ) + " , " + minAvgMax ( deSerStats ) ; }
private static String minAvgMax ( final Stats stats ) { return stats . min + " , " + stats . avg + " , " + stats . max ; }
private static void recover ( ) throws InterruptedException { Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; }
private static MemcachedBackupSession createSession ( final MemcachedBackupSessionManager manager , final String id , final int countPersons , final int countNodesPerEdge ) { final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setId ( id ) ; session . setValid ( true ) ; session . setAttribute ( " stringbuffer " , new StringBuffer ( " < string \ n & buffer / > " ) ) ; session . setAttribute ( " stringbuilder " , new StringBuilder ( " < string \ n & buffer / > " ) ) ; session . setAttribute ( " persons " , createPersons ( countPersons ) ) ; session . setAttribute ( " mycontainer " , new TestClasses . MyContainer ( ) ) ; session . setAttribute ( " component " , createComponents ( countNodesPerEdge ) ) ; return session ; }
static Person createPerson ( final String name , final Gender gender , final String . . . emailAddresses ) { return createPerson ( name , gender , ( Integer ) null , emailAddresses ) ; }
static Person createPerson ( final String name , final Gender gender , final Calendar dateOfBirth , final String . . . emailAddresses ) { final int age = dateOfBirth = = null ? - 1 : Calendar . getInstance ( ) . get ( Calendar . YEAR ) - dateOfBirth . get ( Calendar . YEAR ) ; final Person result = createPerson ( name , gender , age , emailAddresses ) ; result . setDateOfBirth ( dateOfBirth ) ; return result ; }
static ClassWithoutDefaultConstructor createClassWithoutDefaultConstructor ( final String string ) { return new ClassWithoutDefaultConstructor ( string ) ; }
static PrivateClass createPrivateClass ( final String string ) { final PrivateClass result = new PrivateClass ( ) ; result . foo = string ; return result ; }
public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { if ( _target = = null ) { _target = _targetClazz . newInstance ( ) ; } return method . invoke ( _target , args ) ; }
public String hello ( ) { return " hi " ; }
public MyXMLSerializable newInstance ( final Class < MyXMLSerializable > cls , final InputElement xml ) throws XMLStreamException { return new MyXMLSerializable ( Runtime . getRuntime ( ) ) ; }
public void addFriend ( final Person p ) { _friends . add ( p ) ; }
public void addAddress ( final Address a ) { _addresses . add ( a ) ; }
private boolean flatEquals ( final Collection < ? > c1 , final Collection < ? > c2 ) { return c1 = = c2 | | c1 ! = null & & c2 ! = null & & c1 . size ( ) = = c2 . size ( ) ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( _age = = null ) ? 0 : _age . hashCode ( ) ) ; result = prime * result + ( ( _friends = = null ) ? 0 : _friends . size ( ) ) ; result = prime * result + ( ( _gender = = null ) ? 0 : _gender . hashCode ( ) ) ; result = prime * result + ( ( _name = = null ) ? 0 : _name . hashCode ( ) ) ; result = prime * result + ( ( _props = = null ) ? 0 : _props . hashCode ( ) ) ; return result ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( privateClass = = null ) ? 0 : privateClass . hashCode ( ) ) ; return result ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( foo = = null ) ? 0 : foo . hashCode ( ) ) ; return result ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; return result ; }
public String toString ( ) { return " ClassWithoutDefaultConstructor [ value = " + value + " ] " ; }
public Component addChild ( final Component child ) { child . setParent ( this ) ; _children . add ( child ) ; return this ; }
public Component addChildren ( final Collection < Component > children ) { for ( final Component child : children ) { child . setParent ( this ) ; _children . add ( child ) ; } return this ; }
public String toString ( ) { return " Component [ _children = " + _children + " , _name = " + _name + " , _parent = " + _parent + " ] " ; }
protected Class < ? > findClass ( final String name ) throws ClassNotFoundException { if ( _className . equals ( name ) ) { return defineClass ( name , _classBytes , 0 , _classBytes . length ) ; } return super . findClass ( name ) ; }
public static ClassLoader makeClassLoaderForCustomClass ( final ClassLoader parent , final String className , final String . . . fields ) { return new ByteClassLoader ( parent , className , makeClass ( className , fields ) ) ; }
public void testDeserializationError ( ) { final ClassLoader loaderForCustomClassInVersion1 = ClassGenerationUtil . makeClassLoaderForCustomClass ( this . getClass ( ) . getClassLoader ( ) , TEST_TYPE_CLASS_NAME , " field1 " ) ; final Object value = makeValueInstance ( loaderForCustomClassInVersion1 ) ; final SessionAttributesTranscoder transcoder = new KryoTranscoderFactory ( ) . createTranscoder ( loaderForCustomClassInVersion1 ) ; final MemcachedBackupSession memcachedBackupSession = new MemcachedBackupSession ( ) ; final ConcurrentMap < String , Object > attributes = new ConcurrentHashMap < String , Object > ( ) ; attributes . put ( " test " , value ) ; byte [ ] data = transcoder . serializeAttributes ( memcachedBackupSession , attributes ) ; final Map < String , Object > deserializeAttributes = transcoder . deserializeAttributes ( data ) ; final Object actual = deserializeAttributes . get ( " test " ) ; assertNotNull ( actual ) ; assertDeepEquals ( actual , value ) ; final ClassLoader loaderForCustomClassInVersion2 = ClassGenerationUtil . makeClassLoaderForCustomClass ( this . getClass ( ) . getClassLoader ( ) , TEST_TYPE_CLASS_NAME , " field1 " , " field2 " ) ; final SessionAttributesTranscoder secondTranscoder = new KryoTranscoderFactory ( ) . createTranscoder ( loaderForCustomClassInVersion2 ) ; secondTranscoder . deserializeAttributes ( data ) ; }
public void testSpringSecurityUserSerializer ( ) { final Kryo kryo = new Kryo ( ) ; kryo . setInstantiatorStrategy ( new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ) ; kryo . setRegistrationRequired ( false ) ; new SpringSecurityUserRegistration ( ) . customize ( kryo ) ; final Collection < ? extends GrantedAuthority > authorities = Arrays . asList ( new SimpleGrantedAuthority ( " foo " ) ) ; final User user = new User ( " foo " , " bar " , authorities ) ; Output out = new Output ( 100 , 1024 ) ; kryo . writeObject ( out , user ) ; final byte [ ] data = out . toBytes ( ) ; final User user2 = kryo . readObject ( new Input ( data ) , User . class ) ; TestUtils . assertDeepEquals ( user , user2 ) ; }
public void test ( ) { HibernateCollectionsSerializerFactory factory = new HibernateCollectionsSerializerFactory ( new Kryo ( ) ) ; Serializer serializer = factory . newSerializer ( PERSISTENT_LIST_CLASS ) ; assertNotNull ( serializer ) ; }
public void testKryoBuilder ( BuildKryo buildKryo ) { DefaultClassResolver classResolver = new DefaultClassResolver ( ) ; MapReferenceResolver referenceResolver = new MapReferenceResolver ( ) ; DefaultStreamFactory streamFactory = new DefaultStreamFactory ( ) ; InstantiatorStrategy instantiatorStrategy = new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ; KryoCustomization enableAsm = new KryoCustomization ( ) { @ Override public void customize ( Kryo kryo ) { kryo . getFieldSerializerConfig ( ) . setUseAsm ( true ) ; } } ; final CollectionSerializer collectionSerializer = new CollectionSerializer ( ) ; KryoCustomization registerMyCollectionSerializer = new KryoCustomization ( ) { @ Override public void customize ( Kryo kryo ) { kryo . addDefaultSerializer ( Collection . class , collectionSerializer ) ; } } ; Kryo kryo = buildKryo . build ( classResolver , referenceResolver , streamFactory , instantiatorStrategy , enableAsm , registerMyCollectionSerializer ) ; assertSame ( kryo . getClassResolver ( ) , classResolver ) ; assertSame ( kryo . getReferenceResolver ( ) , referenceResolver ) ; assertSame ( kryo . getStreamFactory ( ) , streamFactory ) ; assertSame ( kryo . getInstantiatorStrategy ( ) , instantiatorStrategy ) ; assertTrue ( kryo . isRegistrationRequired ( ) ) ; assertFalse ( kryo . getReferences ( ) ) ; assertTrue ( kryo . getFieldSerializerConfig ( ) . isUseAsm ( ) ) ; assertSame ( kryo . getDefaultSerializer ( Collection . class ) , collectionSerializer ) ; assertFalse ( kryo . getFieldSerializerConfig ( ) . isOptimizedGenerics ( ) ) ; }
@ Override public void customize ( Kryo kryo ) { kryo . getFieldSerializerConfig ( ) . setUseAsm ( true ) ; }
@ Override public void customize ( Kryo kryo ) { kryo . addDefaultSerializer ( Collection . class , collectionSerializer ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( " + description + " ) " ; }
protected KryoTranscoder createTranscoder ( final SessionManager manager ) { final String [ ] customConverter = new String [ ] { HibernateCollectionsSerializerFactory . class . getName ( ) } ; final KryoTranscoder result = new KryoTranscoder ( getClass ( ) . getClassLoader ( ) , customConverter , false ) ; return result ; }
public void customize ( final Kryo kryo ) { kryo . register ( Interval . class , new JodaIntervalSerializer ( ) ) ; kryo . register ( DateTime . class , new JodaDateTimeSerializer ( ) ) ; kryo . register ( LocalDateTime . class , new JodaLocalDateTimeSerializer ( ) ) ; kryo . register ( LocalDate . class , new JodaLocalDateSerializer ( ) ) ; }
public Serializer newDefaultSerializer ( Kryo kryo , Class < ? > type ) { return new CompatibleFieldSerializer ( kryo , type ) ; }
public Serializer makeSerializer ( Kryo kryo , Class < ? > type ) { final FieldSerializer result = new FieldSerializer < Component > ( kryo , type ) ; result . setIgnoreSyntheticFields ( false ) ; return result ; }
public Serializer newDefaultSerializer ( final Kryo kryo , final Class < ? > type ) { final FieldSerializer result = new FieldSerializer ( kryo , type ) ; result . setIgnoreSyntheticFields ( false ) ; return result ; }
public Serializer makeSerializer ( Kryo kryo , Class < ? > type ) { return delegate . newDefaultSerializer ( kryo , type ) ; }
public void customize ( final Kryo kryo ) { kryo . register ( User . class , new SpringSecurityUserSerializer ( kryo ) ) ; }
public void write ( Kryo kryo , Output output , User user ) { output . writeString ( user . getPassword ( ) ) ; output . writeString ( user . getUsername ( ) ) ; final Collection < GrantedAuthority > authorities = user . getAuthorities ( ) ; output . writeInt ( authorities . size ( ) , true ) ; for ( final GrantedAuthority item : authorities ) { _kryo . writeClassAndObject ( output , item ) ; } output . writeBoolean ( user . isAccountNonExpired ( ) ) ; output . writeBoolean ( user . isAccountNonLocked ( ) ) ; output . writeBoolean ( user . isCredentialsNonExpired ( ) ) ; output . writeBoolean ( user . isEnabled ( ) ) ; }
public Serializer newSerializer ( final Class < ? > type ) { if ( HIBERNATE_ABSTRACT_COLLECTION_CLASS = = null ) { return null ; } else if ( HIBERNATE_ABSTRACT_COLLECTION_CLASS . isAssignableFrom ( type ) ) { return new FieldSerializer ( _kryo , type ) ; } return null ; }
public Kryo create ( ) { KryoBuilder kryoBuilder = new KryoBuilder ( ) { @ Override protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { return KryoTranscoder . this . createKryo ( classResolver , referenceResolver , streamFactory , classLoader , customConverterClassNames , copyCollectionsForSerialization ) ; } } . withInstantiatorStrategy ( new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ) ; final List < KryoBuilderConfiguration > builderConfigs = load ( KryoBuilderConfiguration . class , customConverterClassNames , classLoader ) ; for ( KryoBuilderConfiguration config : builderConfigs ) { kryoBuilder = config . configure ( kryoBuilder ) ; } Kryo kryo = kryoBuilder . build ( ) ; kryo . setDefaultSerializer ( new KryoDefaultSerializerFactory . SerializerFactoryAdapter ( _defaultSerializerFactory ) ) ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } kryo . setRegistrationRequired ( false ) ; kryo . register ( Arrays . asList ( " " ) . getClass ( ) , new ArraysAsListSerializer ( ) ) ; kryo . register ( InvocationHandler . class , new JdkProxySerializer ( ) ) ; UnmodifiableCollectionsSerializer . registerSerializers ( kryo ) ; SynchronizedCollectionsSerializer . registerSerializers ( kryo ) ; kryo . addDefaultSerializer ( EnumMap . class , EnumMapSerializer . class ) ; SubListSerializers . addDefaultSerializers ( kryo ) ; final List < KryoCustomization > customizations = load ( KryoCustomization . class , customConverterClassNames , classLoader , kryo ) ; if ( customizations ! = null ) { for ( final KryoCustomization customization : customizations ) { try { LOG . info ( " Executing KryoCustomization " + customization . getClass ( ) . getName ( ) ) ; customization . customize ( kryo ) ; } catch ( final Throwable e ) { LOG . error ( " Could not execute customization " + customization , e ) ; } } } return kryo ; }
private Serializer < ? > loadCustomSerializer ( final Class < ? > clazz , List < SerializerFactory > serializerFactories ) { if ( serializerFactories ! = null ) { for ( SerializerFactory serializerFactory : serializerFactories ) { final Serializer < ? > serializer = serializerFactory . newSerializer ( clazz ) ; if ( serializer ! = null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading custom serializer " + serializer . getClass ( ) . getName ( ) + " for class " + clazz ) ; } return serializer ; } } } return null ; }
private Serializer < ? > loadCopyCollectionSerializer ( final Class < ? > clazz ) { if ( Collection . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateCollectionSerializer for class " + clazz ) ; } return new CopyForIterateCollectionSerializer ( ) ; } if ( Map . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateMapSerializer for class " + clazz ) ; } return new CopyForIterateMapSerializer ( ) ; } return null ; }
private < T > List < T > load ( Class < T > type , final String [ ] customConverterClassNames , final ClassLoader classLoader ) { return load ( type , customConverterClassNames , classLoader , null ) ; }
private < T > List < T > load ( Class < T > type , final String [ ] customConverterClassNames , final ClassLoader classLoader , final Kryo kryo ) { if ( customConverterClassNames = = null | | customConverterClassNames . length = = 0 ) { return Collections . emptyList ( ) ; } final List < T > result = new ArrayList < T > ( ) ; final ClassLoader loader = classLoader ! = null ? classLoader : Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( final String element : customConverterClassNames ) { try { final Class < ? > clazz = Class . forName ( element , true , loader ) ; if ( type . isAssignableFrom ( clazz ) ) { LOG . info ( " Loading " + type . getSimpleName ( ) + " " + element ) ; final T item = createInstance ( clazz . asSubclass ( type ) , kryo ) ; result . add ( item ) ; } } catch ( final Exception e ) { LOG . error ( " Could not instantiate " + element + " , omitting this " + type . getSimpleName ( ) + " . " , e ) ; throw new RuntimeException ( " Could not load " + type . getSimpleName ( ) + " " + element , e ) ; } } return result ; }
protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { Kryo kryo = new Kryo ( classResolver , referenceResolver , streamFactory ) ; kryo . getFieldSerializerConfig ( ) . setOptimizedGenerics ( true ) ; return kryo ; }
public KryoBuilder withClassResolver ( final ClassResolver classResolver ) { this . classResolver = classResolver ; return this ; }
public KryoBuilder withReferenceResolver ( final ReferenceResolver referenceResolver ) { this . referenceResolver = referenceResolver ; return this ; }
public KryoBuilder withStreamFactory ( final StreamFactory streamFactory ) { this . streamFactory = streamFactory ; return this ; }
protected Kryo buildFrom ( KryoBuilder target ) { if ( target . classResolver = = null ) target . classResolver = classResolver ; if ( target . referenceResolver = = null ) target . referenceResolver = referenceResolver ; if ( target . streamFactory = = null ) target . streamFactory = streamFactory ; return target . build ( ) ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . setRegistrationRequired ( registrationRequired ) ; return k ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . setInstantiatorStrategy ( instantiatorStrategy ) ; return k ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . setReferences ( references ) ; return k ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; kryoCustomization . customize ( k ) ; return k ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . getFieldSerializerConfig ( ) . setOptimizedGenerics ( optimizedGenerics ) ; return k ; }
public void customize ( final Kryo kryo ) { new WicketMiniMapRegistration ( ) . customize ( kryo ) ; new ComponentSerializerFactory ( ) . customize ( kryo ) ; }
public Serializer newSerializer ( final Class < ? > type ) { Serializer serializer ; if ( ( serializer = _childListSerializerFactory . newSerializer ( type ) ) ! = null ) { return serializer ; } return null ; }
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return getTranscoder ( manager . getContainerClassLoader ( ) ) ; }
protected SessionAttributesTranscoder createTranscoder ( final ClassLoader loader ) { return getTranscoder ( loader ) ; }
public void customize ( Kryo kryo ) { kryo . setReferences ( true ) ; kryo . register ( GrailsFlashScope . class , new FieldSerializer ( kryo , GrailsFlashScope . class ) ) ; }
public void customize ( final Kryo kryo ) { kryo . register ( CGLibProxySerializer . CGLibProxyMarker . class , new CGLibProxySerializer ( ) ) ; }
public Serializer newSerializer ( Class < ? > type ) { if ( CGLibProxySerializer . canSerialize ( type ) ) { return kryo . getSerializer ( CGLibProxySerializer . CGLibProxyMarker . class ) ; } return null ; }
protected ClassResolver createClassResolver ( ) { return new CGLibProxyClassResolver ( ) ; }
public void customize ( final Kryo kryo ) { kryo . register ( MiniMap . class , new MiniMapSerializer ( ) ) ; }
public void customize ( final Kryo kryo ) { kryo . register ( LRUMap . class , new LRUMapSerializer ( kryo ) ) ; }
public void write ( Kryo kryo , Output output , LRUMap < ? , ? > map ) { output . writeInt ( getMaxCapacity ( map ) , true ) ; output . writeInt ( map . size ( ) , true ) ; for ( final Entry < ? , ? > entry : map . entrySet ( ) ) { _kryo . writeClassAndObject ( output , entry . getKey ( ) ) ; _kryo . writeClassAndObject ( output , entry . getValue ( ) ) ; } if ( TRACE ) trace ( " kryo " , " Wrote map : " + map ) ; }
private Field getField ( final Class < ? > clazz , final String name ) throws NoSuchFieldException { final Field field = clazz . getDeclaredField ( name ) ; field . setAccessible ( true ) ; return field ; }
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return getTranscoder ( manager ) ; }
protected JavolutionTranscoder createTranscoder ( final SessionManager manager ) { return new JavolutionTranscoder ( Thread . currentThread ( ) . getContextClassLoader ( ) , false , new HibernateCollectionsXMLFormat ( ) ) ; }
protected void beforeTest ( ) { _binding = new ReflectionBinding ( getClass ( ) . getClassLoader ( ) , false , new JodaDateTimeFormat ( ) ) ; }
public void testWriteDateTimeWithTimeZone ( final DateTimeZone timeZone ) throws XMLStreamException { final DateTime dateTime = new DateTime ( 0 , timeZone ) ; final byte [ ] serialized = serialize ( dateTime , _binding ) ; final DateTime deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized , dateTime ) ; }
public void testWriteDateTimeWithChronology ( final Chronology chronology ) throws XMLStreamException { final DateTime dateTime = new DateTime ( 0 , chronology ) ; final byte [ ] serialized = serialize ( dateTime , _binding ) ; final DateTime deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized , dateTime ) ; }
protected void beforeTest ( ) { _binding = new ReflectionBinding ( getClass ( ) . getClassLoader ( ) , false , new CGLibProxyFormat ( ) ) ; }
public void testCGLibProxy ( ) throws XMLStreamException { final ClassToProxy proxy = createProxy ( new ClassToProxy ( ) ) ; proxy . setValue ( " foo " ) ; final byte [ ] serialized = serialize ( proxy , _binding ) ; System . out . println ( new String ( serialized ) ) ; final ClassToProxy deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized . getValue ( ) , proxy . getValue ( ) ) ; }
public void testCGLibProxyForExistingFormat ( ) throws XMLStreamException { final Map < String , String > proxy = createProxy ( new HashMap < String , String > ( ) ) ; proxy . put ( " foo " , " bar " ) ; Assert . assertEquals ( proxy . get ( " foo " ) , " bar " ) ; final byte [ ] serialized = serialize ( proxy , _binding ) ; System . out . println ( new String ( serialized ) ) ; final Map < String , String > deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized . get ( " foo " ) , proxy . get ( " foo " ) ) ; }
public String getClassName ( final String prefix , final String source , final Object key , final Predicate names ) { return super . getClassName ( " MSM_ " + prefix , source , key , names ) ; }
public Object invoke ( final Object obj , final Method method , final Object [ ] args ) throws Throwable { return method . invoke ( _delegate , args ) ; }
static Container createContainer ( final String bodyContent ) { return new Container ( bodyContent ) ; }
public void testJavaUtilCollectionsUnmodifiable ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableList ( new ArrayList < String > ( Arrays . asList ( " foo " , " bar " ) ) ) ) ; final HashMap < String , String > m = new HashMap < String , String > ( ) ; m . put ( " foo " , " bar " ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableMap ( m ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testJavaUtilLists ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyList " , Collections . < String > emptyList ( ) ) ; session . setAttribute ( " arrayList " , new ArrayList < String > ( ) ) ; session . setAttribute ( " arraysAsList " , Arrays . asList ( " foo " , " bar " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testJavaUtilCollectionsEmptyMap ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyMap " , Collections . < String , String > emptyMap ( ) ) ; session . setAttribute ( " hashMap " , new HashMap < String , String > ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testProxy ( ) throws Exception { final SomeInterface bean = TestClasses . createProxy ( ) ; final byte [ ] bytes = serialize ( bean ) ; assertDeepEquals ( deserialize ( bytes ) , bean ) ; }
public void testInnerClass ( ) throws Exception { final Container container = TestClasses . createContainer ( " some content " ) ; assertDeepEquals ( deserialize ( serialize ( container ) ) , container ) ; }
public < T > void testTypesAsSessionAttributes ( final Class < T > type , final T instance ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( type . getSimpleName ( ) , instance ) ; final byte [ ] bytes = _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; assertDeepEquals ( _transcoder . deserializeAttributes ( bytes ) , session . getAttributesInternal ( ) ) ; }
public void testTypesInContainerClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( MyContainer . class . getSimpleName ( ) , new MyContainer ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testClassWithoutDefaultConstructor ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " no - default constructor " , TestClasses . createClassWithoutDefaultConstructor ( " foo " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testPrivateClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " pc " , TestClasses . createPrivateClass ( " foo " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testCollections ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " foo " , new EntityWithCollections ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + Arrays . hashCode ( _bars ) ; result = prime * result + ( ( _bazens = = null ) ? 0 : _bazens . hashCode ( ) ) ; result = prime * result + ( ( _foos = = null ) ? 0 : _foos . hashCode ( ) ) ; return result ; }
private void assertDeepEquals ( final Object one , final Object another ) throws Exception { assertDeepEquals ( one , another , new IdentityHashMap < Object , Object > ( ) ) ; }
public void write ( final Enum < ? > object , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " value " , object . name ( ) ) ; xml . setAttribute ( " type " , object . getClass ( ) . getName ( ) ) ; }
public final void write ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , array . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; writeElements ( array , output ) ; }
public boolean isReferenceable ( ) { return false ; }
public Currency newInstance ( final Class < Currency > cls , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return Currency . getInstance ( xml . getAttribute ( " code " , " " ) ) ; }
public void write ( final Currency currency , final OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " code " , currency . getCurrencyCode ( ) ) ; }
public Object newInstance ( final Class < Object > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final InvocationHandler invocationHandler = input . get ( " handler " ) ; final Class < ? > [ ] interfaces = getInterfaces ( input , " interfaces " , _classLoader ) ; return Proxy . newProxyInstance ( _classLoader , interfaces , invocationHandler ) ; }
public final void write ( final Object obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { final InvocationHandler invocationHandler = Proxy . getInvocationHandler ( obj ) ; output . add ( invocationHandler , " handler " ) ; final String [ ] interfaceNames = getInterfaceNames ( obj ) ; output . add ( interfaceNames , " interfaces " ) ; }
public StringBuilder newInstance ( final Class < StringBuilder > cls , final InputElement xml ) throws XMLStreamException { return new StringBuilder ( xml . getAttribute ( " val " ) ) ; }
public void write ( final StringBuilder obj , final OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " val " , obj . toString ( ) ) ; }
public StringBuffer newInstance ( final Class < StringBuffer > cls , final InputElement xml ) throws XMLStreamException { return new StringBuffer ( xml . getAttribute ( " val " ) ) ; }
public void write ( final StringBuffer obj , final OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " val " , obj . toString ( ) ) ; }
public boolean canConvert ( final Class < ? > cls ) { return cls = = DateTime . class ; }
public DateTime newInstance ( final Class < DateTime > cls , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final long millis = input . getAttribute ( MILLIS ) . toLong ( ) ; final Chronology chronology = readChronology ( input ) ; final DateTimeZone tz = readTimeZone ( input ) ; return new DateTime ( millis , chronology . withZone ( tz ) ) ; }
private Chronology readChronology ( final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final CharArray chronologyId = input . getAttribute ( CHRONOLOGY ) ; return IdentifiableChronology . valueOfId ( chronologyId ! = null ? chronologyId . toString ( ) : null ) ; }
private DateTimeZone readTimeZone ( final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final CharArray tz = input . getAttribute ( TIME_ZONE ) ; return tz ! = null ? DateTimeZone . forID ( tz . toString ( ) ) : DateTimeZone . getDefault ( ) ; }
public static Chronology valueOfId ( String id ) throws IllegalArgumentException { if ( id = = null ) { return ISO . _chronology ; } for ( final IdentifiableChronology item : values ( ) ) { if ( id . equals ( item . _id ) ) { return item . _chronology ; } } throw new IllegalArgumentException ( " No chronology found for id " + id ) ; }
private AttributesAndElements allFields ( final Class < T > cls ) { final AttributesAndElements result = new AttributesAndElements ( ) ; Class < ? super T > clazz = cls ; while ( clazz ! = null ) { addDeclaredFields ( clazz , result ) ; clazz = clazz . getSuperclass ( ) ; } return result ; }
protected static boolean isAttribute ( final Field field ) { return isAttribute ( field . getType ( ) ) ; }
public void read ( final javolution . xml . XMLFormat . InputElement input , final T obj ) throws XMLStreamException { readAttributes ( input , obj ) ; readElements ( input , obj ) ; }
public void write ( final T obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { writeAttributes ( obj , output ) ; writeElements ( obj , output ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getBoolean ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getInt ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getLong ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getFloat ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getDouble ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getByte ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getChar ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getShort ( obj ) ) ; }
void add ( final Object object , final OutputElement output ) throws XMLStreamException { output . setAttribute ( _field . getName ( ) , object . toString ( ) ) ; }
void add ( final Object object , final OutputElement output ) throws XMLStreamException { output . setAttribute ( _field . getName ( ) , ( ( Enum < ? > ) object ) . name ( ) ) ; }
private String getAttribute ( final InputElement input , final String name , final String defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? value . toString ( ) : defaultValue ; }
private Boolean getAttribute ( final InputElement input , final String name , final Boolean defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Boolean . valueOf ( value . toBoolean ( ) ) : defaultValue ; }
private Integer getAttribute ( final InputElement input , final String name , final Integer defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Integer . valueOf ( value . toInt ( ) ) : defaultValue ; }
private Long getAttribute ( final InputElement input , final String name , final Long defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Long . valueOf ( value . toLong ( ) ) : defaultValue ; }
private Short getAttribute ( final InputElement input , final String name , final Short defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Short . valueOf ( TypeFormat . parseShort ( value ) ) : defaultValue ; }
private Float getAttribute ( final InputElement input , final String name , final Float defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Float . valueOf ( value . toFloat ( ) ) : defaultValue ; }
private Double getAttribute ( final InputElement input , final String name , final Double defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Double . valueOf ( value . toDouble ( ) ) : defaultValue ; }
private Byte getAttribute ( final InputElement input , final String name , final Byte defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Byte . valueOf ( TypeFormat . parseByte ( value ) ) : defaultValue ; }
static boolean isNumberFormat ( final Class < ? > clazz ) { return Number . class . isAssignableFrom ( clazz ) ; }
public T newInstance ( final Class < T > clazz , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return newInstanceFromAttribute ( xml , " value " ) ; }
public void write ( final T obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " value " , obj . longValue ( ) ) ; }
public Object getAttribute ( final String name , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return xml . getAttribute ( name , 0 ) ; }
public Object getAttribute ( final String name , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return xml . getAttribute ( name , 0L ) ; }
public boolean canConvert ( final Class < ? > cls ) { return AbstractPersistentCollection . class . isAssignableFrom ( cls ) ; }
public void read ( final XMLFormat . InputElement input , final AbstractPersistentCollection obj ) throws XMLStreamException { getFormat ( obj . getClass ( ) ) . read ( input , obj ) ; }
public void write ( final AbstractPersistentCollection obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { getFormat ( obj . getClass ( ) ) . write ( obj , output ) ; }
public boolean canConvert ( final Class < ? > cls ) { return canSerialize ( cls ) | | canDeserialize ( cls ) ; }
private boolean canDeserialize ( final Class < ? > cls ) { return cls = = CGLibProxyMarker . class ; }
public boolean isReferenceable ( ) { return false ; }
public Object newInstance ( final Class < Object > cls , final InputElement xml ) throws XMLStreamException { final Class < ? > superclass ; try { superclass = Class . forName ( xml . getAttribute ( SUPERCLASS ) . toString ( ) ) ; } catch ( final ClassNotFoundException e ) { throw new XMLStreamException ( e ) ; } final ClassLoader classLoader = getClass ( ) . getClassLoader ( ) ; final Class < ? > [ ] interfaces = getInterfaces ( xml , INTERFACES , classLoader ) ; final Callback [ ] callbacks = xml . get ( CALLBACKS ) ; return createProxy ( superclass , interfaces , callbacks ) ; }
private Object createProxy ( final Class < ? > targetClass , final Class < ? > [ ] interfaces , final Callback [ ] callbacks ) { final Enhancer e = new Enhancer ( ) ; e . setInterfaces ( interfaces ) ; e . setSuperclass ( targetClass ) ; e . setCallbacks ( callbacks ) ; return e . create ( ) ; }
public void write ( final Object obj , final OutputElement xml ) throws XMLStreamException { final Class < ? > superclass = obj . getClass ( ) . getSuperclass ( ) ; xml . setAttribute ( SUPERCLASS , superclass . getName ( ) ) ; final String [ ] interfaceNames = getInterfaceNames ( obj ) ; xml . add ( interfaceNames , INTERFACES ) ; final Callback [ ] callbacks = ( ( Factory ) obj ) . getCallbacks ( ) ; xml . add ( callbacks , CALLBACKS ) ; }
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { return doSerialize ( attributes , " attributes " ) ; }
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] in ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Reading serialized data : \ n " + new String ( in ) ) ; } return doDeserialize ( in , " attributes " ) ; }
