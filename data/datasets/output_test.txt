static AuthType valueOfValue ( final String value ) { for ( final AuthType authType : values ( ) ) { if ( value = = null & & authType . _value = = null | | value ! = null & & value . equals ( authType . _value ) ) { return authType ; } } throw new IllegalArgumentException ( " No AuthType found for value " + value ) ; }
public boolean isIgnoredRequest ( ) { final Request request = _currentRequest . get ( ) ; return request ! = null & & request . getNote ( REQUEST_IGNORED ) = = Boolean . TRUE ; }
protected static boolean isPostMethod ( final Request request ) { final String method = request . getMethod ( ) ; if ( method = = null & & _log . isDebugEnabled ( ) ) { _log . debug ( " No method set for request " + request . getRequestURI ( ) + ( request . getQueryString ( ) ! = null ? " ? " + request . getQueryString ( ) : " " ) ) ; } return method ! = null ? method . toLowerCase ( ) . equals ( " post " ) : false ; }
void resetRequestThreadLocal ( ) { _currentRequest . reset ( ) ; }
void storeRequestThreadLocal ( @ Nonnull final Request request ) { _currentRequest . set ( request ) ; }
public int compare ( final Entry < K , ManagedItem < V > > o1 , final Entry < K , ManagedItem < V > > o2 ) { return comparator . compare ( o1 . getValue ( ) . _value , o2 . getValue ( ) . _value ) ; }
public int size ( ) { return a . length ; }
public < T > T [ ] toArray ( final T [ ] a ) { throw new UnsupportedOperationException ( " Not implemented . " ) ; }
public E get ( final int index ) { return a [ index ] . getKey ( ) ; }
public E set ( final int index , final E element ) { throw new UnsupportedOperationException ( " Not implemented . " ) ; }
public boolean contains ( final Object o ) { return indexOf ( o ) ! = - 1 ; }
public void registerReadonlyRequest ( final String requestId ) { _readOnlyRequestCache . readOnlyRequest ( requestId ) ; }
protected void onBackupWithoutLoadedSession ( @ Nonnull final String sessionId , @ Nonnull final String requestId , @ Nonnull final BackupSessionService backupSessionService ) { if ( ! _sessionIdFormat . isValid ( sessionId ) ) { return ; } super . onBackupWithoutLoadedSession ( sessionId , requestId , backupSessionService ) ; _readOnlyRequestCache . readOnlyRequest ( requestId ) ; }
public String changeJvmRoute ( @ Nonnull final String sessionId , @ Nonnull final String newJvmRoute ) { return stripJvmRoute ( sessionId ) + " . " + newJvmRoute ; }
public boolean isValid ( @ Nullable final String sessionId ) { return sessionId ! = null & & _pattern . matcher ( sessionId ) . matches ( ) ; }
public String createLockName ( @ Nonnull final String sessionId ) { if ( sessionId = = null ) { throw new IllegalArgumentException ( " The sessionId must not be null . " ) ; } return " lock : " + _storageKeyFormat . format ( sessionId ) ; }
public String createValidityInfoKeyName ( @ Nonnull final String origKey ) { if ( origKey = = null ) { throw new IllegalArgumentException ( " The sessionId must not be null . " ) ; } return " validity : " + _storageKeyFormat . format ( origKey ) ; }
public String createBackupKey ( @ Nonnull final String origKey ) { if ( origKey = = null ) { throw new IllegalArgumentException ( " The origKey must not be null . " ) ; } return BACKUP_PREFIX + _storageKeyFormat . format ( origKey ) ; }
public boolean isBackupKey ( @ Nonnull final String key ) { return key . startsWith ( BACKUP_PREFIX ) ; }
protected LockStatus onBeforeLoadFromMemcached ( @ Nonnull final String sessionId ) throws InterruptedException , ExecutionException { return lock ( sessionId ) ; }
public static Builder node ( final String id , final InetSocketAddress address ) { return new Builder ( ) . node ( id , address ) ; }
public Builder node ( final String id , final InetSocketAddress address ) { final String previous = _address2Ids . put ( address , id ) ; if ( previous ! = null ) { throw new IllegalArgumentException ( " There ' s already an address bound to id " + previous ) ; } return this ; }
public NodeIdResolver build ( ) { return new MapBasedResolver ( _address2Ids ) ; }
public boolean readOnlyRequest ( final String requestId ) { if ( ! _blacklist . containsKey ( requestId ) ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Registering readonly request : " + requestId ) ; } incrementOrPut ( _readOnlyRequests , requestId ) ; return true ; } return false ; }
public void modifyingRequest ( final String requestId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Registering modifying request : " + requestId ) ; } incrementOrPut ( _blacklist , requestId ) ; _readOnlyRequests . remove ( requestId ) ; }
public boolean isReadOnlyRequest ( final String requestId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Asked for readonly request : " + requestId + " ( " + _readOnlyRequests . containsKey ( requestId ) + " ) " ) ; } return _readOnlyRequests . containsKey ( requestId ) ; }
public static Statistics create ( ) { return create ( true ) ; }
public static Statistics create ( final boolean enabled ) { return enabled ? new Statistics ( ) : DISABLED_STATS ; }
public void registerSince ( @ Nonnull final StatsType statsType , final long startInMillis ) { register ( statsType , System . currentTimeMillis ( ) - startInMillis ) ; }
public void register ( @ Nonnull final StatsType statsType , final long value ) { _probes . get ( statsType ) . register ( value ) ; }
public void requestWithoutSession ( ) { _numRequestsWithoutSession . incrementAndGet ( ) ; }
public void requestWithSession ( ) { _numRequestsWithSession . incrementAndGet ( ) ; }
public void requestWithTomcatFailover ( ) { _numRequestsWithTomcatFailover . incrementAndGet ( ) ; }
public void requestWithMemcachedFailover ( ) { _numRequestsWithMemcachedFailover . incrementAndGet ( ) ; }
public void requestWithBackupFailure ( ) { _numRequestsWithBackupFailure . incrementAndGet ( ) ; }
public void requestWithoutSessionAccess ( ) { _numRequestsWithoutSessionAccess . incrementAndGet ( ) ; }
public void requestWithoutAttributesAccess ( ) { _numRequestsWithoutAttributesAccess . incrementAndGet ( ) ; }
public void requestWithoutSessionModification ( ) { _numRequestsWithoutSessionModification . incrementAndGet ( ) ; }
public void nonStickySessionsPingFailed ( ) { _numNonStickySessionsPingFailed . incrementAndGet ( ) ; }
public void nonStickySessionsReadOnlyRequest ( ) { _numNonStickySessionsReadOnlyRequest . incrementAndGet ( ) ; }
public void registerSince ( final long startInMillis ) { register ( System . currentTimeMillis ( ) - startInMillis ) ; }
public void shutdown ( ) { _executor . shutdown ( ) ; }
protected LockStatus lock ( final String sessionId ) { return lock ( sessionId , _manager . getOperationTimeout ( ) , TimeUnit . MILLISECONDS ) ; }
protected SessionValidityInfo loadSessionValidityInfo ( @ Nonnull final String sessionId ) { return loadSessionValidityInfoForValidityKey ( _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ) ; }
protected SessionValidityInfo loadSessionValidityInfoForValidityKey ( @ Nonnull final String validityInfoKey ) { final byte [ ] validityInfo = _storage . get ( validityInfoKey ) ; return validityInfo ! = null ? decode ( validityInfo ) : null ; }
protected SessionValidityInfo loadBackupSessionValidityInfo ( @ Nonnull final String sessionId ) { final String key = _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ; final String backupKey = _sessionIdFormat . createBackupKey ( key ) ; return loadSessionValidityInfoForValidityKey ( backupKey ) ; }
protected void onAfterDeleteFromMemcached ( @ Nonnull final String sessionId ) { final long start = System . currentTimeMillis ( ) ; final String validityInfoKey = _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ; _storage . delete ( validityInfoKey ) ; if ( _storeSecondaryBackup ) { try { _storage . delete ( _sessionIdFormat . createBackupKey ( sessionId ) ) ; _storage . delete ( _sessionIdFormat . createBackupKey ( validityInfoKey ) ) ; } catch ( Exception e ) { _log . info ( " Could not delete backup data for session " + sessionId + " ( not critical , data will be evicted by memcached automatically ) . " , e ) ; } } _stats . registerSince ( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED , start ) ; }
public static StorageKeyFormat ofHost ( final String host ) { return of ( HOST , host , null , null ) ; }
public String format ( final String input ) { if ( prefix = = null ) { return input ; } return prefix + input ; }
static String parse ( final String configToken , final String host , final String context , final String webappVersion ) { final Matcher staticMatcher = STATIC_PATTERN . matcher ( configToken ) ; if ( staticMatcher . matches ( ) ) return staticMatcher . group ( 1 ) ; if ( HOST . equals ( configToken ) ) return host ; if ( HOST_HASH . equals ( configToken ) ) return hashString ( host ) ; if ( CONTEXT . equals ( configToken ) ) return context ; if ( CONTEXT_HASH . equals ( configToken ) ) return hashString ( context ) ; if ( WEBAPP_VERSION . equals ( configToken ) ) return webappVersion ; throw new IllegalArgumentException ( " Unsupported config token " + configToken ) ; }
static String hashString ( final String s ) { return hashString ( s , 8 ) ; }
public String toString ( ) { return " StorageKeyFormat [ prefix = " + prefix + " , config = " + config + " ] " ; }
protected StorageClient createStorageClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { return null ; }
public byte [ ] get ( final String key ) { return null ; }
public Future < BackupResult > backupSession ( final String sessionId , final boolean sessionIdChanged , final String requestId ) { final MemcachedBackupSession session = _manager . getSessionInternal ( sessionId ) ; if ( session = = null ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( " No session found in session map for " + sessionId ) ; return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } _log . info ( " Serializing session data for session " + session . getIdInternal ( ) ) ; final long startSerialization = System . currentTimeMillis ( ) ; final byte [ ] data = _transcoderService . serializeAttributes ( ( MemcachedBackupSession ) session , ( ( MemcachedBackupSession ) session ) . getAttributesFiltered ( ) ) ; _log . info ( String . format ( " Serializing % 1 $ , . 3f kb session data for session % 2 $ s took % 3 $ d ms . " , ( double ) data . length / 1000 , session . getIdInternal ( ) , System . currentTimeMillis ( ) - startSerialization ) ) ; _sessionData . put ( session . getIdInternal ( ) , data ) ; _statistics . registerSince ( ATTRIBUTES_SERIALIZATION , startSerialization ) ; _statistics . register ( CACHED_DATA_SIZE , data . length ) ; return new SimpleFuture < BackupResult > ( new BackupResult ( BackupResultStatus . SUCCESS ) ) ; }
public MemcachedBackupSession findSession ( final String id ) throws IOException { final MemcachedBackupSession result = super . findSession ( id ) ; if ( result ! = null ) { final byte [ ] data = _sessionData . remove ( id ) ; if ( data ! = null ) { _executorService . submit ( new SessionDeserialization ( id , data ) ) ; } } return result ; }
protected MemcachedBackupSession loadFromMemcachedWithCheck ( final String sessionId ) { return null ; }
public Void call ( ) throws Exception { _log . info ( String . format ( " Deserializing % 1 $ , . 3f kb session data for session % 2 $ s ( asynchronously ) . " , ( double ) _data . length / 1000 , _id ) ) ; final long startDeserialization = System . currentTimeMillis ( ) ; try { _transcoderService . deserializeAttributes ( _data ) ; } catch ( final Exception e ) { _log . warn ( " Could not deserialize session data . " , e ) ; } _log . info ( String . format ( " Deserializing % 1 $ , . 3f kb session data for session % 2 $ s took % 3 $ d ms . " , ( double ) _data . length / 1000 , _id , System . currentTimeMillis ( ) - startDeserialization ) ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , startDeserialization ) ; return null ; }
public void updateLocator ( final List < MemcachedNode > nodes ) { throw new UnsupportedOperationException ( " Not yet supported . " ) ; }
public String toString ( ) { return root . toString ( ) ; }
public void addOp ( final Operation op ) { throw new UnsupportedOperationException ( ) ; }
public void insertOp ( final Operation op ) { throw new UnsupportedOperationException ( ) ; }
public void connected ( ) { throw new UnsupportedOperationException ( ) ; }
public void copyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; }
public void fillWriteBuffer ( final boolean optimizeGets ) { throw new UnsupportedOperationException ( ) ; }
public void fixupOps ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean hasReadOp ( ) { return root . hasReadOp ( ) ; }
public boolean hasWriteOp ( ) { return root . hasReadOp ( ) ; }
public boolean isActive ( ) { return root . isActive ( ) ; }
public void reconnecting ( ) { throw new UnsupportedOperationException ( ) ; }
public void registerChannel ( final SocketChannel ch , final SelectionKey selectionKey ) { throw new UnsupportedOperationException ( ) ; }
public Operation removeCurrentReadOp ( ) { throw new UnsupportedOperationException ( ) ; }
public Operation removeCurrentWriteOp ( ) { throw new UnsupportedOperationException ( ) ; }
public void setupResend ( ) { throw new UnsupportedOperationException ( ) ; }
public void transitionWriteItem ( ) { throw new UnsupportedOperationException ( ) ; }
public int writeSome ( ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public Collection < Operation > destroyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; }
public void authComplete ( ) { throw new UnsupportedOperationException ( ) ; }
public void setupForAuth ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean isAuthenticated ( ) { throw new UnsupportedOperationException ( ) ; }
public long lastReadDelta ( ) { throw new UnsupportedOperationException ( ) ; }
public void completedRead ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean isValid ( final String sessionId ) { return sessionId ! = null ; }
public String createBackupKey ( final String origKey ) { throw new UnsupportedOperationException ( " Not supported for single node configuration without node id . " ) ; }
public String createSessionId ( final String sessionId , final String memcachedId ) { return sessionId ; }
public String extractMemcachedId ( final String sessionId ) { throw new UnsupportedOperationException ( " Not supported for single node configuration without node id . " ) ; }
private boolean isCouchbaseConfig ( final String memcachedNodes ) { return memcachedNodes . startsWith ( " http : / / " ) ; }
private static List < String > initFailoverNodes ( final String failoverNodes , final Collection < String > allNodeIds ) { final List < String > failoverNodeIds = new ArrayList < String > ( ) ; if ( failoverNodes ! = null & & failoverNodes . trim ( ) . length ( ) ! = 0 ) { final String [ ] failoverNodesArray = failoverNodes . split ( " | , " ) ; for ( final String failoverNodeId : failoverNodesArray ) { final String failoverNodeIdTrimmed = failoverNodeId . trim ( ) ; if ( ! allNodeIds . contains ( failoverNodeIdTrimmed ) ) { throw new IllegalArgumentException ( " Invalid failover node id " + failoverNodeIdTrimmed + " : " + " not existing in memcachedNodes ' " + allNodeIds + " ' . " ) ; } failoverNodeIds . add ( failoverNodeIdTrimmed ) ; } } return failoverNodeIds ; }
public boolean isEncodeNodeIdInSessionId ( ) { return _encodeNodeIdInSessionId ; }
public String getNodeId ( final InetSocketAddress socketAddress ) throws IllegalArgumentException { if ( socketAddress = = null ) { throw new IllegalArgumentException ( " SocketAddress must not be null . " ) ; } final String result = _address2Ids . get ( socketAddress ) ; if ( result = = null ) { throw new IllegalArgumentException ( " SocketAddress " + socketAddress + " not known ( registered addresses : " + _address2Ids . keySet ( ) + " ) . " ) ; } return result ; }
public String createSessionId ( @ Nonnull final String sessionId ) { return isEncodeNodeIdInSessionId ( ) ? _sessionIdFormat . createSessionId ( sessionId , _nodeIdService . getMemcachedNodeId ( ) ) : sessionId ; }
public boolean isNodeAvailable ( final String nodeId ) { return _nodeIdService . isNodeAvailable ( nodeId ) ; }
public boolean isValidForMemcached ( final String sessionId ) { if ( isEncodeNodeIdInSessionId ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( nodeId = = null ) { LOG . debug ( " The sessionId does not contain a nodeId so that the memcached node could not be identified . " ) ; return false ; } } return true ; }
public boolean canHitMemcached ( final String sessionId ) { if ( isEncodeNodeIdInSessionId ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( nodeId = = null ) { LOG . debug ( " The sessionId does not contain a nodeId so that the memcached node could not be identified . " ) ; return false ; } if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { LOG . debug ( " The node " + nodeId + " is not available , therefore " + sessionId + " cannot be loaded from this memcached . " ) ; return false ; } } return true ; }
public void onLoadFromMemcachedSuccess ( final String sessionId ) { setNodeAvailableForSessionId ( sessionId , true ) ; }
public void onLoadFromMemcachedFailure ( final String sessionId ) { setNodeAvailableForSessionId ( sessionId , false ) ; }
public String changeSessionIdForTomcatFailover ( @ Nonnull final String sessionId , final String jvmRoute ) { final String newSessionId = jvmRoute ! = null & & ! jvmRoute . trim ( ) . isEmpty ( ) ? _sessionIdFormat . changeJvmRoute ( sessionId , jvmRoute ) : _sessionIdFormat . stripJvmRoute ( sessionId ) ; if ( isEncodeNodeIdInSessionId ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( newSessionId ) ; if ( _failoverNodeIds ! = null & & _failoverNodeIds . contains ( nodeId ) ) { final String newNodeId = _nodeIdService . getAvailableNodeId ( nodeId ) ; if ( newNodeId ! = null ) { return _sessionIdFormat . createNewSessionId ( newSessionId , newNodeId ) ; } } } return newSessionId ; }
public boolean isCouchbaseBucketConfig ( ) { return COUCHBASE_BUCKET_NODES_PATTERN . matcher ( _memcachedNodes ) . matches ( ) ; }
public boolean isRedisConfig ( ) { return _memcachedNodes . startsWith ( " redis : / / " ) | | _memcachedNodes . startsWith ( " rediss : / / " ) ; }
private byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { final long start = System . currentTimeMillis ( ) ; final byte [ ] attributesData = _transcoderService . serializeAttributes ( session , attributes ) ; _statistics . registerSince ( ATTRIBUTES_SERIALIZATION , start ) ; return attributesData ; }
private void handleException ( final MemcachedBackupSession session , final Exception e ) { String msg = " Could not store session " + session . getId ( ) + " in memcached . " ; if ( _force ) { msg + = " \ nNote that this session was relocated to this node because the " + " original node was not available . " ; } _log . warn ( msg , e ) ; _memcachedNodesManager . setNodeAvailableForSessionId ( session . getId ( ) , false ) ; }
public boolean isSuccess ( ) { return _status = = BackupResultStatus . SUCCESS ; }
public static ConnectionType valueOf ( final boolean couchbaseBucketConfig , final String username , final String password ) { return new ConnectionType ( couchbaseBucketConfig , username , password ) ; }
boolean isCouchbaseBucketConfig ( ) { return couchbaseBucketConfig ; }
boolean isSASL ( ) { return ! couchbaseBucketConfig & & ! isBlank ( username ) & & ! isBlank ( password ) ; }
boolean isDefault ( ) { return ! isCouchbaseBucketConfig ( ) & & ! isSASL ( ) ; }
boolean isBlank ( final String value ) { return value = = null | | value . trim ( ) . length ( ) = = 0 ; }
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return new JavaSerializationTranscoder ( manager ) ; }
public void shutdown ( ) { _executorService . shutdown ( ) ; }
public boolean awaitTermination ( final long timeout , final TimeUnit unit ) throws InterruptedException { return true ; }
public < T > List < Future < T > > invokeAll ( final Collection < ? extends Callable < T > > tasks ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; }
public < T > List < Future < T > > invokeAll ( final Collection < ? extends Callable < T > > tasks , final long timeout , final TimeUnit unit ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; }
public < T > T invokeAny ( final Collection < ? extends Callable < T > > tasks ) throws InterruptedException , ExecutionException { throw new UnsupportedOperationException ( ) ; }
public < T > T invokeAny ( final Collection < ? extends Callable < T > > tasks , final long timeout , final TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { throw new UnsupportedOperationException ( ) ; }
public boolean isShutdown ( ) { return _shutdown ; }
public boolean isTerminated ( ) { return _shutdown ; }
public void shutdown ( ) { _shutdown = true ; }
public List < Runnable > shutdownNow ( ) { shutdown ( ) ; return null ; }
public void execute ( final Runnable command ) { command . run ( ) ; }
public boolean cancel ( final boolean mayInterruptIfRunning ) { return true ; }
public T get ( ) throws InterruptedException , ExecutionException { if ( _e ! = null ) { throw _e ; } return _result ; }
public T get ( final long timeout , final TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( _e ! = null ) { throw _e ; } return _result ; }
public boolean isCancelled ( ) { return false ; }
public boolean isDone ( ) { return true ; }
private boolean updateIsNodeAvailable ( final K key ) { final Boolean result = Boolean . valueOf ( _cacheLoader . isNodeAvailable ( key ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " CacheLoader returned node availability ' " + result + " ' for node ' " + key + " ' . " ) ; } _map . put ( key , new ManagedItem < Boolean > ( result , System . currentTimeMillis ( ) ) ) ; return result ; }
public boolean asyncDecode ( final CachedData cachedData ) { return _delegate . asyncDecode ( cachedData ) ; }
public Object decode ( final CachedData cachedData ) { return _delegate . decode ( cachedData ) ; }
public CachedData encode ( final Object object ) { final CachedData result = _delegate . encode ( object ) ; _statistics . register ( StatsType . CACHED_DATA_SIZE , result . getData ( ) . length ) ; return result ; }
protected LockStatus onBeforeLoadFromMemcached ( @ Nonnull final String sessionId ) throws InterruptedException , ExecutionException { return LockStatus . LOCK_NOT_REQUIRED ; }
public ConcurrentMap < String , Object > get ( MemcachedBackupSession session ) { return session . attributes ; }
public void set ( MemcachedBackupSession session , ConcurrentMap < String , Object > attributes ) { session . attributes = attributes ; }
public void removeAttribute ( final String name ) { if ( filterAttribute ( name ) ) { _attributesAccessed = true ; } super . removeAttribute ( name ) ; }
public void recycle ( ) { super . recycle ( ) ; _attributesAccessed = false ; _dataHashCode = 0 ; _expirationUpdateRunning = false ; _backupRunning = false ; _lockStatus = null ; }
private boolean filterAttribute ( final String name ) { if ( this . manager = = null ) { throw new IllegalStateException ( " There ' s no manager set . " ) ; } final Pattern pattern = ( ( SessionManager ) manager ) . getMemcachedSessionService ( ) . getSessionAttributePattern ( ) ; if ( pattern = = null ) { return true ; } return pattern . matcher ( name ) . matches ( ) ; }
void storeThisAccessedTimeFromLastBackupCheck ( ) { _thisAccessedTimeFromLastBackupCheck = this . thisAccessedTime ; }
boolean wasAccessedSinceLastBackupCheck ( ) { return _thisAccessedTimeFromLastBackupCheck ! = this . thisAccessedTime ; }
boolean attributesAccessedSinceLastBackup ( ) { return _attributesAccessed ; }
boolean isExpirationUpdateRunning ( ) { return _expirationUpdateRunning ; }
boolean isBackupRunning ( ) { return _backupRunning ; }
boolean isNewInternal ( ) { return this . isNew ; }
public boolean isValidInternal ( ) { return this . isValid ; }
boolean isExpiring ( ) { return this . expiring ; }
public void removeAttributeInternal ( final String name , final boolean notify ) { super . removeAttributeInternal ( name , notify ) ; }
boolean authenticationChanged ( ) { return _authenticationChanged | | getNote ( Constants . FORM_PRINCIPAL_NOTE ) ! = null ; }
private static boolean equals ( final Object one , final Object another ) { return one = = null & & another = = null | | one ! = null & & one . equals ( another ) ; }
public void backupFinished ( ) { _authenticationChanged = false ; _attributesAccessed = false ; _sessionIdChanged = false ; }
public boolean isSessionIdChanged ( ) { return _sessionIdChanged ; }
public void backupFailed ( ) { _lastBackupTime = _previousLastBackupTime ; }
public synchronized boolean isLocked ( ) { return _lockStatus = = LockStatus . LOCKED ; }
public void releaseLock ( ) { _lockStatus = null ; }
public synchronized boolean registerReference ( ) { return _refCount . add ( Thread . currentThread ( ) . getId ( ) ) ; }
public synchronized int releaseReference ( ) { _refCount . remove ( Thread . currentThread ( ) . getId ( ) ) ; return _refCount . size ( ) ; }
public static byte [ ] encode ( final long maxInactiveInterval , final long lastAccessedTime , final long thisAccessedTime ) { int idx = 0 ; final byte [ ] data = new byte [ 4 + 2 * 8 ] ; encodeNum ( maxInactiveInterval , data , idx , 4 ) ; encodeNum ( lastAccessedTime , data , idx + = 4 , 8 ) ; encodeNum ( thisAccessedTime , data , idx + = 8 , 8 ) ; return data ; }
public static SessionValidityInfo decode ( @ Nonnull final byte [ ] data ) { int idx = 0 ; final int maxInactiveInterval = ( int ) decodeNum ( data , idx , 4 ) ; final long lastAccessedTime = decodeNum ( data , idx + = 4 , 8 ) ; final long thisAccessedTime = decodeNum ( data , idx + = 8 , 8 ) ; return new SessionValidityInfo ( maxInactiveInterval , lastAccessedTime , thisAccessedTime ) ; }
@ Override protected byte [ ] execute ( BinaryJedis jedis ) throws Exception { return jedis . get ( keyBytes ( key ) ) ; }
@ Override protected Boolean execute ( BinaryJedis jedis ) throws Exception { return jedis . del ( keyBytes ( key ) ) = = 1 ; }
public void shutdown ( ) { _pool . shutdown ( ) ; }
private BinaryJedis createJedisInstance ( ) { BinaryJedis binaryJedis = new BinaryJedis ( _uri ) ; binaryJedis . getClient ( ) . setConnectionTimeout ( _timeout ) ; binaryJedis . getClient ( ) . setSoTimeout ( _timeout ) ; return binaryJedis ; }
public Future < Boolean > add ( String key , int exp , byte [ ] o ) { return _memcached . add ( key , exp , o , ByteArrayTranscoder . INSTANCE ) ; }
public Future < Boolean > set ( String key , int exp , byte [ ] o ) { return _memcached . set ( key , exp , o , ByteArrayTranscoder . INSTANCE ) ; }
public byte [ ] get ( String key ) { return _memcached . get ( key , ByteArrayTranscoder . INSTANCE ) ; }
public Future < Boolean > delete ( String key ) { return _memcached . delete ( key ) ; }
public void shutdown ( ) { _memcached . shutdown ( ) ; }
public boolean asyncDecode ( CachedData d ) { return false ; }
public byte [ ] decode ( CachedData d ) { return d . getData ( ) ; }
public CachedData encode ( byte [ ] o ) { return new CachedData ( 0 , o , getMaxSize ( ) ) ; }
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { super . setup ( ) ; final Context context = _manager . getContext ( ) ; when ( _manager . getContext ( ) ) . thenReturn ( context ) ; }
public Tomcat9Builder tomcatBuilder ( ) { return new Tomcat9Builder ( ) ; }
public Tomcat9Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; }
protected GenericPrincipal createPrincipal ( ) { return new GenericPrincipal ( " foo " , " bar " , null ) ; }
protected void setupGetResponseSetCookieHeadersExpectations ( final Response response , final String [ ] result ) { when ( response . getHeaders ( eq ( " Set - Cookie " ) ) ) . thenReturn ( Arrays . asList ( result ) ) ; }
public Tomcat7Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; }
public Tomcat7Builder tomcatBuilder ( ) { return new Tomcat7Builder ( ) ; }
public void remove ( final Session session , final boolean update ) { removeInternal ( session , update , session . getNote ( MemcachedSessionService . NODE_FAILURE ) ! = Boolean . TRUE ) ; }
public void removeInternal ( final Session session , final boolean update ) { super . remove ( session , update ) ; }
private void swapOut ( @ Nonnull final StandardSession session ) { if ( ! session . isValid ( ) ) { return ; } session . passivate ( ) ; removeInternal ( session , true ) ; session . recycle ( ) ; }
public Principal readPrincipal ( final ObjectInputStream ois ) throws ClassNotFoundException , IOException { return SerializablePrincipal . readPrincipal ( ois ) ; }
protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { HttpSession session = req . getSession ( ) ; Integer counter = ( Integer ) session . getAttribute ( COUNTER ) ; int iTmp = 0 ; if ( counter ! = null ) { iTmp = counter + 1 ; } String sTmp = Integer . toString ( iTmp ) ; resp . getOutputStream ( ) . println ( sTmp ) ; session . setAttribute ( COUNTER , iTmp ) ; resp . flushBuffer ( ) ; }
public Object put ( final String key , final Object value ) { return _map . put ( key , value ) ; }
public Object get ( final String key ) { return _map . get ( key ) ; }
public Set < Entry < String , Object > > entrySet ( ) { return _map . entrySet ( ) ; }
private static void benchmark ( final MemcachedBackupSessionManager manager , final int rounds , final int countPersons , final int nodesPerEdge ) throws InterruptedException { final Stats kryoSerStats = new Stats ( ) ; final Stats kryoDeSerStats = new Stats ( ) ; benchmark ( manager , new KryoTranscoder ( ) , kryoSerStats , kryoDeSerStats , rounds , countPersons , nodesPerEdge ) ; final Stats javaSerStats = new Stats ( ) ; final Stats javaDeSerStats = new Stats ( ) ; benchmark ( manager , new JavaSerializationTranscoder ( ) , javaSerStats , javaDeSerStats , rounds , countPersons , nodesPerEdge ) ; recover ( ) ; final Stats javolutionSerStats = new Stats ( ) ; final Stats javolutionDeSerStats = new Stats ( ) ; benchmark ( manager , new JavolutionTranscoder ( Thread . currentThread ( ) . getContextClassLoader ( ) , false ) , javolutionSerStats , javolutionDeSerStats , rounds , countPersons , nodesPerEdge ) ; recover ( ) ; System . out . println ( " Serialization , Size , Ser - Min , Ser - Avg , Ser - Max , Deser - Min , Deser - Avg , Deser - Max " ) ; System . out . println ( toCSV ( " Java " , javaSerStats , javaDeSerStats ) ) ; System . out . println ( toCSV ( " Javolution " , javolutionSerStats , javolutionDeSerStats ) ) ; System . out . println ( toCSV ( " Kryo " , kryoSerStats , kryoDeSerStats ) ) ; }
private static String toCSV ( final String name , final Stats serStats , final Stats deSerStats ) { return name + " , " + serStats . size + " , " + minAvgMax ( serStats ) + " , " + minAvgMax ( deSerStats ) ; }
private static String minAvgMax ( final Stats stats ) { return stats . min + " , " + stats . avg + " , " + stats . max ; }
private static void recover ( ) throws InterruptedException { Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; }
private static MemcachedBackupSession createSession ( final MemcachedBackupSessionManager manager , final String id , final int countPersons , final int countNodesPerEdge ) { final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setId ( id ) ; session . setValid ( true ) ; session . setAttribute ( " stringbuffer " , new StringBuffer ( " < string \ n & buffer / > " ) ) ; session . setAttribute ( " stringbuilder " , new StringBuilder ( " < string \ n & buffer / > " ) ) ; session . setAttribute ( " persons " , createPersons ( countPersons ) ) ; session . setAttribute ( " mycontainer " , new TestClasses . MyContainer ( ) ) ; session . setAttribute ( " component " , createComponents ( countNodesPerEdge ) ) ; return session ; }
static Person createPerson ( final String name , final Gender gender , final String . . . emailAddresses ) { return createPerson ( name , gender , ( Integer ) null , emailAddresses ) ; }
static Person createPerson ( final String name , final Gender gender , final Calendar dateOfBirth , final String . . . emailAddresses ) { final int age = dateOfBirth = = null ? - 1 : Calendar . getInstance ( ) . get ( Calendar . YEAR ) - dateOfBirth . get ( Calendar . YEAR ) ; final Person result = createPerson ( name , gender , age , emailAddresses ) ; result . setDateOfBirth ( dateOfBirth ) ; return result ; }
static ClassWithoutDefaultConstructor createClassWithoutDefaultConstructor ( final String string ) { return new ClassWithoutDefaultConstructor ( string ) ; }
static PrivateClass createPrivateClass ( final String string ) { final PrivateClass result = new PrivateClass ( ) ; result . foo = string ; return result ; }
public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { if ( _target = = null ) { _target = _targetClazz . newInstance ( ) ; } return method . invoke ( _target , args ) ; }
public String hello ( ) { return " hi " ; }
public MyXMLSerializable newInstance ( final Class < MyXMLSerializable > cls , final InputElement xml ) throws XMLStreamException { return new MyXMLSerializable ( Runtime . getRuntime ( ) ) ; }
public void addFriend ( final Person p ) { _friends . add ( p ) ; }
public void addAddress ( final Address a ) { _addresses . add ( a ) ; }
private boolean flatEquals ( final Collection < ? > c1 , final Collection < ? > c2 ) { return c1 = = c2 | | c1 ! = null & & c2 ! = null & & c1 . size ( ) = = c2 . size ( ) ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( _age = = null ) ? 0 : _age . hashCode ( ) ) ; result = prime * result + ( ( _friends = = null ) ? 0 : _friends . size ( ) ) ; result = prime * result + ( ( _gender = = null ) ? 0 : _gender . hashCode ( ) ) ; result = prime * result + ( ( _name = = null ) ? 0 : _name . hashCode ( ) ) ; result = prime * result + ( ( _props = = null ) ? 0 : _props . hashCode ( ) ) ; return result ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( privateClass = = null ) ? 0 : privateClass . hashCode ( ) ) ; return result ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( foo = = null ) ? 0 : foo . hashCode ( ) ) ; return result ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; return result ; }
public String toString ( ) { return " ClassWithoutDefaultConstructor [ value = " + value + " ] " ; }
public Component addChild ( final Component child ) { child . setParent ( this ) ; _children . add ( child ) ; return this ; }
public Component addChildren ( final Collection < Component > children ) { for ( final Component child : children ) { child . setParent ( this ) ; _children . add ( child ) ; } return this ; }
public String toString ( ) { return " Component [ _children = " + _children + " , _name = " + _name + " , _parent = " + _parent + " ] " ; }
protected Class < ? > findClass ( final String name ) throws ClassNotFoundException { if ( _className . equals ( name ) ) { return defineClass ( name , _classBytes , 0 , _classBytes . length ) ; } return super . findClass ( name ) ; }
public static ClassLoader makeClassLoaderForCustomClass ( final ClassLoader parent , final String className , final String . . . fields ) { return new ByteClassLoader ( parent , className , makeClass ( className , fields ) ) ; }
public void testDeserializationError ( ) { final ClassLoader loaderForCustomClassInVersion1 = ClassGenerationUtil . makeClassLoaderForCustomClass ( this . getClass ( ) . getClassLoader ( ) , TEST_TYPE_CLASS_NAME , " field1 " ) ; final Object value = makeValueInstance ( loaderForCustomClassInVersion1 ) ; final SessionAttributesTranscoder transcoder = new KryoTranscoderFactory ( ) . createTranscoder ( loaderForCustomClassInVersion1 ) ; final MemcachedBackupSession memcachedBackupSession = new MemcachedBackupSession ( ) ; final ConcurrentMap < String , Object > attributes = new ConcurrentHashMap < String , Object > ( ) ; attributes . put ( " test " , value ) ; byte [ ] data = transcoder . serializeAttributes ( memcachedBackupSession , attributes ) ; final Map < String , Object > deserializeAttributes = transcoder . deserializeAttributes ( data ) ; final Object actual = deserializeAttributes . get ( " test " ) ; assertNotNull ( actual ) ; assertDeepEquals ( actual , value ) ; final ClassLoader loaderForCustomClassInVersion2 = ClassGenerationUtil . makeClassLoaderForCustomClass ( this . getClass ( ) . getClassLoader ( ) , TEST_TYPE_CLASS_NAME , " field1 " , " field2 " ) ; final SessionAttributesTranscoder secondTranscoder = new KryoTranscoderFactory ( ) . createTranscoder ( loaderForCustomClassInVersion2 ) ; secondTranscoder . deserializeAttributes ( data ) ; }
public void testSpringSecurityUserSerializer ( ) { final Kryo kryo = new Kryo ( ) ; kryo . setInstantiatorStrategy ( new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ) ; kryo . setRegistrationRequired ( false ) ; new SpringSecurityUserRegistration ( ) . customize ( kryo ) ; final Collection < ? extends GrantedAuthority > authorities = Arrays . asList ( new SimpleGrantedAuthority ( " foo " ) ) ; final User user = new User ( " foo " , " bar " , authorities ) ; Output out = new Output ( 100 , 1024 ) ; kryo . writeObject ( out , user ) ; final byte [ ] data = out . toBytes ( ) ; final User user2 = kryo . readObject ( new Input ( data ) , User . class ) ; TestUtils . assertDeepEquals ( user , user2 ) ; }
public void test ( ) { HibernateCollectionsSerializerFactory factory = new HibernateCollectionsSerializerFactory ( new Kryo ( ) ) ; Serializer serializer = factory . newSerializer ( PERSISTENT_LIST_CLASS ) ; assertNotNull ( serializer ) ; }
public void testKryoBuilder ( BuildKryo buildKryo ) { DefaultClassResolver classResolver = new DefaultClassResolver ( ) ; MapReferenceResolver referenceResolver = new MapReferenceResolver ( ) ; DefaultStreamFactory streamFactory = new DefaultStreamFactory ( ) ; InstantiatorStrategy instantiatorStrategy = new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ; KryoCustomization enableAsm = new KryoCustomization ( ) { @ Override public void customize ( Kryo kryo ) { kryo . getFieldSerializerConfig ( ) . setUseAsm ( true ) ; } } ; final CollectionSerializer collectionSerializer = new CollectionSerializer ( ) ; KryoCustomization registerMyCollectionSerializer = new KryoCustomization ( ) { @ Override public void customize ( Kryo kryo ) { kryo . addDefaultSerializer ( Collection . class , collectionSerializer ) ; } } ; Kryo kryo = buildKryo . build ( classResolver , referenceResolver , streamFactory , instantiatorStrategy , enableAsm , registerMyCollectionSerializer ) ; assertSame ( kryo . getClassResolver ( ) , classResolver ) ; assertSame ( kryo . getReferenceResolver ( ) , referenceResolver ) ; assertSame ( kryo . getStreamFactory ( ) , streamFactory ) ; assertSame ( kryo . getInstantiatorStrategy ( ) , instantiatorStrategy ) ; assertTrue ( kryo . isRegistrationRequired ( ) ) ; assertFalse ( kryo . getReferences ( ) ) ; assertTrue ( kryo . getFieldSerializerConfig ( ) . isUseAsm ( ) ) ; assertSame ( kryo . getDefaultSerializer ( Collection . class ) , collectionSerializer ) ; assertFalse ( kryo . getFieldSerializerConfig ( ) . isOptimizedGenerics ( ) ) ; }
@ Override public void customize ( Kryo kryo ) { kryo . getFieldSerializerConfig ( ) . setUseAsm ( true ) ; }
@ Override public void customize ( Kryo kryo ) { kryo . addDefaultSerializer ( Collection . class , collectionSerializer ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( " + description + " ) " ; }
protected KryoTranscoder createTranscoder ( final SessionManager manager ) { final String [ ] customConverter = new String [ ] { HibernateCollectionsSerializerFactory . class . getName ( ) } ; final KryoTranscoder result = new KryoTranscoder ( getClass ( ) . getClassLoader ( ) , customConverter , false ) ; return result ; }
public void customize ( final Kryo kryo ) { kryo . register ( Interval . class , new JodaIntervalSerializer ( ) ) ; kryo . register ( DateTime . class , new JodaDateTimeSerializer ( ) ) ; kryo . register ( LocalDateTime . class , new JodaLocalDateTimeSerializer ( ) ) ; kryo . register ( LocalDate . class , new JodaLocalDateSerializer ( ) ) ; }
public Serializer newDefaultSerializer ( Kryo kryo , Class < ? > type ) { return new CompatibleFieldSerializer ( kryo , type ) ; }
public Serializer makeSerializer ( Kryo kryo , Class < ? > type ) { final FieldSerializer result = new FieldSerializer < Component > ( kryo , type ) ; result . setIgnoreSyntheticFields ( false ) ; return result ; }
public Serializer newDefaultSerializer ( final Kryo kryo , final Class < ? > type ) { final FieldSerializer result = new FieldSerializer ( kryo , type ) ; result . setIgnoreSyntheticFields ( false ) ; return result ; }
public Serializer makeSerializer ( Kryo kryo , Class < ? > type ) { return delegate . newDefaultSerializer ( kryo , type ) ; }
public void customize ( final Kryo kryo ) { kryo . register ( User . class , new SpringSecurityUserSerializer ( kryo ) ) ; }
public void write ( Kryo kryo , Output output , User user ) { output . writeString ( user . getPassword ( ) ) ; output . writeString ( user . getUsername ( ) ) ; final Collection < GrantedAuthority > authorities = user . getAuthorities ( ) ; output . writeInt ( authorities . size ( ) , true ) ; for ( final GrantedAuthority item : authorities ) { _kryo . writeClassAndObject ( output , item ) ; } output . writeBoolean ( user . isAccountNonExpired ( ) ) ; output . writeBoolean ( user . isAccountNonLocked ( ) ) ; output . writeBoolean ( user . isCredentialsNonExpired ( ) ) ; output . writeBoolean ( user . isEnabled ( ) ) ; }
public Serializer newSerializer ( final Class < ? > type ) { if ( HIBERNATE_ABSTRACT_COLLECTION_CLASS = = null ) { return null ; } else if ( HIBERNATE_ABSTRACT_COLLECTION_CLASS . isAssignableFrom ( type ) ) { return new FieldSerializer ( _kryo , type ) ; } return null ; }
public Kryo create ( ) { KryoBuilder kryoBuilder = new KryoBuilder ( ) { @ Override protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { return KryoTranscoder . this . createKryo ( classResolver , referenceResolver , streamFactory , classLoader , customConverterClassNames , copyCollectionsForSerialization ) ; } } . withInstantiatorStrategy ( new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ) ; final List < KryoBuilderConfiguration > builderConfigs = load ( KryoBuilderConfiguration . class , customConverterClassNames , classLoader ) ; for ( KryoBuilderConfiguration config : builderConfigs ) { kryoBuilder = config . configure ( kryoBuilder ) ; } Kryo kryo = kryoBuilder . build ( ) ; kryo . setDefaultSerializer ( new KryoDefaultSerializerFactory . SerializerFactoryAdapter ( _defaultSerializerFactory ) ) ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } kryo . setRegistrationRequired ( false ) ; kryo . register ( Arrays . asList ( " " ) . getClass ( ) , new ArraysAsListSerializer ( ) ) ; kryo . register ( InvocationHandler . class , new JdkProxySerializer ( ) ) ; UnmodifiableCollectionsSerializer . registerSerializers ( kryo ) ; SynchronizedCollectionsSerializer . registerSerializers ( kryo ) ; kryo . addDefaultSerializer ( EnumMap . class , EnumMapSerializer . class ) ; SubListSerializers . addDefaultSerializers ( kryo ) ; final List < KryoCustomization > customizations = load ( KryoCustomization . class , customConverterClassNames , classLoader , kryo ) ; if ( customizations ! = null ) { for ( final KryoCustomization customization : customizations ) { try { LOG . info ( " Executing KryoCustomization " + customization . getClass ( ) . getName ( ) ) ; customization . customize ( kryo ) ; } catch ( final Throwable e ) { LOG . error ( " Could not execute customization " + customization , e ) ; } } } return kryo ; }
private Serializer < ? > loadCustomSerializer ( final Class < ? > clazz , List < SerializerFactory > serializerFactories ) { if ( serializerFactories ! = null ) { for ( SerializerFactory serializerFactory : serializerFactories ) { final Serializer < ? > serializer = serializerFactory . newSerializer ( clazz ) ; if ( serializer ! = null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading custom serializer " + serializer . getClass ( ) . getName ( ) + " for class " + clazz ) ; } return serializer ; } } } return null ; }
private Serializer < ? > loadCopyCollectionSerializer ( final Class < ? > clazz ) { if ( Collection . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateCollectionSerializer for class " + clazz ) ; } return new CopyForIterateCollectionSerializer ( ) ; } if ( Map . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateMapSerializer for class " + clazz ) ; } return new CopyForIterateMapSerializer ( ) ; } return null ; }
private < T > List < T > load ( Class < T > type , final String [ ] customConverterClassNames , final ClassLoader classLoader ) { return load ( type , customConverterClassNames , classLoader , null ) ; }
private < T > List < T > load ( Class < T > type , final String [ ] customConverterClassNames , final ClassLoader classLoader , final Kryo kryo ) { if ( customConverterClassNames = = null | | customConverterClassNames . length = = 0 ) { return Collections . emptyList ( ) ; } final List < T > result = new ArrayList < T > ( ) ; final ClassLoader loader = classLoader ! = null ? classLoader : Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( final String element : customConverterClassNames ) { try { final Class < ? > clazz = Class . forName ( element , true , loader ) ; if ( type . isAssignableFrom ( clazz ) ) { LOG . info ( " Loading " + type . getSimpleName ( ) + " " + element ) ; final T item = createInstance ( clazz . asSubclass ( type ) , kryo ) ; result . add ( item ) ; } } catch ( final Exception e ) { LOG . error ( " Could not instantiate " + element + " , omitting this " + type . getSimpleName ( ) + " . " , e ) ; throw new RuntimeException ( " Could not load " + type . getSimpleName ( ) + " " + element , e ) ; } } return result ; }
protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { Kryo kryo = new Kryo ( classResolver , referenceResolver , streamFactory ) ; kryo . getFieldSerializerConfig ( ) . setOptimizedGenerics ( true ) ; return kryo ; }
public KryoBuilder withClassResolver ( final ClassResolver classResolver ) { this . classResolver = classResolver ; return this ; }
public KryoBuilder withReferenceResolver ( final ReferenceResolver referenceResolver ) { this . referenceResolver = referenceResolver ; return this ; }
public KryoBuilder withStreamFactory ( final StreamFactory streamFactory ) { this . streamFactory = streamFactory ; return this ; }
protected Kryo buildFrom ( KryoBuilder target ) { if ( target . classResolver = = null ) target . classResolver = classResolver ; if ( target . referenceResolver = = null ) target . referenceResolver = referenceResolver ; if ( target . streamFactory = = null ) target . streamFactory = streamFactory ; return target . build ( ) ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . setRegistrationRequired ( registrationRequired ) ; return k ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . setInstantiatorStrategy ( instantiatorStrategy ) ; return k ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . setReferences ( references ) ; return k ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; kryoCustomization . customize ( k ) ; return k ; }
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . getFieldSerializerConfig ( ) . setOptimizedGenerics ( optimizedGenerics ) ; return k ; }
public void customize ( final Kryo kryo ) { new WicketMiniMapRegistration ( ) . customize ( kryo ) ; new ComponentSerializerFactory ( ) . customize ( kryo ) ; }
public Serializer newSerializer ( final Class < ? > type ) { Serializer serializer ; if ( ( serializer = _childListSerializerFactory . newSerializer ( type ) ) ! = null ) { return serializer ; } return null ; }
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return getTranscoder ( manager . getContainerClassLoader ( ) ) ; }
protected SessionAttributesTranscoder createTranscoder ( final ClassLoader loader ) { return getTranscoder ( loader ) ; }
public void customize ( Kryo kryo ) { kryo . setReferences ( true ) ; kryo . register ( GrailsFlashScope . class , new FieldSerializer ( kryo , GrailsFlashScope . class ) ) ; }
public void customize ( final Kryo kryo ) { kryo . register ( CGLibProxySerializer . CGLibProxyMarker . class , new CGLibProxySerializer ( ) ) ; }
public Serializer newSerializer ( Class < ? > type ) { if ( CGLibProxySerializer . canSerialize ( type ) ) { return kryo . getSerializer ( CGLibProxySerializer . CGLibProxyMarker . class ) ; } return null ; }
protected ClassResolver createClassResolver ( ) { return new CGLibProxyClassResolver ( ) ; }
public void customize ( final Kryo kryo ) { kryo . register ( MiniMap . class , new MiniMapSerializer ( ) ) ; }
public void customize ( final Kryo kryo ) { kryo . register ( LRUMap . class , new LRUMapSerializer ( kryo ) ) ; }
public void write ( Kryo kryo , Output output , LRUMap < ? , ? > map ) { output . writeInt ( getMaxCapacity ( map ) , true ) ; output . writeInt ( map . size ( ) , true ) ; for ( final Entry < ? , ? > entry : map . entrySet ( ) ) { _kryo . writeClassAndObject ( output , entry . getKey ( ) ) ; _kryo . writeClassAndObject ( output , entry . getValue ( ) ) ; } if ( TRACE ) trace ( " kryo " , " Wrote map : " + map ) ; }
private Field getField ( final Class < ? > clazz , final String name ) throws NoSuchFieldException { final Field field = clazz . getDeclaredField ( name ) ; field . setAccessible ( true ) ; return field ; }
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return getTranscoder ( manager ) ; }
protected JavolutionTranscoder createTranscoder ( final SessionManager manager ) { return new JavolutionTranscoder ( Thread . currentThread ( ) . getContextClassLoader ( ) , false , new HibernateCollectionsXMLFormat ( ) ) ; }
protected void beforeTest ( ) { _binding = new ReflectionBinding ( getClass ( ) . getClassLoader ( ) , false , new JodaDateTimeFormat ( ) ) ; }
public void testWriteDateTimeWithTimeZone ( final DateTimeZone timeZone ) throws XMLStreamException { final DateTime dateTime = new DateTime ( 0 , timeZone ) ; final byte [ ] serialized = serialize ( dateTime , _binding ) ; final DateTime deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized , dateTime ) ; }
public void testWriteDateTimeWithChronology ( final Chronology chronology ) throws XMLStreamException { final DateTime dateTime = new DateTime ( 0 , chronology ) ; final byte [ ] serialized = serialize ( dateTime , _binding ) ; final DateTime deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized , dateTime ) ; }
protected void beforeTest ( ) { _binding = new ReflectionBinding ( getClass ( ) . getClassLoader ( ) , false , new CGLibProxyFormat ( ) ) ; }
public void testCGLibProxy ( ) throws XMLStreamException { final ClassToProxy proxy = createProxy ( new ClassToProxy ( ) ) ; proxy . setValue ( " foo " ) ; final byte [ ] serialized = serialize ( proxy , _binding ) ; System . out . println ( new String ( serialized ) ) ; final ClassToProxy deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized . getValue ( ) , proxy . getValue ( ) ) ; }
public void testCGLibProxyForExistingFormat ( ) throws XMLStreamException { final Map < String , String > proxy = createProxy ( new HashMap < String , String > ( ) ) ; proxy . put ( " foo " , " bar " ) ; Assert . assertEquals ( proxy . get ( " foo " ) , " bar " ) ; final byte [ ] serialized = serialize ( proxy , _binding ) ; System . out . println ( new String ( serialized ) ) ; final Map < String , String > deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized . get ( " foo " ) , proxy . get ( " foo " ) ) ; }
public String getClassName ( final String prefix , final String source , final Object key , final Predicate names ) { return super . getClassName ( " MSM_ " + prefix , source , key , names ) ; }
public Object invoke ( final Object obj , final Method method , final Object [ ] args ) throws Throwable { return method . invoke ( _delegate , args ) ; }
static Container createContainer ( final String bodyContent ) { return new Container ( bodyContent ) ; }
public void testJavaUtilCollectionsUnmodifiable ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableList ( new ArrayList < String > ( Arrays . asList ( " foo " , " bar " ) ) ) ) ; final HashMap < String , String > m = new HashMap < String , String > ( ) ; m . put ( " foo " , " bar " ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableMap ( m ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testJavaUtilLists ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyList " , Collections . < String > emptyList ( ) ) ; session . setAttribute ( " arrayList " , new ArrayList < String > ( ) ) ; session . setAttribute ( " arraysAsList " , Arrays . asList ( " foo " , " bar " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testJavaUtilCollectionsEmptyMap ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyMap " , Collections . < String , String > emptyMap ( ) ) ; session . setAttribute ( " hashMap " , new HashMap < String , String > ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testProxy ( ) throws Exception { final SomeInterface bean = TestClasses . createProxy ( ) ; final byte [ ] bytes = serialize ( bean ) ; assertDeepEquals ( deserialize ( bytes ) , bean ) ; }
public void testInnerClass ( ) throws Exception { final Container container = TestClasses . createContainer ( " some content " ) ; assertDeepEquals ( deserialize ( serialize ( container ) ) , container ) ; }
public < T > void testTypesAsSessionAttributes ( final Class < T > type , final T instance ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( type . getSimpleName ( ) , instance ) ; final byte [ ] bytes = _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; assertDeepEquals ( _transcoder . deserializeAttributes ( bytes ) , session . getAttributesInternal ( ) ) ; }
public void testTypesInContainerClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( MyContainer . class . getSimpleName ( ) , new MyContainer ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testClassWithoutDefaultConstructor ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " no - default constructor " , TestClasses . createClassWithoutDefaultConstructor ( " foo " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testPrivateClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " pc " , TestClasses . createPrivateClass ( " foo " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public void testCollections ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " foo " , new EntityWithCollections ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; }
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + Arrays . hashCode ( _bars ) ; result = prime * result + ( ( _bazens = = null ) ? 0 : _bazens . hashCode ( ) ) ; result = prime * result + ( ( _foos = = null ) ? 0 : _foos . hashCode ( ) ) ; return result ; }
private void assertDeepEquals ( final Object one , final Object another ) throws Exception { assertDeepEquals ( one , another , new IdentityHashMap < Object , Object > ( ) ) ; }
public void write ( final Enum < ? > object , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " value " , object . name ( ) ) ; xml . setAttribute ( " type " , object . getClass ( ) . getName ( ) ) ; }
public final void write ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , array . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; writeElements ( array , output ) ; }
public boolean isReferenceable ( ) { return false ; }
public Currency newInstance ( final Class < Currency > cls , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return Currency . getInstance ( xml . getAttribute ( " code " , " " ) ) ; }
public void write ( final Currency currency , final OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " code " , currency . getCurrencyCode ( ) ) ; }
public Object newInstance ( final Class < Object > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final InvocationHandler invocationHandler = input . get ( " handler " ) ; final Class < ? > [ ] interfaces = getInterfaces ( input , " interfaces " , _classLoader ) ; return Proxy . newProxyInstance ( _classLoader , interfaces , invocationHandler ) ; }
public final void write ( final Object obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { final InvocationHandler invocationHandler = Proxy . getInvocationHandler ( obj ) ; output . add ( invocationHandler , " handler " ) ; final String [ ] interfaceNames = getInterfaceNames ( obj ) ; output . add ( interfaceNames , " interfaces " ) ; }
public StringBuilder newInstance ( final Class < StringBuilder > cls , final InputElement xml ) throws XMLStreamException { return new StringBuilder ( xml . getAttribute ( " val " ) ) ; }
public void write ( final StringBuilder obj , final OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " val " , obj . toString ( ) ) ; }
public StringBuffer newInstance ( final Class < StringBuffer > cls , final InputElement xml ) throws XMLStreamException { return new StringBuffer ( xml . getAttribute ( " val " ) ) ; }
public void write ( final StringBuffer obj , final OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " val " , obj . toString ( ) ) ; }
public boolean canConvert ( final Class < ? > cls ) { return cls = = DateTime . class ; }
public DateTime newInstance ( final Class < DateTime > cls , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final long millis = input . getAttribute ( MILLIS ) . toLong ( ) ; final Chronology chronology = readChronology ( input ) ; final DateTimeZone tz = readTimeZone ( input ) ; return new DateTime ( millis , chronology . withZone ( tz ) ) ; }
private Chronology readChronology ( final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final CharArray chronologyId = input . getAttribute ( CHRONOLOGY ) ; return IdentifiableChronology . valueOfId ( chronologyId ! = null ? chronologyId . toString ( ) : null ) ; }
private DateTimeZone readTimeZone ( final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final CharArray tz = input . getAttribute ( TIME_ZONE ) ; return tz ! = null ? DateTimeZone . forID ( tz . toString ( ) ) : DateTimeZone . getDefault ( ) ; }
public static Chronology valueOfId ( String id ) throws IllegalArgumentException { if ( id = = null ) { return ISO . _chronology ; } for ( final IdentifiableChronology item : values ( ) ) { if ( id . equals ( item . _id ) ) { return item . _chronology ; } } throw new IllegalArgumentException ( " No chronology found for id " + id ) ; }
private AttributesAndElements allFields ( final Class < T > cls ) { final AttributesAndElements result = new AttributesAndElements ( ) ; Class < ? super T > clazz = cls ; while ( clazz ! = null ) { addDeclaredFields ( clazz , result ) ; clazz = clazz . getSuperclass ( ) ; } return result ; }
protected static boolean isAttribute ( final Field field ) { return isAttribute ( field . getType ( ) ) ; }
public void read ( final javolution . xml . XMLFormat . InputElement input , final T obj ) throws XMLStreamException { readAttributes ( input , obj ) ; readElements ( input , obj ) ; }
public void write ( final T obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { writeAttributes ( obj , output ) ; writeElements ( obj , output ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getBoolean ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getInt ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getLong ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getFloat ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getDouble ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getByte ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getChar ( obj ) ) ; }
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getShort ( obj ) ) ; }
void add ( final Object object , final OutputElement output ) throws XMLStreamException { output . setAttribute ( _field . getName ( ) , object . toString ( ) ) ; }
void add ( final Object object , final OutputElement output ) throws XMLStreamException { output . setAttribute ( _field . getName ( ) , ( ( Enum < ? > ) object ) . name ( ) ) ; }
private String getAttribute ( final InputElement input , final String name , final String defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? value . toString ( ) : defaultValue ; }
private Boolean getAttribute ( final InputElement input , final String name , final Boolean defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Boolean . valueOf ( value . toBoolean ( ) ) : defaultValue ; }
private Integer getAttribute ( final InputElement input , final String name , final Integer defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Integer . valueOf ( value . toInt ( ) ) : defaultValue ; }
private Long getAttribute ( final InputElement input , final String name , final Long defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Long . valueOf ( value . toLong ( ) ) : defaultValue ; }
private Short getAttribute ( final InputElement input , final String name , final Short defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Short . valueOf ( TypeFormat . parseShort ( value ) ) : defaultValue ; }
private Float getAttribute ( final InputElement input , final String name , final Float defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Float . valueOf ( value . toFloat ( ) ) : defaultValue ; }
private Double getAttribute ( final InputElement input , final String name , final Double defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Double . valueOf ( value . toDouble ( ) ) : defaultValue ; }
private Byte getAttribute ( final InputElement input , final String name , final Byte defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Byte . valueOf ( TypeFormat . parseByte ( value ) ) : defaultValue ; }
static boolean isNumberFormat ( final Class < ? > clazz ) { return Number . class . isAssignableFrom ( clazz ) ; }
public T newInstance ( final Class < T > clazz , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return newInstanceFromAttribute ( xml , " value " ) ; }
public void write ( final T obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " value " , obj . longValue ( ) ) ; }
public Object getAttribute ( final String name , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return xml . getAttribute ( name , 0 ) ; }
public Object getAttribute ( final String name , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return xml . getAttribute ( name , 0L ) ; }
public boolean canConvert ( final Class < ? > cls ) { return AbstractPersistentCollection . class . isAssignableFrom ( cls ) ; }
public void read ( final XMLFormat . InputElement input , final AbstractPersistentCollection obj ) throws XMLStreamException { getFormat ( obj . getClass ( ) ) . read ( input , obj ) ; }
public void write ( final AbstractPersistentCollection obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { getFormat ( obj . getClass ( ) ) . write ( obj , output ) ; }
public boolean canConvert ( final Class < ? > cls ) { return canSerialize ( cls ) | | canDeserialize ( cls ) ; }
private boolean canDeserialize ( final Class < ? > cls ) { return cls = = CGLibProxyMarker . class ; }
public boolean isReferenceable ( ) { return false ; }
public Object newInstance ( final Class < Object > cls , final InputElement xml ) throws XMLStreamException { final Class < ? > superclass ; try { superclass = Class . forName ( xml . getAttribute ( SUPERCLASS ) . toString ( ) ) ; } catch ( final ClassNotFoundException e ) { throw new XMLStreamException ( e ) ; } final ClassLoader classLoader = getClass ( ) . getClassLoader ( ) ; final Class < ? > [ ] interfaces = getInterfaces ( xml , INTERFACES , classLoader ) ; final Callback [ ] callbacks = xml . get ( CALLBACKS ) ; return createProxy ( superclass , interfaces , callbacks ) ; }
private Object createProxy ( final Class < ? > targetClass , final Class < ? > [ ] interfaces , final Callback [ ] callbacks ) { final Enhancer e = new Enhancer ( ) ; e . setInterfaces ( interfaces ) ; e . setSuperclass ( targetClass ) ; e . setCallbacks ( callbacks ) ; return e . create ( ) ; }
public void write ( final Object obj , final OutputElement xml ) throws XMLStreamException { final Class < ? > superclass = obj . getClass ( ) . getSuperclass ( ) ; xml . setAttribute ( SUPERCLASS , superclass . getName ( ) ) ; final String [ ] interfaceNames = getInterfaceNames ( obj ) ; xml . add ( interfaceNames , INTERFACES ) ; final Callback [ ] callbacks = ( ( Factory ) obj ) . getCallbacks ( ) ; xml . add ( callbacks , CALLBACKS ) ; }
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { return doSerialize ( attributes , " attributes " ) ; }
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] in ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Reading serialized data : \ n " + new String ( in ) ) ; } return doDeserialize ( in , " attributes " ) ; }
