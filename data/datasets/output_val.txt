public Tomcat6Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; }
public void stop ( ) throws Exception { tomcat . stop ( ) ; }
protected Context createContext ( @ Nonnull final Embedded catalina , @ Nonnull final String contextPath , @ Nonnull final String docBase ) { return catalina . createContext ( contextPath , docBase ) ; }
protected SessionManager createSessionManager ( ) { return new MemcachedBackupSessionManager ( ) ; }
private static SecurityConstraint createSecurityConstraint ( final String pattern , final String role ) { final SecurityConstraint constraint = new SecurityConstraint ( ) ; final SecurityCollection securityCollection = new SecurityCollection ( ) ; securityCollection . addPattern ( pattern ) ; constraint . addCollection ( securityCollection ) ; if ( role ! = null ) { constraint . addAuthRole ( role ) ; } return constraint ; }
protected void startInternal ( final StorageClient storageClient ) throws LifecycleException { _msm . setStorageClient ( storageClient ) ; _msm . startInternal ( ) ; }
public String generateSessionId ( ) { return _msm . newSessionId ( super . generateSessionId ( ) ) ; }
public void expireSession ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " expireSession invoked : " + sessionId ) ; } super . expireSession ( sessionId ) ; _msm . deleteFromMemcached ( sessionId ) ; }
public void remove ( final Session session ) { remove ( session , session . getNote ( MemcachedSessionService . NODE_FAILURE ) ! = Boolean . TRUE ) ; }
public void removeInternal ( final Session session , final boolean update ) { super . remove ( session ) ; }
private void remove ( final Session session , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked , removeFromMemcached : " + removeFromMemcached + " , id : " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session ) ; _msm . sessionRemoved ( ( MemcachedBackupSession ) session ) ; }
public Session findSession ( final String id ) throws IOException { return _msm . findSession ( id ) ; }
public MemcachedBackupSession createSession ( final String sessionId ) { return _msm . createSession ( sessionId ) ; }
public MemcachedBackupSession createEmptySession ( ) { return _msm . createEmptySession ( ) ; }
public MemcachedBackupSession newMemcachedBackupSession ( ) { return new MemcachedBackupSession ( this ) ; }
public void changeSessionId ( final Session session ) { super . changeSessionId ( session ) ; ( ( MemcachedBackupSession ) session ) . setSessionIdChanged ( true ) ; }
public boolean isMaxInactiveIntervalSet ( ) { return _maxInactiveInterval ! = null ; }
public void setEnabled ( final boolean enabled ) throws IllegalStateException { _msm . setEnabled ( enabled ) ; }
public boolean isEnabled ( ) { return _msm . isEnabled ( ) ; }
public boolean isSticky ( ) { return _msm . isSticky ( ) ; }
public void addLifecycleListener ( final LifecycleListener arg0 ) { _lifecycle . addLifecycleListener ( arg0 ) ; }
public LifecycleListener [ ] findLifecycleListeners ( ) { return _lifecycle . findLifecycleListeners ( ) ; }
public void removeLifecycleListener ( final LifecycleListener arg0 ) { _lifecycle . removeLifecycleListener ( arg0 ) ; }
public void start ( ) throws LifecycleException { if ( ! initialized ) { init ( ) ; } if ( _started ) { return ; } _lifecycle . fireLifecycleEvent ( START_EVENT , null ) ; _started = true ; if ( log . isDebugEnabled ( ) ) { log . debug ( " Force random number initialization starting " ) ; } super . generateSessionId ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( " Force random number initialization completed " ) ; } startInternal ( null ) ; }
private void swapOut ( @ Nonnull final StandardSession session ) { if ( ! session . isValid ( ) ) { return ; } session . passivate ( ) ; remove ( session , false ) ; session . recycle ( ) ; }
public void backgroundProcess ( ) { _msm . updateExpirationInMemcached ( ) ; super . backgroundProcess ( ) ; }
public boolean isSessionBackupAsync ( ) { return _msm . isSessionBackupAsync ( ) ; }
public void incrementSessionCounter ( ) { sessionCounter + + ; }
public void incrementRejectedSessions ( ) { _rejectedSessions + + ; }
public boolean isInitialized ( ) { return initialized ; }
public void writePrincipal ( @ Nonnull Principal principal , @ Nonnull ObjectOutputStream oos ) throws IOException { SerializablePrincipal . writePrincipal ( ( GenericPrincipal ) principal , oos ) ; }
public Principal readPrincipal ( final ObjectInputStream ois ) throws ClassNotFoundException , IOException { return SerializablePrincipal . readPrincipal ( ois , getContainer ( ) . getRealm ( ) ) ; }
protected SessionManager createSessionManager ( Context context ) { MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContext ( context ) ; return manager ; }
protected void startInternal ( final SessionManager manager , final MemcachedClient memcachedMock ) throws LifecycleException { manager . getMemcachedSessionService ( ) . setStorageClient ( new MemcachedStorageClient ( memcachedMock ) ) ; ( ( MemcachedBackupSessionManager ) manager ) . start ( ) ; }
protected void setupGetResponseSetCookieHeadersExpectations ( Response response , String [ ] result ) { when ( response . getHeaders ( eq ( " Set - Cookie " ) ) ) . thenReturn ( Arrays . asList ( result ) ) ; }
protected String generateCookieString ( javax . servlet . http . Cookie cookie ) { return COOKIE_PROCESSOR . generateHeader ( cookie ) ; }
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { super . setup ( ) ; final Context context = ( Context ) _manager . getContext ( ) ; when ( _manager . getContext ( ) ) . thenReturn ( context ) ; }
protected GenericPrincipal createPrincipal ( ) { return new GenericPrincipal ( " foo " , " bar " , new ArrayList < String > ( ) ) ; }
public Tomcat8Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; }
public Tomcat8Builder tomcatBuilder ( ) { return new Tomcat8Builder ( ) ; }
protected RequestTrackingContextValve createRequestTrackingContextValve ( final String sessionCookieName ) { final RequestTrackingContextValve result = super . createRequestTrackingContextValve ( sessionCookieName ) ; result . setAsyncSupported ( true ) ; return result ; }
protected RequestTrackingHostValve createRequestTrackingHostValve ( final String sessionCookieName , final CurrentRequest currentRequest ) { final RequestTrackingHostValve result = super . createRequestTrackingHostValve ( sessionCookieName , currentRequest ) ; result . setAsyncSupported ( true ) ; return result ; }
public MemcachedBackupSession createSession ( final String sessionId ) { return _msm . createSession ( sessionId ) ; }
public void expireSession ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " expireSession invoked : " + sessionId ) ; } super . expireSession ( sessionId ) ; _msm . deleteFromMemcached ( sessionId ) ; }
public void remove ( final Session session , final boolean update ) { removeInternal ( session , update , session . getNote ( MemcachedSessionService . NODE_FAILURE ) ! = Boolean . TRUE ) ; }
public void removeInternal ( final Session session , final boolean update ) { super . remove ( session , update ) ; }
private void removeInternal ( final Session session , final boolean update , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked , removeFromMemcached : " + removeFromMemcached + " , id : " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session , update ) ; _msm . sessionRemoved ( ( MemcachedBackupSession ) session ) ; }
public void changeSessionId ( final Session session ) { super . changeSessionId ( session ) ; ( ( MemcachedBackupSession ) session ) . setSessionIdChanged ( true ) ; }
public void startInternal ( ) throws LifecycleException { super . startInternal ( ) ; _msm . startInternal ( ) ; setState ( LifecycleState . STARTING ) ; }
public void stopInternal ( ) throws LifecycleException { setState ( LifecycleState . STOPPING ) ; if ( _msm . isSticky ( ) ) { _log . info ( " Removing sessions from local session map . " ) ; for ( final Session session : sessions . values ( ) ) { swapOut ( ( StandardSession ) session ) ; } } _msm . shutdown ( ) ; super . stopInternal ( ) ; }
private void swapOut ( @ Nonnull final StandardSession session ) { if ( ! session . isValid ( ) ) { return ; } session . passivate ( ) ; removeInternal ( session , true ) ; session . recycle ( ) ; }
public void incrementRejectedSessions ( ) { rejectedSessions + + ; }
public boolean isInitialized ( ) { return getState ( ) = = LifecycleState . INITIALIZED | | getState ( ) = = LifecycleState . STARTED ; }
public void writePrincipal ( @ Nonnull Principal principal , @ Nonnull ObjectOutputStream oos ) throws IOException { oos . writeObject ( principal ) ; }
public Principal readPrincipal ( final ObjectInputStream ois ) throws ClassNotFoundException , IOException { return ( Principal ) ois . readObject ( ) ; }
public void testCreateSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo - n " , cut . createSessionId ( " foo " , " n " ) ) ; assertEquals ( " foo - n . jvm1 " , cut . createSessionId ( " foo . jvm1 " , " n " ) ) ; assertEquals ( " foo - n . j - v - m1 " , cut . createSessionId ( " foo . j - v - m1 " , " n " ) ) ; }
public void testExtractMemcachedId ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " n " , cut . extractMemcachedId ( " foo - n " ) ) ; assertEquals ( " n " , cut . extractMemcachedId ( " foo - n . jvm1 " ) ) ; assertEquals ( " n " , cut . extractMemcachedId ( " foo - n . j - v - m1 " ) ) ; assertEquals ( null , cut . extractMemcachedId ( " foo . j - v - m1 " ) ) ; }
public void testIsValid ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertFalse ( cut . isValid ( " foo " ) ) ; assertFalse ( cut . isValid ( " foo . jvm1 - n " ) ) ; assertFalse ( cut . isValid ( " foo . n . jvm1 " ) ) ; assertFalse ( cut . isValid ( " foo . n . j - v - m1 " ) ) ; assertTrue ( cut . isValid ( " foo - n " ) ) ; assertTrue ( cut . isValid ( " foo - n . jvm1 " ) ) ; assertTrue ( cut . isValid ( " foo - n . j - v - m1 " ) ) ; }
public void testCreateBackupKey ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertEquals ( cut . createBackupKey ( " foo " ) , " bak : localhost_foo " ) ; }
public void testIsBackupKey ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertTrue ( cut . isBackupKey ( " bak : localhost_foo " ) ) ; }
public void testCreateLockName ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertEquals ( cut . createLockName ( " foo " ) , " lock : localhost_foo " ) ; }
public void testCreateValidityInfoKeyName ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertEquals ( cut . createValidityInfoKeyName ( " foo " ) , " validity : localhost_foo " ) ; }
public void testRemove ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 3 ) ; cut . put ( " foo " , " bar " ) ; assertTrue ( cut . containsKey ( " foo " ) ) ; assertEquals ( cut . remove ( " foo " ) , " bar " ) ; assertFalse ( cut . containsKey ( " foo " ) ) ; }
public void testCacheSize ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; cut . put ( " bar " , " baz " ) ; Assert . assertEquals ( " baz " , cut . get ( " bar " ) ) ; Assert . assertNull ( cut . get ( " foo " ) , " old key still existing , unexpected cache size " ) ; }
public void testCacheTTL ( ) throws InterruptedException { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 , 100 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; Thread . sleep ( 120 ) ; Assert . assertNull ( cut . get ( " foo " ) , " expired key still existing , unexpected cache size " ) ; }
public int compare ( final Integer o1 , final Integer o2 ) { return o1 . compareTo ( o2 ) ; }
public void testClear ( ) { final LRUCache < String , Integer > cut = new LRUCache < String , Integer > ( 3 ) ; cut . put ( " foo " , 1 ) ; cut . clear ( ) ; assertNull ( cut . get ( " foo " ) ) ; }
public static void main ( final String [ ] args ) { System . out . println ( System . currentTimeMillis ( ) / 1000 + TimeUnit . DAYS . toSeconds ( 1000 ) ) ; System . out . println ( Integer . MAX_VALUE ) ; }
public void testToMemcachedExpiration ( ) throws Exception { assertEquals ( toMemcachedExpiration ( 60 * 60 * 24 * 30 ) , 60 * 60 * 24 * 30 ) ; assertEquals ( toMemcachedExpiration ( 60 * 60 * 24 * 30 + 1 ) , System . currentTimeMillis ( ) / 1000 + 60 * 60 * 24 * 30 + 1 ) ; }
public byte [ ] get ( final String key ) { return _memcached . get ( key , ByteArrayTranscoder . INSTANCE ) ; }
public void setUp ( final Method testMethod ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? _memcachedNodeId + " : " : " " ; _memcachedNodes = nodePrefix + " localhost : " + _memcachedPort ; try { System . setProperty ( " org . apache . catalina . startup . EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = tcBuilder ( ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } _memcached = createMemcachedClient ( _memcachedNodes , address ) ; _httpClient = new DefaultHttpClient ( ) ; }
private TomcatBuilder < ? > tcBuilder ( ) { return getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( _memcachedNodes ) . sticky ( true ) . jvmRoute ( " app1 " ) ; }
private MemcachedClient createMemcachedClient ( final String memcachedNodes , final InetSocketAddress address ) throws IOException , InterruptedException { final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( memcachedNodes , null , null , _storageClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; final MemcachedClient result = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; Thread . sleep ( 100 ) ; return result ; }
public void tearDown ( ) throws Exception { _memcached . shutdown ( ) ; _tomcat1 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _daemon . stop ( ) ; }
public void testContextReload ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = post ( _httpClient , _portTomcat1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created . " ) ; _tomcat1 . getContext ( ) . reload ( ) ; final Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; final String actualValue = response . get ( " foo " ) ; assertEquals ( " bar " , actualValue ) ; }
public void testConfiguredMemcachedNodeId ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; final String nodeId = sessionId1 . substring ( sessionId1 . indexOf ( ' - ' ) + 1 , sessionId1 . indexOf ( ' . ' ) ) ; assertEquals ( _memcachedNodeId , nodeId , " Invalid memcached node id " ) ; }
public void testSessionIdIsNotChangedIfSingleNodeWithNoMemcachedNodeIdConfigured ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; assertTrue ( sessionId1 . indexOf ( ' - ' ) = = - 1 ) ; }
public void testSessionFoundIfSingleNodeWithNoMemcachedNodeIdConfigured ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , _portTomcat1 , null , key , value ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created . " ) ; final Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; final String sessionId2 = response . getSessionId ( ) ; assertEquals ( sessionId2 , sessionId1 ) ; final String actualValue = response . get ( key ) ; assertEquals ( value , actualValue ) ; }
public void testSessionAvailableInMemcached ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; Thread . sleep ( 50 ) ; assertNotNull ( _memcached . get ( sessionId1 ) , " Session not available in memcached . " ) ; }
public void testSessionAvailableInMemcachedWithCookiesDisabled ( final SessionAffinityMode sessionAffinity ) throws Exception { _tomcat1 . stop ( ) ; _tomcat1 = tcBuilder ( ) . sticky ( sessionAffinity . isSticky ( ) ) . cookies ( false ) . jvmRoute ( " app1 " ) . buildAndStart ( ) ; final Response response = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response . get ( TestServlet . ID ) ; assertNotNull ( sessionId , " No session created . " ) ; Thread . sleep ( 50 ) ; assertNotNull ( _memcached . get ( sessionId ) , " Session not available in memcached . " ) ; }
public void testExpiredSessionRemovedFromMemcached ( @ Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; waitForSessionExpiration ( sessionAffinity . isSticky ( ) ) ; assertNull ( _memcached . get ( sessionId1 ) , " Expired session still existing in memcached " ) ; }
public Object call ( ) throws Exception { return _memcached . get ( new SessionIdFormat ( ) . createValidityInfoKeyName ( sessionId1 ) ) ; }
public void testInvalidSessionNotFound ( @ Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId1 , sessionId2 , " Expired session returned . " ) ; }
public void testDisableMsmAtRuntime ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setSticky ( true ) ; manager . setEnabled ( false ) ; _memcached . shutdown ( ) ; _daemon . stop ( ) ; checkSessionFunctionalityWithMsmDisabled ( ) ; }
private void checkSessionFunctionalityWithMsmDisabled ( ) throws IOException , HttpException , InterruptedException { assertTrue ( _tomcat1 . getManager ( ) . getMemcachedSessionService ( ) . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created . " ) ; assertNull ( new SessionIdFormat ( ) . extractMemcachedId ( sessionId1 ) , " Got a memcached node id , even with msm disabled . " ) ; waitForSessionExpiration ( true ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId2 , sessionId1 , " SessionId not changed . " ) ; }
private void waitForSessionExpiration ( final boolean sticky ) throws InterruptedException { final SessionManager manager = _tomcat1 . getManager ( ) ; assertEquals ( manager . getMemcachedSessionService ( ) . isSticky ( ) , sticky ) ; final Container container = manager . getContext ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( sticky ? container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) : 2 * manager . getMaxInactiveInterval ( ) ) + 1000 ; Thread . sleep ( timeout ) ; }
public void setUp ( final Method testMethod ) throws Throwable { couchbaseProvided = Boolean . parseBoolean ( System . getProperty ( " couchbase . provided " , " false " ) ) ; final int couchbasePort = Integer . parseInt ( System . getProperty ( " couchbase . port " , " 18091 " ) ) ; if ( ! couchbaseProvided ) { cluster . add ( setupCouchbase ( couchbasePort ) ) ; } try { System . setProperty ( " org . apache . catalina . startup . EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( " http : / / localhost : " + couchbasePort + " / pools " ) . sticky ( true ) . memcachedProtocol ( " binary " ) . username ( " default " ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } setupCouchbaseClient ( ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _tomcat1 . getManager ( ) ) ) ; }
public void tearDown ( ) throws Exception { mc . shutdown ( ) ; mc = null ; if ( ! couchbaseProvided ) { tearDownCouchbase ( ) ; } _tomcat1 . stop ( ) ; }
public void testBackupSessionInCouchbase ( ) throws InterruptedException , ExecutionException { final MemcachedSessionService service = _tomcat1 . getService ( ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( mc . get ( sessionId , ByteArrayTranscoder . INSTANCE ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; }
public void testBackupSessionInCouchbaseCluster ( ) throws Exception { final MemcachedSessionService service = _tomcat1 . getService ( ) ; cluster . add ( setupCouchbase ( getMaxCouchbasePort ( ) + 1 ) ) ; service . setMemcachedNodes ( getMemcachedNodesConfig ( getURIs ( ) ) ) ; setupCouchbaseClient ( ) ; waitForReconnect ( service . getStorageClient ( ) , cluster . size ( ) , 1000 ) ; waitForReconnect ( mc , cluster . size ( ) , 1000 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( mc . get ( sessionId , ByteArrayTranscoder . INSTANCE ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; }
private void checkSession ( final MemcachedBackupSession actual , final MemcachedBackupSession expected ) { assertNotNull ( actual ) ; assertEquals ( actual . getId ( ) , expected . getId ( ) ) ; assertEquals ( actual . getAttributesInternal ( ) , expected . getAttributesInternal ( ) ) ; }
private void waitForReconnect ( final StorageClient client , final int expectedServers , final long timeToWait ) throws InterruptedException , RuntimeException { waitForReconnect ( ( ( MemcachedStorageClient ) client ) . getMemcachedClient ( ) , expectedServers , timeToWait ) ; }
private void setupCouchbaseClient ( ) throws URISyntaxException , IOException { if ( mc ! = null ) { LOG . info ( " Closing existing couchbase client . " ) ; mc . shutdown ( ) ; } final List < URI > uris = getURIs ( ) ; LOG . info ( " Creating new couchbase client with uris " + uris ) ; mc = new CouchbaseClient ( uris , " default " , " " ) ; }
private List < URI > getURIs ( ) throws URISyntaxException { final List < URI > uris = new ArrayList < URI > ( cluster . size ( ) ) ; for ( final CouchbaseMock server : cluster ) { uris . add ( new URI ( " http : / / localhost : " + server . getHttpPort ( ) + " / pools " ) ) ; } return uris ; }
private CouchbaseMock setupCouchbase ( final int couchbasePort ) throws IOException { final CouchbaseMock couchbase = new CouchbaseMock ( " localhost " , couchbasePort , 1 , 1 ) ; couchbase . start ( ) ; return couchbase ; }
private void tearDownCouchbase ( ) throws InterruptedException { for ( final CouchbaseMock server : cluster ) { server . stop ( ) ; } cluster . clear ( ) ; }
public void testCounts ( final String getterMethod , final String updateMethod ) throws Exception { final Statistics cut = Statistics . create ( ) ; final Method getMethod = Statistics . class . getMethod ( getterMethod ) ; assertEquals ( ( ( Long ) getMethod . invoke ( cut ) ) . longValue ( ) , 0 ) ; Statistics . class . getMethod ( updateMethod ) . invoke ( cut ) ; assertEquals ( ( ( Long ) getMethod . invoke ( cut ) ) . longValue ( ) , 1 ) ; }
public void testDisabledRequestWithBackup ( ) { final Statistics cut = Statistics . create ( false ) ; assertEquals ( cut . getRequestsWithBackupFailure ( ) , 0 ) ; cut . requestWithBackupFailure ( ) ; assertEquals ( cut . getRequestsWithBackupFailure ( ) , 0 ) ; }
public void testMinMaxAvgProbe ( ) { final MinMaxAvgProbe cut = new MinMaxAvgProbe ( ) ; assertValues ( cut , 0 , 0 , 0 , 0 ) ; cut . register ( 1 ) ; assertValues ( cut , 1 , 1 , 1 , 1 ) ; cut . register ( 1 ) ; assertValues ( cut , 2 , 1 , 1 , 1 ) ; cut . register ( 4 ) ; assertValues ( cut , 3 , 1 , 4 , 2 ) ; cut . register ( 0 ) ; assertValues ( cut , 4 , 0 , 4 , 1 . 5 ) ; }
private void assertValues ( final MinMaxAvgProbe cut , final int count , final int min , final int max , final double avg ) { assertEquals ( cut . getCount ( ) , count ) ; assertEquals ( cut . getMin ( ) , min ) ; assertEquals ( cut . getMax ( ) , max ) ; assertEquals ( cut . getAvg ( ) , avg ) ; }
private void readOnlyRequestsShouldContain ( final ReadOnlyRequestsCache cut , final String key , final boolean shouldBeContained ) { assertEquals ( cut . isReadOnlyRequest ( key ) , shouldBeContained ) ; assertEquals ( cut . getReadOnlyRequests ( ) . contains ( key ) , shouldBeContained ) ; assertEquals ( cut . getReadOnlyRequestsByFrequency ( ) . contains ( key ) , shouldBeContained ) ; }
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; final Context _contextContainer = mock ( Context . class ) ; final Host _hostContainer = mock ( Host . class ) ; final SessionManager _manager = mock ( SessionManager . class ) ; when ( _service . getManager ( ) ) . thenReturn ( _manager ) ; when ( _manager . getContext ( ) ) . thenReturn ( _contextContainer ) ; when ( _contextContainer . getParent ( ) ) . thenReturn ( _hostContainer ) ; when ( _contextContainer . getPath ( ) ) . thenReturn ( " / " ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _sessionTrackerValve . setContainer ( _hostContainer ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " / someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; when ( _request . getContext ( ) ) . thenReturn ( _contextContainer ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . FALSE ) ; }
public final void testProcessRequestNotePresent ( ) throws IOException , ServletException { _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service , never ( ) ) . backupSession ( anyString ( ) , anyBoolean ( ) , anyString ( ) ) ; verify ( _request ) . setNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESS ) , eq ( Boolean . TRUE ) ) ; }
public final void testBackupSessionNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; when ( _response . getHeader ( eq ( " Set - Cookie " ) ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service , never ( ) ) . backupSession ( anyString ( ) , anyBoolean ( ) , anyString ( ) ) ; }
public final void testRequestFinishedShouldBeInvokedForIgnoredResources ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( " foo " ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " / pixel . gif " ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . requestFinished ( eq ( " foo " ) , anyString ( ) ) ; }
protected String generateCookieString ( final Cookie cookie ) { final StringBuffer sb = new StringBuffer ( ) ; ServerCookie . appendCookieValue ( sb , cookie . getVersion ( ) , cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) , true ) ; final String setSessionCookieHeader = sb . toString ( ) ; return setSessionCookieHeader ; }
public MemcachedBackupSession answer ( final InvocationOnMock invocation ) throws Throwable { return newMemcachedBackupSession ( _manager ) ; }
public MemcachedBackupSession answer ( final InvocationOnMock invocation ) throws Throwable { return createSession ( service ) ; }
protected MemcachedBackupSession newMemcachedBackupSession ( @ Nullable final SessionManager manager ) { return new MemcachedBackupSession ( manager ) ; }
public void testSerializeSessionFieldsIncludesFormPrincipalNote ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final Principal saved = createPrincipal ( ) ; session . setNote ( Constants . FORM_PRINCIPAL_NOTE , saved ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; final Principal actual = ( Principal ) deserialized . getNote ( Constants . FORM_PRINCIPAL_NOTE ) ; assertNotNull ( actual ) ; assertDeepEquals ( actual , saved ) ; }
public void testSerializeSessionFieldsIncludesFormRequestNote ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final SavedRequest saved = new SavedRequest ( ) ; saved . setQueryString ( " foo = bar " ) ; saved . setRequestURI ( " http : / / www . foo . org " ) ; session . setNote ( Constants . FORM_REQUEST_NOTE , saved ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; final SavedRequest actual = ( SavedRequest ) deserialized . getNote ( Constants . FORM_REQUEST_NOTE ) ; assertNotNull ( actual ) ; assertDeepEquals ( actual , saved ) ; }
public void testVersionUpgrade ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session , TranscoderService . VERSION_1 ) ; final byte [ ] attributesData = TranscoderService . deserializeSessionFields ( data , _manager ) . getAttributesData ( ) ; assertEquals ( attributesData . length , 0 ) ; }
public void testSerializeSessionFields ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; }
public void testSerializeSessionFieldsWithAuthenticatedPrincipal ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAuthType ( HttpServletRequest . FORM_AUTH ) ; session . setPrincipal ( createPrincipal ( ) ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; }
public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; }
private void assertSessionFields ( final MemcachedBackupSession session , final MemcachedBackupSession deserialized ) { Assert . assertEquals ( session . getCreationTimeInternal ( ) , deserialized . getCreationTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastAccessedTimeInternal ( ) , deserialized . getLastAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getMaxInactiveInterval ( ) , deserialized . getMaxInactiveInterval ( ) ) ; Assert . assertEquals ( session . isNewInternal ( ) , deserialized . isNewInternal ( ) ) ; Assert . assertEquals ( session . isValidInternal ( ) , deserialized . isValidInternal ( ) ) ; Assert . assertEquals ( session . getThisAccessedTimeInternal ( ) , deserialized . getThisAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastBackupTime ( ) , deserialized . getLastBackupTime ( ) ) ; Assert . assertEquals ( session . getIdInternal ( ) , deserialized . getIdInternal ( ) ) ; Assert . assertEquals ( session . getAuthType ( ) , deserialized . getAuthType ( ) ) ; assertDeepEquals ( session . getPrincipal ( ) , deserialized . getPrincipal ( ) ) ; }
public void setUp ( final Method testMethod ) throws Throwable { redisProvided = Boolean . parseBoolean ( System . getProperty ( " redis . provided " , " false " ) ) ; final int redisPort = Integer . parseInt ( System . getProperty ( " redis . port " , " 16379 " ) ) ; if ( ! redisProvided ) { embeddedRedisServer = new RedisServer ( redisPort ) ; embeddedRedisServer . start ( ) ; } try { System . setProperty ( " org . apache . catalina . startup . EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( " redis : / / localhost : " + redisPort ) . sticky ( true ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } redisClient = new BinaryJedis ( " localhost " , redisPort ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _tomcat1 . getManager ( ) ) ) ; }
public void tearDown ( ) throws Exception { if ( redisClient ! = null ) { redisClient . close ( ) ; redisClient = null ; } if ( embeddedRedisServer ! = null ) { embeddedRedisServer . stop ( ) ; embeddedRedisServer = null ; } _tomcat1 . stop ( ) ; }
public void testBackupSessionInRedis ( ) throws InterruptedException , ExecutionException , UnsupportedEncodingException , ClassNotFoundException , IOException { final MemcachedSessionService service = _tomcat1 . getService ( ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( redisClient . get ( sessionId . getBytes ( " UTF - 8 " ) ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; }
public boolean isNodeAvailable ( final String key ) { return true ; }
public final void testGetNextNodeId_SingleNode ( ) { final CacheLoader < String > cacheLoader = new DummyCacheLoader ( null ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( " n1 " ) , null ) ; final String actual = cut . getAvailableNodeId ( " n1 " ) ; assertNull ( actual , " For a sole existing node we cannot get a next node " ) ; }
public final void testGetNextNodeId_TwoNodes ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final CacheLoader < String > cacheLoader = new DummyCacheLoader ( null ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( nodeId1 , nodeId2 ) , null ) ; String actual = cut . getAvailableNodeId ( nodeId1 ) ; assertEquals ( nodeId2 , actual ) ; actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId1 , actual ) ; }
public final void testGetNextNodeId_TwoNodes_NoNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final CacheLoader < String > cacheLoader = new DummyCacheLoader ( Arrays . asList ( nodeId1 ) ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( nodeId1 , nodeId2 ) , null ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertNull ( actual ) ; }
public final void testGetNextNodeId_RegularNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId1 ) ; assertEquals ( nodeId2 , actual , " The failover node is not chosen " ) ; }
public final void testGetNextNodeId_FailoverNode_RegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId1 , actual , " The regular node is not chosen " ) ; }
public final void testGetNextNodeId_FailoverNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( nodeId1 ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertNull ( actual ) ; }
public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( nodeId1 ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 , nodeId3 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId3 , actual , " The second failover node is not chosen " ) ; }
private NodeAvailabilityCache < String > createNodeAvailabilityCache ( final String . . . unavailableNodes ) { final List < String > unavailable = unavailableNodes ! = null ? Arrays . asList ( unavailableNodes ) : null ; return new NodeAvailabilityCache < String > ( 10 , 100 , new DummyCacheLoader ( unavailable ) ) ; }
public boolean isNodeAvailable ( final String key ) { return _unavailable = = null | | ! _unavailable . contains ( key ) ; }
public void beforeClass ( ) { _mcc = mock ( StorageClientCallback . class ) ; }
public void testParseWithNullShouldThrowException ( ) { createFor ( null , null , null , _mcc ) ; }
public void testParseWithEmptyStringShouldThrowException ( ) { createFor ( " " , null , null , _mcc ) ; }
public void testSingleSimpleNodeAndFailoverNodeShouldThrowException ( ) { createFor ( " localhost : 11211 " , " n1 " , null , _mcc ) ; }
public void testSingleNodeAndFailoverNodeShouldThrowException ( ) { createFor ( " n1 : localhost : 11211 " , " n1 " , null , _mcc ) ; }
public void testCouchbaseNodesAndFailoverNodeShouldThrowException ( ) { createFor ( " http : / / localhost : 8091 / pools " , " n1 " , null , _mcc ) ; }
public void testCountNodes ( final String memcachedNodes , final int expectedCount ) { final MemcachedNodesManager result = createFor ( memcachedNodes , null , null , _mcc ) ; assertNotNull ( result ) ; assertEquals ( result . getCountNodes ( ) , expectedCount ) ; }
public void testPrimaryNodes ( final String memcachedNodes , final String failoverNodes , final NodeIdList expectedPrimaryNodeIds ) { final MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; assertNotNull ( result ) ; assertEquals ( result . getPrimaryNodeIds ( ) , expectedPrimaryNodeIds ) ; }
public void testFailoverNodes ( final String memcachedNodes , final String failoverNodes , final List < String > expectedFailoverNodeIds ) { final MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; assertNotNull ( result ) ; assertEquals ( result . getFailoverNodeIds ( ) , expectedFailoverNodeIds ) ; }
public void testIsEncodeNodeIdInSessionId ( final String memcachedNodes , final String failoverNodes , final boolean expectedIsEncodeNodeIdInSessionId ) { final MemcachedNodesManager result = createFor ( memcachedNodes , null , null , _mcc ) ; assertNotNull ( result ) ; assertEquals ( result . isEncodeNodeIdInSessionId ( ) , expectedIsEncodeNodeIdInSessionId ) ; }
public void testGetNodeIdShouldThrowExceptionForNullArgument ( ) { final MemcachedNodesManager result = createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) ; result . getNodeId ( null ) ; }
public void testGetNodeId ( final String memcachedNodes , final String failoverNodes , final InetSocketAddress socketAddress , final String expectedNodeId ) { final MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; assertEquals ( result . getNodeId ( socketAddress ) , expectedNodeId ) ; }
public void testGetNextPrimaryNodeId ( ) { assertNull ( createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) . getNextPrimaryNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 " , null , null , _mcc ) . getNextPrimaryNodeId ( " n1 " ) , " n2 " ) ; }
public void testGetNextAvailableNodeId ( ) throws IOException { assertNull ( createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) , " n2 " ) ; final StorageClientCallback mcc = mock ( StorageClientCallback . class ) ; when ( mcc . get ( anyString ( ) ) ) . thenReturn ( null ) ; when ( mcc . get ( endsWith ( " n2 " ) ) ) . thenThrow ( new OperationTimeoutException ( " SimulatedException " ) ) ; assertNull ( createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 , n3 : localhost : 11213 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) , " n3 " ) ; }
public void testGetAllMemcachedAddresses ( final String memcachedNodes , final String failoverNodes , final Collection < InetSocketAddress > expectedSocketAddresses ) { final MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; assertEquals ( result . getAllMemcachedAddresses ( ) , expectedSocketAddresses ) ; }
public void testGetSessionIdFormat ( ) { final SessionIdFormat sessionIdFormat = createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) . getSessionIdFormat ( ) ; assertNotNull ( sessionIdFormat ) ; }
public void testSessionIdFormatForSingleNodeSetupShouldSupportLocking ( ) { final SessionIdFormat sessionIdFormat = createFor ( " localhost : 11211 " , null , StorageKeyFormat . EMPTY , _mcc ) . getSessionIdFormat ( ) ; assertNotNull ( sessionIdFormat ) ; final String sessionId = " 12345678 " ; assertEquals ( sessionIdFormat . createLockName ( sessionId ) , " lock : " + sessionId ) ; }
public void testCreateSessionIdShouldOnlyAddNodeIdIfPresent ( ) { assertEquals ( createFor ( " n1 : localhost : 11211 " , null , null , _mcc ) . createSessionId ( " foo " ) , " foo - n1 " ) ; assertEquals ( createFor ( " localhost : 11211 " , null , null , _mcc ) . createSessionId ( " foo " ) , " foo " ) ; }
public void testSetNodeAvailable ( ) { final MemcachedNodesManager cut = createFor ( " n1 : localhost : 11211 , n2 : localhost : 11212 " , null , null , _mcc ) ; assertTrue ( cut . isNodeAvailable ( " n1 " ) ) ; assertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; cut . setNodeAvailable ( " n1 " , false ) ; assertFalse ( cut . isNodeAvailable ( " n1 " ) ) ; assertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; }
public void testIsCouchbaseBucketConfig ( ) { assertTrue ( createFor ( " http : / / 10 . 10 . 0 . 1 : 8091 / pools " , null , null , _mcc ) . isCouchbaseBucketConfig ( ) ) ; assertTrue ( createFor ( " http : / / 10 . 10 . 0 . 1 : 8091 / pools , http : / / 10 . 10 . 0 . 2 : 8091 / pools " , null , null , _mcc ) . isCouchbaseBucketConfig ( ) ) ; }
private static String sessionId ( final String plainId , final String memcachedId , final String jvmRoute ) { final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final String withMemcachedId = sessionIdFormat . createSessionId ( plainId , memcachedId ) ; return jvmRoute ! = null ? sessionIdFormat . changeJvmRoute ( withMemcachedId , jvmRoute ) : withMemcachedId ; }
public void testBlankValue ( ) { assertEquals ( StorageKeyFormat . of ( null , null , null , null ) . format ( " foo " ) , " foo " ) ; assertEquals ( StorageKeyFormat . of ( " " , null , null , null ) . format ( " foo " ) , " foo " ) ; }
public void testPrefixBuilderFactory ( ) { final String prefix = PrefixTokenFactory . parse ( " static : foo " , null , null , null ) ; assertEquals ( prefix , " foo " ) ; }
public void testStaticValue ( ) { final StorageKeyFormat cut = StorageKeyFormat . of ( " static : x " , null , null , null ) ; assertNotNull ( cut ) ; assertEquals ( cut . format ( " foo " ) , " x_foo " ) ; }
public void testHost ( ) { final StorageKeyFormat cut = StorageKeyFormat . of ( " host " , " hst " , null , null ) ; assertNotNull ( cut ) ; assertEquals ( cut . format ( " foo " ) , " hst_foo " ) ; }
public void testHostHash ( ) { final StorageKeyFormat cut = StorageKeyFormat . of ( " host . hash " , " hst " , null , null ) ; assertNotNull ( cut ) ; assertEquals ( cut . format ( " foo " ) , hashString ( " hst " ) + " _foo " ) ; }
public void testContext ( ) { assertEquals ( StorageKeyFormat . of ( " context " , null , " ctxt " , null ) . format ( " foo " ) , " ctxt_foo " ) ; assertEquals ( StorageKeyFormat . of ( " context " , null , null , null ) . format ( " foo " ) , " foo " ) ; assertEquals ( StorageKeyFormat . of ( " context " , null , " " , null ) . format ( " foo " ) , " foo " ) ; }
public void testContextHash ( ) { assertEquals ( StorageKeyFormat . of ( " context . hash " , null , " ctxt " , null ) . format ( " foo " ) , hashString ( " ctxt " ) + " _foo " ) ; }
public void testWebappVersion ( ) { assertEquals ( StorageKeyFormat . of ( " webappVersion " , null , null , " 001 " ) . format ( " foo " ) , " 001_foo " ) ; assertEquals ( StorageKeyFormat . of ( " webappVersion " , null , null , null ) . format ( " foo " ) , " foo " ) ; assertEquals ( StorageKeyFormat . of ( " webappVersion " , null , null , " " ) . format ( " foo " ) , " foo " ) ; }
public void testHostAndContext ( ) { assertEquals ( StorageKeyFormat . of ( " host , context " , " hst " , " ctxt " , null ) . format ( " foo " ) , " hst : ctxt_foo " ) ; assertEquals ( StorageKeyFormat . of ( " host , context " , " hst " , " " , null ) . format ( " foo " ) , " hst_foo " ) ; }
public void testHostAndContextHashesWithWebappVersion ( ) { final StorageKeyFormat cut = StorageKeyFormat . of ( " host . hash , context . hash , webappVersion " , " hst " , " ctxt " , " 001 " ) ; assertNotNull ( cut ) ; assertEquals ( cut . format ( " foo " ) , hashString ( " hst " ) + " : " + hashString ( " ctxt " ) + " : 001_foo " ) ; }
public void beforeMethod ( ) { cut = new MemcachedBackupSession ( ) ; executor = Executors . newCachedThreadPool ( ) ; alternateExecutor = Executors . newCachedThreadPool ( ) ; }
public void afterMethod ( ) { executor . shutdown ( ) ; alternateExecutor . shutdown ( ) ; }
public void testRefCount ( ) throws InterruptedException , ExecutionException { assertEquals ( cut . getRefCount ( ) , 0 ) ; cut . registerReference ( ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; cut . releaseReference ( ) ; assertEquals ( cut . getRefCount ( ) , 0 ) ; final Runnable registerReference = new Runnable ( ) { @ Override public void run ( ) { cut . registerReference ( ) ; } } ; executor . submit ( registerReference ) . get ( ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; alternateExecutor . submit ( registerReference ) . get ( ) ; assertEquals ( cut . getRefCount ( ) , 2 ) ; cut . releaseReference ( ) ; assertEquals ( cut . getRefCount ( ) , 2 ) ; }
public void afterMethod ( ) { _executor . shutdown ( ) ; }
protected void startInternal ( @ Nonnull final SessionManager manager , @ Nonnull final MemcachedClient memcachedMock ) throws LifecycleException { throw new UnsupportedOperationException ( ) ; }
public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 , n2 : 127 . 0 . 0 . 1 : 11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; }
public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 n3 : 127 . 0 . 0 . 1 : 11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 n3 : 127 . 0 . 0 . 1 : 11213 " ) ; _service . setFailoverNodes ( " n1 , n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; }
public void testConfigurationFormatMemcachedNodesFeature105 ( ) throws LifecycleException { _service . setMemcachedNodes ( " 127 . 0 . 0 . 1 : 11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . getCountNodes ( ) , 1 ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isEncodeNodeIdInSessionId ( ) , false ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 " ) , true ) ; _service . shutdown ( ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . getCountNodes ( ) , 1 ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isEncodeNodeIdInSessionId ( ) , true ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 " ) , false ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 - n1 " ) , true ) ; }
public void testBackupSessionFailureWithoutMemcachedNodeIdConfigured105 ( ) throws Exception { _service . setMemcachedNodes ( " 127 . 0 . 0 . 1 : 11211 " ) ; _service . setSessionBackupAsync ( false ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; final MemcachedBackupSession session = createSession ( _service ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; @ SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > futureMock = mock ( OperationFuture . class ) ; when ( futureMock . get ( ) ) . thenThrow ( new ExecutionException ( new RuntimeException ( " Simulated exception . " ) ) ) ; when ( futureMock . get ( anyInt ( ) , any ( TimeUnit . class ) ) ) . thenThrow ( new ExecutionException ( new RuntimeException ( " Simulated exception . " ) ) ) ; when ( _memcachedMock . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ) . thenReturn ( futureMock ) ; final BackupResult backupResult = _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . FAILURE ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ; }
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1 : 127 . 0 . 0 . 1 : 11211 n2 : 127 . 0 . 0 . 1 : 11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; final String sessionId = " someSessionNotLoaded - n1 " ; final String validityKey = new SessionIdFormat ( ) . createValidityInfoKeyName ( sessionId ) ; final byte [ ] validityData = encode ( - 1 , System . currentTimeMillis ( ) , System . currentTimeMillis ( ) ) ; when ( _memcachedMock . get ( eq ( validityKey ) , any ( Transcoder . class ) ) ) . thenReturn ( validityData ) ; @ SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > futureMock = mock ( OperationFuture . class ) ; when ( futureMock . get ( ) ) . thenReturn ( Boolean . FALSE ) ; when ( futureMock . get ( anyInt ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( Boolean . FALSE ) ; when ( _memcachedMock . add ( any ( String . class ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ) . thenReturn ( futureMock ) ; _service . backupSession ( sessionId , false , " unused " ) . get ( ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( validityKey ) , eq ( 0 ) , any ( ) , any ( Transcoder . class ) ) ; _service . getLockingStrategy ( ) . getExecutorService ( ) . shutdown ( ) ; Thread . sleep ( 15 ) ; verify ( _memcachedMock , times ( 1 ) ) . add ( eq ( sessionId ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ; final String backupSessionKey = new SessionIdFormat ( ) . createBackupKey ( sessionId ) ; verify ( _memcachedMock , times ( 1 ) ) . add ( eq ( backupSessionKey ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ; final String backupValidityKey = new SessionIdFormat ( ) . createBackupKey ( validityKey ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( backupValidityKey ) , eq ( 0 ) , any ( ) , any ( Transcoder . class ) ) ; }
public BackupResult call ( ) throws Exception { final MemcachedBackupSession session3 = _service . findSession ( session . getId ( ) ) ; assertSame ( session3 , session2 ) ; assertEquals ( session3 . getRefCount ( ) , 2 ) ; barrier . await ( ) ; barrier . await ( ) ; final Future < BackupResult > result = _service . backupSession ( session . getId ( ) , false , " unused " ) ; _service . getTrackingHostValve ( ) . resetRequestThreadLocal ( ) ; assertEquals ( result . get ( ) . getStatus ( ) , BackupResultStatus . SUCCESS ) ; assertFalse ( _service . getManager ( ) . getSessionsInternal ( ) . containsKey ( session . getId ( ) ) ) ; assertEquals ( session2 . getRefCount ( ) , 0 ) ; return result . get ( ) ; }
public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137 ( ) throws Exception { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; final String sessionId = " nonStickySessionToTimeOut - n1 " ; final Request requestMock = mock ( Request . class ) ; when ( requestMock . getNote ( eq ( RequestTrackingContextValve . INVOKED ) ) ) . thenReturn ( Boolean . TRUE ) ; _service . getTrackingHostValve ( ) . storeRequestThreadLocal ( requestMock ) ; final MemcachedBackupSession session = _service . findSession ( sessionId ) ; assertNull ( session ) ; _service . backupSession ( sessionId , false , null ) . get ( ) ; final String validityKey = new SessionIdFormat ( ) . createValidityInfoKeyName ( sessionId ) ; verify ( _memcachedMock , times ( 0 ) ) . get ( eq ( validityKey ) ) ; }
public void testDecodeEncodedData ( ) { final byte [ ] encoded = SessionValidityInfo . encode ( 23 , 42 , 4711 ) ; final SessionValidityInfo decoded = SessionValidityInfo . decode ( encoded ) ; assertEquals ( decoded . getMaxInactiveInterval ( ) , 23 ) ; assertEquals ( decoded . getLastAccessedTime ( ) , 42 ) ; assertEquals ( decoded . getThisAccessedTime ( ) , 4711 ) ; }
public void negativeInactivityAlwaysValid ( ) { final SessionValidityInfo info = new SessionValidityInfo ( - 1 , 0 , 0 ) ; assertTrue ( info . isValid ( ) ) ; }
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESS ) ) ) . thenReturn ( Boolean . TRUE ) ; }
protected RequestTrackingContextValve createSessionTrackerValve ( ) { return new RequestTrackingContextValve ( " foo " , _service ) ; }
public final void testGetSessionCookieName ( ) throws IOException , ServletException { final RequestTrackingContextValve cut = new RequestTrackingContextValve ( " foo " , _service ) ; assertEquals ( cut . getSessionCookieName ( ) , " foo " ) ; }
public final void testRequestIsMarkedAsProcessed ( ) throws IOException , ServletException { _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _request ) . setNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) , eq ( Boolean . TRUE ) ) ; }
protected void beforeTest ( ) { Configuration configuration = new Configuration ( ) . addAnnotatedClass ( Person . class ) . addAnnotatedClass ( Animal . class ) . configure ( ) ; StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder ( ) . applySettings ( configuration . getProperties ( ) ) . build ( ) ; _sessionFactory = configuration . buildSessionFactory ( serviceRegistry ) ; }
private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @ Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @ SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; }
public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @ SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; }
private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @ Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; }
public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; }
public String toString ( ) { return " Person [ id = " + id + " , name = " + name + " , animals = " + animals + " ] " ; }
public String toString ( ) { return " Animal [ id = " + id + " , name = " + name + " ] " ; }
protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; final StandardContext context = createContext ( ) ; when ( manager . getContext ( ) ) . thenReturn ( context ) ; when ( manager . getContainer ( ) ) . thenReturn ( context ) ; when ( manager . getMemcachedSessionService ( ) ) . thenReturn ( newMemcachedSessionService ( manager ) ) ; when ( manager . newMemcachedBackupSession ( ) ) . thenReturn ( new MemcachedBackupSession ( manager ) ) ; when ( manager . willAttributeDistribute ( anyString ( ) , anyObject ( ) ) ) . thenReturn ( true ) ; return manager ; }
protected MemcachedSessionService newMemcachedSessionService ( final SessionManager manager ) { return new MemcachedSessionService ( manager ) ; }
private static MemcachedBackupSession createSession ( final SessionManager manager , final String id ) { final MemcachedBackupSession session = manager . getMemcachedSessionService ( ) . createEmptySession ( ) ; session . setId ( id ) ; session . setValid ( true ) ; return session ; }
public static String loginWithForm ( final DefaultHttpClient client , final int tcPort ) throws IOException , HttpException { final Response tc1Response1 = get ( client , tcPort , null ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( tc1Response1 . getContent ( ) . contains ( " j_security_check " ) , " / j_security_check not found , app is not properly initialized " ) ; final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( LoginServlet . J_USERNAME , TestUtils . USER_NAME ) ; params . put ( LoginServlet . J_PASSWORD , TestUtils . PASSWORD ) ; final Response tc1Response2 = post ( client , tcPort , " / j_security_check " , sessionId , params ) ; assertEquals ( tc1Response2 . getSessionId ( ) , sessionId ) ; assertEquals ( tc1Response2 . get ( TestServlet . ID ) , sessionId ) ; return tc1Response2 . getSessionId ( ) ; }
public static Response get ( final DefaultHttpClient client , final int port , final String rsessionId ) throws IOException , HttpException { return get ( client , port , null , rsessionId ) ; }
public static Response get ( final DefaultHttpClient client , final int port , final String rsessionId , final Credentials credentials ) throws IOException , HttpException { return get ( client , port , null , rsessionId , null , null , credentials ) ; }
public static Response get ( final DefaultHttpClient client , final int port , final String path , final String rsessionId ) throws IOException , HttpException { return get ( client , port , path , rsessionId , null , null , null ) ; }
public static Response get ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { return get ( client , port , path , rsessionId , null , params , null ) ; }
private static String getUrl ( final int port , String path ) throws IllegalArgumentException { if ( path ! = null & & ! path . startsWith ( " / " ) ) { path = CONTEXT_PATH + path ; } return " http : / / " + DEFAULT_HOST + " : " + port + ( path ! = null ? path : CONTEXT_PATH ) ; }
private static String toQueryString ( final Map < String , String > params ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " ? " ) ; for ( final Iterator < Entry < String , String > > iterator = params . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { final Entry < String , String > entry = iterator . next ( ) ; sb . append ( entry . getKey ( ) ) . append ( " = " ) . append ( entry . getValue ( ) ) ; if ( iterator . hasNext ( ) ) { sb . append ( " & " ) ; } } final String qs = sb . toString ( ) ; return qs ; }
private static HttpResponse executeRequestWithAuth ( final DefaultHttpClient client , final HttpUriRequest method , final Credentials credentials ) throws IOException , ClientProtocolException { client . getCredentialsProvider ( ) . setCredentials ( AuthScope . ANY , credentials ) ; final BasicHttpContext localcontext = new BasicHttpContext ( ) ; final BasicScheme basicAuth = new BasicScheme ( ) ; localcontext . setAttribute ( " preemptive - auth " , basicAuth ) ; return client . execute ( method , localcontext ) ; }
public static Response post ( final DefaultHttpClient client , final int port , final String rsessionId , final String paramName , final String paramValue ) throws IOException , HttpException { final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( paramName , paramValue ) ; return post ( client , port , null , rsessionId , params ) ; }
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { return post ( client , port , path , rsessionId , params , null , true ) ; }
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params , @ Nullable final Credentials credentials , final boolean followRedirects ) throws IOException , HttpException { final String baseUri = " http : / / " + DEFAULT_HOST + " : " + port ; final String url = getUrl ( port , path ) ; final HttpPost method = new HttpPost ( url ) ; if ( rsessionId ! = null ) { method . setHeader ( " Cookie " , " JSESSIONID = " + rsessionId ) ; } method . setEntity ( createFormEntity ( params ) ) ; if ( ! followRedirects ) { HttpClientParams . setRedirecting ( method . getParams ( ) , false ) ; } final HttpResponse response = credentials = = null ? client . execute ( method ) : executeRequestWithAuth ( client , method , credentials ) ; final int statusCode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( followRedirects & & isRedirect ( statusCode ) ) { return redirect ( response , client , port , rsessionId , baseUri ) ; } if ( statusCode ! = 200 & & ! ( ! followRedirects & & isRedirect ( statusCode ) ) ) { throw new RuntimeException ( " POST " + ( path ! = null ? " " + path : " " ) + " did not return status 200 , but " + response . getStatusLine ( ) + " \ n " + toString ( response . getEntity ( ) . getContent ( ) ) ) ; } return readResponse ( rsessionId , response ) ; }
public static boolean isRedirect ( final int statusCode ) { return statusCode = = 302 | | statusCode = = 303 ; }
public static String toString ( final InputStream in ) { final StringBuilder sb = new StringBuilder ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) ! = null ) { sb . append ( line ) ; } } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader ! = null ) { try { reader . close ( ) ; } catch ( final IOException e ) { } } } return sb . toString ( ) ; }
private static Response redirect ( final HttpResponse response , final DefaultHttpClient client , final int port , final String rsessionId , final String baseUri ) throws IOException , HttpException { EntityUtils . consume ( response . getEntity ( ) ) ; final String location = response . getFirstHeader ( " Location " ) . getValue ( ) ; final String redirectPath = location . startsWith ( baseUri ) ? location . substring ( baseUri . length ( ) , location . length ( ) ) : location ; return get ( client , port , redirectPath , rsessionId ) ; }
private static UrlEncodedFormEntity createFormEntity ( final Map < String , String > params ) throws UnsupportedEncodingException { final List < NameValuePair > parameters = new ArrayList < NameValuePair > ( ) ; for ( final Map . Entry < String , String > param : params . entrySet ( ) ) { parameters . add ( new BasicNameValuePair ( param . getKey ( ) , param . getValue ( ) ) ) ; } final UrlEncodedFormEntity entity = new UrlEncodedFormEntity ( parameters , HTTP . UTF_8 ) ; return entity ; }
public static MemCacheDaemon < ? extends CacheElement > createDaemon ( final InetSocketAddress address ) throws IOException { final MemCacheDaemon < LocalCacheElement > daemon = new MemCacheDaemon < LocalCacheElement > ( ) ; final ConcurrentLinkedHashMap < Key , LocalCacheElement > cacheStorage = ConcurrentLinkedHashMap . create ( EvictionPolicy . LRU , 100000 , 1024 * 1024 ) ; daemon . setCache ( new CacheImpl ( cacheStorage ) ) ; daemon . setAddr ( address ) ; daemon . setVerbose ( true ) ; return daemon ; }
public String get ( final String key ) { return _keyValues . get ( key ) ; }
public static void assertDeepEquals ( final Object one , final Object another ) { assertDeepEquals ( one , another , new IdentityHashMap < Object , Object > ( ) ) ; }
public void sessionDidActivate ( final HttpSessionEvent se ) { _sessionDidActivate = se . getSession ( ) . getId ( ) ; }
public static Key key ( @ Nonnull final String value ) { return new Key ( ChannelBuffers . wrappedBuffer ( value . getBytes ( ) ) ) ; }
public static MemcachedBackupSession createSession ( @ Nonnull final MemcachedSessionService service ) { final MemcachedBackupSession session = service . createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( 23 ) ; session . setId ( " foo - n1 " ) ; return session ; }
public static void waitForReconnect ( final StorageClient client , final int expectedNumServers , final long timeToWait ) throws InterruptedException { waitForReconnect ( ( ( MemcachedStorageClient ) client ) . getMemcachedClient ( ) , expectedNumServers , timeToWait ) ; }
public static < T , V > T assertNotNullElementWaitingWithProxy ( final int elementIndex , final long maxTimeToWait , final T objectToProxy ) { return assertWaitingWithProxy ( elementAt ( elementIndex , notNull ( ) ) , maxTimeToWait , objectToProxy ) ; }
public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { return assertPredicateWaiting ( predicate , maxTimeToWait , objectToProxy , method , args ) ; }
public boolean apply ( final Object input ) { return input ! = null ; }
public boolean apply ( final Object input ) { return input = = null ; }
public static < T > Predicate < T > notNull ( ) { return ( Predicate < T > ) NOT_NULL ; }
public static < T > Predicate < T > isNull ( ) { return ( Predicate < T > ) IS_NULL ; }
public boolean apply ( final T input ) { return target . equals ( input ) ; }
public byte [ ] get ( final String key ) { return _client . get ( key , ByteArrayTranscoder . INSTANCE ) ; }
public void setUp ( ) throws Throwable { final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_1 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_2 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( MEMCACHED_NODES , null , null , _storageClientCallback ) ; _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) , Arrays . asList ( address1 , address2 ) ) ; final SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ; schemeRegistry . register ( new Scheme ( " http " , 80 , PlainSocketFactory . getSocketFactory ( ) ) ) ; _httpClient = new DefaultHttpClient ( new ThreadSafeClientConnManager ( schemeRegistry ) ) ; _executor = Executors . newCachedThreadPool ( ) ; }
private TomcatBuilder < ? > startTomcat ( final int port ) throws Exception { return startTomcat ( port , MEMCACHED_NODES , null ) ; }
public void tearDown ( ) throws Exception { _client . shutdown ( 10 , SECONDS ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; if ( _daemon3 ! = null & & _daemon3 . isRunning ( ) ) { _daemon3 . stop ( ) ; } _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _executor . shutdownNow ( ) ; }
public void testLoadBackupSessionShouldWorkWithInfiniteSessionTimeoutIssue120 ( @ Nonnull final LockingMode lockingMode , @ Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( - 1 ) ; setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Thread . sleep ( 200 ) ; Response response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; final SessionIdFormat fmt = new SessionIdFormat ( ) ; final String nodeId = fmt . extractMemcachedId ( sessionId ) ; final MemCacheDaemon < ? > primary = NODE_ID_1 . equals ( nodeId ) ? _daemon1 : _daemon2 ; primary . stop ( ) ; Thread . sleep ( 200 ) ; response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( fmt . createNewSessionId ( response . getSessionId ( ) , nodeId ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; }
public void testLoadBackupSessionShouldWorkWithHighSessionTimeoutIssue104 ( @ Nonnull final LockingMode lockingMode , @ Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 60 * 60 * 24 * 30 / 2 + 1 ) ; setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Thread . sleep ( 200 ) ; Response response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; final SessionIdFormat fmt = new SessionIdFormat ( ) ; final String nodeId = fmt . extractMemcachedId ( sessionId ) ; final MemCacheDaemon < ? > primary = NODE_ID_1 . equals ( nodeId ) ? _daemon1 : _daemon2 ; primary . stop ( ) ; Thread . sleep ( 200 ) ; response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( fmt . createNewSessionId ( response . getSessionId ( ) , nodeId ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; }
public void testSessionLockingSupportedWithSingleNodeSetup ( @ Nonnull final LockingMode lockingMode , @ Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMemcachedNodes ( " localhost : " + MEMCACHED_PORT_1 ) ; _tomcat1 . getManager ( ) . setLockingMode ( lockingMode , uriPattern , false ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Response response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; post ( _httpClient , TC_PORT_1 , sessionId , " k2 " , " v2 " ) ; response = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( " k1 " ) , " v1 " ) ; assertEquals ( response . get ( " k2 " ) , " v2 " ) ; }
public void testParallelRequestsToSameTomcatInstanceIssue111 ( @ Nonnull final LockingMode lockingMode , @ Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; final Future < Response > response2 = _executor . submit ( new Callable < Response > ( ) { @ Override public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , " k2 " , " v2 " ) ) ; } } ) ; Thread . sleep ( 200 ) ; post ( _httpClient , TC_PORT_1 , sessionId , " k3 " , " v3 " ) ; final Response finalResponse = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( finalResponse . getSessionId ( ) , sessionId ) ; assertEquals ( response2 . get ( ) . getSessionId ( ) , sessionId ) ; assertEquals ( finalResponse . get ( " k1 " ) , " v1 " ) ; assertEquals ( finalResponse . get ( " k2 " ) , " v2 " ) ; assertEquals ( finalResponse . get ( " k3 " ) , " v3 " ) ; }
public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , " k2 " , " v2 " ) ) ; }
public Object call ( ) throws Exception { return _client . get ( sessionId1 ) ; }
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , paramsWait ) ; }
public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , " foo " , " bar " ) ) ; }
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_1 , " / pathNotMatchingLockUriPattern " , sessionId , paramsWait ) ; }
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_1 , pathToLock , sessionId , paramsWait ) ; }
public void testSessionNotLoadedForNoSessionAccess ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setMemcachedNodes ( NODE_ID_1 + " : localhost : " + MEMCACHED_PORT_1 ) ; waitForReconnect ( _tomcat1 . getService ( ) . getStorageClient ( ) , 1 , 1000 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; assertWaitingWithProxy ( equalTo ( 2 ) , 1000 , _daemon1 . getCache ( ) ) . getSetCmds ( ) ; assertEquals ( _daemon1 . getCache ( ) . getGetHits ( ) , 0 ) ; get ( _httpClient , TC_PORT_1 , PATH_NO_SESSION_ACCESS , sessionId1 ) ; assertWaitingWithProxy ( equalTo ( 3 ) , 1000 , _daemon1 . getCache ( ) ) . getSetCmds ( ) ; assertEquals ( _daemon1 . getCache ( ) . getGetHits ( ) , getExpectedHitsForNoSessionAccess ( ) ) ; }
public void testInvalidateSessionShouldReleaseLockIssue144 ( ) throws IOException , InterruptedException , HttpException { _tomcat1 . getManager ( ) . setLockingMode ( LockingMode . AUTO . name ( ) ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created . " ) ; final Response response = get ( _httpClient , TC_PORT_1 , PATH_INVALIDATE , sessionId1 ) ; assertNull ( response . getResponseSessionId ( ) ) ; assertNull ( _client . get ( sessionId1 ) , " Invalidated session should be removed from memcached " ) ; assertNull ( _client . get ( new SessionIdFormat ( ) . createLockName ( sessionId1 ) ) , " Lock should be released . " ) ; }
private TomcatBuilder < ? > startTomcatWithAuth ( final int port , @ Nonnull final LockingMode lockingMode ) throws Exception { return startTomcatWithAuth ( port , MEMCACHED_NODES , lockingMode , LoginType . BASIC ) ; }
public void setUp ( final Method testMethod ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? NODE_ID + " : " : " " ; _memcachedNodes = nodePrefix + " localhost : " + MEMCACHED_PORT ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( _memcachedNodes , null , null , _storageClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; _client = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; }
private TomcatBuilder < ? > startTomcat ( final int port , final String jvmRoute ) throws Exception { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; }
public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute ( ) throws Exception { final SessionManager manager1 = _tomcat1 . getManager ( ) ; final SessionManager manager2 = _tomcat2 . getManager ( ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertEquals ( format . extractJvmRoute ( sessionId1 ) , JVM_ROUTE_1 ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( format . stripJvmRoute ( sessionId2 ) , format . stripJvmRoute ( sessionId1 ) ) ; assertEquals ( format . extractJvmRoute ( sessionId2 ) , JVM_ROUTE_2 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; }
public void testHttpSessionActivationListenersNotifiedOnLoadWithoutJvmRoute ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , null ) ; _tomcat2 = startTomcat ( TC_PORT_2 , null ) ; final SessionManager manager1 = _tomcat1 . getManager ( ) ; final SessionManager manager2 = _tomcat2 . getManager ( ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNull ( format . extractJvmRoute ( sessionId1 ) ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( sessionId2 , sessionId1 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; }
public void testTomcatFailoverWithSingleNodeWithoutConfiguredNodeId ( ) throws IOException , InterruptedException , HttpException { testTomcatFailover ( ) ; }
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_2 , sessionId1 ) ; }
public boolean matchesSafely ( Response response ) { final String sessionId2 = response . getSessionId ( ) ; return format . extractMemcachedId ( sessionId2 ) . equals ( " n1 " ) ; }
private MemCacheDaemon < ? > startMemcached ( final int memcachedPort ) throws IOException { final InetSocketAddress address = new InetSocketAddress ( " localhost " , memcachedPort ) ; final MemCacheDaemon < ? > daemon2 = createDaemon ( address ) ; daemon2 . start ( ) ; return daemon2 ; }
public void init ( final ServletConfig config ) throws ServletException { super . init ( config ) ; defaultServlet = new DefaultServlet ( ) ; defaultServlet . init ( config ) ; }
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . sessionTimeout ( 10 ) . memcachedNodes ( memcachedNodes ) . sticky ( true ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat . " , e ) ; throw e ; } _httpClient = new DefaultHttpClient ( ) ; }
private String toString ( final String nodeId , final InetSocketAddress address ) { return nodeId + " : " + address . getHostName ( ) + " : " + address . getPort ( ) ; }
public void tearDown ( ) throws Exception { if ( _daemon1 . isRunning ( ) ) { _daemon1 . stop ( ) ; } if ( _daemon2 . isRunning ( ) ) { _daemon2 . stop ( ) ; } if ( _daemon3 . isRunning ( ) ) { _daemon3 . stop ( ) ; } _tomcat1 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; }
private void waitForReconnect ( final MemcachedSessionService service , final MemCacheDaemon < ? > value , final long timeToWait ) throws InterruptedException { MemcachedClient client ; InetSocketAddress serverAddress ; try { final Method m = MemcachedSessionService . class . getDeclaredMethod ( " getStorageClient " ) ; m . setAccessible ( true ) ; client = ( ( MemcachedStorageClient ) m . invoke ( service ) ) . getMemcachedClient ( ) ; final Field field = MemCacheDaemon . class . getDeclaredField ( " addr " ) ; field . setAccessible ( true ) ; serverAddress = ( InetSocketAddress ) field . get ( value ) ; } catch ( final Exception e ) { throw new RuntimeException ( e ) ; } waitForReconnect ( client , serverAddress , timeToWait ) ; }
private Set < String > toArray ( final Iterator < String > noteNames ) { final Set < String > result = new HashSet < String > ( ) ; while ( noteNames . hasNext ( ) ) { result . add ( noteNames . next ( ) ) ; } return result ; }
private void restartTomcat ( final String memcachedNodes , final String failoverNodes ) throws Exception { _tomcat1 . stop ( ) ; Thread . sleep ( 500 ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . sessionTimeout ( 10 ) . memcachedNodes ( memcachedNodes ) . failoverNodes ( failoverNodes ) . buildAndStart ( ) ; }
private Map < String , Session > getSessions ( ) throws NoSuchFieldException , IllegalAccessException { final Field field = ManagerBase . class . getDeclaredField ( " sessions " ) ; field . setAccessible ( true ) ; @ SuppressWarnings ( " unchecked " ) final Map < String , Session > sessions = ( Map < String , Session > ) field . get ( _tomcat1 . getManager ( ) ) ; return sessions ; }
private Map < String , MemCacheDaemon < ? > > asMap ( final String nodeId1 , final MemCacheDaemon < ? > daemon1 , final String nodeId2 , final MemCacheDaemon < ? > daemon2 ) { final Map < String , MemCacheDaemon < ? > > result = new LinkedHashMap < String , MemCacheDaemon < ? > > ( 2 ) ; result . put ( nodeId1 , daemon1 ) ; result . put ( nodeId2 , daemon2 ) ; return result ; }
public Entry < String , MemCacheDaemon < ? > > nextNode ( ) { return otherNodes . entrySet ( ) . iterator ( ) . next ( ) ; }
public Entry < String , MemCacheDaemon < ? > > previousNode ( ) { Entry < String , MemCacheDaemon < ? > > last = null ; for ( final Entry < String , MemCacheDaemon < ? > > entry : otherNodes . entrySet ( ) ) { last = entry ; } return last ; }
public TomcatBuilder < T > port ( final int port ) { this . port = port ; return this ; }
public TomcatBuilder < T > sessionTimeout ( final int sessionTimeout ) { this . sessionTimeout = sessionTimeout ; return this ; }
public TomcatBuilder < T > cookies ( final boolean cookies ) { this . cookies = cookies ; return this ; }
public TomcatBuilder < T > memcachedNodes ( final String memcachedNodes ) { this . memcachedNodes = memcachedNodes ; return this ; }
public TomcatBuilder < T > failoverNodes ( final String failoverNodes ) { this . failoverNodes = failoverNodes ; return this ; }
public TomcatBuilder < T > storageKeyPrefix ( final String storageKeyPrefix ) { this . storageKeyPrefix = storageKeyPrefix ; return this ; }
public TomcatBuilder < T > enabled ( final boolean enabled ) { this . enabled = enabled ; return this ; }
public TomcatBuilder < T > sticky ( final boolean sticky ) { this . sticky = sticky ; return this ; }
public TomcatBuilder < T > lockingMode ( final LockingMode lockingMode ) { this . lockingMode = lockingMode ; return this ; }
public TomcatBuilder < T > lockExpire ( final int lockExpire ) { this . lockExpire = lockExpire ; return this ; }
public TomcatBuilder < T > memcachedProtocol ( final String memcachedProtocol ) { this . memcachedProtocol = memcachedProtocol ; return this ; }
public TomcatBuilder < T > username ( final String memcachedUsername ) { this . username = memcachedUsername ; return this ; }
public TomcatBuilder < T > jvmRoute ( final String jvmRoute ) { this . jvmRoute = jvmRoute ; return this ; }
public TomcatBuilder < T > loginType ( final LoginType loginType ) { this . loginType = loginType ; return this ; }
public TomcatBuilder < T > transcoderFactoryClassName ( final String transcoderFactoryClassName ) { this . transcoderFactoryClassName = transcoderFactoryClassName ; return this ; }
protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; }
public void testFunctions ( ) throws Exception { RedisStorageClient client = createClient ( ) ; assertTrue ( client . add ( " key1 " , 0 , toBytes ( " foo " ) ) . get ( ) ) ; assertTrue ( client . add ( " key2 " , 0 , toBytes ( " bar " ) ) . get ( ) ) ; assertEquals ( " foo " , toString ( client . get ( " key1 " ) ) ) ; assertEquals ( " bar " , toString ( client . get ( " key2 " ) ) ) ; assertTrue ( client . set ( " key1 " , 0 , toBytes ( " baz " ) ) . get ( ) ) ; assertFalse ( client . add ( " key2 " , 0 , toBytes ( " zoom " ) ) . get ( ) ) ; assertEquals ( " baz " , toString ( client . get ( " key1 " ) ) ) ; assertEquals ( " bar " , toString ( client . get ( " key2 " ) ) ) ; assertTrue ( client . delete ( " key1 " ) . get ( ) ) ; assertNull ( client . get ( " key1 " ) ) ; assertEquals ( " bar " , toString ( client . get ( " key2 " ) ) ) ; client . shutdown ( ) ; }
public void testExpirationSeconds ( ) throws Exception { RedisStorageClient client = createClient ( ) ; assertTrue ( client . add ( " exp " , 2 , toBytes ( " foo " ) ) . get ( ) ) ; Thread . sleep ( 1000 ) ; assertEquals ( " foo " , toString ( client . get ( " exp " ) ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " exp " ) ) ; client . shutdown ( ) ; }
public void testExpirationTime ( ) throws Exception { RedisStorageClient client = createClient ( ) ; assertTrue ( client . add ( " exp " , ( int ) ( 2 + ( System . currentTimeMillis ( ) / 1000 ) ) , toBytes ( " foo " ) ) . get ( ) ) ; assertEquals ( " foo " , toString ( client . get ( " exp " ) ) ) ; Thread . sleep ( 1000 ) ; assertEquals ( " foo " , toString ( client . get ( " exp " ) ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " exp " ) ) ; client . shutdown ( ) ; }
public void testAutoReconnect ( ) throws Exception { RedisStorageClient client = createClient ( ) ; assertTrue ( client . add ( " key1 " , 0 , toBytes ( " foo " ) ) . get ( ) ) ; assertEquals ( " foo " , toString ( client . get ( " key1 " ) ) ) ; if ( ! redisProvided ) { embeddedRedisServer . stop ( ) ; embeddedRedisServer . start ( ) ; } assertTrue ( client . add ( " key1 " , 0 , toBytes ( " foo " ) ) . get ( ) ) ; assertEquals ( " foo " , toString ( client . get ( " key1 " ) ) ) ; client . shutdown ( ) ; }
public void testCreateUri01 ( ) throws Exception { RedisStorageClient client = createClient ( ) ; URI uri = client . createURI ( " redis : / / user : pwd @ localhost " ) ; assertEquals ( uri . getScheme ( ) , " redis " ) ; assertEquals ( uri . getUserInfo ( ) , " user : pwd " ) ; assertEquals ( uri . getHost ( ) , " localhost " ) ; assertTrue ( uri . getPort ( ) = = 6379 ) ; uri = client . createURI ( " rediss : / / : pwd @ localhost : 9999 " ) ; assertEquals ( uri . getScheme ( ) , " rediss " ) ; assertEquals ( uri . getUserInfo ( ) , " : pwd " ) ; assertTrue ( uri . getPort ( ) = = 9999 ) ; uri = client . createURI ( " redis : / / localhost " ) ; assertEquals ( uri . getScheme ( ) , " redis " ) ; assertNull ( uri . getUserInfo ( ) ) ; assertTrue ( uri . getPort ( ) = = 6379 ) ; }
private RedisStorageClient createClient ( ) { return new RedisStorageClient ( " redis : / / localhost : " + redisPort , 1000 ) ; }
private byte [ ] toBytes ( String s ) { return s . getBytes ( StandardCharsets . UTF_8 ) ; }
private String toString ( byte [ ] bytes ) { return new String ( bytes , StandardCharsets . UTF_8 ) ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Key key1 = ( Key ) o ; bytes . readerIndex ( 0 ) ; key1 . bytes . readerIndex ( 0 ) ; if ( ! bytes . equals ( key1 . bytes ) ) return false ; return true ; }
public int hashCode ( ) { return hashCode ; }
public String toString ( ) { return new String ( bytes . toByteBuffer ( ) . array ( ) ) ; }
public boolean wasInvokedWith ( final Request currentRequest ) { return currentRequest ! = null & & currentRequest . getNote ( INVOKED ) = = Boolean . TRUE ; }
public void shutdown ( ) { _log . info ( " Stopping services . " ) ; _manager . getContext ( ) . getParent ( ) . getPipeline ( ) . removeValve ( _trackingHostValve ) ; _manager . getContext ( ) . getPipeline ( ) . removeValve ( _trackingContextValve ) ; _backupSessionService . shutdown ( ) ; if ( _lockingStrategy ! = null ) { _lockingStrategy . shutdown ( ) ; } if ( _storage ! = null ) { _storage . shutdown ( ) ; _storage = null ; } _transcoderFactory = null ; _invalidSessionsCache . clear ( ) ; }
void startInternal ( final StorageClient storage ) throws LifecycleException { if ( storage = = null ) _storage = null ; else _storage = storage ; startInternal ( ) ; }
protected RequestTrackingContextValve createRequestTrackingContextValve ( final String sessionCookieName ) { return new RequestTrackingContextValve ( sessionCookieName , this ) ; }
public byte [ ] get ( final String key ) { return _storage . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( key ) ) ; }
protected MemcachedNodesManager createMemcachedNodesManager ( final String memcachedNodes , final String failoverNodes ) { final Context context = _manager . getContext ( ) ; final String webappVersion = Reflections . invoke ( context , " getWebappVersion " , null ) ; final StorageKeyFormat storageKeyFormat = StorageKeyFormat . of ( _storageKeyPrefix , context . getParent ( ) . getName ( ) , context . getName ( ) , webappVersion ) ; return MemcachedNodesManager . createFor ( memcachedNodes , failoverNodes , storageKeyFormat , _storageClientCallback ) ; }
private TranscoderService createTranscoderService ( final Statistics statistics ) { return new TranscoderService ( getTranscoderFactory ( ) . createTranscoder ( _manager ) ) ; }
private TranscoderFactory createTranscoderFactory ( ) throws InstantiationException , IllegalAccessException , ClassNotFoundException { _log . info ( " Creating transcoder factory " + _transcoderFactoryClassName ) ; final Class < ? extends TranscoderFactory > transcoderFactoryClass = loadTranscoderFactoryClass ( ) ; final TranscoderFactory transcoderFactory = transcoderFactoryClass . newInstance ( ) ; transcoderFactory . setCopyCollectionsForSerialization ( _copyCollectionsForSerialization ) ; if ( _customConverterClassNames ! = null ) { _log . info ( " Found configured custom converter classes , setting on transcoder factory : " + _customConverterClassNames ) ; transcoderFactory . setCustomConverterClassNames ( _customConverterClassNames . split ( " , \ \ s * " ) ) ; } return transcoderFactory ; }
private Class < ? extends TranscoderFactory > loadTranscoderFactoryClass ( ) throws ClassNotFoundException { Class < ? extends TranscoderFactory > transcoderFactoryClass ; final ClassLoader classLoader = _manager . getContainerClassLoader ( ) ; try { _log . debug ( " Loading transcoder factory class " + _transcoderFactoryClassName + " using classloader " + classLoader ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , classLoader ) . asSubclass ( TranscoderFactory . class ) ; } catch ( final ClassNotFoundException e ) { _log . info ( " Could not load transcoderfactory class with classloader " + classLoader + " , trying " + getClass ( ) . getClassLoader ( ) ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , getClass ( ) . getClassLoader ( ) ) . asSubclass ( TranscoderFactory . class ) ; } return transcoderFactoryClass ; }
public String newSessionId ( @ Nonnull final String sessionId ) { return _memcachedNodesManager . createSessionId ( sessionId ) ; }
private boolean isContainerSessionLookup ( ) { return ! _trackingContextValve . wasInvokedWith ( _currentRequest . get ( ) ) ; }
private boolean isConnectorSessionLookup ( ) { return _currentRequest . get ( ) = = null ; }
private void addValidLoadedSession ( final MemcachedBackupSession result ) { String jvmRoute ; final boolean sessionIdWillBeChanged = _sticky & & ( jvmRoute = _manager . getJvmRoute ( ) ) ! = null & & ! jvmRoute . equals ( getSessionIdFormat ( ) . extractJvmRoute ( result . getId ( ) ) ) ; final boolean activate = ! sessionIdWillBeChanged ; addValidLoadedSession ( result , activate ) ; }
private void addValidLoadedSession ( final StandardSession session , final boolean activate ) { if ( session . isNew ( ) ) { session . tellNew ( ) ; } _manager . add ( session ) ; if ( activate ) { session . activate ( ) ; } session . access ( ) ; session . endAccess ( ) ; }
public MemcachedBackupSession createEmptySession ( ) { final MemcachedBackupSession result = _manager . newMemcachedBackupSession ( ) ; result . setSticky ( _sticky ) ; return result ; }
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { if ( ! _memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ) { return null ; } try { if ( _sticky ) { final MemcachedBackupSession session = _manager . getSessionInternal ( requestedSessionId ) ; if ( session ! = null & & session . isValid ( ) ) { final String newSessionId = _memcachedNodesManager . getNewSessionIdIfNodeFromSessionIdUnavailable ( session . getId ( ) ) ; if ( newSessionId ! = null ) { _log . debug ( " Session needs to be relocated , setting new id on session . . . " ) ; session . setIdForRelocate ( newSessionId ) ; _statistics . requestWithMemcachedFailover ( ) ; return newSessionId ; } } } else { final String nodeId = getSessionIdFormat ( ) . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _memcachedNodesManager . isNodeAvailable ( nodeId ) ) { return null ; } _log . info ( " Session needs to be relocated as node " + nodeId + " is not available , loading backup session for " + requestedSessionId ) ; final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { _log . debug ( " Loaded backup session for " + requestedSessionId + " , adding locally with " + backupSession . getIdInternal ( ) + " . " ) ; addValidLoadedSession ( backupSession , true ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final RuntimeException e ) { _log . warn ( " Could not find session in local session map . " , e ) ; } return null ; }
private MemcachedBackupSession loadBackupSession ( @ Nonnull final String requestedSessionId ) { final String nodeId = getSessionIdFormat ( ) . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null ) { _log . info ( " Cannot load backupSession for sessionId without nodeId : " + requestedSessionId ) ; return null ; } final String newNodeId = _memcachedNodesManager . getNextAvailableNodeId ( nodeId ) ; if ( newNodeId = = null ) { _log . info ( " No next available node found for nodeId " + nodeId ) ; return null ; } MemcachedBackupSession result = loadBackupSession ( requestedSessionId , newNodeId ) ; String nextNodeId = nodeId ; while ( result = = null & & ( nextNodeId = _memcachedNodesManager . getNextAvailableNodeId ( nextNodeId ) ) ! = null & & ! nextNodeId . equals ( nodeId ) ) { final String newSessionId = getSessionIdFormat ( ) . createNewSessionId ( requestedSessionId , nextNodeId ) ; result = loadBackupSession ( newSessionId , newNodeId ) ; } if ( result = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } return result ; }
byte [ ] serialize ( @ Nonnull final MemcachedBackupSession session ) { return _transcoderService . serialize ( session ) ; }
protected MemcachedBackupSession loadFromMemcachedWithCheck ( final String sessionId ) { if ( ! canHitMemcached ( sessionId ) | | _invalidSessionsCache . get ( sessionId ) ! = null ) { return null ; } return loadFromMemcached ( sessionId ) ; }
private boolean canHitMemcached ( @ Nonnull final String sessionId ) { return _enabled . get ( ) & & _memcachedNodesManager . canHitMemcached ( sessionId ) ; }
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached : " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final byte [ ] object = _storage . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _memcachedNodesManager . onLoadFromMemcachedSuccess ( sessionId ) ; if ( object ! = null ) { final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { releaseIfLocked ( sessionId , lockStatus ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached . " ) ; } return null ; } } catch ( final TranscoderDeserializationException e ) { _log . warn ( " Could not deserialize session with id " + sessionId + " from memcached , session will be purged from storage . " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; _storage . delete ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached . " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; } finally { } return null ; }
private MemcachedNodesManager reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { final MemcachedNodesManager memcachedNodesManager = createMemcachedNodesManager ( memcachedNodes , failoverNodes ) ; final StorageClient storage = createStorageClient ( memcachedNodesManager , _statistics ) ; final BackupSessionService backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , storage , memcachedNodesManager , _statistics ) ; if ( _storage ! = null ) { _storage . shutdown ( ) ; } _storage = storage ; _memcachedNodesManager = memcachedNodesManager ; _backupSessionService = backupSessionService ; initNonStickyLockingMode ( memcachedNodesManager ) ; return memcachedNodesManager ; }
public boolean isEnabled ( ) { return _enabled . get ( ) ; }
public boolean isSticky ( ) { return _sticky ; }
public boolean isSessionBackupAsync ( ) { return _sessionBackupAsync ; }
public Request get ( ) { return _requestsThreadLocal . get ( ) ; }
public void set ( final Request request ) { _requestsThreadLocal . set ( request ) ; }
public void reset ( ) { _requestsThreadLocal . set ( null ) ; }
public Thread newThread ( final Runnable runnable ) { final Thread t = new Thread ( group , runnable , namePrefix + threadNumber . getAndIncrement ( ) ) ; if ( t . isDaemon ( ) ) t . setDaemon ( false ) ; if ( t . getPriority ( ) ! = Thread . NORM_PRIORITY ) t . setPriority ( Thread . NORM_PRIORITY ) ; return t ; }
public static NodeIdList create ( @ Nonnull final String . . . nodeIds ) { return new NodeIdList ( nodeIds ) ; }
protected CouchbaseConnectionFactoryBuilder newCouchbaseConnectionFactoryBuilder ( ) { return new CouchbaseConnectionFactoryBuilder ( ) ; }
public boolean isNodeAvailable ( @ Nonnull final String nodeId ) { return _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ; }
public String getNextNodeId ( @ Nonnull final String nodeId ) throws IllegalArgumentException { return _nodeIds . getNextNodeId ( nodeId ) ; }
public NodeLocator createLocator ( final List < MemcachedNode > nodes ) { return new SuffixBasedNodeLocator ( nodes , _memcachedNodesManager , _sessionIdFormat ) ; }
public static < A , B > Pair < A , B > of ( final A first , final B second ) { return new Pair < A , B > ( first , second ) ; }
public byte [ ] serialize ( final MemcachedBackupSession session ) { final byte [ ] attributesData = serializeAttributes ( session , session . getAttributesInternal ( ) ) ; return serialize ( session , attributesData ) ; }
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { return _attributesTranscoder . serializeAttributes ( session , attributes ) ; }
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] data ) { return _attributesTranscoder . deserializeAttributes ( data ) ; }
public byte [ ] serialize ( final MemcachedBackupSession session , final byte [ ] attributesData ) { final byte [ ] sessionData = serializeSessionFields ( session ) ; final byte [ ] result = new byte [ sessionData . length + attributesData . length ] ; System . arraycopy ( sessionData , 0 , result , 0 , sessionData . length ) ; System . arraycopy ( attributesData , 0 , result , sessionData . length , attributesData . length ) ; return result ; }
static byte [ ] serializeSessionFields ( final MemcachedBackupSession session ) { return serializeSessionFields ( session , VERSION_2 ) ; }
private static < T > List < T > newArrayList ( final Iterator < T > iter ) { if ( ! iter . hasNext ( ) ) { return Collections . emptyList ( ) ; } final List < T > result = new ArrayList < T > ( ) ; while ( iter . hasNext ( ) ) { result . add ( iter . next ( ) ) ; } return result ; }
private static int encodeBoolean ( final boolean b , final byte [ ] data , final int index ) { data [ index ] = ( byte ) ( b ? ' 1 ' : ' 0 ' ) ; return index + 1 ; }
private static boolean decodeBoolean ( final byte [ ] in , final int index ) { return in [ index ] = = ' 1 ' ; }
protected static int copy ( final byte [ ] src , final byte [ ] dest , final int destBeginIndex ) { if ( src = = null ) { return destBeginIndex ; } System . arraycopy ( src , 0 , dest , destBeginIndex , src . length ) ; return destBeginIndex + src . length ; }
static AuthType valueOfId ( final short id ) { for ( final AuthType authType : values ( ) ) { if ( id = = authType . _id ) { return authType ; } } throw new IllegalArgumentException ( " No AuthType found for id " + id ) ; }
