public void test ( ) { try { Thread . sleep ( 200 ) ;
public void testZeroTimeoutIsIgnored ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeOutZero . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should not have failed " , 0 , result . getFailureCount ( ) ) ; }
protected void collectInitializationErrors ( List < Throwable > errors ) { validatePublicVoidNoArgMethods ( BeforeClass . class , true , errors ) ; validatePublicVoidNoArgMethods ( AfterClass . class , true , errors ) ; validateClassRules ( errors ) ; applyValidators ( errors ) ; }
public boolean isPublic ( ) { return Modifier . isPublic ( fClass . getModifiers ( ) ) ; }
public List < Exception > validateTestClass ( TestClass testClass ) { if ( testClass . isPublic ( ) ) { return NO_VALIDATION_ERRORS ;
public List < Exception > validateTestClass ( TestClass testClass ) ; }
public void identifiesPublicModifier ( ) { TestClass tc = new TestClass ( PublicClass . class ) ; assertEquals ( " Wrong flag ' public ' , " , true , tc . isPublic ( ) ) ; }
public void identifiesNonPublicModifier ( ) { TestClass tc = new TestClass ( NonPublicClass . class ) ; assertEquals ( " Wrong flag ' public ' , " , false , tc . isPublic ( ) ) ; }
public void test1 ( ) throws Exception { } @ Test public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } }
public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } }
public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } }
public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class ,
public void acceptsPublicClass ( ) { TestClass testClass = new TestClass ( PublicClass . class ) ; List < Exception > validationErrors = validator . validateTestClass ( testClass ) ; assertThat ( validationErrors , is ( equalTo ( Collections . < Exception > emptyList ( ) ) ) ) ;
public void rejectsNonPublicClass ( ) { TestClass testClass = new TestClass ( NonPublicClass . class ) ; List < Exception > validationErrors = validator . validateTestClass ( testClass ) ; assertThat ( " Wrong number of errors . " , validationErrors . size ( ) , is ( equalTo ( 1 ) ) ) ;
public void topLevelTestClassWithoutAnnotation_isRunWithDefaultRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( Object . class ) ; assertThat ( runner , is ( nullValue ( ) ) ) ; }
public void topLevelTestClassWithAnnotation_isRunWithAnnotatedRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . class ) ; assertThat ( runner , is ( instanceOf ( RunnerSpy . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( equalTo ( ( Class ) OuterClass . class ) ) ) ; }
public void memberClassInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . InnerClassWithoutOwnRunWith . class ) ; assertThat ( runner , is ( instanceOf ( RunnerSpy . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( equalTo ( ( Class ) OuterClass . InnerClassWithoutOwnRunWith . class ) ) ) ; }
public void memberClassDeepInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . InnerClassWithoutOwnRunWith . MostInnerClass . class ) ; assertThat ( runner , is ( instanceOf ( RunnerSpy . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( equalTo ( ( Class ) OuterClass . InnerClassWithoutOwnRunWith . MostInnerClass . class ) ) ) ; }
public void annotatedMemberClassInsideAnnotatedTopLevelClass_isRunWithOwnRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . InnerClassWithOwnRunWith . class ) ; assertThat ( runner , is ( instanceOf ( InnerRunner . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( equalTo ( ( Class ) OuterClass . InnerClassWithOwnRunWith . class ) ) ) ; }
public void memberClassDeepInsideAnnotatedMemberClass_isRunWithParentMemberClassRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . InnerClassWithOwnRunWith . MostInnerClass . class ) ; assertThat ( runner , is ( instanceOf ( InnerRunner . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( equalTo ( ( Class ) OuterClass . InnerClassWithOwnRunWith . MostInnerClass . class ) ) ) ; }
public void test ( ) { } public class MostInnerClass { @ Test public void test ( ) { } } } @ RunWith ( InnerRunner . class ) public class InnerClassWithOwnRunWith { @ Test public void test ( ) { } public class MostInnerClass { @ Test public void test ( ) { } } } } public static class InnerRunner extends RunnerSpy { public InnerRunner ( Class testClass ) { super ( testClass ) ; } public InnerRunner ( Class testClass , RunnerBuilder runnerBuilder ) { super ( testClass , runnerBuilder ) ; } } }
public void test ( ) { } } } @ RunWith ( InnerRunner . class ) public class InnerClassWithOwnRunWith { @ Test public void test ( ) { } public class MostInnerClass { @ Test public void test ( ) { } } } } public static class InnerRunner extends RunnerSpy { public InnerRunner ( Class testClass ) { super ( testClass ) ; } public InnerRunner ( Class testClass , RunnerBuilder runnerBuilder ) { super ( testClass , runnerBuilder ) ; } } }
public void test ( ) { } public class MostInnerClass { @ Test public void test ( ) { } } } } public static class InnerRunner extends RunnerSpy { public InnerRunner ( Class testClass ) { super ( testClass ) ; } public InnerRunner ( Class testClass , RunnerBuilder runnerBuilder ) { super ( testClass , runnerBuilder ) ; } } }
public void test ( ) { } } } } public static class InnerRunner extends RunnerSpy { public InnerRunner ( Class testClass ) { super ( testClass ) ; } public InnerRunner ( Class testClass , RunnerBuilder runnerBuilder ) { super ( testClass , runnerBuilder ) ; } } }
public Runner runnerForClass ( Class < ? > testClass ) throws Throwable { return new RunnerSpy ( testClass , this ) ; }
private void validateStatic ( FrameworkMember < ? > member , List < Throwable > errors ) { if ( fStaticMembers & & ! member . isStatic ( ) ) { addError ( errors , member , " must be static . " ) ; } if ( ! fStaticMembers & & member . isStatic ( ) ) { addError ( errors , member , " must not be static or it has to be annotated with @ ClassRule . " ) ;
public void rejectStaticTestRule ( ) { TestClass target = new TestClass ( TestWithStaticTestRule . class ) ; RULE_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ Rule ' temporaryFolder ' must not be static or it has to be annotated with @ ClassRule . " ) ; }
public void rejectMethodStaticTestRule ( ) { TestClass target = new TestClass ( TestMethodWithStaticTestRule . class ) ; RULE_METHOD_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ Rule ' getTemporaryFolder ' must not be static or it has to be annotated with @ ClassRule . " ) ; }
public void test1 ( ) throws Exception { } @ Test public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; }
public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; }
public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; }
public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; }
public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; }
public void ignore ( ) { } @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; }
public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; }
private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; }
public void testStarted ( Description description ) throws Exception { testStarted + + ; }
public void testFinished ( Description description ) throws Exception { testFinished + + ; }
public void testFailure ( Failure failure ) throws Exception { testFailure + + ; }
public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; }
public void testIgnored ( Description description ) throws Exception { testIgnored + + ; }
public void testComparisonErrorOverlappingMatches ( ) { String failure = new ComparisonCompactor ( 0 , " abc " , " abbc " ) . compact ( null ) ; assertEquals ( " expected : < . . . [ ] . . . > but was : < . . . [ b ] . . . > " , failure ) ; }
public void testComparisonErrorOverlappingMatchesContext ( ) { String failure = new ComparisonCompactor ( 2 , " abc " , " abbc " ) . compact ( null ) ; assertEquals ( " expected : < ab [ ] c > but was : < ab [ b ] c > " , failure ) ; }
public void testComparisonErrorOverlappingMatches2 ( ) { String failure = new ComparisonCompactor ( 0 , " abcdde " , " abcde " ) . compact ( null ) ; assertEquals ( " expected : < . . . [ d ] . . . > but was : < . . . [ ] . . . > " , failure ) ; }
public void testComparisonErrorOverlappingMatches2Context ( ) { String failure = new ComparisonCompactor ( 2 , " abcdde " , " abcde " ) . compact ( null ) ; assertEquals ( " expected : < . . . cd [ d ] e > but was : < . . . cd [ ] e > " , failure ) ; }
public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { " \ n " } ,
public void methodNameTest ( ) throws Exception { Description description = Description . createTestDescription ( " some - class - name " , methodName ) ; assertNotNull ( " Method name should be not null " , description . getMethodName ( ) ) ; assertEquals ( methodName , description . getMethodName ( ) ) ; }
public void arrayEquals ( String message , Object expecteds , Object actuals ) throws ArrayComparisonFailure { if ( expecteds = = actuals | | Arrays . deepEquals ( new Object [ ] { expecteds } , new Object [ ] { actuals } ) ) { return ; } String header = message = = null ? " " : message + " : " ; int expectedsLength = assertArraysAreSameLength ( expecteds , actuals , header ) ; for ( int i = 0 ; i < expectedsLength ; i + + ) { Object expected = Array . get ( expecteds , i ) ;
public String compact ( String message ) { if ( expected = = null | | actual = = null | | expected . equals ( actual ) ) { return Assert . format ( message , expected , actual ) ;
private String sharedPrefix ( ) { int end = Math . min ( expected . length ( ) , actual . length ( ) ) ; for ( int i = 0 ; i < end ; i + + ) { if ( expected . charAt ( i ) ! = actual . charAt ( i ) ) { return expected . substring ( 0 , i ) ; } } return expected . substring ( 0 , end ) ; }
private String sharedSuffix ( String prefix ) { int suffixLength = 0 ; int maxSuffixLength = Math . min ( expected . length ( ) - prefix . length ( ) , actual . length ( ) - prefix . length ( ) ) - 1 ; for ( ; suffixLength < = maxSuffixLength ; suffixLength + + ) { if ( expected . charAt ( expected . length ( ) - 1 - suffixLength ) ! = actual . charAt ( actual . length ( ) - 1 - suffixLength ) ) { break ; } } return expected . substring ( expected . length ( ) - suffixLength ) ; }
public String expectedDiff ( ) { return extractDiff ( expected ) ; }
public String actualDiff ( ) { return extractDiff ( actual ) ; }
public String compactPrefix ( ) { if ( sharedPrefix . length ( ) < = contextLength ) { return sharedPrefix ; } return ELLIPSIS + sharedPrefix . substring ( sharedPrefix . length ( ) - contextLength ) ; }
public String compactSuffix ( ) { if ( sharedSuffix . length ( ) < = contextLength ) { return sharedSuffix ; } return sharedSuffix . substring ( 0 , contextLength ) + ELLIPSIS ; }
private String extractDiff ( String source ) { return DIFF_START + source . substring ( sharedPrefix . length ( ) , source . length ( ) - sharedSuffix . length ( ) ) + DIFF_END ;
public Runner getSuite ( RunnerBuilder builder , java . lang . Class < ? > [ ] classes ) throws InitializationError { Runner suite = super . getSuite ( builder , classes ) ; return this . classes ? parallelize ( suite ) : suite ; }
protected Runner getRunner ( RunnerBuilder builder , Class < ? > testClass ) throws Throwable { Runner runner = super . getRunner ( builder , testClass ) ; return methods ? parallelize ( runner ) : runner ; }
@ Override public String toString ( ) { StringBuilder description = new StringBuilder ( " categories " ) . append ( included . isEmpty ( ) ? " [ all ] " : included ) ; if ( ! excluded . isEmpty ( ) ) { description . append ( " - " ) . append ( excluded ) ; } return description . toString ( ) ; }
private boolean hasCorrectCategoryAnnotation ( Description description ) { final Set < Class < ? > > childCategories = categories ( description ) ; if ( childCategories . isEmpty ( ) ) { return included . isEmpty ( ) ; } if ( ! excluded . isEmpty ( ) ) { if ( excludedAny ) { if ( matchesAnyParentCategories ( childCategories , excluded ) ) { return false ; } } else { if ( matchesAllParentCategories ( childCategories , excluded ) ) { return false ; } } } if ( included . isEmpty ( ) ) {
public Result run ( Request request , JUnitCore core ) { core . addListener ( history . listener ( ) ) ; return core . run ( sortRequest ( request ) . getRunner ( ) ) ; }
public Request sortRequest ( Request request ) { if ( request instanceof SortingRequest ) { return request ; } List < Description > leaves = findLeaves ( request ) ; Collections . sort ( leaves , history . testComparator ( ) ) ; return constructLeafRequest ( leaves ) ; }
private void save ( ) throws IOException { ObjectOutputStream stream = new ObjectOutputStream ( new FileOutputStream ( historyStore ) ) ; stream . writeObject ( this ) ; stream . close ( ) ; }
void putTestFailureTimestamp ( Description key , long end ) { failureTimestamps . put ( key . toString ( ) , end ) ; }
boolean isNewTest ( Description key ) { return ! durations . containsKey ( key . toString ( ) ) ; }
void putTestDuration ( Description description , long duration ) { durations . put ( description . toString ( ) , duration ) ; }
public void evaluate ( ) throws Throwable { runWithAssignment ( Assignments . allUnassigned ( testMethod . getMethod ( ) , getTestClass ( ) ) ) ; boolean hasTheoryAnnotation = testMethod . getAnnotation ( Theory . class ) ! = null ; if ( successes = = 0 & & hasTheoryAnnotation ) { Assert
protected void collectInitializationErrors ( List < Throwable > errors ) { } @ Override public Statement methodBlock ( FrameworkMethod method ) { final Statement statement = super . methodBlock ( method ) ; return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { try { statement . evaluate ( ) ; handleDataPointSuccess ( ) ; } catch ( AssumptionViolatedException e ) { handleAssumptionViolation ( e ) ; } catch ( Throwable e ) { reportParameterizedError ( e , complete . getArgumentStrings ( nullsOk ( ) ) ) ; } } } ; } @ Override protected Statement methodInvoker ( FrameworkMethod method , Object test ) { return methodCompletesWithParameters ( method , complete , test ) ; } @ Override public Object createTest ( ) throws Exception { Object [ ] params = complete . getConstructorArguments ( ) ; if ( ! nullsOk ( ) ) { Assume . assumeNotNull ( params ) ; } return getTestClass ( ) . getOnlyConstructor ( ) . newInstance ( params ) ; } } . methodBlock ( testMethod ) . evaluate ( ) ; } private Statement methodCompletesWithParameters ( final FrameworkMethod method , final Assignments complete , final Object freshInstance ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { final Object [ ] values = complete . getMethodArguments ( ) ; if ( ! nullsOk ( ) ) { Assume . assumeNotNull ( values ) ; } method . invokeExplosively ( freshInstance , values ) ; } } ; } protected void handleAssumptionViolation ( AssumptionViolatedException e ) { fInvalidParameters . add ( e ) ; } protected void reportParameterizedError ( Throwable e , Object . . . params ) throws Throwable { if ( params . length = = 0 ) { throw e ; } throw new ParameterizedAssertionError ( e , testMethod . getName ( ) , params ) ; } private boolean nullsOk ( ) { Theory annotation = testMethod . getMethod ( ) . getAnnotation ( Theory . class ) ; if ( annotation = = null ) { return false ; } return annotation . nullsAccepted ( ) ; } protected void handleDataPointSuccess ( ) { successes + + ; } } }
protected void reportParameterizedError ( Throwable e , Object . . . params ) throws Throwable { if ( params . length = = 0 ) { throw e ; } throw new ParameterizedAssertionError ( e , testMethod . getName ( ) , params ) ;
private boolean nullsOk ( ) { Theory annotation = testMethod . getMethod ( ) . getAnnotation ( Theory . class ) ; if ( annotation = = null ) { return false ; } return annotation . nullsAccepted ( ) ; }
public Object getValue ( ) throws CouldNotGenerateValueException { try { return method . invokeExplosively ( null ) ;
public String getDescription ( ) throws CouldNotGenerateValueException { return method . getName ( ) ; }
public boolean isComplete ( ) { return unassigned . size ( ) = = 0 ; }
public ParameterSignature nextUnassigned ( ) { return unassigned . get ( 0 ) ; }
public Assignments assignNext ( PotentialAssignment source ) { List < PotentialAssignment > assigned = new ArrayList < PotentialAssignment > ( this . assigned ) ; assigned . add ( source ) ; return new Assignments ( assigned , unassigned . subList ( 1 , unassigned . size ( ) ) , clazz ) ;
public Object [ ] getActualValues ( int start , int stop ) throws CouldNotGenerateValueException { Object [ ] values = new Object [ stop - start ] ; for ( int i = start ; i < stop ; i + + ) { values [ i - start ] = assigned . get ( i ) . getValue ( ) ; } return values ; }
private ParameterSupplier buildParameterSupplierFromClass ( Class < ? extends ParameterSupplier > cls ) throws Exception { Constructor < ? > [ ] supplierConstructors = cls . getConstructors ( ) ; for ( Constructor < ? > constructor : supplierConstructors ) { Class < ? > [ ] parameterTypes = constructor . getParameterTypes ( ) ; if ( parameterTypes . length = = 1 & & parameterTypes [ 0 ] . equals ( TestClass . class ) ) { return ( ParameterSupplier ) constructor . newInstance ( clazz ) ; } } return cls . newInstance ( ) ; }
public Object [ ] getMethodArguments ( ) throws CouldNotGenerateValueException { return getActualValues ( getConstructorParameterCount ( ) , assigned . size ( ) ) ; }
public Object [ ] getAllArguments ( ) throws CouldNotGenerateValueException { return getActualValues ( 0 , assigned . size ( ) ) ; }
public Object [ ] getArgumentStrings ( boolean nullsOk ) throws CouldNotGenerateValueException { Object [ ] values = new Object [ assigned . size ( ) ] ; for ( int i = 0 ; i < values . length ; i + + ) { values [ i ] = assigned . get ( i ) . getDescription ( ) ; } return values ; }
public void addDimension ( int index ) { indices . add ( 0 , index ) ; }
public void describeTo ( Description description ) { if ( assumption ! = null ) { description . appendText ( assumption ) ; } if ( valueMatcher ) { if ( assumption ! = null ) {
public void testStarted ( Description description ) { writer . append ( ' . ' ) ; }
public void testFailure ( Failure failure ) { writer . append ( ' E ' ) ; }
public void testIgnored ( Description description ) { writer . append ( ' I ' ) ; }
protected RunnerBuilder suiteMethodBuilder ( ) { if ( canUseSuiteMethod ) { return new SuiteMethodBuilder ( ) ; } return new NullBuilder ( ) ; }
public void describeTo ( Description description ) { throwableMatcher . describeTo ( description ) ; }
protected boolean matchesSafely ( T item ) { return throwableMatcher . matches ( item ) ; }
protected void describeMismatchSafely ( T item , Description description ) { throwableMatcher . describeMismatch ( item , description ) ; description . appendText ( " \ nStacktrace was : " ) ; description . appendText ( readStacktrace ( item ) ) ; }
public void describeTo ( Description description ) { description . appendText ( " exception with cause " ) ; description . appendDescriptionOf ( matcher ) ; }
protected boolean matchesSafely ( T item ) { return matcher . matches ( item . getCause ( ) ) ; }
protected void describeMismatchSafely ( T item , Description description ) { description . appendText ( " cause " ) ; matcher . describeMismatch ( item . getCause ( ) , description ) ; }
public void describeTo ( Description description ) { description . appendText ( " exception with message " ) ; description . appendDescriptionOf ( matcher ) ; }
protected boolean matchesSafely ( T item ) { return matcher . matches ( item . getMessage ( ) ) ; }
protected void describeMismatchSafely ( T item , Description description ) { description . appendText ( " message " ) ; matcher . describeMismatch ( item . getMessage ( ) , description ) ; }
public void run ( RunNotifier notifier ) { for ( Throwable each : causes ) { runCause ( each , notifier ) ;
private Description describeCause ( Throwable child ) { return Description . createTestDescription ( testClass , " initializationError " ) ;
public void endTest ( Test test ) { notifier . fireTestFinished ( asDescription ( test ) ) ; }
public void startTest ( Test test ) { notifier . fireTestStarted ( asDescription ( test ) ) ; }
public void addError ( Test test , Throwable e ) { Failure failure = new Failure ( asDescription ( test ) , e ) ; notifier . fireTestFailure ( failure ) ; }
public void addFailedAssumption ( AssumptionViolatedException e ) { notifier . fireTestAssumptionFailed ( new Failure ( description , e ) ) ; }
public void fireTestFinished ( ) { notifier . fireTestFinished ( description ) ; }
public void fireTestStarted ( ) { notifier . fireTestStarted ( description ) ; }
public void fireTestIgnored ( ) { notifier . fireTestIgnored ( description ) ; }
public void validate ( TestClass target , List < Throwable > errors ) { List < ? extends FrameworkMember < ? > > members = methods ? target . getAnnotatedMethods ( annotation ) : target . getAnnotatedFields ( annotation ) ; for ( FrameworkMember < ? > each : members ) { validateMember ( each , errors ) ;
private void validatePublicClass ( FrameworkMember < ? > member , List < Throwable > errors ) { if ( staticMembers & & ! isDeclaringClassPublic ( member ) ) { addError ( errors , member , " must be declared in a public class . " ) ;
private void validateStatic ( FrameworkMember < ? > member , List < Throwable > errors ) { if ( staticMembers & & ! member . isStatic ( ) ) { addError ( errors , member , " must be static . " ) ; } if ( ! staticMembers & & member . isStatic ( ) ) { addError ( errors , member , " must not be static or it has to be annotated with @ ClassRule . " ) ;
private void validateTestRuleOrMethodRule ( FrameworkMember < ? > member , List < Throwable > errors ) { if ( ! isMethodRule ( member ) & & ! isTestRule ( member ) ) { addError ( errors , member , methods ?
private void addError ( List < Throwable > errors , FrameworkMember < ? > member , String suffix ) { String message = " The @ " + annotation . getSimpleName ( ) + " ' " + member . getName ( ) + " ' " + suffix ; errors . add ( new Exception ( message ) ) ; }
public void evaluate ( ) throws Throwable { throw error ; }
public void evaluate ( ) throws Throwable { FutureTask < Throwable > task = new FutureTask < Throwable > ( new CallableStatement ( ) ) ; threadGroup = new ThreadGroup ( " FailOnTimeoutGroup " ) ; Thread thread = new Thread ( threadGroup , task , " Time - limited test " ) ; thread . setDaemon ( true ) ; thread . start ( ) ; Throwable throwable = getResult ( task , thread ) ; if ( throwable ! = null ) { throw throwable ;
private Exception createTimeoutException ( Thread thread ) { StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; final Thread stuckThread = lookForStuckThread ? getStuckThread ( thread ) : null ; Exception currThreadException = new TestTimedOutException ( timeout , timeUnit ) ; if ( stackTrace ! = null ) { currThreadException . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } if ( stuckThread ! = null ) { Exception stuckThreadException =
public Throwable call ( ) throws Exception { try { originalStatement . evaluate ( ) ; } catch ( Exception e ) { throw e ; } catch ( Throwable e ) { return e ; } return null ; }
public void evaluate ( ) throws Throwable { testMethod . invokeExplosively ( target ) ; }
public void evaluate ( ) throws Throwable { List < Throwable > errors = new ArrayList < Throwable > ( ) ; try { next . evaluate ( ) ; } catch ( Throwable e ) { errors . add ( e ) ; } finally { for ( FrameworkMethod each : afters ) { try { each . invokeExplosively ( target ) ; } catch ( Throwable e ) { errors . add ( e ) ; } } } MultipleFailureException . assertEmpty ( errors ) ; }
public void evaluate ( ) throws Throwable { for ( FrameworkMethod before : befores ) { before . invokeExplosively ( target ) ; } next . evaluate ( ) ; }
public void expect ( Matcher < ? > matcher ) { matcherBuilder . add ( matcher ) ; }
public void evaluate ( ) throws Throwable { try { next . evaluate ( ) ; } catch ( Throwable e ) { handleException ( e ) ; return ; } if ( isAnyExceptionExpected ( ) ) { failDueToMissingException ( ) ;
private void handleException ( Throwable e ) throws Throwable { if ( isAnyExceptionExpected ( ) ) { assertThat ( e , matcherBuilder . build ( ) ) ;
private boolean isAnyExceptionExpected ( ) { return matcherBuilder . expectsThrowable ( ) ; }
private String missingExceptionMessage ( ) { String expectation = StringDescription . toString ( matcherBuilder . build ( ) ) ; return format ( missingExceptionMessage , expectation ) ; }
void add ( Matcher < ? > matcher ) { matchers . add ( matcher ) ; }
boolean expectsThrowable ( ) { return ! matchers . isEmpty ( ) ; }
private Matcher < Throwable > allOfTheMatchers ( ) { if ( matchers . size ( ) = = 1 ) { return cast ( matchers . get ( 0 ) ) ; } return allOf ( castedMatchers ( ) ) ; }
private List < Matcher < ? super Throwable > > castedMatchers ( ) { return new ArrayList < Matcher < ? super Throwable > > ( ( List ) matchers ) ; }
public long runtime ( TimeUnit unit ) { return unit . convert ( currentNanoTime ( ) - startNanos , TimeUnit . NANOSECONDS ) ; }
private void starting ( ) { startNanos = currentNanoTime ( ) ; }
private void stopping ( ) { endNanos = currentNanoTime ( ) ; }
protected void starting ( Description d ) { name = d . getMethodName ( ) ; }
public Statement apply ( Statement base , Description description ) { return new FailOnTimeout ( base , timeout , timeUnit , lookForStuckThread ) ; }
public void addChild ( Description description ) { children . add ( description ) ; }
public boolean isTest ( ) { return children . isEmpty ( ) ; }
public int testCount ( ) { if ( isTest ( ) ) { return 1 ; } int result = 0 ; for ( Description child : children ) { result + = child . testCount ( ) ; } return result ; }
public int hashCode ( ) { return uniqueId . hashCode ( ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof Description ) ) { return false ; } Description d = ( Description ) obj ; return uniqueId . equals ( d . uniqueId ) ; }
public Description childlessCopy ( ) { return new Description ( testClass , displayName , annotations ) ; }
public Result run ( Runner runner ) { Result result = new Result ( ) ; RunListener listener = result . createListener ( ) ; notifier . addFirstListener ( listener ) ; try { notifier . fireTestRunStarted ( runner . getDescription ( ) ) ; runner . run ( notifier ) ; notifier . fireTestRunFinished ( result ) ; } finally { removeListener ( listener ) ; } return result ; }
public void addListener ( RunListener listener ) { notifier . addListener ( listener ) ; }
public void removeListener ( RunListener listener ) { notifier . removeListener ( listener ) ; }
public void testRunStarted ( Description description ) throws Exception { startTime . set ( System . currentTimeMillis ( ) ) ; }
public void testRunFinished ( Result result ) throws Exception { long endTime = System . currentTimeMillis ( ) ; runTime . addAndGet ( endTime - startTime . get ( ) ) ; }
public void testFinished ( Description description ) throws Exception { count . getAndIncrement ( ) ; }
public void testFailure ( Failure failure ) throws Exception { failures . add ( failure ) ; }
public void testIgnored ( Description description ) throws Exception { ignoreCount . getAndIncrement ( ) ; }
public int compare ( Description o1 , Description o2 ) { return comparator . compare ( o1 , o2 ) ; }
public String toString ( ) { return getTestHeader ( ) + " : " + thrownException . getMessage ( ) ; }
public void addListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot add a null listener " ) ; } listeners . add ( wrapIfNotThreadSafe ( listener ) ) ; }
public void removeListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot remove a null listener " ) ; } listeners . remove ( wrapIfNotThreadSafe ( listener ) ) ; }
void run ( ) { int capacity = currentListeners . size ( ) ; ArrayList < RunListener > safeListeners = new ArrayList < RunListener > ( capacity ) ; ArrayList < Failure > failures = new ArrayList < Failure > ( capacity ) ; for ( RunListener listener : currentListeners ) { try { notifyListener ( listener ) ; safeListeners . add ( listener ) ; } catch ( Exception e ) { failures . add ( new Failure ( Description . TEST_MECHANISM , e ) ) ; } } fireTestFailures ( safeListeners , failures ) ; }
abstract protected void notifyListener ( RunListener each ) throws Exception ; } public void fireTestRunStarted ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testRunStarted ( description ) ; } } . run ( ) ; } public void fireTestRunFinished ( final Result result ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testRunFinished ( result ) ; } } . run ( ) ; } public void fireTestStarted ( final Description description ) throws StoppedByUserException { if ( pleaseStop ) { throw new StoppedByUserException ( ) ; } new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testStarted ( description ) ; } } . run ( ) ; } public void fireTestFailure ( Failure failure ) { fireTestFailures ( listeners , asList ( failure ) ) ; } private void fireTestFailures ( List < RunListener > listeners , final List < Failure > failures ) { if ( ! failures . isEmpty ( ) ) { new SafeNotifier ( listeners ) { @ Override protected void notifyListener ( RunListener listener ) throws Exception { for ( Failure each : failures ) { listener . testFailure ( each ) ; } } } . run ( ) ; } } public void fireTestAssumptionFailed ( final Failure failure ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testAssumptionFailure ( failure ) ; } } . run ( ) ; } public void fireTestIgnored ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testIgnored ( description ) ; } } . run ( ) ; } public void fireTestFinished ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testFinished ( description ) ; } } . run ( ) ; } public void pleaseStop ( ) { pleaseStop = true ; } public void addFirstListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot add a null listener " ) ; } listeners . add ( 0 , wrapIfNotThreadSafe ( listener ) ) ; } }
public void fireTestStarted ( final Description description ) throws StoppedByUserException { if ( pleaseStop ) { throw new StoppedByUserException ( ) ; } new SafeNotifier ( ) { @ Override
public void fireTestFailure ( Failure failure ) { fireTestFailures ( listeners , asList ( failure ) ) ; }
public void pleaseStop ( ) { pleaseStop = true ; }
public void addFirstListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot add a null listener " ) ; } listeners . add ( 0 , wrapIfNotThreadSafe ( listener ) ) ; }
public void testRunStarted ( Description description ) throws Exception { synchronized ( monitor ) { listener . testRunStarted ( description ) ;
public void testRunFinished ( Result result ) throws Exception { synchronized ( monitor ) { listener . testRunFinished ( result ) ;
public void testStarted ( Description description ) throws Exception { synchronized ( monitor ) { listener . testStarted ( description ) ;
public void testFinished ( Description description ) throws Exception { synchronized ( monitor ) { listener . testFinished ( description ) ;
public void testFailure ( Failure failure ) throws Exception { synchronized ( monitor ) { listener . testFailure ( failure ) ;
public void testAssumptionFailure ( Failure failure ) { synchronized ( monitor ) { listener . testAssumptionFailure ( failure ) ;
public void testIgnored ( Description description ) throws Exception { synchronized ( monitor ) { listener . testIgnored ( description ) ;
public int hashCode ( ) { return listener . hashCode ( ) ; }
public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( ! ( other instanceof SynchronizedRunListener ) ) { return false ; } SynchronizedRunListener that = ( SynchronizedRunListener ) other ; return listener . equals ( that . listener ) ; }
public String toString ( ) { return listener . toString ( ) + " ( with synchronization wrapper ) " ; }
protected Description describeChild ( FrameworkMethod method ) { Description description = methodDescriptions . get ( method ) ; if ( description = = null ) { description = Description . createTestDescription ( getTestClass ( ) . getJavaClass ( ) , testName ( method ) , method . getAnnotations ( ) ) ; methodDescriptions . putIfAbsent ( method , description ) ; } return description ; }
protected Statement withBeforeClasses ( Statement statement ) { List < FrameworkMethod > befores = testClass . getAnnotatedMethods ( BeforeClass . class ) ; return befores . isEmpty ( ) ? statement : new RunBefores ( statement , befores , null ) ;
protected Statement withAfterClasses ( Statement statement ) { List < FrameworkMethod > afters = testClass . getAnnotatedMethods ( AfterClass . class ) ; return afters . isEmpty ( ) ? statement : new RunAfters ( statement , afters , null ) ;
protected List < TestRule > classRules ( ) { List < TestRule > result = testClass . getAnnotatedMethodValues ( null , ClassRule . class , TestRule . class ) ; result . addAll ( testClass . getAnnotatedFieldValues ( null , ClassRule . class , TestRule . class ) ) ; return result ; }
public void filter ( Filter filter ) throws NoTestsRemainException { synchronized ( childrenLock ) { List < T > children = new ArrayList < T > ( getFilteredChildren ( ) ) ;
public Object get ( Object target ) throws IllegalArgumentException , IllegalAccessException { return field . get ( target ) ; }
public String toString ( ) { return field . toString ( ) ; }
protected Object runReflectiveCall ( ) throws Throwable { return method . invoke ( target , params ) ; }
public void validateNoTypeParametersOnArgs ( List < Throwable > errors ) { new NoGenericTypeParametersValidator ( method ) . validate ( errors ) ; }
public boolean equals ( Object obj ) { if ( ! FrameworkMethod . class . isInstance ( obj ) ) { return false ; } return ( ( FrameworkMethod ) obj ) . method . equals ( method ) ; }
public int hashCode ( ) { return method . hashCode ( ) ; }
public boolean producesType ( Type type ) { return getParameterTypes ( ) . length = = 0 & & type instanceof Class < ? > & & ( ( Class < ? > ) type ) . isAssignableFrom ( method . getReturnType ( ) ) ;
public String toString ( ) { return method . toString ( ) ; }
private void validateNoTypeParameterOnType ( Type type , List < Throwable > errors ) { if ( type instanceof TypeVariable < ? > ) { errors . add ( new Exception ( " Method " + method . getName ( )
public List < FrameworkMethod > getAnnotatedMethods ( Class < ? extends Annotation > annotationClass ) { return Collections . unmodifiableList ( getAnnotatedMembers ( methodsForAnnotations , annotationClass , false ) ) ; }
public List < FrameworkField > getAnnotatedFields ( Class < ? extends Annotation > annotationClass ) { return Collections . unmodifiableList ( getAnnotatedMembers ( fieldsForAnnotations , annotationClass , false ) ) ; }
public boolean isPublic ( ) { return Modifier . isPublic ( clazz . getModifiers ( ) ) ; }
public boolean isANonStaticInnerClass ( ) { return clazz . isMemberClass ( ) & & ! isStatic ( clazz . getModifiers ( ) ) ; }
public int hashCode ( ) { return ( clazz = = null ) ? 0 : clazz . hashCode ( ) ; }
private Object createTestUsingConstructorInjection ( ) throws Exception { return getTestClass ( ) . getOnlyConstructor ( ) . newInstance ( parameters ) ; }
private Object createTestUsingFieldInjection ( ) throws Exception { List < FrameworkField > annotatedFieldsByParameter = getAnnotatedFieldsByParameter ( ) ; if ( annotatedFieldsByParameter . size ( ) ! = parameters . length ) { throw new Exception ( " Wrong number of parameters and @ Parameter fields . " + " @ Parameter fields counted : " + annotatedFieldsByParameter . size ( ) + " , available parameters : " + parameters . length + " . " ) ; } Object testClassInstance = getTestClass ( ) . getJavaClass ( ) . newInstance ( ) ; for ( FrameworkField each : annotatedFieldsByParameter ) { Field field = each . getField ( ) ; Parameter annotation = field . getAnnotation ( Parameter . class ) ; int index = annotation . value ( ) ; try { field . set ( testClassInstance , parameters [ index ] ) ; } catch ( IllegalArgumentException iare ) { throw new Exception ( getTestClass ( ) . getName ( ) + " : Trying to set " + field . getName ( ) + " with the value " + parameters [ index ] + " that is not the right type ( " + parameters [ index ] . getClass ( ) . getSimpleName ( ) + " instead of " + field . getType ( ) . getSimpleName ( ) + " ) . " , iare ) ; } } return testClassInstance ; }
public int hashCode ( ) { int prime = 14747 ; int result = prime + name . hashCode ( ) ; result = prime * result + testClass . hashCode ( ) ; return prime * result + parameters . hashCode ( ) ; }
public String toString ( ) { return testClass . getName ( ) + " ' " + name + " ' with parameters " + parameters ;
private void validateMember ( FrameworkMember < ? > member , List < Throwable > errors ) { for ( RuleValidator strategy : validatorStrategies ) { strategy . validate ( member , annotation , errors ) ;
private static Builder classRuleValidatorBuilder ( ) { return new Builder ( ClassRule . class ) ; }
private static Builder testRuleValidatorBuilder ( ) { return new Builder ( Rule . class ) ; }
Builder forMethods ( ) { methods = true ; return this ; }
Builder withValidator ( RuleValidator validator ) { validators . add ( validator ) ; return this ; }
RuleFieldValidator build ( ) { return new RuleFieldValidator ( this ) ; }
private static boolean isRuleType ( FrameworkMember < ? > member ) { return isMethodRule ( member ) | | isTestRule ( member ) ; }
private static boolean isTestRule ( FrameworkMember < ? > member ) { return TestRule . class . isAssignableFrom ( member . getType ( ) ) ; }
private static boolean isMethodRule ( FrameworkMember < ? > member ) { return MethodRule . class . isAssignableFrom ( member . getType ( ) ) ; }
void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) ; } private static final class MemberMustBeNonStatic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( member . isStatic ( ) ) { errors . add ( new ValidationError ( member , annotation , " must not be static or it must be annotated with @ ClassRule . " ) ) ; } } } private static final class MemberMustBeStatic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isStatic ( ) ) { errors . add ( new ValidationError ( member , annotation , " must be static . " ) ) ; } } } private static final class DeclaringClassMustBePublic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isDeclaringClassPublic ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must be declared in a public class . " ) ) ; } } private boolean isDeclaringClassPublic ( FrameworkMember < ? > member ) { return Modifier . isPublic ( member . getDeclaringClass ( ) . getModifiers ( ) ) ; } } private static final class MemberMustBePublic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isPublic ( ) ) { errors . add ( new ValidationError ( member , annotation , " must be public . " ) ) ; } } } private static final class FieldMustBeARule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isRuleType ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must implement MethodRule or TestRule . " ) ) ; } } } private static final class MethodMustBeARule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isRuleType ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must return an implementation of MethodRule or TestRule . " ) ) ; } } } }
public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( member . isStatic ( ) ) { errors . add ( new ValidationError ( member , annotation ,
public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isStatic ( ) ) { errors . add ( new ValidationError ( member , annotation ,
public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isDeclaringClassPublic ( member ) ) { errors . add ( new ValidationError ( member , annotation ,
private boolean isDeclaringClassPublic ( FrameworkMember < ? > member ) { return Modifier . isPublic ( member . getDeclaringClass ( ) . getModifiers ( ) ) ; }
public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isPublic ( ) ) { errors . add ( new ValidationError ( member , annotation ,
public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isRuleType ( member ) ) { errors . add ( new ValidationError ( member , annotation ,
public void rejectClassRuleInNonPublicClass ( ) { TestClass target = new TestClass ( NonPublicTestWithClassRule . class ) ; CLASS_RULE_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ ClassRule ' temporaryFolder ' must be declared in a public class . " ) ; }
public void rejectStaticTestRule ( ) { TestClass target = new TestClass ( TestWithStaticTestRule . class ) ; RULE_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ Rule ' temporaryFolder ' must not be static or it must be annotated with @ ClassRule . " ) ; }
public void rejectMethodStaticTestRule ( ) { TestClass target = new TestClass ( TestMethodWithStaticTestRule . class ) ; RULE_METHOD_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ Rule ' getTemporaryFolder ' must not be static or it must be annotated with @ ClassRule . " ) ; }
void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) ; } private static final class MemberMustBeNonStatic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( member . isStatic ( ) ) { String message ; if ( isMethodRule ( member ) ) { message = " must not be static . " ; } else { message = " must not be static or it must be annotated with @ ClassRule . " ; } errors . add ( new ValidationError ( member , annotation , message ) ) ; } } } private static final class MemberMustBeStatic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isStatic ( ) ) { errors . add ( new ValidationError ( member , annotation , " must be static . " ) ) ; } } } private static final class DeclaringClassMustBePublic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isDeclaringClassPublic ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must be declared in a public class . " ) ) ; } } private boolean isDeclaringClassPublic ( FrameworkMember < ? > member ) { return Modifier . isPublic ( member . getDeclaringClass ( ) . getModifiers ( ) ) ; } } private static final class MemberMustBePublic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isPublic ( ) ) { errors . add ( new ValidationError ( member , annotation , " must be public . " ) ) ; } } } private static final class FieldMustBeARule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isRuleType ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must implement MethodRule or TestRule . " ) ) ; } } } private static final class MethodMustBeARule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isRuleType ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must return an implementation of MethodRule or TestRule . " ) ) ; } } } }
public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( member . isStatic ( ) ) { String message ;
public void rejectStaticMethodRule ( ) { TestClass target = new TestClass ( TestWithStaticMethodRule . class ) ; RULE_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ Rule ' testWatchman ' must not be static . " ) ; }
public void rejectMethodStaticMethodRule ( ) { TestClass target = new TestClass ( TestMethodWithStaticMethodRule . class ) ; RULE_METHOD_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ Rule ' getTestWatchman ' must not be static . " ) ; }
RuleMemberValidator build ( ) { return new RuleMemberValidator ( this ) ; }
void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) ; } private static final class MemberMustBeNonStaticOrAlsoClassRule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { boolean isMethodRuleMember = isMethodRule ( member ) ; boolean isClassRuleAnnotated = ( member . getAnnotation ( ClassRule . class ) ! = null ) ; if ( member . isStatic ( ) & & ( isMethodRuleMember | | ! isClassRuleAnnotated ) ) { String message ; if ( isMethodRule ( member ) ) { message = " must not be static . " ; } else { message = " must not be static or it must be annotated with @ ClassRule . " ; } errors . add ( new ValidationError ( member , annotation , message ) ) ; } } } private static final class MemberMustBeStatic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isStatic ( ) ) { errors . add ( new ValidationError ( member , annotation , " must be static . " ) ) ; } } } private static final class DeclaringClassMustBePublic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isDeclaringClassPublic ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must be declared in a public class . " ) ) ; } } private boolean isDeclaringClassPublic ( FrameworkMember < ? > member ) { return Modifier . isPublic ( member . getDeclaringClass ( ) . getModifiers ( ) ) ; } } private static final class MemberMustBePublic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isPublic ( ) ) { errors . add ( new ValidationError ( member , annotation , " must be public . " ) ) ; } } } private static final class FieldMustBeARule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isRuleType ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must implement MethodRule or TestRule . " ) ) ; } } } private static final class MethodMustBeARule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isRuleType ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must return an implementation of MethodRule or TestRule . " ) ) ; } } } }
public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { boolean isMethodRuleMember = isMethodRule ( member ) ; boolean isClassRuleAnnotated = ( member . getAnnotation ( ClassRule . class ) ! = null ) ; if ( member . isStatic ( ) & & ( isMethodRuleMember | | ! isClassRuleAnnotated ) ) { String message ;
Annotation [ ] getAnnotations ( ) ; < T extends Annotation > T getAnnotation ( Class < T > annotationType ) ; }
< T extends Annotation > T getAnnotation ( Class < T > annotationType ) ; }
public void presentAnnotationIsAvailable ( ) throws Exception { Field field = ClassWithDummyField . class . getField ( " annotatedField " ) ; FrameworkField frameworkField = new FrameworkField ( field ) ; Annotation annotation = frameworkField . getAnnotation ( Rule . class ) ; assertTrue ( Rule . class . isAssignableFrom ( annotation . getClass ( ) ) ) ; }
public void missingAnnotationIsNotAvailable ( ) throws Exception { Field field = ClassWithDummyField . class . getField ( " annotatedField " ) ; FrameworkField frameworkField = new FrameworkField ( field ) ; Annotation annotation = frameworkField . getAnnotation ( ClassRule . class ) ; assertThat ( annotation , is ( nullValue ( ) ) ) ; }
public void presentAnnotationIsAvailable ( ) throws Exception { Method method = ClassWithDummyMethod . class . getMethod ( " annotatedDummyMethod " ) ; FrameworkMethod frameworkMethod = new FrameworkMethod ( method ) ; Annotation annotation = frameworkMethod . getAnnotation ( Rule . class ) ; assertTrue ( Rule . class . isAssignableFrom ( annotation . getClass ( ) ) ) ; }
public void missingAnnotationIsNotAvailable ( ) throws Exception { Method method = ClassWithDummyMethod . class . getMethod ( " annotatedDummyMethod " ) ; FrameworkMethod frameworkMethod = new FrameworkMethod ( method ) ; Annotation annotation = frameworkMethod . getAnnotation ( ClassRule . class ) ; assertThat ( annotation , is ( nullValue ( ) ) ) ; }
public void dummyMethod ( ) { } @ Rule public void annotatedDummyMethod ( ) { } } }
public void annotatedDummyMethod ( ) { } } }
public void presentAnnotationIsAvailable ( ) { TestClass tc = new TestClass ( AnnotatedClass . class ) ; Annotation annotation = tc . getAnnotation ( Ignore . class ) ; assertTrue ( Ignore . class . isAssignableFrom ( annotation . getClass ( ) ) ) ; }
public void missingAnnotationIsNotAvailable ( ) { TestClass tc = new TestClass ( AnnotatedClass . class ) ; Annotation annotation = tc . getAnnotation ( RunWith . class ) ; assertThat ( annotation , is ( nullValue ( ) ) ) ; }
public void acceptStaticTestRuleThatIsAlsoClassRule ( ) { TestClass target = new TestClass ( TestWithStaticClassAndTestRule . class ) ; CLASS_RULE_VALIDATOR . validate ( target , errors ) ; assertNumberOfErrors ( 0 ) ; }
public void acceptMethodStaticTestRuleThatIsAlsoClassRule ( ) { TestClass target = new TestClass ( MethodTestWithStaticClassAndTestRule . class ) ; CLASS_RULE_METHOD_VALIDATOR . validate ( target , errors ) ; assertNumberOfErrors ( 0 ) ; }
public void evaluate ( ) throws Throwable { List < Throwable > errors = new ArrayList < Throwable > ( ) ; startingQuietly ( description , errors ) ; try { base . evaluate ( ) ; succeededQuietly ( description , errors ) ; } catch ( @ SuppressWarnings ( " deprecation " ) org . junit . internal . AssumptionViolatedException e ) { errors . add ( e ) ; skippedQuietly ( e , description , errors ) ; } catch ( Throwable e ) { errors . add ( e ) ; failedQuietly ( e , description , errors ) ; } finally { finishedQuietly ( description , errors ) ; } MultipleFailureException . assertEmpty ( errors ) ; }
private void skippedQuietly ( org . junit . internal . AssumptionViolatedException e , Description description , List < Throwable > errors ) { try { if ( e instanceof AssumptionViolatedException ) {
protected void succeeded ( Description description ) { } protected void failed ( Throwable e , Description description ) { } @ SuppressWarnings ( " deprecation " ) protected void skipped ( AssumptionViolatedException e , Description description ) { org . junit . internal . AssumptionViolatedException asInternalException = e ; skipped ( asInternalException , description ) ; } @ Deprecated protected void skipped ( org . junit . internal . AssumptionViolatedException e , Description description ) { } protected void starting ( Description description ) { } protected void finished ( Description description ) { } }
protected void failed ( Throwable e , Description description ) { } @ SuppressWarnings ( " deprecation " ) protected void skipped ( AssumptionViolatedException e , Description description ) { org . junit . internal . AssumptionViolatedException asInternalException = e ; skipped ( asInternalException , description ) ; } @ Deprecated protected void skipped ( org . junit . internal . AssumptionViolatedException e , Description description ) { } protected void starting ( Description description ) { } protected void finished ( Description description ) { } }
protected void skipped ( AssumptionViolatedException e , Description description ) { org . junit . internal . AssumptionViolatedException asInternalException = e ; skipped ( asInternalException , description ) ; }
protected void skipped ( org . junit . internal . AssumptionViolatedException e , Description description ) { } protected void starting ( Description description ) { } protected void finished ( Description description ) { } }
protected void skipped ( AssumptionViolatedException e , Description description ) { log . append ( " skipped " ) ; }
public void neitherLogSuccessNorFailedForViolatedAssumption ( ) { ViolatedAssumptionTest . watchedLog = new StringBuilder ( ) ; runClasses ( ViolatedAssumptionTest . class ) ; assertThat ( ViolatedAssumptionTest . watchedLog . toString ( ) , is ( " starting skipped finished " ) ) ;
protected void starting ( Description description ) { watchedLog . append ( " starting " ) ; }
protected void finished ( Description description ) { watchedLog . append ( " finished " ) ; }
protected void skipped ( AssumptionViolatedException e , Description description ) { watchedLog . append ( " skipped " ) ; }
public void succeeds ( ) { throw new AssumptionViolatedException ( " don ' t run " ) ; }
public void internalViolatedAssumption ( ) { InternalViolatedAssumptionTest . watchedLog = new StringBuilder ( ) ; runClasses ( InternalViolatedAssumptionTest . class ) ; assertThat ( InternalViolatedAssumptionTest . watchedLog . toString ( ) , is ( " starting skipped finished " ) ) ;
public int hashCode ( ) { return toString ( ) . hashCode ( ) ; }
public void equalsReturnsTrue ( Throwable targetException , String methodName , Object [ ] params ) { assertThat ( new ParameterizedAssertionError ( targetException , methodName , params ) ,
public void sameHashCodeWhenEquals ( Throwable targetException , String methodName , Object [ ] params ) { ParameterizedAssertionError one = new ParameterizedAssertionError ( targetException , methodName , params ) ; ParameterizedAssertionError two = new ParameterizedAssertionError ( targetException , methodName , params ) ; assumeThat ( one , is ( two ) ) ; assertThat ( one . hashCode ( ) , is ( two . hashCode ( ) ) ) ; }
public void buildParameterizedAssertionError ( String methodName , String param ) { assertThat ( new ParameterizedAssertionError ( new RuntimeException ( ) , methodName , param ) . toString ( ) ,
public long runtime ( TimeUnit unit ) { return unit . convert ( clock . nanoTime ( ) - startNanos , TimeUnit . NANOSECONDS ) ; }
private void starting ( ) { startNanos = clock . nanoTime ( ) ; endNanos = 0 ; }
private void stopping ( ) { endNanos = clock . nanoTime ( ) ; }
public final Statement apply ( Statement base , Description description ) { return new InternalWatcher ( ) . apply ( base , description ) ; }
@ Override protected void starting ( Description description ) { Stopwatch . this . starting ( ) ; }
@ Override protected void finished ( Description description ) { Stopwatch . this . finished ( getNanos ( ) , description ) ; }
@ Override protected void succeeded ( Description description ) { Stopwatch . this . stopping ( ) ; Stopwatch . this . succeeded ( getNanos ( ) , description ) ; }
@ Override protected void failed ( Throwable e , Description description ) { Stopwatch . this . stopping ( ) ; Stopwatch . this . failed ( getNanos ( ) , e , description ) ; }
@ Override protected void skipped ( AssumptionViolatedException e , Description description ) { Stopwatch . this . stopping ( ) ; Stopwatch . this . skipped ( getNanos ( ) , e , description ) ; }
public long nanoTime ( ) { return System . nanoTime ( ) ; }
public long nanoTime ( ) { return fakeTimeNanos + + ; }
protected void succeeded ( long nanos , Description description ) { StopwatchTest . record = new Record ( nanos , TestStatus . SUCCEEDED , description ) ; }
protected void failed ( long nanos , Throwable e , Description description ) { StopwatchTest . record = new Record ( nanos , TestStatus . FAILED , description ) ; }
protected void skipped ( long nanos , AssumptionViolatedException e , Description description ) { StopwatchTest . record = new Record ( nanos , TestStatus . SKIPPED , description ) ; }
protected void finished ( long nanos , Description description ) { StopwatchTest . finishedRecord = new Record ( nanos , description ) ; }
public void successfulTest ( ) { } } public static class FailedTest extends AbstractStopwatchTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractStopwatchTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } public static class WrongDurationTest extends AbstractStopwatchTest { @ Test public void duration ( ) { simulateTimePassing ( 300L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; simulateTimePassing ( 500L ) ; assertEquals ( 800L , stopwatch . runtime ( MILLISECONDS ) ) ; } } @ Before public void init ( ) { record = new Record ( ) ; finishedRecord = new Record ( ) ; simulateTimePassing ( 1L ) ; } private static Result runTest ( Class < ? > test ) { simulateTimePassing ( 1L ) ; JUnitCore junitCore = new JUnitCore ( ) ; return junitCore . run ( Request . aClass ( test ) . getRunner ( ) ) ; } private static void simulateTimePassing ( long millis ) { fakeTimeNanos + = TimeUnit . MILLISECONDS . toNanos ( millis ) ; } @ Test public void succeeded ( ) { Result result = runTest ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " successfulTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; } @ Test public void failed ( ) { Result result = runTest ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " failedTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; } @ Test public void skipped ( ) { Result result = runTest ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " skippedTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; } @ Test public void wrongDuration ( ) { Result result = runTest ( WrongDurationTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void duration ( ) { simulateTimePassing ( 300L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; simulateTimePassing ( 500L ) ; assertEquals ( 800L , stopwatch . runtime ( MILLISECONDS ) ) ; }
public void init ( ) { record = new Record ( ) ; finishedRecord = new Record ( ) ; simulateTimePassing ( 1L ) ; }
private static Result runTest ( Class < ? > test ) { simulateTimePassing ( 1L ) ; JUnitCore junitCore = new JUnitCore ( ) ; return junitCore . run ( Request . aClass ( test ) . getRunner ( ) ) ; }
private static void simulateTimePassing ( long millis ) { fakeTimeNanos + = TimeUnit . MILLISECONDS . toNanos ( millis ) ; }
public void succeeded ( ) { Result result = runTest ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " successfulTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; }
public void failed ( ) { Result result = runTest ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " failedTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; }
public void skipped ( ) { Result result = runTest ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " skippedTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; }
public void wrongDuration ( ) { Result result = runTest ( WrongDurationTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; }
public long runtime ( TimeUnit unit ) { return unit . convert ( getNanos ( ) , TimeUnit . NANOSECONDS ) ; }
protected void succeeded ( long nanos , Description description ) { StopwatchTest . record = new Record ( nanos , TestStatus . SUCCEEDED , description ) ; simulateTimePassing ( 1 ) ; }
protected void failed ( long nanos , Throwable e , Description description ) { StopwatchTest . record = new Record ( nanos , TestStatus . FAILED , description ) ; simulateTimePassing ( 1 ) ; }
protected void skipped ( long nanos , AssumptionViolatedException e , Description description ) { StopwatchTest . record = new Record ( nanos , TestStatus . SKIPPED , description ) ; simulateTimePassing ( 1 ) ; }
protected void finished ( Description description ) { afterStopwatchRule ( ) ; }
protected void afterStopwatchRule ( ) { } } public static class SuccessfulTest extends AbstractStopwatchTest { @ Test public void successfulTest ( ) { } } public static class FailedTest extends AbstractStopwatchTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractStopwatchTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } public static class DurationDuringTestTest extends AbstractStopwatchTest { @ Test public void duration ( ) { simulateTimePassing ( 300L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; simulateTimePassing ( 500L ) ; assertEquals ( 800L , stopwatch . runtime ( MILLISECONDS ) ) ; } } public static class DurationAfterTestTest extends AbstractStopwatchTest { @ Test public void duration ( ) { simulateTimePassing ( 300L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; } @ Override protected void afterStopwatchRule ( ) { assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; simulateTimePassing ( 500L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; } } @ Before public void init ( ) { record = new Record ( ) ; finishedRecord = new Record ( ) ; simulateTimePassing ( 1L ) ; } private static Result runTest ( Class < ? > test ) { simulateTimePassing ( 1L ) ; JUnitCore junitCore = new JUnitCore ( ) ; return junitCore . run ( Request . aClass ( test ) . getRunner ( ) ) ; } private static void simulateTimePassing ( long millis ) { fakeTimeNanos + = TimeUnit . MILLISECONDS . toNanos ( millis ) ; } @ Test public void succeeded ( ) { Result result = runTest ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " successfulTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; } @ Test public void failed ( ) { Result result = runTest ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " failedTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; } @ Test public void skipped ( ) { Result result = runTest ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " skippedTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; } @ Test public void runtimeDuringTestShouldReturnTimeSinceStart ( ) { Result result = runTest ( DurationDuringTestTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test public void runtimeAfterTestShouldReturnRunDuration ( ) { Result result = runTest ( DurationAfterTestTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void successfulTest ( ) { } } public static class FailedTest extends AbstractStopwatchTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractStopwatchTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } public static class DurationDuringTestTest extends AbstractStopwatchTest { @ Test public void duration ( ) { simulateTimePassing ( 300L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; simulateTimePassing ( 500L ) ; assertEquals ( 800L , stopwatch . runtime ( MILLISECONDS ) ) ; } } public static class DurationAfterTestTest extends AbstractStopwatchTest { @ Test public void duration ( ) { simulateTimePassing ( 300L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; } @ Override protected void afterStopwatchRule ( ) { assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; simulateTimePassing ( 500L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; } } @ Before public void init ( ) { record = new Record ( ) ; finishedRecord = new Record ( ) ; simulateTimePassing ( 1L ) ; } private static Result runTest ( Class < ? > test ) { simulateTimePassing ( 1L ) ; JUnitCore junitCore = new JUnitCore ( ) ; return junitCore . run ( Request . aClass ( test ) . getRunner ( ) ) ; } private static void simulateTimePassing ( long millis ) { fakeTimeNanos + = TimeUnit . MILLISECONDS . toNanos ( millis ) ; } @ Test public void succeeded ( ) { Result result = runTest ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " successfulTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; } @ Test public void failed ( ) { Result result = runTest ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " failedTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; } @ Test public void skipped ( ) { Result result = runTest ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . name , is ( " skippedTest " ) ) ; assertThat ( record . name , is ( finishedRecord . name ) ) ; assertThat ( record . status , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , record . duration > 0 ) ; assertThat ( record . duration , is ( finishedRecord . duration ) ) ; } @ Test public void runtimeDuringTestShouldReturnTimeSinceStart ( ) { Result result = runTest ( DurationDuringTestTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test public void runtimeAfterTestShouldReturnRunDuration ( ) { Result result = runTest ( DurationAfterTestTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void duration ( ) { simulateTimePassing ( 300L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; }
protected void afterStopwatchRule ( ) { assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; simulateTimePassing ( 500L ) ; assertEquals ( 300L , stopwatch . runtime ( MILLISECONDS ) ) ; }
public void runtimeDuringTestShouldReturnTimeSinceStart ( ) { Result result = runTest ( DurationDuringTestTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; }
public void runtimeAfterTestShouldReturnRunDuration ( ) { Result result = runTest ( DurationAfterTestTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; }
public void aTest ( ) { } } @ Test public void beforeAndAfterClassAreRun ( ) { fLog = " " ; JUnitCore . runClasses ( BeforeAndAfter . class ) ; assertEquals ( " before after " , fLog ) ; } @ RunWith ( Parameterized . class ) static public class EmptyTest { @ BeforeClass public static void before ( ) { fLog + = " before " ; } @ AfterClass public static void after ( ) { fLog + = " after " ; } } @ Test public void validateClassCatchesNoParameters ( ) { Result result = JUnitCore . runClasses ( EmptyTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class IncorrectTest { @ Test public int test ( ) { return 0 ; } @ Parameters public static Collection < Object [ ] > data ( ) { return Collections . singletonList ( new Object [ ] { 1 } ) ; } } @ Test public void failuresAddedForBadTestMethod ( ) throws Exception { Result result = JUnitCore . runClasses ( IncorrectTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ProtectedParametersTest { @ Parameters protected static Collection < Object [ ] > data ( ) { return Collections . emptyList ( ) ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersNotPublic ( ) { assertTestCreatesSingleFailureWithMessage ( ProtectedParametersTest . class , " No public static parameters method on class " + ProtectedParametersTest . class . getName ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ParametersNotIterable { @ Parameters public static String data ( ) { return " foo " ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersNotPublic ( ) { assertTestCreatesSingleFailureWithMessage ( ProtectedParametersTest . class , " No public static parameters method on class " + ProtectedParametersTest . class . getName ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ParametersNotIterable { @ Parameters public static String data ( ) { return " foo " ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class ,
public static Filter createFilterFromFilterSpec ( Request request , String filterSpec ) throws FilterFactory . FilterNotCreatedException { Description topLevelDescription = request . getRunner ( ) . getDescription ( ) ; String [ ] tuple ; if ( filterSpec . contains ( " = " ) ) { tuple = filterSpec . split ( " = " , 2 ) ; } else { tuple = new String [ ] { filterSpec , " " } ; } return createFilter ( tuple [ 0 ] , new FilterFactoryParams ( topLevelDescription , tuple [ 1 ] ) ) ; }
private void parseArgs ( String [ ] args ) { parseParameters ( parseOptions ( args ) ) ; }
String [ ] parseOptions ( String . . . args ) { for ( int i = 0 ; i ! = args . length ; + + i ) { String arg = args [ i ] ; if ( arg . equals ( " - - " ) ) { return copyArray ( args , i + 1 , args . length ) ; } else if ( arg . startsWith ( " - - " ) ) { if ( arg . startsWith ( " - - filter = " ) | | arg . equals ( " - - filter " ) ) { String filterSpec ; if ( arg . equals ( " - - filter " ) ) { + + i ; if ( i < args . length ) { filterSpec = args [ i ] ; } else { parserErrors . add ( new CommandLineParserError ( arg + " value not specified " ) ) ; break ; } } else { filterSpec = arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ; } filterSpecs . add ( filterSpec ) ; } else { parserErrors . add ( new CommandLineParserError ( " JUnit knows nothing about the " + arg + " option " ) ) ; } } else { return copyArray ( args , i , args . length ) ; } } return new String [ ] { } ; }
private Request errorReport ( Throwable cause ) { return Request . errorReport ( JUnitCommandLineParseResult . class , cause ) ; }
public Request createRequest ( Computer computer ) { if ( parserErrors . isEmpty ( ) ) { Request request = Request . classes (
private Request applyFilterSpecs ( Request request ) { try { for ( String filterSpec : filterSpecs ) {
public void shouldCreateFilter ( ) throws Exception { FilterFactoryParams params = new FilterFactoryParams ( createSuiteDescription ( testName . getMethodName ( ) ) , CategoryFilterFactoryStub . class . getName ( ) ) ; Filter filter = categoryFilterFactory . createFilter ( params ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldThrowException ( ) throws Exception { FilterFactoryParams params = new FilterFactoryParams ( createSuiteDescription ( testName . getMethodName ( ) ) , " NonExistentFilter " ) ; expectedException . expect ( FilterFactory . FilterNotCreatedException . class ) ; categoryFilterFactory . createFilter ( params ) ; }
private Request createSuiteRequest ( ) { return Request . aClass ( DummySuite . class ) ; }
public void shouldCreateFilterWithArguments ( ) throws Exception { Filter filter = FilterFactories . createFilterFromFilterSpec ( createSuiteRequest ( ) , ExcludeCategories . class . getName ( ) + " = " + DummyCategory . class . getName ( ) ) ; assertThat ( filter . describe ( ) , startsWith ( " excludes " ) ) ; }
public void shouldCreateFilterWithNoArguments ( ) throws Exception { Filter filter = FilterFactories . createFilterFromFilterSpec ( createSuiteRequest ( ) , FilterFactoryStub . class . getName ( ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldPassOnDescriptionToFilterFactory ( ) throws Exception { Request request = createSuiteRequest ( ) ; Description description = request . getRunner ( ) . getDescription ( ) ; Filter filter = FilterFactories . createFilterFromFilterSpec ( request , FilterFactoryStub . class . getName ( ) ) ; assumeThat ( filter , instanceOf ( DummyFilter . class ) ) ; DummyFilter dummyFilter = ( DummyFilter ) filter ; assertThat ( dummyFilter . getTopLevelDescription ( ) , is ( description ) ) ; }
public void shouldCreateFilter ( ) throws Exception { Filter filter = FilterFactories . createFilter ( FilterFactoryStub . class , new FilterFactoryParams ( Description . createSuiteDescription ( testName . getMethodName ( ) ) , " " ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public Filter createFilter ( FilterFactoryParams params ) { return new DummyFilter ( params . getTopLevelDescription ( ) ) ; }
public void shouldStopParsingOptionsUponDoubleHyphenArg ( ) throws Exception { String [ ] restOfArgs = jUnitCommandLineParseResult . parseOptions ( " - - 0 " , " - - 1 " , " - - " , " - - 2 " , " - - 3 " ) ; assertThat ( restOfArgs , is ( new String [ ] { " - - 2 " , " - - 3 " } ) ) ; }
public void shouldParseFilterArgWithEqualsSyntax ( ) throws Exception { String value = IncludeCategories . class . getName ( ) + " = " + DummyCategory0 . class . getName ( ) ; jUnitCommandLineParseResult . parseOptions ( " - - filter = " + value ) ; List < String > specs = jUnitCommandLineParseResult . getFilterSpecs ( ) ; assertThat ( specs , hasItems ( value ) ) ; }
public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue ( ) { jUnitCommandLineParseResult . parseOptions ( " - - filter " ) ; Runner runner = jUnitCommandLineParseResult . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public void shouldParseFilterArgInWhichValueIsASeparateArg ( ) throws Exception { String value = IncludeCategories . class . getName ( ) + " = " + DummyCategory0 . class . getName ( ) ; jUnitCommandLineParseResult . parseOptions ( " - - filter " , value ) ; List < String > specs = jUnitCommandLineParseResult . getFilterSpecs ( ) ; assertThat ( specs , hasItems ( value ) ) ; }
public Statement apply ( Statement base , Description description ) { if ( debugging ) { return base ;
private static boolean isDebugging ( List < String > arguments ) { for ( final String argument : arguments ) { if ( " - Xdebug " . equals ( argument ) ) { return true ; } else if ( argument . startsWith ( " - agentlib : jdwp " ) ) { return true ; } } return false ; }
public boolean isDebugging ( ) { return debugging ; }
public Statement apply ( Statement base , Description description ) { return new Statement ( ) {
public void evaluate ( ) throws Throwable { throw new AssertionError ( ) ; }
public void test ( ) { } } public static class PreJava5DebugArgumentsTest extends AbstractDisableOnDebugTest { public PreJava5DebugArgumentsTest ( ) { super ( PRE_JAVA5_DEBUG_ARGUMENTS ) ; } } public static class PreJava5DebugArgumentsReversedTest extends AbstractDisableOnDebugTest { public PreJava5DebugArgumentsReversedTest ( ) { super ( PRE_JAVA5_DEBUG_ARGUMENTS_IN_REVERSE_ORDER ) ; } } public static class PostJava5DebugArgumentsTest extends AbstractDisableOnDebugTest { public PostJava5DebugArgumentsTest ( ) { super ( POST_JAVA5_DEBUG_ARGUMENTS ) ; } } public static class WithoutDebugArgumentsTest extends AbstractDisableOnDebugTest { public WithoutDebugArgumentsTest ( ) { super ( WITHOUT_DEBUG_ARGUMENTS ) ; } } @ Test public void givenPreJava5DebugArgumentsIsDebuggingShouldReturnTrue ( ) { DisableOnDebug subject = new DisableOnDebug ( new FailOnExecution ( ) , PRE_JAVA5_DEBUG_ARGUMENTS ) ; assertTrue ( " Should be debugging " , subject . isDebugging ( ) ) ; } @ Test public void givenPreJava5DebugArgumentsInReverseIsDebuggingShouldReturnTrue ( ) { DisableOnDebug subject = new DisableOnDebug ( new FailOnExecution ( ) , PRE_JAVA5_DEBUG_ARGUMENTS_IN_REVERSE_ORDER ) ; assertTrue ( " Should be debugging " , subject . isDebugging ( ) ) ; } @ Test public void givenPostJava5DebugArgumentsIsDebuggingShouldReturnTrue ( ) { DisableOnDebug subject = new DisableOnDebug ( new FailOnExecution ( ) , POST_JAVA5_DEBUG_ARGUMENTS ) ; assertTrue ( " Should be debugging " , subject . isDebugging ( ) ) ; } @ Test public void givenArgumentsWithoutDebugFlagsIsDebuggingShouldReturnFalse ( ) { DisableOnDebug subject = new DisableOnDebug ( new FailOnExecution ( ) , WITHOUT_DEBUG_ARGUMENTS ) ; Assert . assertFalse ( " Should not be debugging " , subject . isDebugging ( ) ) ; } @ Test public void whenRunWithPreJava5DebugArgumentsTestShouldFail ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( PreJava5DebugArgumentsTest . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should not have failed " , 0 , result . getFailureCount ( ) ) ; } @ Test public void whenRunWithPreJava5DebugArgumentsInReverseOrderTestShouldFail ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( PreJava5DebugArgumentsReversedTest . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should not have failed " , 0 , result . getFailureCount ( ) ) ; } @ Test public void whenRunWithPostJava5DebugArgumentsTestShouldFail ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( PostJava5DebugArgumentsTest . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should not have failed " , 0 , result . getFailureCount ( ) ) ; } @ Test public void whenRunWithoutDebugFlagsTestShouldPass ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( WithoutDebugArgumentsTest . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should have failed " , 1 , result . getFailureCount ( ) ) ; } }
public void givenPreJava5DebugArgumentsIsDebuggingShouldReturnTrue ( ) { DisableOnDebug subject = new DisableOnDebug ( new FailOnExecution ( ) , PRE_JAVA5_DEBUG_ARGUMENTS ) ; assertTrue ( " Should be debugging " , subject . isDebugging ( ) ) ; }
public void givenPreJava5DebugArgumentsInReverseIsDebuggingShouldReturnTrue ( ) { DisableOnDebug subject = new DisableOnDebug ( new FailOnExecution ( ) , PRE_JAVA5_DEBUG_ARGUMENTS_IN_REVERSE_ORDER ) ; assertTrue ( " Should be debugging " , subject . isDebugging ( ) ) ; }
public void givenPostJava5DebugArgumentsIsDebuggingShouldReturnTrue ( ) { DisableOnDebug subject = new DisableOnDebug ( new FailOnExecution ( ) , POST_JAVA5_DEBUG_ARGUMENTS ) ; assertTrue ( " Should be debugging " , subject . isDebugging ( ) ) ; }
public void givenArgumentsWithoutDebugFlagsIsDebuggingShouldReturnFalse ( ) { DisableOnDebug subject = new DisableOnDebug ( new FailOnExecution ( ) , WITHOUT_DEBUG_ARGUMENTS ) ; Assert . assertFalse ( " Should not be debugging " , subject . isDebugging ( ) ) ; }
public void whenRunWithPreJava5DebugArgumentsTestShouldFail ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( PreJava5DebugArgumentsTest . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should not have failed " , 0 , result . getFailureCount ( ) ) ; }
public void whenRunWithPreJava5DebugArgumentsInReverseOrderTestShouldFail ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( PreJava5DebugArgumentsReversedTest . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should not have failed " , 0 , result . getFailureCount ( ) ) ; }
public void whenRunWithPostJava5DebugArgumentsTestShouldFail ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( PostJava5DebugArgumentsTest . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should not have failed " , 0 , result . getFailureCount ( ) ) ; }
public void whenRunWithoutDebugFlagsTestShouldPass ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( WithoutDebugArgumentsTest . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should have failed " , 1 , result . getFailureCount ( ) ) ; }
public void evaluate ( ) throws Throwable { CallableStatement callable = new CallableStatement ( ) ; FutureTask < Throwable > task = new FutureTask < Throwable > ( callable ) ; threadGroup = new ThreadGroup ( " FailOnTimeoutGroup " ) ; Thread thread = new Thread ( threadGroup , task , " Time - limited test " ) ; thread . setDaemon ( true ) ; thread . start ( ) ; callable . awaitStarted ( ) ; Throwable throwable = getResult ( task , thread ) ; if ( throwable ! = null ) { throw throwable ;
public Throwable call ( ) throws Exception { try { startLatch . countDown ( ) ; originalStatement . evaluate ( ) ; } catch ( Exception e ) { throw e ; } catch ( Throwable e ) { return e ; } return null ; }
public void awaitStarted ( ) throws InterruptedException { startLatch . await ( ) ; }
public void throwsTestTimedOutException ( ) throws Throwable { thrown . expect ( TestTimedOutException . class ) ; evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ; }
public void throwExceptionWithNiceMessageOnTimeout ( ) throws Throwable { thrown . expectMessage ( " test timed out after 100 milliseconds " ) ; evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ; }
public void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime ( ) throws Throwable { thrown . expect ( TestTimedOutException . class ) ; evaluateWithWaitDuration ( 0 ) ; evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ; }
public void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException ( ) throws Throwable { thrown . expectMessage ( " test timed out after 100 milliseconds " ) ; try { evaluateWithException ( new RuntimeException ( ) ) ; } catch ( Throwable expected ) { } evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ; }
public void throwsExceptionWithTimeoutValueAndTimeUnitSet ( ) throws Throwable { try { evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ;
public File newFolder ( String . . . folderNames ) throws IOException { File file = getRoot ( ) ; for ( int i = 0 ; i < folderNames . length ; i + + ) { String folderName = folderNames [ i ] ; validateFolderName ( folderName ) ; file = new File ( file , folderName ) ; if ( ! file . mkdir ( ) & & isLastElementInArray ( i , folderNames ) ) { throw new IOException ( " a folder with the name \ ' " + folderName + " \ ' already exists " ) ; } } return file ; }
public void newFolderWithGivenFolderThrowsIOExceptionIfFolderNameConsistsOfMultiplePathComponents ( ) throws IOException { tempFolder . create ( ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " name cannot consist of multiple path components " ) ; tempFolder . newFolder ( " temp1 / temp2 " ) ; }
public void newFolderWithGivenPathThrowsIOExceptionIfFolderNamesConsistOfMultiplePathComponents ( ) throws IOException { tempFolder . create ( ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " name cannot consist of multiple path components " ) ; tempFolder . newFolder ( " temp1 " , " temp2 " , " temp3 / temp4 " ) ; }
public static Builder builder ( ) { return new Builder ( ) ; }
public Builder withTimeout ( long timeout , TimeUnit unit ) { if ( timeout < 0 ) { throw new IllegalArgumentException ( " timeout must be non - negative " ) ; } if ( unit = = null ) { throw new NullPointerException ( " TimeUnit cannot be null " ) ; } this . timeout = timeout ; this . unit = unit ; return this ; }
public Builder withLookingForStuckThread ( boolean enable ) { this . lookForStuckThread = enable ; return this ; }
public FailOnTimeout build ( Statement statement ) { if ( statement = = null ) { throw new NullPointerException ( " statement cannot be null " ) ; } return new FailOnTimeout ( this , statement ) ; }
private Thread [ ] copyThreads ( Thread [ ] threads , int count ) { int length = Math . min ( count , threads . length ) ; Thread [ ] result = new Thread [ length ] ; for ( int i = 0 ; i < length ; i + + ) { result [ i ] = threads [ i ] ; } return result ; }
public Statement apply ( Statement base , Description description ) { try { return FailOnTimeout . builder ( )
@ Override public void evaluate ( ) throws Throwable { throw new RuntimeException ( " Invalid parameters for Timeout " , e ) ; }
public void wouldPass ( ) { } } @ Before public void before ( ) { run4done = false ; run1Lock . lock ( ) ; } @ After public void after ( ) { run4done = true ; run1Lock . unlock ( ) ; } @ Test public void timeUnitTimeout ( ) { HasGlobalTimeUnitTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalTimeUnitTimeout . class ) ; assertEquals ( 6 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run4 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run5 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run6 " ) ) ; } @ Test public void longTimeout ( ) { HasGlobalLongTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalLongTimeout . class ) ; assertEquals ( 6 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run4 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run5 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run6 " ) ) ; } @ Test public void nullTimeUnit ( ) { Result result = JUnitCore . runClasses ( HasNullTimeUnit . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . getException ( ) . getMessage ( ) , containsString ( " Invalid parameters for Timeout " ) ) ; Throwable cause = failure . getException ( ) . getCause ( ) ; assertThat ( cause . getMessage ( ) , containsString ( " TimeUnit cannot be null " ) ) ; } }
public void nullTimeUnit ( ) { Result result = JUnitCore . runClasses ( HasNullTimeUnit . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . getException ( ) . getMessage ( ) , containsString ( " Invalid parameters for Timeout " ) ) ; Throwable cause = failure . getException ( ) . getCause ( ) ; assertThat ( cause . getMessage ( ) , containsString ( " TimeUnit cannot be null " ) ) ; }
protected Statement withPotentialTimeout ( FrameworkMethod method , Object test , Statement next ) { long timeout = getTimeout ( method . getAnnotation ( Test . class ) ) ; if ( timeout < = 0 ) { return next ; } return FailOnTimeout . builder ( ) . withTimeout ( timeout , TimeUnit . MILLISECONDS )
public void evaluate ( ) throws Throwable { CallableStatement callable = new CallableStatement ( ) ; FutureTask < Throwable > task = new FutureTask < Throwable > ( callable ) ; ThreadGroup threadGroup = new ThreadGroup ( " FailOnTimeoutGroup " ) ; Thread thread = new Thread ( threadGroup , task , " Time - limited test " ) ; thread . setDaemon ( true ) ; thread . start ( ) ; callable . awaitStarted ( ) ; Throwable throwable = getResult ( task , thread ) ; if ( throwable ! = null ) { throw throwable ;
private long cpuTime ( Thread thr ) { ThreadMXBean mxBean = ManagementFactory . getThreadMXBean ( ) ; if ( mxBean . isThreadCpuTimeSupported ( ) ) { try { return mxBean . getThreadCpuTime ( thr . getId ( ) ) ; } catch ( UnsupportedOperationException e ) { } } return 0 ; }
public void describeTo ( Description description ) { description . appendText ( " exception with cause " ) ; description . appendDescriptionOf ( causeMatcher ) ; }
protected boolean matchesSafely ( T item ) { return causeMatcher . matches ( item . getCause ( ) ) ; }
protected void describeMismatchSafely ( T item , Description description ) { description . appendText ( " cause " ) ; causeMatcher . describeMismatch ( item . getCause ( ) , description ) ; }
public static < T extends Throwable > Matcher < T > hasCause ( final Matcher < ? extends Throwable > matcher ) { return new ThrowableCauseMatcher < T > ( matcher ) ; }
public void shouldAllowCauseOfDifferentClassFromRoot ( ) throws Exception { NullPointerException expectedCause = new NullPointerException ( " expected " ) ; Exception actual = new Exception ( expectedCause ) ; assertThat ( actual , hasCause ( is ( expectedCause ) ) ) ; }
public void assumptionViolatedExceptionWithMatcherDescribesItself ( ) { AssumptionViolatedException e = new AssumptionViolatedException ( 3 , is ( 2 ) ) ; assertThat ( StringDescription . asString ( e ) , is ( " got : < 3 > , expected : is < 2 > " ) ) ; }
public void canInitCauseWithInstanceCreatedWithString ( ) { AssumptionViolatedException e = new AssumptionViolatedException ( " invalid number " ) ; Throwable cause = new RuntimeException ( " cause " ) ; e . initCause ( cause ) ; assertThat ( e . getCause ( ) , is ( cause ) ) ; }
public void canSetCauseWithInstanceCreatedWithObjectAndMatcher ( ) { Throwable testObject = new Exception ( ) ; AssumptionViolatedException e = new AssumptionViolatedException ( testObject , containsString ( " test matcher " ) ) ; assertThat ( e . getCause ( ) , is ( testObject ) ) ; }
public void canSetCauseWithInstanceCreatedWithAssumptionObjectAndMatcher ( ) { Throwable testObject = new Exception ( ) ; AssumptionViolatedException e = new AssumptionViolatedException ( " sample assumption " , testObject , containsString ( " test matcher " ) ) ; assertThat ( e . getCause ( ) , is ( testObject ) ) ; }
public void canSetCauseWithInstanceCreatedWithMainConstructor ( ) { Throwable testObject = new Exception ( ) ; AssumptionViolatedException e = new AssumptionViolatedException ( " sample assumption " , false , testObject , containsString ( " test matcher " ) ) ; assertThat ( e . getCause ( ) , is ( testObject ) ) ; }
public void canSetCauseWithInstanceCreatedWithExplicitThrowableConstructor ( ) { Throwable cause = new Exception ( ) ; AssumptionViolatedException e = new AssumptionViolatedException ( " invalid number " , cause ) ; assertThat ( e . getCause ( ) , is ( cause ) ) ; }
public void exit ( int code ) { System . exit ( code ) ; }
public void exit ( int code ) { fCode = code ; }
protected void runUnprotected ( ) { runnable . run ( ) ; }
protected void addFailure ( Throwable targetException ) { notifier . fireTestFailure ( new Failure ( description , targetException ) ) ; }
private void runAfters ( ) { List < Method > afters = testClass . getAfters ( ) ; for ( Method after : afters ) { try {
protected void validate ( ) throws InitializationError { MethodValidator methodValidator = new MethodValidator ( testClass ) ; methodValidator . validateMethodsForDefaultRunner ( ) ; methodValidator . assertValid ( ) ; }
protected void runMethods ( final RunNotifier notifier ) { for ( Method method : testMethods ) { invokeTestMethod ( method , notifier ) ;
protected Annotation [ ] classAnnotations ( ) { return testClass . getJavaClass ( ) . getAnnotations ( ) ; }
protected TestMethod wrapMethod ( Method method ) { return new TestMethod ( method , testClass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { for ( Iterator < Method > iter = testMethods . iterator ( ) ; iter . hasNext ( ) ; ) { Method method = iter . next ( ) ; if ( ! filter . shouldRun ( methodDescription ( method ) ) ) { iter . remove ( ) ; } } if ( testMethods . isEmpty ( ) ) { throw new NoTestsRemainException ( ) ;
public void sort ( final Sorter sorter ) { Collections . sort ( testMethods , new Comparator < Method > ( ) { public int compare ( Method o1 , Method o2 ) {
public void run ( ) { if ( testMethod . isIgnored ( ) ) { notifier . fireTestIgnored ( description ) ; return ; } notifier . fireTestStarted ( description ) ; try { long timeout = testMethod . getTimeout ( ) ;
protected void runTestMethod ( ) { try { testMethod . invoke ( test ) ;
private void runAfters ( ) { List < Method > afters = testMethod . getAfters ( ) ; for ( Method after : afters ) { try {
protected void addFailure ( Throwable e ) { notifier . fireTestFailure ( new Failure ( description , e ) ) ; }
public void validateInstanceMethods ( ) { validateTestMethods ( After . class , false ) ; validateTestMethods ( Before . class , false ) ; validateTestMethods ( Test . class , false ) ; List < Method > methods = testClass . getAnnotatedMethods ( Test . class ) ; if ( methods . size ( ) = = 0 ) { errors . add ( new Exception ( " No runnable methods " ) ) ;
public List < Throwable > validateMethodsForDefaultRunner ( ) { validateNoArgConstructor ( ) ; validateStaticMethods ( ) ; validateInstanceMethods ( ) ; return errors ; }
public void assertValid ( ) throws InitializationError { if ( ! errors . isEmpty ( ) ) { throw new InitializationError ( errors ) ;
public void validateNoArgConstructor ( ) { try { testClass . getConstructor ( ) ;
public Constructor < ? > getConstructor ( ) throws SecurityException , NoSuchMethodException { return klass . getConstructor ( ) ; }
public boolean isIgnored ( ) { return method . getAnnotation ( Ignore . class ) ! = null ; }
public void invoke ( Object test ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { method . invoke ( test ) ; }
protected Statement createFailOnTimeoutStatement ( Statement statement ) throws Exception { return FailOnTimeout . builder ( ) . withTimeout ( timeout , timeUnit )
public Statement apply ( Statement base , Description description ) { try { return createFailOnTimeoutStatement ( base ) ;
public Builder withTimeout ( long timeout , TimeUnit unit ) { this . timeout = timeout ; this . timeUnit = unit ; return this ; }
public Timeout build ( ) { return new Timeout ( this ) ; }
public void test ( ) { assertEquals ( 1000 , timeout . getTimeoutFromSuperclass ( TimeUnit . MILLISECONDS ) ) ; }
public void testGetTimeout ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeOutOneSecond . class ) ; assertEquals ( " Should run the test " , 1 , result . getRunCount ( ) ) ; assertEquals ( " Test should not have failed " , 0 , result . getFailureCount ( ) ) ; }
public void describeTo ( Description description ) { if ( fAssumption ! = null ) { description . appendText ( fAssumption ) ; } if ( fValueMatcher ) {
public void toStringReportsMatcher ( Integer actual , Matcher < Integer > matcher ) { assumeThat ( matcher , notNullValue ( ) ) ; assertThat ( new AssumptionViolatedException ( actual , matcher ) . toString ( ) , containsString ( matcher . toString ( ) ) ) ;
public void toStringReportsValue ( Integer actual , Matcher < Integer > matcher ) { assertThat ( new AssumptionViolatedException ( actual , matcher ) . toString ( ) , containsString ( String . valueOf ( actual ) ) ) ;
public void canSetCauseWithInstanceCreatedWithObjectAndMatcher ( ) { Throwable testObject = new Exception ( ) ; org . junit . internal . AssumptionViolatedException e = new org . junit . internal . AssumptionViolatedException ( testObject , containsString ( " test matcher " ) ) ; assertThat ( e . getCause ( ) , is ( testObject ) ) ; }
public void canSetCauseWithInstanceCreatedWithAssumptionObjectAndMatcher ( ) { Throwable testObject = new Exception ( ) ; org . junit . internal . AssumptionViolatedException e = new org . junit . internal . AssumptionViolatedException ( " sample assumption " , testObject , containsString ( " test matcher " ) ) ; assertThat ( e . getCause ( ) , is ( testObject ) ) ; }
public void canSetCauseWithInstanceCreatedWithMainConstructor ( ) { Throwable testObject = new Exception ( ) ; org . junit . internal . AssumptionViolatedException e = new org . junit . internal . AssumptionViolatedException ( " sample assumption " , false , testObject , containsString ( " test matcher " ) ) ; assertThat ( e . getCause ( ) , is ( testObject ) ) ; }
private void writeObject ( ObjectOutputStream s ) throws IOException { SerializedForm serializedForm = new SerializedForm ( this ) ; serializedForm . serialize ( s ) ; }
private void readObject ( ObjectInputStream s ) throws ClassNotFoundException , IOException { serializedForm = SerializedForm . deserialize ( s ) ; }
private Object readResolve ( ) { return new Result ( serializedForm ) ; }
public void testAssumptionFailure ( Failure failure ) { } } public RunListener createListener ( ) { return new Listener ( ) ; } private static class SerializedForm implements Serializable { private static final long serialVersionUID = 1L ; private final AtomicInteger fCount ; private final AtomicInteger fIgnoreCount ; private final List < Failure > fFailures ; private final long fRunTime ; private final long fStartTime ; public SerializedForm ( Result result ) { fCount = result . count ; fIgnoreCount = result . ignoreCount ; fFailures = Collections . synchronizedList ( new ArrayList < Failure > ( result . failures ) ) ; fRunTime = result . runTime . longValue ( ) ; fStartTime = result . startTime . longValue ( ) ; } @ SuppressWarnings ( " unchecked " ) private SerializedForm ( ObjectInputStream . GetField fields ) throws IOException { fCount = ( AtomicInteger ) fields . get ( " fCount " , null ) ; fIgnoreCount = ( AtomicInteger ) fields . get ( " fIgnoreCount " , null ) ; fFailures = ( List < Failure > ) fields . get ( " fFailures " , null ) ; fRunTime = fields . get ( " fRunTime " , 0L ) ; fStartTime = fields . get ( " fStartTime " , 0L ) ; } public void serialize ( ObjectOutputStream s ) throws IOException { ObjectOutputStream . PutField fields = s . putFields ( ) ; fields . put ( " fCount " , fCount ) ; fields . put ( " fIgnoreCount " , fIgnoreCount ) ; fields . put ( " fFailures " , fFailures ) ; fields . put ( " fRunTime " , fRunTime ) ; fields . put ( " fStartTime " , fStartTime ) ; s . writeFields ( ) ; } public static SerializedForm deserialize ( ObjectInputStream s ) throws ClassNotFoundException , IOException { ObjectInputStream . GetField fields = s . readFields ( ) ; return new SerializedForm ( fields ) ; } } }
public void serialize ( ObjectOutputStream s ) throws IOException { ObjectOutputStream . PutField fields = s . putFields ( ) ; fields . put ( " fCount " , fCount ) ; fields . put ( " fIgnoreCount " , fIgnoreCount ) ; fields . put ( " fFailures " , fFailures ) ; fields . put ( " fRunTime " , fRunTime ) ; fields . put ( " fStartTime " , fStartTime ) ; s . writeFields ( ) ; }
public static SerializedForm deserialize ( ObjectInputStream s ) throws ClassNotFoundException , IOException { ObjectInputStream . GetField fields = s . readFields ( ) ; return new SerializedForm ( fields ) ; }
private void assertResultSerializable ( Result result ) throws IOException , ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; new ObjectOutputStream ( byteArrayOutputStream ) . writeObject ( result ) ; byte [ ] bytes = byteArrayOutputStream . toByteArray ( ) ; ObjectInputStream objectInputStream = new ObjectInputStream ( new ByteArrayInputStream ( bytes ) ) ; Result fromStream = ( Result ) objectInputStream . readObject ( ) ; assertSerializedCorrectly ( result , fromStream ) ; InputStream resource = getClass ( ) . getResourceAsStream ( getName ( ) ) ; assertNotNull ( " Could not read resource " + getName ( ) , resource ) ; objectInputStream = new ObjectInputStream ( resource ) ; fromStream = ( Result ) objectInputStream . readObject ( ) ; assertSerializedCorrectly ( new ResultWithFixedRunTime ( result ) , fromStream ) ; }
protected List < MethodRule > rules ( Object target ) { List < MethodRule > rules = getTestClass ( ) . getAnnotatedMethodValues ( target , Rule . class , MethodRule . class ) ; rules . addAll ( getTestClass ( ) . getAnnotatedFieldValues ( target , Rule . class , MethodRule . class ) ) ; return rules ; }
public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override
public void evaluate ( ) throws Throwable { runCount + + ; base . evaluate ( ) ; }
public void nothing ( ) { } } @ Test public void multipleRulesAreRun ( ) { runCount = 0 ; JUnitCore . runClasses ( MultipleRuleTest . class ) ; assertEquals ( 2 , runCount ) ; } public static class NoRulesTest { public int x ; @ Test public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { Result result = JUnitCore . runClasses ( NoRulesTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; Result result = JUnitCore . runClasses ( OnFailureTest . class ) ; assertEquals ( " nothing AssertionError " , log ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { Result result = JUnitCore . runClasses ( NoRulesTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; Result result = JUnitCore . runClasses ( OnFailureTest . class ) ; assertEquals ( " nothing AssertionError " , log ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) {
public MethodRule methodRule ( ) { return methodRule ; }
public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; }
public Increment methodRule1 ( ) { return new Increment ( ) ; }
public Increment methodRule2 ( ) { return new Increment ( ) ; }
public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { @ Override public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; }
public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; }
public void doNothing ( ) { assertEquals ( 1 , callCount ) ; }
public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; }
void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) ; } private static final class MemberMustBeNonStaticOrAlsoClassRule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { boolean isMethodRuleMember = isMethodRule ( member ) ; boolean isClassRuleAnnotated = ( member . getAnnotation ( ClassRule . class ) ! = null ) ; if ( member . isStatic ( ) & & ( isMethodRuleMember | | ! isClassRuleAnnotated ) ) { String message ; if ( isMethodRule ( member ) ) { message = " must not be static . " ; } else { message = " must not be static or it must be annotated with @ ClassRule . " ; } errors . add ( new ValidationError ( member , annotation , message ) ) ; } } } private static final class MemberMustBeStatic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isStatic ( ) ) { errors . add ( new ValidationError ( member , annotation , " must be static . " ) ) ; } } } private static final class DeclaringClassMustBePublic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isDeclaringClassPublic ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must be declared in a public class . " ) ) ; } } private boolean isDeclaringClassPublic ( FrameworkMember < ? > member ) { return Modifier . isPublic ( member . getDeclaringClass ( ) . getModifiers ( ) ) ; } } private static final class MemberMustBePublic implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! member . isPublic ( ) ) { errors . add ( new ValidationError ( member , annotation , " must be public . " ) ) ; } } } private static final class FieldMustBeARule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isRuleType ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must implement MethodRule or TestRule . " ) ) ; } } } private static final class MethodMustBeARule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isRuleType ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must return an implementation of MethodRule or TestRule . " ) ) ; } } } private static final class MethodMustBeATestRule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isTestRule ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must return an implementation of TestRule . " ) ) ; } } } private static final class FieldMustBeATestRule implements RuleValidator { public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isTestRule ( member ) ) { errors . add ( new ValidationError ( member , annotation , " must implement TestRule . " ) ) ; } } } }
public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isTestRule ( member ) ) { errors . add ( new ValidationError ( member , annotation ,
public void validate ( FrameworkMember < ? > member , Class < ? extends Annotation > annotation , List < Throwable > errors ) { if ( ! isTestRule ( member ) ) { errors . add ( new ValidationError ( member , annotation ,
public void rejectClassRuleThatIsImplemetationOfMethodRule ( ) { TestClass target = new TestClass ( TestWithClassRuleIsImplementationOfMethodRule . class ) ; CLASS_RULE_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ ClassRule ' classRule ' must implement TestRule . " ) ; }
public Statement apply ( Statement base , FrameworkMethod method , Object target ) { return base ; }
public void rejectClassRuleThatReturnsImplementationOfMethodRule ( ) { TestClass target = new TestClass ( TestWithClassRuleMethodThatReturnsMethodRule . class ) ; CLASS_RULE_METHOD_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ ClassRule ' methodRule ' must return an implementation of TestRule . " ) ; }
public static MethodRule methodRule ( ) { return new MethodRule ( ) {
public Statement apply ( Statement base , FrameworkMethod method , Object target ) { return base ; }
public void rejectClassRuleIsAnArbitraryObject ( ) throws Exception { TestClass target = new TestClass ( TestWithClassRuleIsAnArbitraryObject . class ) ; CLASS_RULE_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ ClassRule ' arbitraryObject ' must implement TestRule . " ) ; }
public void rejectClassRuleMethodReturnsAnArbitraryObject ( ) throws Exception { TestClass target = new TestClass ( TestWithClassRuleMethodReturnsAnArbitraryObject . class ) ; CLASS_RULE_METHOD_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ ClassRule ' arbitraryObject ' must return an implementation of TestRule . " ) ; }
public static Object arbitraryObject ( ) { return 1 ; }
public void nothing ( ) { } } @ Test public void multipleRulesAreRun ( ) { runCount = 0 ; JUnitCore . runClasses ( MultipleRuleTest . class ) ; assertEquals ( 2 , runCount ) ; } public static class NoRulesTest { public int x ; @ Test public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { Result result = JUnitCore . runClasses ( NoRulesTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; Result result = JUnitCore . runClasses ( OnFailureTest . class ) ; assertEquals ( " nothing AssertionError " , log ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { Result result = JUnitCore . runClasses ( NoRulesTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; Result result = JUnitCore . runClasses ( OnFailureTest . class ) ; assertEquals ( " nothing AssertionError " , log ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } }
private List < Runner > createRunnersForParameters ( Iterable < Object > allParameters , String namePattern , ParametersRunnerFactory runnerFactory ) throws Exception { try { List < TestWithParameters > tests = createTestsForParameters (
static List < Runner > createRunnersForClass ( Class < ? > klass ) throws Throwable { return new RunnersFactory ( klass ) . createRunners ( ) ; }
private List < Runner > createRunners ( ) throws Throwable { Parameters parameters = getParametersMethod ( ) . getAnnotation ( Parameters . class ) ; return Collections . unmodifiableList ( createRunnersForParameters ( allParameters ( ) , parameters . name ( ) ,
private ParametersRunnerFactory getParametersRunnerFactory ( ) throws InstantiationException , IllegalAccessException { UseParametersRunnerFactory annotation = testClass . getAnnotation ( UseParametersRunnerFactory . class ) ; if ( annotation = = null ) { return DEFAULT_FACTORY ;
private TestWithParameters createTestWithNotNormalizedParameters ( String pattern , int index , Object parametersOrSingleParameter ) { Object [ ] parameters = ( parametersOrSingleParameter instanceof Object [ ] ) ? ( Object [ ] ) parametersOrSingleParameter : new Object [ ] { parametersOrSingleParameter } ; return createTestWithParameters ( testClass , pattern , index , parameters ) ;
private Iterable < Object > allParameters ( ) throws Throwable { Object parameters = getParametersMethod ( ) . invokeExplosively ( null ) ; if ( parameters instanceof Iterable ) { return ( Iterable < Object > ) parameters ;
private FrameworkMethod getParametersMethod ( ) throws Exception { List < FrameworkMethod > methods = testClass . getAnnotatedMethods ( Parameters . class ) ; for ( FrameworkMethod each : methods ) { if ( each . isStatic ( ) & & each . isPublic ( ) ) { return each ; } } throw new Exception ( " No public static parameters method on class " + testClass . getName ( ) ) ;
private List < Runner > createRunnersForParameters ( Iterable < Object > allParameters , String namePattern , ParametersRunnerFactory runnerFactory ) throws Exception { try { List < TestWithParameters > tests = createTestsForParameters (
private List < TestWithParameters > createTestsForParameters ( Iterable < Object > allParameters , String namePattern ) throws Exception { int i = 0 ; List < TestWithParameters > children = new ArrayList < TestWithParameters > ( ) ; for ( Object parametersOfSingleTest : allParameters ) { children . add ( createTestWithNotNormalizedParameters ( namePattern , i + + , parametersOfSingleTest ) ) ; } return children ; }
private Exception parametersMethodReturnedWrongType ( ) throws Exception { String className = testClass . getName ( ) ; String methodName = getParametersMethod ( ) . getName ( ) ; String message = MessageFormat . format ( " { 0 } . { 1 } ( ) must return an Iterable of arrays . " , className , methodName ) ; return new Exception ( message ) ; }
private TestWithParameters createTestWithParameters ( TestClass testClass , String pattern , int index , Object [ ] parameters ) { String finalPattern = pattern . replaceAll ( " \ \ { index \ \ } " , Integer . toString ( index ) ) ; String name = MessageFormat . format ( finalPattern , parameters ) ; return new TestWithParameters ( " [ " + name + " ] " , testClass , Arrays . asList ( parameters ) ) ;
IMoney add ( IMoney m ) ; IMoney addMoney ( Money m ) ; IMoney addMoneyBag ( MoneyBag s ) ; boolean isZero ( ) ; IMoney multiply ( int factor ) ; IMoney negate ( ) ; IMoney subtract ( IMoney m ) ; void appendTo ( MoneyBag m ) ; }
IMoney addMoney ( Money m ) ; IMoney addMoneyBag ( MoneyBag s ) ; boolean isZero ( ) ; IMoney multiply ( int factor ) ; IMoney negate ( ) ; IMoney subtract ( IMoney m ) ; void appendTo ( MoneyBag m ) ; }
IMoney addMoneyBag ( MoneyBag s ) ; boolean isZero ( ) ; IMoney multiply ( int factor ) ; IMoney negate ( ) ; IMoney subtract ( IMoney m ) ; void appendTo ( MoneyBag m ) ; }
boolean isZero ( ) ; IMoney multiply ( int factor ) ; IMoney negate ( ) ; IMoney subtract ( IMoney m ) ; void appendTo ( MoneyBag m ) ; }
IMoney multiply ( int factor ) ; IMoney negate ( ) ; IMoney subtract ( IMoney m ) ; void appendTo ( MoneyBag m ) ; }
IMoney negate ( ) ; IMoney subtract ( IMoney m ) ; void appendTo ( MoneyBag m ) ; }
IMoney subtract ( IMoney m ) ; void appendTo ( MoneyBag m ) ; }
public < T > T checkSucceeds ( Callable < T > callable ) { try { return callable . call ( ) ;
public void example ( ) { collector . checkSucceeds ( new Callable < Object > ( ) { public Object call ( ) throws Exception { throw new RuntimeException ( " first ! " ) ; } } ) ; collector . checkSucceeds ( new Callable < Integer > ( ) { public Integer call ( ) throws Exception { throw new RuntimeException ( " second ! " ) ; } } ) ; Integer result = collector . checkSucceeds ( new Callable < Integer > ( ) { public Integer call ( ) throws Exception { return 1 ; } } ) ; assertEquals ( Integer . valueOf ( 1 ) , result ) ; }
public Integer call ( ) throws Exception { throw new RuntimeException ( " second ! " ) ; }
public Integer call ( ) throws Exception { return 1 ; }
protected Object createTest ( FrameworkMethod method ) throws Exception { return createTest ( ) ; }
protected Statement methodBlock ( final FrameworkMethod method ) { Object test ; try { test = new ReflectiveCallable ( ) { @ Override protected Object runReflectiveCall ( ) throws Throwable { return createTest ( method ) ; } } . run ( ) ; } catch ( Throwable e ) { return new Fail ( e ) ; } Statement statement = methodInvoker ( method , test ) ; statement = possiblyExpectingExceptions ( method , test , statement ) ; statement = withPotentialTimeout ( method , test , statement ) ; statement = withBefores ( method , test , statement ) ; statement = withAfters ( method , test , statement ) ; statement = withRules ( method , test , statement ) ; return statement ; }
protected Object runReflectiveCall ( ) throws Throwable { return createTest ( method ) ; }
protected Object createTest ( FrameworkMethod method ) { final OverrideCreateTest obj = new OverrideCreateTest ( ) ; obj . method = method ; return obj ; }
public void testMethodA ( ) { assertEquals ( " testMethodA " , method . getMethod ( ) . getName ( ) ) ; }
public void testMethodB ( ) { assertEquals ( " testMethodB " , method . getMethod ( ) . getName ( ) ) ; }
public void overrideCreateTestMethod ( ) { assertThat ( testResult ( OverrideCreateTest . class ) , isSuccessful ( ) ) ; }
protected Object createTest ( ) { final CreateTestDefersToNoArgCreateTestTest obj = new CreateTestDefersToNoArgCreateTestTest ( ) ; obj . createTestCalled = true ; return obj ; }
public void testCreateTestCalled ( ) { assertEquals ( true , createTestCalled ) ; }
public void createTestDefersToNoArgCreateTest ( ) { assertThat ( testResult ( CreateTestDefersToNoArgCreateTestTest . class ) , isSuccessful ( ) ) ; }
public void evaluate ( ) throws Throwable { List < Throwable > errors = new ArrayList < Throwable > ( ) ; startingQuietly ( description , errors ) ; try { base . evaluate ( ) ; succeededQuietly ( description , errors ) ; } catch ( org . junit . internal . AssumptionViolatedException e ) { errors . add ( e ) ; skippedQuietly ( e , description , errors ) ; } catch ( Throwable e ) { errors . add ( e ) ; failedQuietly ( e , description , errors ) ; } finally { finishedQuietly ( description , errors ) ; } MultipleFailureException . assertEmpty ( errors ) ; }
protected void succeeded ( Description description ) { } protected void failed ( Throwable e , Description description ) { } protected void skipped ( AssumptionViolatedException e , Description description ) { org . junit . internal . AssumptionViolatedException asInternalException = e ; skipped ( asInternalException , description ) ; } @ Deprecated protected void skipped ( org . junit . internal . AssumptionViolatedException e , Description description ) { } protected void starting ( Description description ) { } protected void finished ( Description description ) { } }
protected void failed ( Throwable e , Description description ) { } protected void skipped ( AssumptionViolatedException e , Description description ) { org . junit . internal . AssumptionViolatedException asInternalException = e ; skipped ( asInternalException , description ) ; } @ Deprecated protected void skipped ( org . junit . internal . AssumptionViolatedException e , Description description ) { } protected void starting ( Description description ) { } protected void finished ( Description description ) { } }
public AnnotationValidator createAnnotationValidator ( ValidateWith validateWithAnnotation ) { AnnotationValidator validator = VALIDATORS_FOR_ANNOTATION_TYPES . get ( validateWithAnnotation ) ; if ( validator ! = null ) { return validator ; } Class < ? extends AnnotationValidator > clazz = validateWithAnnotation . value ( ) ; try { AnnotationValidator annotationValidator = clazz . newInstance ( ) ;
public void test1 ( ) throws Exception { } @ Test public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ SuppressWarnings ( " deprecation " ) @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ SuppressWarnings ( " deprecation " ) @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ SuppressWarnings ( " deprecation " ) @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ SuppressWarnings ( " deprecation " ) @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void topLevelTestClassWithAnnotation_isRunWithAnnotatedRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . class ) ; assertThat ( runner , is ( instanceOf ( RunnerSpy . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( ( Object ) OuterClass . class ) ) ; }
public void memberClassInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . InnerClassWithoutOwnRunWith . class ) ; assertThat ( runner , is ( instanceOf ( RunnerSpy . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( ( Object ) OuterClass . InnerClassWithoutOwnRunWith . class ) ) ; }
public void memberClassDeepInsideAnnotatedTopLevelClass_isRunWithTopLevelRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . InnerClassWithoutOwnRunWith . MostInnerClass . class ) ; assertThat ( runner , is ( instanceOf ( RunnerSpy . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( ( Object ) OuterClass . InnerClassWithoutOwnRunWith . MostInnerClass . class ) ) ; }
public void annotatedMemberClassInsideAnnotatedTopLevelClass_isRunWithOwnRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . InnerClassWithOwnRunWith . class ) ; assertThat ( runner , is ( instanceOf ( InnerRunner . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( ( Object ) OuterClass . InnerClassWithOwnRunWith . class ) ) ; }
public void memberClassDeepInsideAnnotatedMemberClass_isRunWithParentMemberClassRunner ( ) throws Exception { Runner runner = builder . runnerForClass ( OuterClass . InnerClassWithOwnRunWith . MostInnerClass . class ) ; assertThat ( runner , is ( instanceOf ( InnerRunner . class ) ) ) ; RunnerSpy runnerSpy = ( RunnerSpy ) runner ; assertThat ( runnerSpy . getInvokedTestClass ( ) , is ( ( Object ) OuterClass . InnerClassWithOwnRunWith . MostInnerClass . class ) ) ; }
public void test ( ) { } public class MostInnerClass { @ Test public void test ( ) { } } } @ RunWith ( InnerRunner . class ) public class InnerClassWithOwnRunWith { @ Test public void test ( ) { } public class MostInnerClass { @ Test public void test ( ) { } } } } public static class InnerRunner extends RunnerSpy { public InnerRunner ( Class < ? > testClass ) { super ( testClass ) ; } public InnerRunner ( Class < ? > testClass , RunnerBuilder runnerBuilder ) { super ( testClass , runnerBuilder ) ; } } }
public void test ( ) { } } } @ RunWith ( InnerRunner . class ) public class InnerClassWithOwnRunWith { @ Test public void test ( ) { } public class MostInnerClass { @ Test public void test ( ) { } } } } public static class InnerRunner extends RunnerSpy { public InnerRunner ( Class < ? > testClass ) { super ( testClass ) ; } public InnerRunner ( Class < ? > testClass , RunnerBuilder runnerBuilder ) { super ( testClass , runnerBuilder ) ; } } }
public void test ( ) { } public class MostInnerClass { @ Test public void test ( ) { } } } } public static class InnerRunner extends RunnerSpy { public InnerRunner ( Class < ? > testClass ) { super ( testClass ) ; } public InnerRunner ( Class < ? > testClass , RunnerBuilder runnerBuilder ) { super ( testClass , runnerBuilder ) ; } } }
public void test ( ) { } } } } public static class InnerRunner extends RunnerSpy { public InnerRunner ( Class < ? > testClass ) { super ( testClass ) ; } public InnerRunner ( Class < ? > testClass , RunnerBuilder runnerBuilder ) { super ( testClass , runnerBuilder ) ; } } }
private void evaluateWithWaitDuration ( long waitDuration ) throws Throwable { statement . nextException = null ; statement . waitDuration = waitDuration ; failOnTimeout . evaluate ( ) ; }
public void stopEndlessStatement ( ) throws Throwable { InfiniteLoopStatement infiniteLoop = new InfiniteLoopStatement ( ) ; FailOnTimeout infiniteLoopTimeout = builder ( ) . withTimeout ( TIMEOUT , MILLISECONDS ) . build ( infiniteLoop ) ; try { infiniteLoopTimeout . evaluate ( ) ;
public void stackTraceContainsRealCauseOfTimeout ( ) throws Throwable { StuckStatement stuck = new StuckStatement ( ) ; FailOnTimeout stuckTimeout = builder ( ) . withTimeout ( TIMEOUT , MILLISECONDS ) . build ( stuck ) ; try { stuckTimeout . evaluate ( ) ;
public void test1 ( ) throws Exception { } @ Test public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ SuppressWarnings ( " deprecation " ) @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ SuppressWarnings ( " deprecation " ) @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @ Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , " The class org . junit . tests . running . classes . ParentRunnerTest $ NonPublicTestClass is not public . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 2 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @ BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ SuppressWarnings ( " deprecation " ) @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test ( ) { } } @ Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @ SuppressWarnings ( " deprecation " ) @ BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( " Thrown from @ BeforeClass " ) ; } @ Test public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void test ( ) { } } @ Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; } public static class TestTest { @ Test public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void pass ( ) { } @ Test public void fail ( ) { throw new AssertionError ( " Thrown from @ Test " ) ; } @ Ignore @ Test public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
public void ignore ( ) { } @ SuppressWarnings ( " deprecation " ) @ Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( " Thrown from @ Test " ) ; } } @ Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = 0 ; private int testFinished = 0 ; private int testFailure = 0 ; private int testAssumptionFailure = 0 ; private int testIgnored = 0 ; @ Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @ Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @ Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @ Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @ Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } }
private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; }
public void rejectStaticMethodRule ( ) { TestClass target = new TestClass ( TestWithStaticMethodRule . class ) ; RULE_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ Rule ' someMethodRule ' must not be static . " ) ; }
public void rejectMethodStaticMethodRule ( ) { TestClass target = new TestClass ( TestMethodWithStaticMethodRule . class ) ; RULE_METHOD_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ Rule ' getSomeMethodRule ' must not be static . " ) ; }
public Statement apply ( Statement base , FrameworkMethod method , Object target ) { return base ; }
Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException ; @ SuppressWarnings ( " serial " ) public static class FilterNotCreatedException extends Exception { public FilterNotCreatedException ( Exception exception ) { super ( exception . getMessage ( ) , exception ) ; } } }
public void arrayEquals ( String message , Object expecteds , Object actuals ) throws ArrayComparisonFailure { arrayEquals ( message , expecteds , actuals , true ) ; }
private void arrayEquals ( String message , Object expecteds , Object actuals , boolean outer ) throws ArrayComparisonFailure { if ( expecteds = = actuals | | Arrays . deepEquals ( new Object [ ] { expecteds } , new Object [ ] { actuals } ) ) { return ; } String header = message = = null ? " " : message + " : " ; String exceptionMessage = outer ? header : " " ; int expectedsLength = assertArraysAreSameLength ( expecteds , actuals , exceptionMessage ) ; for ( int i = 0 ; i < expectedsLength ; i + + ) { Object expected = Array . get ( expecteds , i ) ;
public void multiDimensionalArraysDifferentLengthMessage ( ) { try { assertArrayEquals ( " message " , new Object [ ] [ ] { { true , true } , { false , false } } , new Object [ ] [ ] { { true , true } , { false } } ) ; } catch ( AssertionError exception ) { assertEquals ( " message : arrays first differed at element [ 1 ] ; array lengths differed , expected . length = 2 actual . length = 1 " , exception . getMessage ( ) ) ; return ; } fail ( " Expected AssertionError to be thrown " ) ; }
public void multiDimensionalArraysDifferentLengthNoMessage ( ) { try { assertArrayEquals ( new Object [ ] [ ] { { true , true } , { false , false } } , new Object [ ] [ ] { { true , true } , { false } } ) ; } catch ( AssertionError exception ) { assertEquals ( " arrays first differed at element [ 1 ] ; array lengths differed , expected . length = 2 actual . length = 1 " , exception . getMessage ( ) ) ; return ; } fail ( " Expected AssertionError to be thrown " ) ; }
public Builder parentFolder ( File parentFolder ) { this . parentFolder = parentFolder ; return this ; }
public Builder assureDeletion ( ) { this . assureDeletion = true ; return this ; }
public TemporaryFolder build ( ) { return new TemporaryFolder ( this ) ; }
public void delete ( ) { if ( ! tryDelete ( ) ) { if ( assureDeletion ) {
protected boolean tryDelete ( ) { if ( folder = = null ) { return true ; } return recursiveDelete ( folder ) ; }
private boolean recursiveDelete ( File file ) { boolean result = true ; File [ ] files = file . listFiles ( ) ; if ( files ! = null ) { for ( File each : files ) { result = result & & recursiveDelete ( each ) ; } } return result & & file . delete ( ) ; }
public void create ( ) throws IOException { } @ Override protected boolean tryDelete ( ) { return false ; } public static Builder builder ( ) { return new TemporaryFolder . Builder ( ) { @ Override public TemporaryFolder build ( ) { return new StubTemporaryFolder ( this ) ; } } ; } } public static class HasTempFolderWithAssuredDeletion { @ Rule public TemporaryFolder folder = StubTemporaryFolder . builder ( ) . assureDeletion ( ) . build ( ) ; @ Test public void alwaysPasses ( ) { } } @ Test public void testStrictVerificationFailure ( ) { PrintableResult result = testResult ( HasTempFolderWithAssuredDeletion . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result . toString ( ) , containsString ( " Unable to clean up temporary folder " ) ) ; } public static class HasTempFolderWithoutAssuredDeletion { @ Rule public TemporaryFolder folder = StubTemporaryFolder . builder ( ) . build ( ) ; @ Test public void alwaysPasses ( ) { } } @ Test public void testStrictVerificationSuccess ( ) { PrintableResult result = testResult ( HasTempFolderWithoutAssuredDeletion . class ) ; assertThat ( result , isSuccessful ( ) ) ; } }
protected boolean tryDelete ( ) { return false ; }
public static Builder builder ( ) { return new TemporaryFolder . Builder ( ) { @ Override
public TemporaryFolder build ( ) { return new StubTemporaryFolder ( this ) ; }
public void alwaysPasses ( ) { } } @ Test public void testStrictVerificationFailure ( ) { PrintableResult result = testResult ( HasTempFolderWithAssuredDeletion . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result . toString ( ) , containsString ( " Unable to clean up temporary folder " ) ) ; } public static class HasTempFolderWithoutAssuredDeletion { @ Rule public TemporaryFolder folder = StubTemporaryFolder . builder ( ) . build ( ) ; @ Test public void alwaysPasses ( ) { } } @ Test public void testStrictVerificationSuccess ( ) { PrintableResult result = testResult ( HasTempFolderWithoutAssuredDeletion . class ) ; assertThat ( result , isSuccessful ( ) ) ; } }
public void testStrictVerificationFailure ( ) { PrintableResult result = testResult ( HasTempFolderWithAssuredDeletion . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result . toString ( ) , containsString ( " Unable to clean up temporary folder " ) ) ; }
public void alwaysPasses ( ) { } } @ Test public void testStrictVerificationSuccess ( ) { PrintableResult result = testResult ( HasTempFolderWithoutAssuredDeletion . class ) ; assertThat ( result , isSuccessful ( ) ) ; } }
public void testStrictVerificationSuccess ( ) { PrintableResult result = testResult ( HasTempFolderWithoutAssuredDeletion . class ) ; assertThat ( result , isSuccessful ( ) ) ; }
private Description describeCause ( Throwable child ) { return Description . createTestDescription ( classNames , " initializationError " ) ; }
public void cannotCreateWithNullClass2 ( ) { new ErrorReportingRunner ( new RuntimeException ( ) , ( Class < ? > ) null ) ; }
public void cannotCreateWithNullClasses ( ) { new ErrorReportingRunner ( new RuntimeException ( ) , ( Class < ? > [ ] ) null ) ; }
public void cannotCreateWithoutClass ( ) { new ErrorReportingRunner ( new RuntimeException ( ) ) ; }
protected List < MethodRule > rules ( Object target ) { List < MethodRule > rules = getTestClass ( ) . getAnnotatedMethodValues ( target , Rule . class , MethodRule . class ) ; rules . addAll ( getTestClass ( ) . getAnnotatedFieldValues ( target , Rule . class , MethodRule . class ) ) ; return rules ; }
public void exceptionsFromMethodBlockMustNotResultInUnrootedTests ( ) throws Exception { TrackingRunListener listener = new TrackingRunListener ( ) ; RunNotifier notifier = new RunNotifier ( ) ; notifier . addListener ( listener ) ; new CustomBlockJUnit4ClassRunner ( CustomBlockJUnit4ClassRunnerTestCase . class ) . run ( notifier ) ; assertEquals ( " tests started . " , 2 , listener . testStartedCount . get ( ) ) ; assertEquals ( " tests failed . " , 1 , listener . testFailureCount . get ( ) ) ; assertEquals ( " tests finished . " , 2 , listener . testFinishedCount . get ( ) ) ; }
public void testStarted ( Description description ) throws Exception { testStartedCount . incrementAndGet ( ) ; }
public void testFailure ( Failure failure ) throws Exception { testFailureCount . incrementAndGet ( ) ; }
public void testFinished ( Description description ) throws Exception { testFinishedCount . incrementAndGet ( ) ; }
public void ask ( @ Stub Correspondent correspondent ) { assumeThat ( correspondent . getAnswer ( " What is five ? " , " four " , " five " ) , is ( " five " ) ) ;
public static void main ( String [ ] args ) { TestRunner aTestRunner = new TestRunner ( ) ; try { TestResult r = aTestRunner . start ( args ) ;
public TestResult start ( String [ ] args ) throws Exception { String testCase = " " ; String method = " " ; boolean wait = false ; for ( int i = 0 ; i < args . length ; i + + ) { if ( args [ i ] . equals ( " - wait " ) ) { wait = true ; } else if ( args [ i ] . equals ( " - c " ) ) { testCase = extractClassName ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - m " ) ) { String arg = args [ + + i ] ; int lastIndex = arg . lastIndexOf ( ' . ' ) ; testCase = arg . substring ( 0 , lastIndex ) ; method = arg . substring ( lastIndex + 1 ) ; } else if ( args [ i ] . equals ( " - v " ) ) { System . err . println ( " JUnit " + Version . id ( ) + " by Kent Beck and Erich Gamma " ) ; } else { testCase = args [ i ] ; } } if ( testCase . equals ( " " ) ) { throw new Exception ( " Usage : TestRunner [ - wait ] testCaseName , where name is the name of the TestCase class " ) ; } try { if ( ! method . equals ( " " ) ) {
private static Set < Class < ? > > copyAndRefine ( Set < Class < ? > > classes ) { Set < Class < ? > > c = new HashSet < Class < ? > > ( ) ; if ( classes ! = null ) { c . addAll ( classes ) ; } c . remove ( null ) ; return c ; }
void run ( ) { int capacity = currentListeners . size ( ) ; List < RunListener > safeListeners = new ArrayList < RunListener > ( capacity ) ; List < Failure > failures = new ArrayList < Failure > ( capacity ) ; for ( RunListener listener : currentListeners ) { try { notifyListener ( listener ) ; safeListeners . add ( listener ) ; } catch ( Exception e ) { failures . add ( new Failure ( Description . TEST_MECHANISM , e ) ) ; } } fireTestFailures ( safeListeners , failures ) ; }
public abstract Runner runnerForClass ( Class < ? > testClass ) throws Throwable ; public Runner safeRunnerForClass ( Class < ? > testClass ) { try { return runnerForClass ( testClass ) ; } catch ( Throwable e ) { return new ErrorReportingRunner ( testClass , e ) ; } } Class < ? > addParent ( Class < ? > parent ) throws InitializationError { if ( ! parents . add ( parent ) ) { throw new InitializationError ( String . format ( " class ' % s ' ( possibly indirectly ) contains itself as a SuiteClass " , parent . getName ( ) ) ) ; } return parent ; } void removeParent ( Class < ? > klass ) { parents . remove ( klass ) ; } public List < Runner > runners ( Class < ? > parent , Class < ? > [ ] children ) throws InitializationError { addParent ( parent ) ; try { return runners ( children ) ; } finally { removeParent ( parent ) ; } } public List < Runner > runners ( Class < ? > parent , List < Class < ? > > children ) throws InitializationError { return runners ( parent , children . toArray ( new Class < ? > [ 0 ] ) ) ; } private List < Runner > runners ( Class < ? > [ ] children ) { List < Runner > runners = new ArrayList < Runner > ( ) ; for ( Class < ? > each : children ) { Runner childRunner = safeRunnerForClass ( each ) ; if ( childRunner ! = null ) { runners . add ( childRunner ) ; } } return runners ; } }
private List < Runner > runners ( Class < ? > [ ] children ) { List < Runner > runners = new ArrayList < Runner > ( ) ; for ( Class < ? > each : children ) { Runner childRunner = safeRunnerForClass ( each ) ; if ( childRunner ! = null ) { runners . add ( childRunner ) ; } } return runners ; }
private static < T extends FrameworkMember < T > > Map < Class < ? extends Annotation > , List < T > > makeDeeplyUnmodifiable ( Map < Class < ? extends Annotation > , List < T > > source ) { Map < Class < ? extends Annotation > , List < T > > copy = new LinkedHashMap < Class < ? extends Annotation > , List < T > > ( ) ; for ( Map . Entry < Class < ? extends Annotation > , List < T > > entry : source . entrySet ( ) ) { copy . put ( entry . getKey ( ) , Collections . unmodifiableList ( entry . getValue ( ) ) ) ; } return Collections . unmodifiableMap ( copy ) ; }
public void countsRuns ( ) { Result result = JUnitCore . runClasses ( FibonacciTest . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; }
public static Collection < Integer > data ( ) { return Arrays . asList ( 1 , 2 , 3 ) ; }
public void testSomething ( ) { fail ( ) ; }
public void countsFailures ( ) throws Exception { Result result = JUnitCore . runClasses ( ThreeFailures . class ) ; assertEquals ( 3 , result . getFailureCount ( ) ) ; }
public void providesDataByAnnotatedFields ( ) { Result result = JUnitCore . runClasses ( FibonacciWithParameterizedFieldTest . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; assertEquals ( 6 , result . getFailureCount ( ) ) ; }
public static Iterable < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ) ;
public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; }
public void countsRuns ( ) { Result result = JUnitCore . runClasses ( AdditionTest . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; }
public void countBeforeRun ( ) throws Exception { Runner runner = Request . aClass ( AdditionTest . class ) . getRunner ( ) ; assertEquals ( 4 , runner . testCount ( ) ) ; }
public void plansNamedCorrectly ( ) throws Exception { Runner runner = Request . aClass ( AdditionTest . class ) . getRunner ( ) ; Description description = runner . getDescription ( ) ; assertEquals ( " [ 2 : 3 + 2 = 5 ] " , description . getChildren ( ) . get ( 2 ) . getDisplayName ( ) ) ;
public void failuresNamedCorrectly ( ) { Result result = JUnitCore . runClasses ( ThreeFailures . class ) ; assertEquals ( " testSomething [ 0 : x = 1 ] ( " + ThreeFailures . class . getName ( ) + " ) " ,
public void providesDataByAnnotatedFields ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithAnnotatedFields . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; }
public void aTest ( ) { } } @ Test public void beforeAndAfterClassAreRun ( ) { fLog = " " ; JUnitCore . runClasses ( BeforeAndAfter . class ) ; assertEquals ( " before after " , fLog ) ; } @ RunWith ( Parameterized . class ) static public class EmptyTest { @ BeforeClass public static void before ( ) { fLog + = " before " ; } @ AfterClass public static void after ( ) { fLog + = " after " ; } } @ Test public void validateClassCatchesNoParameters ( ) { Result result = JUnitCore . runClasses ( EmptyTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class IncorrectTest { @ Test public int test ( ) { return 0 ; } @ Parameters public static Collection < Object [ ] > data ( ) { return Collections . singletonList ( new Object [ ] { 1 } ) ; } } @ Test public void failuresAddedForBadTestMethod ( ) throws Exception { Result result = JUnitCore . runClasses ( IncorrectTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ProtectedParametersTest { @ Parameters protected static Collection < Object [ ] > data ( ) { return Collections . emptyList ( ) ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersNotPublic ( ) { assertTestCreatesSingleFailureWithMessage ( ProtectedParametersTest . class , " No public static parameters method on class " + ProtectedParametersTest . class . getName ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ParametersNotIterable { @ Parameters public static String data ( ) { return " foo " ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersNotPublic ( ) { assertTestCreatesSingleFailureWithMessage ( ProtectedParametersTest . class , " No public static parameters method on class " + ProtectedParametersTest . class . getName ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ParametersNotIterable { @ Parameters public static String data ( ) { return " foo " ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ;
public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; }
public Object createTest ( ) throws Exception { InjectionType injectionType = getInjectionType ( ) ; switch ( injectionType ) { case CONSTRUCTOR :
public void dummyTest ( ) { } } @ Test public void hasAllAnnotationsExceptRunWith ( ) throws Exception { TestWithParameters testWithParameters = new TestWithParameters ( " dummy name " , new TestClass ( ClassWithParameterizedAnnotation . class ) , NO_PARAMETERS ) ; BlockJUnit4ClassRunnerWithParameters runner = new BlockJUnit4ClassRunnerWithParameters ( testWithParameters ) ; Annotation [ ] annotations = runner . getRunnerAnnotations ( ) ; assertEquals ( 1 , annotations . length ) ; assertEquals ( annotations [ 0 ] . annotationType ( ) , DummyAnnotation . class ) ; } @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . TYPE ) private static @ interface DummyAnnotation { } }
public void hasAllAnnotationsExceptRunWith ( ) throws Exception { TestWithParameters testWithParameters = new TestWithParameters ( " dummy name " , new TestClass ( ClassWithParameterizedAnnotation . class ) , NO_PARAMETERS ) ; BlockJUnit4ClassRunnerWithParameters runner = new BlockJUnit4ClassRunnerWithParameters ( testWithParameters ) ; Annotation [ ] annotations = runner . getRunnerAnnotations ( ) ; assertEquals ( 1 , annotations . length ) ; assertEquals ( annotations [ 0 ] . annotationType ( ) , DummyAnnotation . class ) ; }
public void doesNotRunTestsWithoutCategory ( ) { Result result = new JUnitCore ( ) . run ( SuiteWithParameterizedTestWithoutCategory . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; }
public void runsTestsWithoutCategory ( ) { Result result = new JUnitCore ( ) . run ( SuiteWithParameterizedTestWithCategory . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; }
public void testThatIsNotExecuted ( ) { Assert . assertTrue ( true ) ; }
public void runsTestMethodWithCategory ( ) { Result result = new JUnitCore ( ) . run ( SuiteWithParameterizedTestWithMethodWithCategory . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; }
Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException ; @ SuppressWarnings ( " serial " ) class FilterNotCreatedException extends Exception { public FilterNotCreatedException ( Exception exception ) { super ( exception . getMessage ( ) , exception ) ; } } }
List < Exception > validateTestClass ( TestClass testClass ) ; }
public static void assertTrue ( String message , boolean condition ) { if ( ! condition ) { fail ( message ) ;
public static void assertTrue ( boolean condition ) { assertTrue ( null , condition ) ; }
public static void assertFalse ( String message , boolean condition ) { assertTrue ( message , ! condition ) ; }
public static void assertFalse ( boolean condition ) { assertFalse ( null , condition ) ; }
public static void fail ( String message ) { if ( message = = null ) { throw new AssertionError ( ) ; } throw new AssertionError ( message ) ; }
public static void assertEquals ( String message , Object expected , Object actual ) { if ( equalsRegardingNull ( expected , actual ) ) { return ; } if ( expected instanceof String & & actual instanceof String ) { String cleanMessage = message = = null ? " " : message ;
public static void assertEquals ( Object expected , Object actual ) { assertEquals ( null , expected , actual ) ; }
public static void assertNotEquals ( String message , Object unexpected , Object actual ) { if ( equalsRegardingNull ( unexpected , actual ) ) { failEquals ( message , actual ) ;
public static void assertNotEquals ( Object unexpected , Object actual ) { assertNotEquals ( null , unexpected , actual ) ; }
public static void assertNotEquals ( String message , long unexpected , long actual ) { if ( unexpected = = actual ) { failEquals ( message , Long . valueOf ( actual ) ) ;
public static void assertNotEquals ( long unexpected , long actual ) { assertNotEquals ( null , unexpected , actual ) ; }
public static void assertNotEquals ( String message , double unexpected , double actual , double delta ) { if ( ! doubleIsDifferent ( unexpected , actual , delta ) ) { failEquals ( message , Double . valueOf ( actual ) ) ;
public static void assertNotEquals ( double unexpected , double actual , double delta ) { assertNotEquals ( null , unexpected , actual , delta ) ; }
public static void assertNotEquals ( float unexpected , float actual , float delta ) { assertNotEquals ( null , unexpected , actual , delta ) ; }
public static void assertEquals ( String message , double expected , double actual , double delta ) { if ( doubleIsDifferent ( expected , actual , delta ) ) { failNotEquals ( message , Double . valueOf ( expected ) , Double . valueOf ( actual ) ) ;
public static void assertEquals ( String message , float expected , float actual , float delta ) { if ( floatIsDifferent ( expected , actual , delta ) ) { failNotEquals ( message , Float . valueOf ( expected ) , Float . valueOf ( actual ) ) ;
public static void assertNotEquals ( String message , float unexpected , float actual , float delta ) { if ( ! floatIsDifferent ( unexpected , actual , delta ) ) { failEquals ( message , actual ) ;
private static boolean doubleIsDifferent ( double d1 , double d2 , double delta ) { if ( Double . compare ( d1 , d2 ) = = 0 ) { return false ; } if ( ( Math . abs ( d1 - d2 ) < = delta ) ) { return false ; } return true ; }
private static boolean floatIsDifferent ( float f1 , float f2 , float delta ) { if ( Float . compare ( f1 , f2 ) = = 0 ) { return false ; } if ( ( Math . abs ( f1 - f2 ) < = delta ) ) { return false ; } return true ; }
public static void assertEquals ( long expected , long actual ) { assertEquals ( null , expected , actual ) ; }
public static void assertEquals ( String message , long expected , long actual ) { if ( expected ! = actual ) { failNotEquals ( message , Long . valueOf ( expected ) , Long . valueOf ( actual ) ) ;
public static void assertEquals ( double expected , double actual ) { assertEquals ( null , expected , actual ) ; }
public static void assertEquals ( String message , double expected , double actual ) { fail ( " Use assertEquals ( expected , actual , delta ) to compare floating - point numbers " ) ; }
public static void assertEquals ( double expected , double actual , double delta ) { assertEquals ( null , expected , actual , delta ) ; }
public static void assertEquals ( float expected , float actual , float delta ) { assertEquals ( null , expected , actual , delta ) ; }
public static void assertNotNull ( String message , Object object ) { assertTrue ( message , object ! = null ) ; }
public static void assertNotNull ( Object object ) { assertNotNull ( null , object ) ; }
public static void assertNull ( String message , Object object ) { if ( object = = null ) { return ; } failNotNull ( message , object ) ; }
public static void assertNull ( Object object ) { assertNull ( null , object ) ; }
private static void failNotNull ( String message , Object actual ) { String formatted = " " ; if ( message ! = null ) { formatted = message + " " ; } fail ( formatted + " expected null , but was : < " + actual + " > " ) ; }
public static void assertSame ( String message , Object expected , Object actual ) { if ( expected = = actual ) { return ; } failNotSame ( message , expected , actual ) ; }
public static void assertSame ( Object expected , Object actual ) { assertSame ( null , expected , actual ) ; }
public static void assertNotSame ( String message , Object unexpected , Object actual ) { if ( unexpected = = actual ) { failSame ( message ) ;
public static void assertNotSame ( Object unexpected , Object actual ) { assertNotSame ( null , unexpected , actual ) ; }
private static void failSame ( String message ) { String formatted = " " ; if ( message ! = null ) { formatted = message + " " ; } fail ( formatted + " expected not same " ) ; }
private static void failNotSame ( String message , Object expected , Object actual ) { String formatted = " " ; if ( message ! = null ) { formatted = message + " " ; } fail ( formatted + " expected same : < " + expected + " > was not : < " + actual + " > " ) ;
private static void failNotEquals ( String message , Object expected , Object actual ) { fail ( format ( message , expected , actual ) ) ; }
static String format ( String message , Object expected , Object actual ) { String formatted = " " ; if ( message ! = null & & ! " " . equals ( message ) ) { formatted = message + " " ; } String expectedString = String . valueOf ( expected ) ; String actualString = String . valueOf ( actual ) ; if ( expectedString . equals ( actualString ) ) { return formatted + " expected : "
public boolean isComplete ( ) { return unassigned . isEmpty ( ) ; }
public Assignments assignNext ( PotentialAssignment source ) { List < PotentialAssignment > potentialAssignments = new ArrayList < PotentialAssignment > ( assigned ) ; potentialAssignments . add ( source ) ; return new Assignments ( potentialAssignments , unassigned . subList ( 1 , unassigned . size ( ) ) , clazz ) ;
public List < PotentialAssignment > potentialsForNextUnassigned ( ) throws Throwable { ParameterSignature unassigned = nextUnassigned ( ) ; List < PotentialAssignment > assignments = getSupplier ( unassigned ) . getValueSources ( unassigned ) ; if ( assignments . isEmpty ( ) ) { assignments = generateAssignmentsFromTypeAlone ( unassigned ) ; } return assignments ; }
protected void printFailures ( Result result ) { List < Failure > failures = result . getFailures ( ) ; if ( failures . isEmpty ( ) ) { return ; } if ( failures . size ( ) = = 1 ) { getWriter ( ) . println ( " There was " + failures . size ( ) + " failure : " ) ; } else { getWriter ( ) . println ( " There were " + failures . size ( ) + " failures : " ) ; } int i = 1 ; for ( Failure each : failures ) { printFailure ( each , " " + i + + ) ;
private static boolean isMatchesSafelyMethod ( Method method ) { return " matchesSafely " . equals ( method . getName ( ) ) & & method . getParameterTypes ( ) . length = = 1
protected void validateInstanceMethods ( List < Throwable > errors ) { validatePublicVoidNoArgMethods ( After . class , false , errors ) ; validatePublicVoidNoArgMethods ( Before . class , false , errors ) ; validateTestMethods ( errors ) ; if ( computeTestMethods ( ) . isEmpty ( ) ) { errors . add ( new Exception ( " No runnable methods " ) ) ;
public static void assertArrayEquals ( String message , boolean [ ] expecteds , boolean [ ] actuals ) throws ArrayComparisonFailure { internalArrayEquals ( message , expecteds , actuals ) ; }
void run ( ) throws Throwable ; } public static void assertThrows ( Class < ? extends Throwable > expectedThrowable , ThrowingRunnable runnable ) { expectThrows ( expectedThrowable , runnable ) ; } public static < T extends Throwable > T expectThrows ( Class < T > expectedThrowable , ThrowingRunnable runnable ) { try { runnable . run ( ) ; } catch ( Throwable actualThrown ) { if ( expectedThrowable . isInstance ( actualThrown ) ) { @ SuppressWarnings ( " unchecked " ) T retVal = ( T ) actualThrown ; return retVal ; } else { String mismatchMessage = format ( " unexpected exception type thrown ; " , expectedThrowable . getSimpleName ( ) , actualThrown . getClass ( ) . getSimpleName ( ) ) ; AssertionError assertionError = new AssertionError ( mismatchMessage ) ; assertionError . initCause ( actualThrown ) ; throw assertionError ; } } String message = String . format ( " expected % s to be thrown , but nothing was thrown " , expectedThrowable . getSimpleName ( ) ) ; throw new AssertionError ( message ) ; } }
public static void assertThrows ( Class < ? extends Throwable > expectedThrowable , ThrowingRunnable runnable ) { expectThrows ( expectedThrowable , runnable ) ; }
public static < T extends Throwable > T expectThrows ( Class < T > expectedThrowable , ThrowingRunnable runnable ) { try { runnable . run ( ) ; } catch ( Throwable actualThrown ) { if ( expectedThrowable . isInstance ( actualThrown ) ) { @ SuppressWarnings ( " unchecked " ) T retVal = ( T ) actualThrown ; return retVal ; } else { String mismatchMessage = format ( " unexpected exception type thrown ; " , expectedThrowable . getSimpleName ( ) , actualThrown . getClass ( ) . getSimpleName ( ) ) ; AssertionError assertionError = new AssertionError ( mismatchMessage ) ; assertionError . initCause ( actualThrown ) ; throw assertionError ; } } String message = String . format ( " expected % s to be thrown , but nothing was thrown " , expectedThrowable . getSimpleName ( ) ) ; throw new AssertionError ( message ) ; }
public void expectThrowsRequiresAnExceptionToBeThrown ( ) { expectThrows ( Throwable . class , nonThrowingRunnable ( ) ) ; }
public void expectThrowsIncludesAnInformativeDefaultMessage ( ) { try { expectThrows ( Throwable . class , nonThrowingRunnable ( ) ) ; } catch ( AssertionError ex ) { assertEquals ( " expected Throwable to be thrown , but nothing was thrown " , ex . getMessage ( ) ) ; return ; } fail ( ) ; }
public void expectThrowsReturnsTheSameObjectThrown ( ) { NullPointerException npe = new NullPointerException ( ) ; Throwable throwable = expectThrows ( Throwable . class , throwingRunnable ( npe ) ) ; assertSame ( npe , throwable ) ; }
public void expectThrowsDetectsTypeMismatchesViaExplicitTypeHint ( ) { NullPointerException npe = new NullPointerException ( ) ; expectThrows ( IOException . class , throwingRunnable ( npe ) ) ; }
public void expectThrowsWrapsAndPropagatesUnexpectedExceptions ( ) { NullPointerException npe = new NullPointerException ( " inner - message " ) ; try { expectThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError ex ) { assertSame ( npe , ex . getCause ( ) ) ; assertEquals ( " inner - message " , ex . getCause ( ) . getMessage ( ) ) ; return ; } fail ( ) ; }
public void expectThrowsSuppliesACoherentErrorMessageUponTypeMismatch ( ) { NullPointerException npe = new NullPointerException ( ) ; try { expectThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < IOException > but was : < NullPointerException > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } fail ( ) ; }
private static ThrowingRunnable nonThrowingRunnable ( ) { return new ThrowingRunnable ( ) { public void run ( ) throws Throwable {
public void run ( ) throws Throwable { } } ; } private static ThrowingRunnable throwingRunnable ( final Throwable t ) { return new ThrowingRunnable ( ) { public void run ( ) throws Throwable { throw t ; } } ; } }
private static ThrowingRunnable throwingRunnable ( final Throwable t ) { return new ThrowingRunnable ( ) { public void run ( ) throws Throwable {
public void run ( ) throws Throwable { throw t ; }
public ExpectedException expect ( Matcher < ? > matcher ) { matcherBuilder . add ( matcher ) ; return this ; }
public ExpectedException expect ( Class < ? extends Throwable > type ) { expect ( instanceOf ( type ) ) ; return this ; }
public ExpectedException expectMessage ( String substring ) { expectMessage ( containsString ( substring ) ) ; return this ; }
public ExpectedException expectMessage ( Matcher < String > matcher ) { expect ( hasMessage ( matcher ) ) ; return this ; }
public ExpectedException expectCause ( Matcher < ? extends Throwable > expectedCause ) { expect ( hasCause ( expectedCause ) ) ; return this ; }
private String [ ] copyArray ( String [ ] args , int from , int to ) { String [ ] result = new String [ to - from ] ; for ( int j = from ; j ! = to ; + + j ) { result [ j - from ] = args [ j ] ; } return result ; }
public void neitherLogSuccessNorFailedForViolatedAssumption ( ) { runClasses ( ViolatedAssumptionTest . class ) ; assertThat ( ViolatedAssumptionTest . log . toString ( ) , is ( " starting finished " ) ) ;
public void logFailingTest ( ) { runClasses ( FailingTest . class ) ; assertThat ( FailingTest . log . toString ( ) , is ( " starting failed finished " ) ) ;
private void assertResultSerializable ( Result result ) throws IOException , ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; ObjectOutputStream objectOutputStream = new ObjectOutputStream ( byteArrayOutputStream ) ; objectOutputStream . writeObject ( result ) ; objectOutputStream . flush ( ) ; byte [ ] bytes = byteArrayOutputStream . toByteArray ( ) ; ObjectInputStream objectInputStream = new ObjectInputStream ( new ByteArrayInputStream ( bytes ) ) ; Result fromStream = ( Result ) objectInputStream . readObject ( ) ; assertSerializedCorrectly ( result , fromStream ) ; InputStream resource = getClass ( ) . getResourceAsStream ( getName ( ) ) ; assertNotNull ( " Could not read resource " + getName ( ) , resource ) ; objectInputStream = new ObjectInputStream ( resource ) ; fromStream = ( Result ) objectInputStream . readObject ( ) ; assertSerializedCorrectly ( new ResultWithFixedRunTime ( result ) , fromStream ) ; }
public void assertEmptyThrowsMultipleFailureExceptionForManyThrowables ( ) throws Exception { List < Throwable > errors = new ArrayList < Throwable > ( ) ; errors . add ( new ExpectedException ( " basil " ) ) ; errors . add ( new RuntimeException ( " garlic " ) ) ; try { MultipleFailureException . assertEmpty ( errors ) ;
public void testAssumptionFailure ( Failure failure ) { assumptionFailureCount . getAndIncrement ( ) ; }
private void assertCompletesNormally ( ) { } @ Test ( expected = AssumptionViolatedException . class ) public void assumeTrueWorks ( ) { Assume . assumeTrue ( false ) ; } public static class HasFailingAssumeInBefore { @ Before public void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforePreventsTestRun ( ) { assertThat ( testResult ( HasFailingAssumeInBefore . class ) , isSuccessful ( ) ) ; } public static class HasFailingAssumeInBeforeClass { @ BeforeClass public static void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforeClassIgnoresClass ( ) { assertThat ( testResult ( HasFailingAssumeInBeforeClass . class ) , isSuccessful ( ) ) ; } public static class AssumptionFailureInConstructor { public AssumptionFailureInConstructor ( ) { assumeTrue ( false ) ; } @ Test public void shouldFail ( ) { fail ( ) ; } } @ Test public void failingAssumptionInConstructorIgnoresClass ( ) { assertThat ( testResult ( AssumptionFailureInConstructor . class ) , isSuccessful ( ) ) ; } public static class TestClassWithAssumptionFailure { @ Test ( expected = IllegalArgumentException . class ) public void assumeWithExpectedException ( ) { assumeTrue ( false ) ; } } @ Test public void assumeWithExpectedExceptionShouldThrowAssumptionViolatedException ( ) { Result result = JUnitCore . runClasses ( TestClassWithAssumptionFailure . class ) ; assertThat ( result . getAssumptionFailureCount ( ) , is ( 1 ) ) ; } final static String message = " Some random message string . " ; final static Throwable e = new Throwable ( ) ; public static class HasAssumeWithMessage { @ Test public void testMethod ( ) { assumeTrue ( message , false ) ; } } @ Test public void assumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessage . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } public static class HasAssumeWithMessageAndCause { @ Test public void testMethod ( ) { assumeNoException ( message , e ) ; } } @ Test public void assumptionsWithMessageAndCause ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessageAndCause . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; assertSame ( failures . get ( 0 ) . getException ( ) . getCause ( ) , e ) ; } public static class HasFailingAssumptionWithMessage { @ Test public void assumptionsFail ( ) { assumeThat ( message , 3 , is ( 4 ) ) ; fail ( ) ; } } @ Test public void failedAssumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasFailingAssumptionWithMessage . class ) ; assertEquals ( failures . size ( ) , 1 ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } private static List < Failure > runAndGetAssumptionFailures ( Class < ? > clazz ) { final List < Failure > failures = new ArrayList < Failure > ( ) ; final JUnitCore core = new JUnitCore ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { failures . add ( failure ) ; } } ) ; core . run ( clazz ) ; return failures ; } }
public void assumeWithExpectedException ( ) { assumeTrue ( false ) ; }
public void assumeWithExpectedExceptionShouldThrowAssumptionViolatedException ( ) { Result result = JUnitCore . runClasses ( TestClassWithAssumptionFailure . class ) ; assertThat ( result . getAssumptionFailureCount ( ) , is ( 1 ) ) ; }
private Description describeCause ( ) { return Description . createTestDescription ( classNames , " initializationError " ) ; }
private void runCause ( Throwable child , RunNotifier notifier ) { Description description = describeCause ( ) ; notifier . fireTestStarted ( description ) ; notifier . fireTestFailure ( new Failure ( description , child ) ) ; notifier . fireTestFinished ( description ) ; }
public void assumeThatWorks ( ) { try { assumeThat ( 1 , is ( 2 ) ) ;
public void assumeNotNullThrowsException ( ) { Object [ ] objects = { 1 , 2 , null } ; try { assumeNotNull ( objects ) ;
private void assertCompletesNormally ( ) { } @ Test public void assumeTrueWorks ( ) { try { Assume . assumeTrue ( false ) ; fail ( " should throw AssumptionViolatedException " ) ; } catch ( AssumptionViolatedException e ) { } } public static class HasFailingAssumeInBefore { @ Before public void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforePreventsTestRun ( ) { assertThat ( testResult ( HasFailingAssumeInBefore . class ) , isSuccessful ( ) ) ; } public static class HasFailingAssumeInBeforeClass { @ BeforeClass public static void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforeClassIgnoresClass ( ) { assertThat ( testResult ( HasFailingAssumeInBeforeClass . class ) , isSuccessful ( ) ) ; } public static class AssumptionFailureInConstructor { public AssumptionFailureInConstructor ( ) { assumeTrue ( false ) ; } @ Test public void shouldFail ( ) { fail ( ) ; } } @ Test public void failingAssumptionInConstructorIgnoresClass ( ) { assertThat ( testResult ( AssumptionFailureInConstructor . class ) , isSuccessful ( ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void assumeWithExpectedException ( ) { assumeTrue ( false ) ; } final static String message = " Some random message string . " ; final static Throwable e = new Throwable ( ) ; public static class HasAssumeWithMessage { @ Test public void testMethod ( ) { assumeTrue ( message , false ) ; } } @ Test public void assumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessage . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } public static class HasAssumeWithMessageAndCause { @ Test public void testMethod ( ) { assumeNoException ( message , e ) ; } } @ Test public void assumptionsWithMessageAndCause ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessageAndCause . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; assertSame ( failures . get ( 0 ) . getException ( ) . getCause ( ) , e ) ; } public static class HasFailingAssumptionWithMessage { @ Test public void assumptionsFail ( ) { assumeThat ( message , 3 , is ( 4 ) ) ; fail ( ) ; } } @ Test public void failedAssumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasFailingAssumptionWithMessage . class ) ; assertEquals ( failures . size ( ) , 1 ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } private static List < Failure > runAndGetAssumptionFailures ( Class < ? > clazz ) { final List < Failure > failures = new ArrayList < Failure > ( ) ; final JUnitCore core = new JUnitCore ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { failures . add ( failure ) ; } } ) ; core . run ( clazz ) ; return failures ; } }
public void assumeTrueWorks ( ) { try { Assume . assumeTrue ( false ) ;
public File newFile ( ) throws IOException { return File . createTempFile ( TMP_PREFIX , null , getRoot ( ) ) ; }
private File createTemporaryFolderIn ( File parentFolder ) throws IOException { File createdFolder = null ; for ( int i = 0 ; i < TEMP_DIR_ATTEMPTS ; + + i ) { String suffix = " . tmp " ; File tmpFile = File . createTempFile ( TMP_PREFIX , suffix , parentFolder ) ; String tmpName = tmpFile . getName ( ) ; String folderName = tmpName . substring ( 0 , tmpName . length ( ) - suffix . length ( ) ) ; createdFolder = new File ( parentFolder , folderName ) ; if ( createdFolder . mkdir ( ) ) { tmpFile . delete ( ) ; return createdFolder ; } tmpFile . delete ( ) ; } throw new IOException ( " Unable to create temporary directory in : " + parentFolder . toString ( ) + " . Tried " + TEMP_DIR_ATTEMPTS + " times . "
private File createTemporaryFolderIn ( File parentFolder ) throws IOException { File createdFolder = null ; for ( int i = 0 ; i < TEMP_DIR_ATTEMPTS ; + + i ) { String suffix = " . tmp " ; File tmpFile = File . createTempFile ( TMP_PREFIX , suffix , parentFolder ) ; String tmpName = tmpFile . toString ( ) ; String folderName = tmpName . substring ( 0 , tmpName . length ( ) - suffix . length ( ) ) ; createdFolder = new File ( folderName ) ; if ( createdFolder . mkdir ( ) ) { tmpFile . delete ( ) ; return createdFolder ; } tmpFile . delete ( ) ; } throw new IOException ( " Unable to create temporary directory in : " + parentFolder . toString ( ) + " . Tried " + TEMP_DIR_ATTEMPTS + " times . "
public void testTempFolderLocation ( ) throws IOException { File folderRoot = folder . getRoot ( ) ; String tmpRoot = System . getProperty ( " java . io . tmpdir " ) ; assertTrue ( folderRoot . toString ( ) . startsWith ( tmpRoot ) ) ; }
public Statement apply ( Statement base , Description description ) { return new RunRules ( base , rulesStartingWithInnerMost , description ) ; }
public void checkThrows ( Class < ? extends Throwable > expectedThrowable , ThrowingRunnable runnable ) { try { assertThrows ( expectedThrowable , runnable ) ;
public void example ( ) { collector . checkThrows ( IllegalArgumentException . class , new ThrowingRunnable ( ) { public void run ( ) throws Throwable {
public void run ( ) throws Throwable { throw new IllegalArgumentException ( ) ; }
public void usedErrorCollectorCheckThrowsMatchingClassShouldPass ( ) { PrintableResult testResult = testResult ( UsesErrorCollectorCheckThrowsMatchingClass . class ) ; assertThat ( testResult , isSuccessful ( ) ) ; }
public void run ( ) throws Throwable { throw new NullPointerException ( ) ; }
public void usedErrorCollectorCheckThrowsClassMismatchShouldFail ( ) { PrintableResult testResult = testResult ( UsesErrorCollectorCheckThrowsClassMismatch . class ) ; assertThat ( testResult , hasFailureContaining ( " expected : < IllegalArgumentException > but was : < NullPointerException > " ) ) ;
public void run ( ) throws Throwable { } } ) ; } } @ Test public void usedErrorCollectorCheckThrowsNothingThrownShouldFail ( ) { PrintableResult testResult = testResult ( UsesErrorCollectorCheckThrowsNothingThrown . class ) ; assertThat ( testResult , hasFailureContaining ( " but nothing was thrown " ) ) ; } private static String sequence ; public static class UsesVerifier { @ Rule public Verifier collector = new Verifier ( ) { @ Override protected void verify ( ) { sequence + = " verify " ; } } ; @ Test public void example ( ) { sequence + = " test " ; } } @ Test public void verifierRunsAfterTest ( ) { sequence = " " ; assertThat ( testResult ( UsesVerifier . class ) , isSuccessful ( ) ) ; assertEquals ( " test verify " , sequence ) ; } }
public void usedErrorCollectorCheckThrowsNothingThrownShouldFail ( ) { PrintableResult testResult = testResult ( UsesErrorCollectorCheckThrowsNothingThrown . class ) ; assertThat ( testResult , hasFailureContaining ( " but nothing was thrown " ) ) ; }
private boolean recursiveDelete ( File file ) { if ( file . delete ( ) ) { return true ; } boolean result = true ; File [ ] files = file . listFiles ( ) ; if ( files ! = null ) { for ( File each : files ) { result = result & & recursiveDelete ( each ) ; } } return result & & file . delete ( ) ; }
private void arrayEquals ( String message , Object expecteds , Object actuals , boolean outer ) throws ArrayComparisonFailure { if ( expecteds = = actuals | | Arrays . deepEquals ( new Object [ ] { expecteds } , new Object [ ] { actuals } ) ) { return ; } String header = message = = null ? " " : message + " : " ; String exceptionMessage = outer ? header : " " ; if ( expecteds = = null ) { Assert . fail ( exceptionMessage + " expected array was null " ) ; } if ( actuals = = null ) { Assert . fail ( exceptionMessage + " actual array was null " ) ; } int actualsLength = Array . getLength ( actuals ) ; int expectedsLength = Array . getLength ( expecteds ) ; if ( actualsLength ! = expectedsLength ) { header + = " array lengths differed , expected . length = " + expectedsLength + " actual . length = " + actualsLength + " ; " ; } int prefixLength = Math . min ( actualsLength , expectedsLength ) ; for ( int i = 0 ; i < prefixLength ; i + + ) { Object expected = Array . get ( expecteds , i ) ; Object actual = Array . get ( actuals , i ) ; if ( isArray ( expected ) & & isArray ( actual ) ) { try { arrayEquals ( message , expected , actual , false ) ; } catch ( ArrayComparisonFailure e ) { e . addDimension ( i ) ; throw e ; } catch ( AssertionError e ) { throw new ArrayComparisonFailure ( header , e , i ) ; } } else { try { assertElementsEqual ( expected , actual ) ; } catch ( AssertionError e ) { throw new ArrayComparisonFailure ( header , e , i ) ; } } } if ( actualsLength ! = expectedsLength ) { Object expected = getArrayElementOrSentinel ( expecteds , expectedsLength , prefixLength ) ;
public String toString ( ) { return " end of array " ; }
public void arraysDifferentLengthDifferingAtStartNotEqual ( ) { assertArrayEquals ( " not equal " , ( new Object [ ] { true } ) , ( new Object [ ] { false , true } ) ) ; }
public void arraysDifferentLengthDifferingAtEndNotEqual ( ) { assertArrayEquals ( " not equal " , ( new Object [ ] { true } ) , ( new Object [ ] { true , false } ) ) ; }
public void arraysDifferentLengthDifferingAtEndAndExpectedArrayLongerNotEqual ( ) { assertArrayEquals ( " not equal " , ( new Object [ ] { true , false } ) , ( new Object [ ] { true } ) ) ; }
public void arraysDifferentLengthDifferingAtStartMessage ( ) { try { assertArrayEquals ( " not equal " , ( new Object [ ] { true } ) , ( new Object [ ] { false , true } ) ) ;
public void arraysDifferentLengthDifferingAtEndMessage ( ) { try { assertArrayEquals ( " not equal " , ( new Object [ ] { true } ) , ( new Object [ ] { true , false } ) ) ;
public void arraysDifferentLengthDifferingAtEndAndExpectedArrayLongerMessage ( ) { try { assertArrayEquals ( " not equal " , ( new Object [ ] { true , false } ) , ( new Object [ ] { true } ) ) ;
public void multiDimensionalArraysDifferentLengthMessage ( ) { try { assertArrayEquals ( " message " , new Object [ ] [ ] { { true , true } , { false , false } } , new Object [ ] [ ] { { true , true } , { false } } ) ; } catch ( AssertionError exception ) { assertEquals ( " message : array lengths differed , expected . length = 2 actual . length = 1 ; arrays first differed at element [ 1 ] [ 1 ] ; expected : < false > but was : < end of array > " , exception . getMessage ( ) ) ; return ; } fail ( " Expected AssertionError to be thrown " ) ; }
public void multiDimensionalArraysDifferentLengthNoMessage ( ) { try { assertArrayEquals ( new Object [ ] [ ] { { true , true } , { false , false } } , new Object [ ] [ ] { { true , true } , { false } } ) ; } catch ( AssertionError exception ) { assertEquals ( " array lengths differed , expected . length = 2 actual . length = 1 ; arrays first differed at element [ 1 ] [ 1 ] ; expected : < false > but was : < end of array > " , exception . getMessage ( ) ) ; return ; } fail ( " Expected AssertionError to be thrown " ) ; }
public void arraysNotEqual ( ) { assertArrayEqualsFailure ( new Object [ ] { " right " } ,
public void arraysNotEqualWithMessage ( ) { assertArrayEqualsFailure ( " not equal " ,
public void arraysExpectedNullMessage ( ) { try { assertArrayEquals ( " not equal " , null , new Object [ ] { new Object ( ) } ) ; } catch ( AssertionError exception ) { assertEquals ( " not equal : expected array was null " , exception . getMessage ( ) ) ; return ; } fail ( " should have thrown an exception " ) ; }
public void arraysActualNullMessage ( ) { try { assertArrayEquals ( " not equal " , new Object [ ] { new Object ( ) } , null ) ; } catch ( AssertionError exception ) { assertEquals ( " not equal : actual array was null " , exception . getMessage ( ) ) ; return ; } fail ( " should have thrown an exception " ) ; }
public void arraysDifferentLengthDifferingAtStartMessage ( ) { assertArrayEqualsFailure ( " not equal " ,
public void arraysDifferentLengthDifferingAtEndMessage ( ) { assertArrayEqualsFailure ( " not equal " ,
public void arraysDifferentLengthDifferingAtEndAndExpectedArrayLongerMessage ( ) { assertArrayEqualsFailure ( " not equal " ,
public void arraysElementsDiffer ( ) { assertArrayEqualsFailure ( " not equal " ,
public void arraysDifferAtElement0nullMessage ( ) { assertArrayEqualsFailure ( new Object [ ] { true } ,
public void arraysDifferAtElement1nullMessage ( ) { assertArrayEqualsFailure ( new Object [ ] { true , true } ,
public void arraysDifferAtElement0withMessage ( ) { assertArrayEqualsFailure ( " message " ,
public void arraysDifferAtElement1withMessage ( ) { assertArrayEqualsFailure ( " message " ,
public void multiDimensionalArraysAreNotEqual ( ) { assertArrayEqualsFailure ( " message " ,
public void multiDimensionalArraysAreNotEqualNoMessage ( ) { assertArrayEqualsFailure ( new Object [ ] [ ] { { true , true } , { false , false } } ,
public void twoDimensionalArraysDifferentOuterLengthNotEqual ( ) { Object [ ] extraArray = { true } ; assertArrayEqualsFailure ( " not equal " , new Object [ ] [ ] { extraArray , { } } , new Object [ ] [ ] { { } } , " not equal : array lengths differed , expected . length = 1 actual . length = 0 ; arrays first differed at element [ 0 ] [ 0 ] ; expected : < true > but was : < end of array > " ) ; assertArrayEqualsFailure ( " not equal " , new Object [ ] [ ] { { } , extraArray } , new Object [ ] [ ] { { } } , " not equal : array lengths differed , expected . length = 2 actual . length = 1 ; arrays first differed at element [ 1 ] ; expected : < " + extraArray . toString ( ) + " > but was : < end of array > " ) ; assertArrayEqualsFailure ( " not equal " , new Object [ ] [ ] { { } } , new Object [ ] [ ] { extraArray , { } } , " not equal : array lengths differed , expected . length = 0 actual . length = 1 ; arrays first differed at element [ 0 ] [ 0 ] ; expected : < end of array > but was : < true > " ) ; assertArrayEqualsFailure ( " not equal " ,
public void twoDimensionalArraysDifferentInnerLengthNotEqual ( ) { assertArrayEqualsFailure ( " not equal " , new Object [ ] [ ] { { true } , { } } , new Object [ ] [ ] { { } , { } } , " not equal : array lengths differed , expected . length = 1 actual . length = 0 ; arrays first differed at element [ 0 ] [ 0 ] ; expected : < true > but was : < end of array > " ) ; assertArrayEqualsFailure ( " not equal " , new Object [ ] [ ] { { } , { true } } , new Object [ ] [ ] { { } , { } } , " not equal : array lengths differed , expected . length = 1 actual . length = 0 ; arrays first differed at element [ 1 ] [ 0 ] ; expected : < true > but was : < end of array > " ) ; assertArrayEqualsFailure ( " not equal " , new Object [ ] [ ] { { } , { } } , new Object [ ] [ ] { { true } , { } } , " not equal : array lengths differed , expected . length = 0 actual . length = 1 ; arrays first differed at element [ 0 ] [ 0 ] ; expected : < end of array > but was : < true > " ) ; assertArrayEqualsFailure ( " not equal " ,
private void assertArrayEqualsFailure ( Object [ ] expecteds , Object [ ] actuals , String expectedMessage ) { try { assertArrayEquals ( expecteds , actuals ) ; } catch ( ArrayComparisonFailure e ) { assertEquals ( expectedMessage , e . getMessage ( ) ) ; return ; } fail ( " should have thrown an exception " ) ; }
private void assertArrayEqualsFailure ( String message , Object [ ] expecteds , Object [ ] actuals , String expectedMessage ) { try { assertArrayEquals ( message , expecteds , actuals ) ; } catch ( ArrayComparisonFailure e ) { assertEquals ( expectedMessage , e . getMessage ( ) ) ; return ; } fail ( " should have thrown an exception " ) ; }
private void arrayEquals ( String message , Object expecteds , Object actuals , boolean outer ) throws ArrayComparisonFailure { if ( expecteds = = actuals | | Arrays . deepEquals ( new Object [ ] { expecteds } , new Object [ ] { actuals } ) ) { return ; } String header = message = = null ? " " : message + " : " ; String exceptionMessage = outer ? header : " " ; if ( expecteds = = null ) { Assert . fail ( exceptionMessage + " expected array was null " ) ; } if ( actuals = = null ) { Assert . fail ( exceptionMessage + " actual array was null " ) ; } int actualsLength = Array . getLength ( actuals ) ; int expectedsLength = Array . getLength ( expecteds ) ; if ( actualsLength ! = expectedsLength ) { header + = " array lengths differed , expected . length = " + expectedsLength + " actual . length = " + actualsLength + " ; " ; } int prefixLength = Math . min ( actualsLength , expectedsLength ) ; for ( int i = 0 ; i < prefixLength ; i + + ) { Object expected = Array . get ( expecteds , i ) ; Object actual = Array . get ( actuals , i ) ; if ( isArray ( expected ) & & isArray ( actual ) ) { try { arrayEquals ( message , expected , actual , false ) ; } catch ( ArrayComparisonFailure e ) { e . addDimension ( i ) ; throw e ; } catch ( AssertionError e ) { throw new ArrayComparisonFailure ( header , e , i ) ; } } else { try { assertElementsEqual ( expected , actual ) ; } catch ( AssertionError e ) { throw new ArrayComparisonFailure ( header , e , i ) ; } } } if ( actualsLength ! = expectedsLength ) { Object expected = getToStringableArrayElement ( expecteds , expectedsLength , prefixLength ) ;
private static Object objectWithToString ( final String string ) { return new Object ( ) { @ Override
public String toString ( ) { return string ; }
private String componentTypeName ( Class < ? > arrayClass ) { Class < ? > componentType = arrayClass . getComponentType ( ) ; if ( componentType . isArray ( ) ) { return componentTypeName ( componentType ) + " [ ] " ;
public void twoDimensionalArraysDifferentOuterLengthNotEqual ( ) { assertArrayEqualsFailure ( " not equal " , new Object [ ] [ ] { { true } , { } } , new Object [ ] [ ] { { } } , " not equal : array lengths differed , expected . length = 1 actual . length = 0 ; arrays first differed at element [ 0 ] [ 0 ] ; expected : < true > but was : < end of array > " ) ; assertArrayEqualsFailure ( " not equal " , new Object [ ] [ ] { { } , { true } } , new Object [ ] [ ] { { } } , " not equal : array lengths differed , expected . length = 2 actual . length = 1 ; arrays first differed at element [ 1 ] ; expected : < java . lang . Object [ 1 ] > but was : < end of array > " ) ; assertArrayEqualsFailure ( " not equal " , new Object [ ] [ ] { { } } , new Object [ ] [ ] { { true } , { } } , " not equal : array lengths differed , expected . length = 0 actual . length = 1 ; arrays first differed at element [ 0 ] [ 0 ] ; expected : < end of array > but was : < true > " ) ; assertArrayEqualsFailure ( " not equal " ,
public void primitiveArraysConvertedToStringCorrectly ( ) { assertArrayEqualsFailure ( " not equal " , new boolean [ ] [ ] { { } , { true } } , new boolean [ ] [ ] { { } } , " not equal : array lengths differed , expected . length = 2 actual . length = 1 ; arrays first differed at element [ 1 ] ; expected : < boolean [ 1 ] > but was : < end of array > " ) ; assertArrayEqualsFailure ( " not equal " ,
public void twoDimensionalArraysConvertedToStringCorrectly ( ) { assertArrayEqualsFailure ( " not equal " ,
public String trace ( ) { return Throwables . getStacktrace ( thrownException ( ) ) ; }
private String readStacktrace ( Throwable throwable ) { return Throwables . getStacktrace ( throwable ) ; }
public void fireTestSuiteStarted ( ) { notifier . fireTestSuiteStarted ( description ) ; }
public void fireTestSuiteFinished ( ) { notifier . fireTestSuiteFinished ( description ) ; }
public void testRunStarted ( Description description ) throws Exception { } public void testRunFinished ( Result result ) throws Exception { } public void testSuiteStarted ( Description description ) throws Exception { } public void testSuiteFinished ( Description description ) throws Exception { } public void testStarted ( Description description ) throws Exception { } public void testFinished ( Description description ) throws Exception { } public void testFailure ( Failure failure ) throws Exception { } public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void testRunFinished ( Result result ) throws Exception { } public void testSuiteStarted ( Description description ) throws Exception { } public void testSuiteFinished ( Description description ) throws Exception { } public void testStarted ( Description description ) throws Exception { } public void testFinished ( Description description ) throws Exception { } public void testFailure ( Failure failure ) throws Exception { } public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void testSuiteStarted ( Description description ) throws Exception { } public void testSuiteFinished ( Description description ) throws Exception { } public void testStarted ( Description description ) throws Exception { } public void testFinished ( Description description ) throws Exception { } public void testFailure ( Failure failure ) throws Exception { } public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void testSuiteFinished ( Description description ) throws Exception { } public void testStarted ( Description description ) throws Exception { } public void testFinished ( Description description ) throws Exception { } public void testFailure ( Failure failure ) throws Exception { } public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
abstract protected void notifyListener ( RunListener each ) throws Exception ; } public void fireTestRunStarted ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testRunStarted ( description ) ; } } . run ( ) ; } public void fireTestRunFinished ( final Result result ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testRunFinished ( result ) ; } } . run ( ) ; } public void fireTestSuiteStarted ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testSuiteStarted ( description ) ; } } . run ( ) ; } public void fireTestSuiteFinished ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testSuiteFinished ( description ) ; } } . run ( ) ; } public void fireTestStarted ( final Description description ) throws StoppedByUserException { if ( pleaseStop ) { throw new StoppedByUserException ( ) ; } new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testStarted ( description ) ; } } . run ( ) ; } public void fireTestFailure ( Failure failure ) { fireTestFailures ( listeners , asList ( failure ) ) ; } private void fireTestFailures ( List < RunListener > listeners , final List < Failure > failures ) { if ( ! failures . isEmpty ( ) ) { new SafeNotifier ( listeners ) { @ Override protected void notifyListener ( RunListener listener ) throws Exception { for ( Failure each : failures ) { listener . testFailure ( each ) ; } } } . run ( ) ; } } public void fireTestAssumptionFailed ( final Failure failure ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testAssumptionFailure ( failure ) ; } } . run ( ) ; } public void fireTestIgnored ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testIgnored ( description ) ; } } . run ( ) ; } public void fireTestFinished ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testFinished ( description ) ; } } . run ( ) ; } public void pleaseStop ( ) { pleaseStop = true ; } public void addFirstListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot add a null listener " ) ; } listeners . add ( 0 , wrapIfNotThreadSafe ( listener ) ) ; } }
public void fireTestSuiteStarted ( final Description description ) { new SafeNotifier ( ) { @ Override
protected void notifyListener ( RunListener each ) throws Exception { each . testSuiteStarted ( description ) ; }
public void fireTestSuiteFinished ( final Description description ) { new SafeNotifier ( ) { @ Override
protected void notifyListener ( RunListener each ) throws Exception { each . testSuiteFinished ( description ) ; }
public void testSuiteStarted ( Description description ) throws Exception { synchronized ( monitor ) { listener . testSuiteStarted ( description ) ;
public void testSuiteFinished ( Description description ) throws Exception { synchronized ( monitor ) { listener . testSuiteFinished ( description ) ;
public void run ( final RunNotifier notifier ) { EachTestNotifier testNotifier = new EachTestNotifier ( notifier , getDescription ( ) ) ; testNotifier . fireTestSuiteStarted ( ) ; try { Statement statement = classBlock ( notifier ) ;
public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( 1 , countingRunListener . testSuiteStarted ) ; Assert . assertEquals ( 1 , countingRunListener . testSuiteFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testSuiteFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testSuiteAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; }
public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( 1 , countingRunListener . testSuiteStarted ) ; Assert . assertEquals ( 1 , countingRunListener . testSuiteFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testSuiteFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testSuiteAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testStarted ) ; Assert . assertEquals ( 0 , countingRunListener . testFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testIgnored ) ; }
public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( 1 , countingRunListener . testSuiteStarted ) ; Assert . assertEquals ( 1 , countingRunListener . testSuiteFinished ) ; Assert . assertEquals ( 0 , countingRunListener . testSuiteFailure ) ; Assert . assertEquals ( 0 , countingRunListener . testSuiteAssumptionFailure ) ; Assert . assertEquals ( 3 , countingRunListener . testStarted ) ; Assert . assertEquals ( 3 , countingRunListener . testFinished ) ; Assert . assertEquals ( 1 , countingRunListener . testFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( 1 , countingRunListener . testIgnored ) ; }
public void testSuiteStarted ( Description description ) throws Exception { testSuiteStarted + + ; }
public void testSuiteFinished ( Description description ) throws Exception { testSuiteFinished + + ; }
private void validate ( ) throws InitializationError { List < Throwable > errors = new ArrayList < Throwable > ( ) ; collectInitializationErrors ( errors ) ; if ( ! errors . isEmpty ( ) ) { throw new InvalidTestClassError ( testClass . getJavaClass ( ) , errors ) ;
private static String createMessage ( Class < ? > testClass , List < Throwable > validationErrors ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( String . format ( " Invalid test class ' % s ' : " , testClass . getName ( ) ) ) ; int i = 1 ; for ( Throwable error : validationErrors ) { sb . append ( " \ n " + ( i + + ) + " . " + error . getMessage ( ) ) ; } return sb . toString ( ) ; }
public void givenInvalidTestClassErrorAsCause ( ) { final List < Failure > firedFailures = new ArrayList < Failure > ( ) ; InvalidTestClassError testClassError = new InvalidTestClassError ( TestClassWithErrors . class , Arrays . asList ( new Throwable ( " validation error 1 " ) , new Throwable ( " validation error 2 " ) ) ) ; ErrorReportingRunner sut = new ErrorReportingRunner ( TestClassWithErrors . class , testClassError ) ; sut . run ( new RunNotifier ( ) { @ Override public void fireTestFailure ( Failure failure ) { super . fireTestFailure ( failure ) ; firedFailures . add ( failure ) ; } } ) ; assertThat ( firedFailures . size ( ) , is ( 1 ) ) ; Throwable exception = firedFailures . get ( 0 ) . getException ( ) ; assertThat ( exception , instanceOf ( InvalidTestClassError . class ) ) ; assertThat ( ( ( InvalidTestClassError ) exception ) , is ( testClassError ) ) ; }
public void fireTestFailure ( Failure failure ) { super . fireTestFailure ( failure ) ; firedFailures . add ( failure ) ; }
public void givenInvalidTestClass_integrationTest ( ) { Result result = JUnitCore . runClasses ( TestClassWithErrors . class ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; Throwable failure = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( failure , instanceOf ( InvalidTestClassError . class ) ) ; assertThat ( failure . getMessage ( ) , allOf ( startsWith ( " Invalid test class ' " + TestClassWithErrors . class . getName ( ) + " ' " ) ,
@ Before public static void staticBeforeMethod ( ) { } @ After public static void staticAfterMethod ( ) { } @ Test public String testMethodReturningString ( ) { return " this should not be allowed " ; } } }
@ After public static void staticAfterMethod ( ) { } @ Test public String testMethodReturningString ( ) { return " this should not be allowed " ; } } }
@ Test public String testMethodReturningString ( ) { return " this should not be allowed " ; }
public void invalidTestClassErrorShouldListAllValidationErrorsInItsMessage ( ) { InvalidTestClassError sut = new InvalidTestClassError ( SampleTestClass . class , asList ( new Throwable ( " validation error 1 " ) , new Throwable ( " validation error 2 " ) ) ) ; assertThat ( sut . getMessage ( ) , equalTo ( " Invalid test class ' " + SampleTestClass . class . getName ( ) + " ' : " + " \ n 1 . validation error 1 " +
void numbers ( int x ) { } } @ Test public void theoriesMustBePublic ( ) { assertThat ( testResult ( TheoriesMustBePublic . class ) , hasSingleFailureContaining ( " public " ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBeStatic { @ DataPoint public int THREE = 3 ; @ DataPoints public int [ ] FOURS = new int [ ] { 4 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBeStatic ( ) { assertThat ( testResult ( DataPointFieldsMustBeStatic . class ) , CoreMatchers . both ( hasFailureContaining ( " DataPoint field THREE must be static " ) ) . and ( hasFailureContaining ( " DataPoint field FOURS must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBeStatic { @ DataPoint public int singleDataPointMethod ( ) { return 1 ; } @ DataPoints public int [ ] dataPointArrayMethod ( ) { return new int [ ] { 1 , 2 , 3 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( hasFailureContaining ( " DataPoint method singleDataPointMethod must be static " ) ) . and ( hasFailureContaining ( " DataPoint method dataPointArrayMethod must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBePublic { @ DataPoint static int THREE = 3 ; @ DataPoints static int [ ] THREES = new int [ ] { 3 } ; @ DataPoint protected static int FOUR = 4 ; @ DataPoints protected static int [ ] FOURS = new int [ ] { 4 } ; @ DataPoint private static int FIVE = 5 ; @ DataPoints private static int [ ] FIVES = new int [ ] { 5 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBeStatic ( ) { assertThat ( testResult ( DataPointFieldsMustBeStatic . class ) , CoreMatchers . both ( hasFailureContaining ( " DataPoint field THREE must be static " ) ) . and ( hasFailureContaining ( " DataPoint field FOURS must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBeStatic { @ DataPoint public int singleDataPointMethod ( ) { return 1 ; } @ DataPoints public int [ ] dataPointArrayMethod ( ) { return new int [ ] { 1 , 2 , 3 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( hasFailureContaining ( " DataPoint method singleDataPointMethod must be static " ) ) . and ( hasFailureContaining ( " DataPoint method dataPointArrayMethod must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBePublic { @ DataPoint static int THREE = 3 ; @ DataPoints static int [ ] THREES = new int [ ] { 3 } ; @ DataPoint protected static int FOUR = 4 ; @ DataPoints protected static int [ ] FOURS = new int [ ] { 4 } ; @ DataPoint private static int FIVE = 5 ; @ DataPoints private static int [ ] FIVES = new int [ ] { 5 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( hasFailureContaining ( " DataPoint method singleDataPointMethod must be static " ) ) . and ( hasFailureContaining ( " DataPoint method dataPointArrayMethod must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBePublic { @ DataPoint static int THREE = 3 ; @ DataPoints static int [ ] THREES = new int [ ] { 3 } ; @ DataPoint protected static int FOUR = 4 ; @ DataPoints protected static int [ ] FOURS = new int [ ] { 4 } ; @ DataPoint private static int FIVE = 5 ; @ DataPoints private static int [ ] FIVES = new int [ ] { 5 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) ,
public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) ,
public < T > void forItems ( Collection < ? > items ) { } } @ Test public void whereTypeVariableIsOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnTheoryParm { @ DataPoint public static String string = " foo " ; @ Theory public < T > void forItem ( T item ) { } } @ Test public void whereTypeVariableIsOnParameterizedTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnParameterizedTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnParameterizedTheoryParm { @ DataPoint public static List < String > strings = Arrays . asList ( " foo " , " bar " ) ; @ Theory public < T > void forItems ( Collection < T > items ) { } } @ Test public void whereTypeVariableIsOnWildcardUpperBoundOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnWildcardUpperBoundOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable U " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnWildcardUpperBoundOnTheoryParm { @ DataPoint public static List < String > strings = Arrays . asList ( " foo " , " bar " ) ; @ Theory public < U > void forItems ( Collection < ? extends U > items ) { } } @ Test public void whereTypeVariableIsOnWildcardLowerBoundOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnWildcardLowerBoundOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable V " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnWildcardLowerBoundOnTheoryParm { @ DataPoint public static List < String > strings = Arrays . asList ( " foo " , " bar " ) ; @ Theory public < V > void forItems ( Collection < ? super V > items ) { } } @ Test public void whereTypeVariableIsOnArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnArrayTypeOnTheoryParm { @ DataPoints public static String [ ] [ ] items ( ) { return new String [ ] [ ] { new String [ ] { " foo " } , new String [ ] { " bar " } } ; } @ Theory public < T > void forItems ( T [ ] items ) { } } @ Test public void whereTypeVariableIsOnComponentOfArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnComponentOfArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable U " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnComponentOfArrayTypeOnTheoryParm { @ DataPoints public static List < ? > [ ] [ ] items ( ) { return new List < ? > [ ] [ ] { new List < ? > [ ] { Arrays . asList ( " foo " ) } , new List < ? > [ ] { Arrays . asList ( " bar " ) } } ; } @ Theory public < U > void forItems ( Collection < U > [ ] items ) { } } @ Test public void whereTypeVariableIsOnTheoryClass ( ) { PrintableResult result = testResult ( TypeVariableOnTheoryClass . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnTheoryClass < T > { @ DataPoint public static String item = " bar " ; @ Theory public void forItem ( T item ) { } } @ Test public void whereTypeVariablesAbound ( ) { PrintableResult result = testResult ( TypeVariablesAbound . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable A " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable B " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable C " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable D " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable E " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable F " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable G " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariablesAbound < A , B extends A , C extends Collection < B > > { @ Theory public < D , E extends D , F , G > void forItem ( A first , Collection < B > second , Map < C , ? extends D > third , List < ? super E > fourth , F [ ] fifth , Collection < G > [ ] sixth ) { } } }
public < T > void forItem ( T item ) { } } @ Test public void whereTypeVariableIsOnParameterizedTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnParameterizedTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnParameterizedTheoryParm { @ DataPoint public static List < String > strings = Arrays . asList ( " foo " , " bar " ) ; @ Theory public < T > void forItems ( Collection < T > items ) { } } @ Test public void whereTypeVariableIsOnWildcardUpperBoundOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnWildcardUpperBoundOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable U " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnWildcardUpperBoundOnTheoryParm { @ DataPoint public static List < String > strings = Arrays . asList ( " foo " , " bar " ) ; @ Theory public < U > void forItems ( Collection < ? extends U > items ) { } } @ Test public void whereTypeVariableIsOnWildcardLowerBoundOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnWildcardLowerBoundOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable V " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnWildcardLowerBoundOnTheoryParm { @ DataPoint public static List < String > strings = Arrays . asList ( " foo " , " bar " ) ; @ Theory public < V > void forItems ( Collection < ? super V > items ) { } } @ Test public void whereTypeVariableIsOnArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnArrayTypeOnTheoryParm { @ DataPoints public static String [ ] [ ] items ( ) { return new String [ ] [ ] { new String [ ] { " foo " } , new String [ ] { " bar " } } ; } @ Theory public < T > void forItems ( T [ ] items ) { } } @ Test public void whereTypeVariableIsOnComponentOfArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnComponentOfArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable U " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnComponentOfArrayTypeOnTheoryParm { @ DataPoints public static List < ? > [ ] [ ] items ( ) { return new List < ? > [ ] [ ] { new List < ? > [ ] { Arrays . asList ( " foo " ) } , new List < ? > [ ] { Arrays . asList ( " bar " ) } } ; } @ Theory public < U > void forItems ( Collection < U > [ ] items ) { } } @ Test public void whereTypeVariableIsOnTheoryClass ( ) { PrintableResult result = testResult ( TypeVariableOnTheoryClass . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnTheoryClass < T > { @ DataPoint public static String item = " bar " ; @ Theory public void forItem ( T item ) { } } @ Test public void whereTypeVariablesAbound ( ) { PrintableResult result = testResult ( TypeVariablesAbound . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable A " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable B " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable C " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable D " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable E " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable F " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable G " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariablesAbound < A , B extends A , C extends Collection < B > > { @ Theory public < D , E extends D , F , G > void forItem ( A first , Collection < B > second , Map < C , ? extends D > third , List < ? super E > fourth , F [ ] fifth , Collection < G > [ ] sixth ) { } } }
public < T > void forItems ( Collection < T > items ) { } } @ Test public void whereTypeVariableIsOnWildcardUpperBoundOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnWildcardUpperBoundOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable U " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnWildcardUpperBoundOnTheoryParm { @ DataPoint public static List < String > strings = Arrays . asList ( " foo " , " bar " ) ; @ Theory public < U > void forItems ( Collection < ? extends U > items ) { } } @ Test public void whereTypeVariableIsOnWildcardLowerBoundOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnWildcardLowerBoundOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable V " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnWildcardLowerBoundOnTheoryParm { @ DataPoint public static List < String > strings = Arrays . asList ( " foo " , " bar " ) ; @ Theory public < V > void forItems ( Collection < ? super V > items ) { } } @ Test public void whereTypeVariableIsOnArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnArrayTypeOnTheoryParm { @ DataPoints public static String [ ] [ ] items ( ) { return new String [ ] [ ] { new String [ ] { " foo " } , new String [ ] { " bar " } } ; } @ Theory public < T > void forItems ( T [ ] items ) { } } @ Test public void whereTypeVariableIsOnComponentOfArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnComponentOfArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable U " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnComponentOfArrayTypeOnTheoryParm { @ DataPoints public static List < ? > [ ] [ ] items ( ) { return new List < ? > [ ] [ ] { new List < ? > [ ] { Arrays . asList ( " foo " ) } , new List < ? > [ ] { Arrays . asList ( " bar " ) } } ; } @ Theory public < U > void forItems ( Collection < U > [ ] items ) { } } @ Test public void whereTypeVariableIsOnTheoryClass ( ) { PrintableResult result = testResult ( TypeVariableOnTheoryClass . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnTheoryClass < T > { @ DataPoint public static String item = " bar " ; @ Theory public void forItem ( T item ) { } } @ Test public void whereTypeVariablesAbound ( ) { PrintableResult result = testResult ( TypeVariablesAbound . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable A " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable B " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable C " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable D " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable E " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable F " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable G " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariablesAbound < A , B extends A , C extends Collection < B > > { @ Theory public < D , E extends D , F , G > void forItem ( A first , Collection < B > second , Map < C , ? extends D > third , List < ? super E > fourth , F [ ] fifth , Collection < G > [ ] sixth ) { } } }
public < U > void forItems ( Collection < ? extends U > items ) { } } @ Test public void whereTypeVariableIsOnWildcardLowerBoundOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnWildcardLowerBoundOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable V " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnWildcardLowerBoundOnTheoryParm { @ DataPoint public static List < String > strings = Arrays . asList ( " foo " , " bar " ) ; @ Theory public < V > void forItems ( Collection < ? super V > items ) { } } @ Test public void whereTypeVariableIsOnArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnArrayTypeOnTheoryParm { @ DataPoints public static String [ ] [ ] items ( ) { return new String [ ] [ ] { new String [ ] { " foo " } , new String [ ] { " bar " } } ; } @ Theory public < T > void forItems ( T [ ] items ) { } } @ Test public void whereTypeVariableIsOnComponentOfArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnComponentOfArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable U " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnComponentOfArrayTypeOnTheoryParm { @ DataPoints public static List < ? > [ ] [ ] items ( ) { return new List < ? > [ ] [ ] { new List < ? > [ ] { Arrays . asList ( " foo " ) } , new List < ? > [ ] { Arrays . asList ( " bar " ) } } ; } @ Theory public < U > void forItems ( Collection < U > [ ] items ) { } } @ Test public void whereTypeVariableIsOnTheoryClass ( ) { PrintableResult result = testResult ( TypeVariableOnTheoryClass . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnTheoryClass < T > { @ DataPoint public static String item = " bar " ; @ Theory public void forItem ( T item ) { } } @ Test public void whereTypeVariablesAbound ( ) { PrintableResult result = testResult ( TypeVariablesAbound . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable A " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable B " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable C " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable D " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable E " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable F " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable G " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariablesAbound < A , B extends A , C extends Collection < B > > { @ Theory public < D , E extends D , F , G > void forItem ( A first , Collection < B > second , Map < C , ? extends D > third , List < ? super E > fourth , F [ ] fifth , Collection < G > [ ] sixth ) { } } }
public < V > void forItems ( Collection < ? super V > items ) { } } @ Test public void whereTypeVariableIsOnArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnArrayTypeOnTheoryParm { @ DataPoints public static String [ ] [ ] items ( ) { return new String [ ] [ ] { new String [ ] { " foo " } , new String [ ] { " bar " } } ; } @ Theory public < T > void forItems ( T [ ] items ) { } } @ Test public void whereTypeVariableIsOnComponentOfArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnComponentOfArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable U " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnComponentOfArrayTypeOnTheoryParm { @ DataPoints public static List < ? > [ ] [ ] items ( ) { return new List < ? > [ ] [ ] { new List < ? > [ ] { Arrays . asList ( " foo " ) } , new List < ? > [ ] { Arrays . asList ( " bar " ) } } ; } @ Theory public < U > void forItems ( Collection < U > [ ] items ) { } } @ Test public void whereTypeVariableIsOnTheoryClass ( ) { PrintableResult result = testResult ( TypeVariableOnTheoryClass . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnTheoryClass < T > { @ DataPoint public static String item = " bar " ; @ Theory public void forItem ( T item ) { } } @ Test public void whereTypeVariablesAbound ( ) { PrintableResult result = testResult ( TypeVariablesAbound . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable A " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable B " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable C " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable D " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable E " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable F " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable G " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariablesAbound < A , B extends A , C extends Collection < B > > { @ Theory public < D , E extends D , F , G > void forItem ( A first , Collection < B > second , Map < C , ? extends D > third , List < ? super E > fourth , F [ ] fifth , Collection < G > [ ] sixth ) { } } }
public < T > void forItems ( T [ ] items ) { } } @ Test public void whereTypeVariableIsOnComponentOfArrayTypeOnTheoryParm ( ) { PrintableResult result = testResult ( TypeVariableOnComponentOfArrayTypeOnTheoryParm . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable U " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnComponentOfArrayTypeOnTheoryParm { @ DataPoints public static List < ? > [ ] [ ] items ( ) { return new List < ? > [ ] [ ] { new List < ? > [ ] { Arrays . asList ( " foo " ) } , new List < ? > [ ] { Arrays . asList ( " bar " ) } } ; } @ Theory public < U > void forItems ( Collection < U > [ ] items ) { } } @ Test public void whereTypeVariableIsOnTheoryClass ( ) { PrintableResult result = testResult ( TypeVariableOnTheoryClass . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnTheoryClass < T > { @ DataPoint public static String item = " bar " ; @ Theory public void forItem ( T item ) { } } @ Test public void whereTypeVariablesAbound ( ) { PrintableResult result = testResult ( TypeVariablesAbound . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable A " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable B " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable C " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable D " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable E " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable F " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable G " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariablesAbound < A , B extends A , C extends Collection < B > > { @ Theory public < D , E extends D , F , G > void forItem ( A first , Collection < B > second , Map < C , ? extends D > third , List < ? super E > fourth , F [ ] fifth , Collection < G > [ ] sixth ) { } } }
public < U > void forItems ( Collection < U > [ ] items ) { } } @ Test public void whereTypeVariableIsOnTheoryClass ( ) { PrintableResult result = testResult ( TypeVariableOnTheoryClass . class ) ; assertThat ( result , hasSingleFailureContaining ( " unresolved type variable T " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariableOnTheoryClass < T > { @ DataPoint public static String item = " bar " ; @ Theory public void forItem ( T item ) { } } @ Test public void whereTypeVariablesAbound ( ) { PrintableResult result = testResult ( TypeVariablesAbound . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable A " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable B " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable C " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable D " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable E " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable F " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable G " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariablesAbound < A , B extends A , C extends Collection < B > > { @ Theory public < D , E extends D , F , G > void forItem ( A first , Collection < B > second , Map < C , ? extends D > third , List < ? super E > fourth , F [ ] fifth , Collection < G > [ ] sixth ) { } } }
public void forItem ( T item ) { } } @ Test public void whereTypeVariablesAbound ( ) { PrintableResult result = testResult ( TypeVariablesAbound . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable A " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable B " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable C " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable D " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable E " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable F " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable G " ) ) ; } @ RunWith ( Theories . class ) public static class TypeVariablesAbound < A , B extends A , C extends Collection < B > > { @ Theory public < D , E extends D , F , G > void forItem ( A first , Collection < B > second , Map < C , ? extends D > third , List < ? super E > fourth , F [ ] fifth , Collection < G > [ ] sixth ) { } } }
public void whereTypeVariablesAbound ( ) { PrintableResult result = testResult ( TypeVariablesAbound . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable A " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable B " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable C " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable D " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable E " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable F " ) ) ; assertThat ( result , hasFailureContaining ( " unresolved type variable G " ) ) ; }
public void failureOnInitialization ( ) { Result result = JUnitCore . runClasses ( BadIndexForAnnotatedFieldTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; List < Failure > failures = result . getFailures ( ) ; assertThat ( failures . get ( 0 ) . getException ( ) . getMessage ( ) , allOf ( containsString ( " Invalid @ Parameter value : 2 . @ Parameter fields counted : 1 . Please use an index between 0 and 0 . " ) ,
private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , containsString ( message ) ) ;
public void someTest ( ) { } } ; @ RunWith ( JUnit4ClassRunner . class ) public static class BadBeforeMethodWithLegacyRunner { @ Before void before ( ) { } @ Test public void someTest ( ) { } } ; public static class NoTests { } @ Test public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; } @ Test public void noRunnableMethods ( ) { assertThat ( exceptionMessageFrom ( NoTests . class ) , containsString ( " No runnable methods " ) ) ; } @ Test public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ; } private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; } }
void before ( ) { } @ Test public void someTest ( ) { } } ; public static class NoTests { } @ Test public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; } @ Test public void noRunnableMethods ( ) { assertThat ( exceptionMessageFrom ( NoTests . class ) , containsString ( " No runnable methods " ) ) ; } @ Test public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ; } private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; } }
public void someTest ( ) { } } ; public static class NoTests { } @ Test public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; } @ Test public void noRunnableMethods ( ) { assertThat ( exceptionMessageFrom ( NoTests . class ) , containsString ( " No runnable methods " ) ) ; } @ Test public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ; } private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; } }
public void noRunnableMethods ( ) { assertThat ( exceptionMessageFrom ( NoTests . class ) , containsString ( " No runnable methods " ) ) ; }
public void before ( ) { } @ Test public void hereBecauseEveryTestClassNeedsATest ( ) { } } @ Test public void nonStaticBeforeClass ( ) { Result result = JUnitCore . runClasses ( NonStaticBeforeClass . class ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , containsString ( " Method before ( ) should be static " ) ) ; } }
public void hereBecauseEveryTestClassNeedsATest ( ) { } } @ Test public void nonStaticBeforeClass ( ) { Result result = JUnitCore . runClasses ( NonStaticBeforeClass . class ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , containsString ( " Method before ( ) should be static " ) ) ; } }
public void nonStaticBeforeClass ( ) { Result result = JUnitCore . runClasses ( NonStaticBeforeClass . class ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , containsString ( " Method before ( ) should be static " ) ) ; }
void numbers ( int x ) { } } @ Test public void theoriesMustBePublic ( ) { assertThat ( testResult ( TheoriesMustBePublic . class ) , hasSingleFailureContaining ( " public " ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBeStatic { @ DataPoint public int THREE = 3 ; @ DataPoints public int [ ] FOURS = new int [ ] { 4 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBeStatic ( ) { assertThat ( testResult ( DataPointFieldsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( hasFailureContaining ( " DataPoint field THREE must be static " ) ) . and ( hasFailureContaining ( " DataPoint field FOURS must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBeStatic { @ DataPoint public int singleDataPointMethod ( ) { return 1 ; } @ DataPoints public int [ ] dataPointArrayMethod ( ) { return new int [ ] { 1 , 2 , 3 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( hasFailureContaining ( " DataPoint method singleDataPointMethod must be static " ) ) . and ( hasFailureContaining ( " DataPoint method dataPointArrayMethod must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBePublic { @ DataPoint static int THREE = 3 ; @ DataPoints static int [ ] THREES = new int [ ] { 3 } ; @ DataPoint protected static int FOUR = 4 ; @ DataPoints protected static int [ ] FOURS = new int [ ] { 4 } ; @ DataPoint private static int FIVE = 5 ; @ DataPoints private static int [ ] FIVES = new int [ ] { 5 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBeStatic ( ) { assertThat ( testResult ( DataPointFieldsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( hasFailureContaining ( " DataPoint field THREE must be static " ) ) . and ( hasFailureContaining ( " DataPoint field FOURS must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBeStatic { @ DataPoint public int singleDataPointMethod ( ) { return 1 ; } @ DataPoints public int [ ] dataPointArrayMethod ( ) { return new int [ ] { 1 , 2 , 3 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( hasFailureContaining ( " DataPoint method singleDataPointMethod must be static " ) ) . and ( hasFailureContaining ( " DataPoint method dataPointArrayMethod must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBePublic { @ DataPoint static int THREE = 3 ; @ DataPoints static int [ ] THREES = new int [ ] { 3 } ; @ DataPoint protected static int FOUR = 4 ; @ DataPoints protected static int [ ] FOURS = new int [ ] { 4 } ; @ DataPoint private static int FIVE = 5 ; @ DataPoints private static int [ ] FIVES = new int [ ] { 5 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public RuleChain around ( TestRule enclosedRule ) { if ( enclosedRule = = null ) { throw new NullPointerException ( " The enclosed rule must not be null " ) ; } List < TestRule > rulesOfNewChain = new ArrayList < TestRule > ( ) ; rulesOfNewChain . add ( enclosedRule ) ; rulesOfNewChain . addAll ( rulesStartingWithInnerMost ) ; return new RuleChain ( rulesOfNewChain ) ; }
public void aroundShouldNotAllowNullRules ( ) { RuleChain chain = RuleChain . emptyRuleChain ( ) ; try { chain . around ( null ) ;
public void example ( ) { } } @ Test public void whenRuleChainHasNullRuleTheStacktraceShouldPointToIt ( ) { Result result = JUnitCore . runClasses ( RuleChainWithNullRules . class ) ; assertThat ( result . getFailures ( ) . size ( ) , equalTo ( 1 ) ) ; String stacktrace = Throwables . getStacktrace ( result . getFailures ( ) . get ( 0 ) . getException ( ) ) ; assertThat ( stacktrace , containsString ( " \ tat org . junit . rules . RuleChainTest $ RuleChainWithNullRules . < init > ( RuleChainTest . java : " ) ) ; } }
public void whenRuleChainHasNullRuleTheStacktraceShouldPointToIt ( ) { Result result = JUnitCore . runClasses ( RuleChainWithNullRules . class ) ; assertThat ( result . getFailures ( ) . size ( ) , equalTo ( 1 ) ) ; String stacktrace = Throwables . getStacktrace ( result . getFailures ( ) . get ( 0 ) . getException ( ) ) ; assertThat ( stacktrace , containsString ( " \ tat org . junit . rules . RuleChainTest $ RuleChainWithNullRules . < init > ( RuleChainTest . java : " ) ) ; }
public void testOne ( ) { } public void testTwo ( ) { } } @ Test public void junit3TestsAreRunOnce ( ) throws Exception { Result result = fMax . run ( Request . aClass ( TwoOldTests . class ) , new JUnitCore ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void filterSingleMethodFromOldTestClass ( ) throws Exception { final Description method = Description . createTestDescription ( TwoOldTests . class , " testOne " ) ; Filter filter = Filter . matchMethodDescription ( method ) ; JUnit38ClassRunner child = new JUnit38ClassRunner ( TwoOldTests . class ) ; child . filter ( filter ) ; assertEquals ( 1 , child . testCount ( ) ) ; } @ Test public void testCountsStandUpToFiltration ( ) { assertFilterLeavesTestUnscathed ( AllTests . class ) ; } private void assertFilterLeavesTestUnscathed ( Class < ? > testClass ) { Request oneClass = Request . aClass ( testClass ) ; Request filtered = oneClass . filterWith ( new Filter ( ) { @ Override public boolean shouldRun ( Description description ) { return true ; } @ Override public String describe ( ) { return " Everything " ; } } ) ; int filterCount = filtered . getRunner ( ) . testCount ( ) ; int coreCount = oneClass . getRunner ( ) . testCount ( ) ; assertEquals ( " Counts match up in " + testClass , coreCount , filterCount ) ; } private static class MalformedJUnit38Test { private MalformedJUnit38Test ( ) { } @ SuppressWarnings ( " unused " ) public void testSucceeds ( ) { } } @ Test public void maxShouldSkipMalformedJUnit38Classes ( ) { Request request = Request . aClass ( MalformedJUnit38Test . class ) ; fMax . run ( request ) ; } public static class MalformedJUnit38TestMethod extends TestCase { @ SuppressWarnings ( " unused " ) private void testNothing ( ) { } } @ Test public void correctErrorFromMalformedTest ( ) { Request request = Request . aClass ( MalformedJUnit38TestMethod . class ) ; JUnitCore core = new JUnitCore ( ) ; Request sorted = fMax . sortRequest ( request ) ; Runner runner = sorted . getRunner ( ) ; Result result = core . run ( runner ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . toString ( ) , containsString ( " MalformedJUnit38TestMethod " ) ) ; assertThat ( failure . toString ( ) , containsString ( " testNothing " ) ) ; assertThat ( failure . toString ( ) , containsString ( " isn ' t public " ) ) ; } public static class HalfMalformedJUnit38TestMethod extends TestCase { public void testSomething ( ) { } @ SuppressWarnings ( " unused " ) private void testNothing ( ) { } } @ Test public void halfMalformed ( ) { assertThat ( JUnitCore . runClasses ( HalfMalformedJUnit38TestMethod . class ) . getFailureCount ( ) , is ( 1 ) ) ; } @ Test public void correctErrorFromHalfMalformedTest ( ) { Request request = Request . aClass ( HalfMalformedJUnit38TestMethod . class ) ; JUnitCore core = new JUnitCore ( ) ; Request sorted = fMax . sortRequest ( request ) ; Runner runner = sorted . getRunner ( ) ; Result result = core . run ( runner ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . toString ( ) , containsString ( " MalformedJUnit38TestMethod " ) ) ; assertThat ( failure . toString ( ) , containsString ( " testNothing " ) ) ; assertThat ( failure . toString ( ) , containsString ( " isn ' t public " ) ) ; } }
public void testTwo ( ) { } } @ Test public void junit3TestsAreRunOnce ( ) throws Exception { Result result = fMax . run ( Request . aClass ( TwoOldTests . class ) , new JUnitCore ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void filterSingleMethodFromOldTestClass ( ) throws Exception { final Description method = Description . createTestDescription ( TwoOldTests . class , " testOne " ) ; Filter filter = Filter . matchMethodDescription ( method ) ; JUnit38ClassRunner child = new JUnit38ClassRunner ( TwoOldTests . class ) ; child . filter ( filter ) ; assertEquals ( 1 , child . testCount ( ) ) ; } @ Test public void testCountsStandUpToFiltration ( ) { assertFilterLeavesTestUnscathed ( AllTests . class ) ; } private void assertFilterLeavesTestUnscathed ( Class < ? > testClass ) { Request oneClass = Request . aClass ( testClass ) ; Request filtered = oneClass . filterWith ( new Filter ( ) { @ Override public boolean shouldRun ( Description description ) { return true ; } @ Override public String describe ( ) { return " Everything " ; } } ) ; int filterCount = filtered . getRunner ( ) . testCount ( ) ; int coreCount = oneClass . getRunner ( ) . testCount ( ) ; assertEquals ( " Counts match up in " + testClass , coreCount , filterCount ) ; } private static class MalformedJUnit38Test { private MalformedJUnit38Test ( ) { } @ SuppressWarnings ( " unused " ) public void testSucceeds ( ) { } } @ Test public void maxShouldSkipMalformedJUnit38Classes ( ) { Request request = Request . aClass ( MalformedJUnit38Test . class ) ; fMax . run ( request ) ; } public static class MalformedJUnit38TestMethod extends TestCase { @ SuppressWarnings ( " unused " ) private void testNothing ( ) { } } @ Test public void correctErrorFromMalformedTest ( ) { Request request = Request . aClass ( MalformedJUnit38TestMethod . class ) ; JUnitCore core = new JUnitCore ( ) ; Request sorted = fMax . sortRequest ( request ) ; Runner runner = sorted . getRunner ( ) ; Result result = core . run ( runner ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . toString ( ) , containsString ( " MalformedJUnit38TestMethod " ) ) ; assertThat ( failure . toString ( ) , containsString ( " testNothing " ) ) ; assertThat ( failure . toString ( ) , containsString ( " isn ' t public " ) ) ; } public static class HalfMalformedJUnit38TestMethod extends TestCase { public void testSomething ( ) { } @ SuppressWarnings ( " unused " ) private void testNothing ( ) { } } @ Test public void halfMalformed ( ) { assertThat ( JUnitCore . runClasses ( HalfMalformedJUnit38TestMethod . class ) . getFailureCount ( ) , is ( 1 ) ) ; } @ Test public void correctErrorFromHalfMalformedTest ( ) { Request request = Request . aClass ( HalfMalformedJUnit38TestMethod . class ) ; JUnitCore core = new JUnitCore ( ) ; Request sorted = fMax . sortRequest ( request ) ; Runner runner = sorted . getRunner ( ) ; Result result = core . run ( runner ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . toString ( ) , containsString ( " MalformedJUnit38TestMethod " ) ) ; assertThat ( failure . toString ( ) , containsString ( " testNothing " ) ) ; assertThat ( failure . toString ( ) , containsString ( " isn ' t public " ) ) ; } }
public void testSucceeds ( ) { } } @ Test public void maxShouldSkipMalformedJUnit38Classes ( ) { Request request = Request . aClass ( MalformedJUnit38Test . class ) ; fMax . run ( request ) ; } public static class MalformedJUnit38TestMethod extends TestCase { @ SuppressWarnings ( " unused " ) private void testNothing ( ) { } } @ Test public void correctErrorFromMalformedTest ( ) { Request request = Request . aClass ( MalformedJUnit38TestMethod . class ) ; JUnitCore core = new JUnitCore ( ) ; Request sorted = fMax . sortRequest ( request ) ; Runner runner = sorted . getRunner ( ) ; Result result = core . run ( runner ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . toString ( ) , containsString ( " MalformedJUnit38TestMethod " ) ) ; assertThat ( failure . toString ( ) , containsString ( " testNothing " ) ) ; assertThat ( failure . toString ( ) , containsString ( " isn ' t public " ) ) ; } public static class HalfMalformedJUnit38TestMethod extends TestCase { public void testSomething ( ) { } @ SuppressWarnings ( " unused " ) private void testNothing ( ) { } } @ Test public void halfMalformed ( ) { assertThat ( JUnitCore . runClasses ( HalfMalformedJUnit38TestMethod . class ) . getFailureCount ( ) , is ( 1 ) ) ; } @ Test public void correctErrorFromHalfMalformedTest ( ) { Request request = Request . aClass ( HalfMalformedJUnit38TestMethod . class ) ; JUnitCore core = new JUnitCore ( ) ; Request sorted = fMax . sortRequest ( request ) ; Runner runner = sorted . getRunner ( ) ; Result result = core . run ( runner ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . toString ( ) , containsString ( " MalformedJUnit38TestMethod " ) ) ; assertThat ( failure . toString ( ) , containsString ( " testNothing " ) ) ; assertThat ( failure . toString ( ) , containsString ( " isn ' t public " ) ) ; } }
private void testNothing ( ) { } } @ Test public void correctErrorFromMalformedTest ( ) { Request request = Request . aClass ( MalformedJUnit38TestMethod . class ) ; JUnitCore core = new JUnitCore ( ) ; Request sorted = fMax . sortRequest ( request ) ; Runner runner = sorted . getRunner ( ) ; Result result = core . run ( runner ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . toString ( ) , containsString ( " MalformedJUnit38TestMethod " ) ) ; assertThat ( failure . toString ( ) , containsString ( " testNothing " ) ) ; assertThat ( failure . toString ( ) , containsString ( " isn ' t public " ) ) ; } public static class HalfMalformedJUnit38TestMethod extends TestCase { public void testSomething ( ) { } @ SuppressWarnings ( " unused " ) private void testNothing ( ) { } } @ Test public void halfMalformed ( ) { assertThat ( JUnitCore . runClasses ( HalfMalformedJUnit38TestMethod . class ) . getFailureCount ( ) , is ( 1 ) ) ; } @ Test public void correctErrorFromHalfMalformedTest ( ) { Request request = Request . aClass ( HalfMalformedJUnit38TestMethod . class ) ; JUnitCore core = new JUnitCore ( ) ; Request sorted = fMax . sortRequest ( request ) ; Runner runner = sorted . getRunner ( ) ; Result result = core . run ( runner ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; assertThat ( failure . toString ( ) , containsString ( " MalformedJUnit38TestMethod " ) ) ; assertThat ( failure . toString ( ) , containsString ( " testNothing " ) ) ; assertThat ( failure . toString ( ) , containsString ( " isn ' t public " ) ) ; } }
public void evaluate ( ) throws Throwable { before ( ) ; List < Throwable > errors = new ArrayList < Throwable > ( ) ; try { base . evaluate ( ) ; } catch ( Throwable t ) { errors . add ( t ) ; } finally { try { after ( ) ; } catch ( Throwable t ) { errors . add ( t ) ; } } MultipleFailureException . assertEmpty ( errors ) ; }
public void shouldThrowMultipleFailureExceptionWhenTestFailsAndClosingResourceFails ( ) throws Throwable { ExternalResource resourceRule = new ExternalResource ( ) { @ Override protected void after ( ) { throw new RuntimeException ( " simulating resource tear down failure " ) ; } } ; Statement failingTest = new Fail ( new RuntimeException ( " simulated test failure " ) ) ; Description dummyDescription = Description . createTestDescription ( " dummy test class name " , " dummy test name " ) ; try { resourceRule . apply ( failingTest , dummyDescription ) . evaluate ( ) ;
protected void after ( ) { throw new RuntimeException ( " simulating resource tear down failure " ) ; }
public void classShouldAccept411Version ( ) throws Exception { assertFailureSerializableFromOthers ( ARRAY_COMPARISON_FAILURE_411 ) ; }
public void classShouldAccept412Version ( ) throws Exception { assertFailureSerializableFromOthers ( ARRAY_COMPARISON_FAILURE_412 ) ; }
private void assertFailureSerializableFromOthers ( String failureFileName ) throws IOException , ClassNotFoundException { try { assertArrayEquals ( new int [ ] { 0 , 1 } , new int [ ] { 0 , 5 } ) ;
private ArrayComparisonFailure deserializeFailureFromFile ( String fileName ) throws IOException , ClassNotFoundException { InputStream resource = getClass ( ) . getResourceAsStream ( fileName ) ; ObjectInputStream objectInputStream = new ObjectInputStream ( resource ) ; return ( ArrayComparisonFailure ) objectInputStream . readObject ( ) ; }
public void printStackTrace ( ) { for ( Throwable e : fErrors ) { e . printStackTrace ( ) ;
public void printStackTrace ( PrintStream s ) { for ( Throwable e : fErrors ) { e . printStackTrace ( s ) ;
public void printStackTrace ( PrintWriter s ) { for ( Throwable e : fErrors ) { e . printStackTrace ( s ) ;
public static Description createSuiteDescription ( Class < ? > testClass , Annotation . . . annotations ) { return new Description ( testClass , testClass . getName ( ) , annotations ) ; }
public void testClassRuleAccessToClassInAnotherClassLoader ( ) throws Exception { Class < ? > testClassWithOwnClassLoader = wrapToClassLoader ( TestWithClassRule . class ) ; runTestWithParentRunner ( testClassWithOwnClassLoader ) ; Field fieldWithReference = testClassWithOwnClassLoader . getDeclaredField ( " applyTestClass " ) ; Class < ? > usedClass = ( Class < ? > ) fieldWithReference . get ( null ) ; assertEquals ( " JUnitRunner can be located in own classLoader , so , " + " Class . forName org . junit . runner . Description . getTestClass can not see " +
public void testDescriptionContainCorrectTestClass ( ) throws Exception { Class < ? > testClassWithOwnClassLoader = wrapToClassLoader ( TestWithClassRule . class ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClassWithOwnClassLoader ) ; Description description = runner . getDescription ( ) ; assertEquals ( " ParentRunner accept already instantiate Class < ? > with tests , if we lost it instance , and will " + " use Class . forName we can not find test class again , because tests can be " +
private void runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( new RunNotifier ( ) ) ; }
private Class < ? > wrapToClassLoader ( Class < ? > sourceClass ) throws ClassNotFoundException { URL classpath = sourceClass . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) ; VisibleClassLoader loader = new VisibleClassLoader ( new URL [ ] { classpath } , this . getClass ( ) . getClassLoader ( ) ) ; Class < ? > testClassWithOwnClassLoader = loader . findClass ( sourceClass . getName ( ) ) ; assert testClassWithOwnClassLoader ! = sourceClass ; return testClassWithOwnClassLoader ; }
public Class < ? > findClass ( String name ) throws ClassNotFoundException { return super . findClass ( name ) ; }
public void testClassRuleExecuted ( ) throws Exception { Assert . assertNotNull ( " Description should contain reference to TestClass " , applyTestClass ) ; }
public void evaluate ( ) throws Throwable { Class < ? > testClass = description . getTestClass ( ) ; if ( testClass ! = null ) { Field field = testClass . getDeclaredField ( " applyTestClass " ) ; field . set ( null , description . getTestClass ( ) ) ; } base . evaluate ( ) ; }
public boolean isThreadCpuTimeSupported ( ) { return false ; }
public boolean isThreadCpuTimeSupported ( ) { if ( Holder . isThreadCpuTimeSupportedMethod ! = null ) { try { return ( Boolean ) Holder . isThreadCpuTimeSupportedMethod . invoke ( threadMxBean ) ; } catch ( ClassCastException e ) { } catch ( IllegalAccessException e ) { } catch ( IllegalArgumentException e ) { } catch ( InvocationTargetException e ) { } } return false ; }
long getThreadCpuTime ( long id ) ; boolean isThreadCpuTimeSupported ( ) ; }
public static Matcher < PrintableResult > hasFailureContaining ( final String string ) { return new TypeSafeMatcher < PrintableResult > ( ) { public boolean matchesSafely ( PrintableResult item ) {
public boolean matchesSafely ( PrintableResult item ) { return item . failureCount ( ) > 0 & & item . toString ( ) . contains ( string ) ; }
public void hasFailureContaining_givenResultWithNoFailures ( ) { PrintableResult resultWithNoFailures = new PrintableResult ( new ArrayList < Failure > ( ) ) ; assertThat ( ResultMatchers . hasFailureContaining ( " " ) . matches ( resultWithNoFailures ) , is ( false ) ) ; }
public void hasFailureContaining_givenResultWithOneFailure ( ) { PrintableResult resultWithOneFailure = new PrintableResult ( Collections . singletonList ( new Failure ( Description . EMPTY , new RuntimeException ( " my failure " ) ) ) ) ; assertThat ( ResultMatchers . hasFailureContaining ( " my failure " ) . matches ( resultWithOneFailure ) , is ( true ) ) ; assertThat ( ResultMatchers . hasFailureContaining ( " his failure " ) . matches ( resultWithOneFailure ) , is ( false ) ) ; }
protected RunnerBuilder suiteMethodBuilder ( ) { return new CustomSuiteMethodBuilder ( ) ; }
public Runner runnerForClass ( Class < ? > testClass ) throws Throwable { if ( testClass = = fTestClass & & ! canUseSuiteMethod ) { return null ; } return super . runnerForClass ( testClass ) ; }
public static Request classes ( Computer computer , Class < ? > . . . classes ) { try { AllDefaultPossibilitiesBuilder builder = new AllDefaultPossibilitiesBuilder ( ) ;
private static void doTest ( Class < ? > clazz ) { Result result = JUnitCore . runClasses ( clazz ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; TestResult testResult = new TestResult ( ) ; new JUnit4TestAdapter ( clazz ) . run ( testResult ) ; assertEquals ( 1 , testResult . runCount ( ) ) ; assertEquals ( 0 , testResult . failureCount ( ) ) ; assertEquals ( Collections . emptyList ( ) , Collections . list ( testResult . errors ( ) ) ) ; }
public void pass ( ) throws Exception { } } @ RunWith ( Suite . class ) @ Suite . SuiteClasses ( Test4 . class ) public static class TestSuiteFor4 { } @ Test public void testJUnit4Suite ( ) { doTest ( TestSuiteFor4 . class ) ; } public static class Test3 extends TestCase { public void testPass ( ) throws Exception { } } @ RunWith ( Suite . class ) @ Suite . SuiteClasses ( Test3 . class ) public static class TestSuiteFor3 { } @ Test public void testJUnit3Suite ( ) { doTest ( TestSuiteFor3 . class ) ; } public static class TestSuite3 { public static junit . framework . Test suite ( ) { return new TestSuite ( Test3 . class ) ; } } @ RunWith ( Suite . class ) @ Suite . SuiteClasses ( TestSuite3 . class ) public static class TestSuite4ForTestSuite3 { } @ Test public void testJUnit4SuiteThatContainsJUnit3SuiteClass ( ) { doTest ( TestSuite4ForTestSuite3 . class ) ; } }
public void testJUnit4Suite ( ) { doTest ( TestSuiteFor4 . class ) ; }
public void testPass ( ) throws Exception { } } @ RunWith ( Suite . class ) @ Suite . SuiteClasses ( Test3 . class ) public static class TestSuiteFor3 { } @ Test public void testJUnit3Suite ( ) { doTest ( TestSuiteFor3 . class ) ; } public static class TestSuite3 { public static junit . framework . Test suite ( ) { return new TestSuite ( Test3 . class ) ; } } @ RunWith ( Suite . class ) @ Suite . SuiteClasses ( TestSuite3 . class ) public static class TestSuite4ForTestSuite3 { } @ Test public void testJUnit4SuiteThatContainsJUnit3SuiteClass ( ) { doTest ( TestSuite4ForTestSuite3 . class ) ; } }
public void testJUnit3Suite ( ) { doTest ( TestSuiteFor3 . class ) ; }
public static junit . framework . Test suite ( ) { return new TestSuite ( Test3 . class ) ; }
public void testJUnit4SuiteThatContainsJUnit3SuiteClass ( ) { doTest ( TestSuite4ForTestSuite3 . class ) ; }
public void assertEmptyErrorListConstructorFailure ( ) { try { new MultipleFailureException ( Collections . < Throwable > emptyList ( ) ) ;
public void createsADescriptionWithANameForClasses ( ) { Description description = Request . classes ( RequestTest . class , RequestTest . class ) . getRunner ( ) . getDescription ( ) ; assertThat ( description . toString ( ) , is ( " classes " ) ) ; }
void testRunStarted ( String testSuiteName , int testCount ) ; void testRunEnded ( long elapsedTime ) ; void testRunStopped ( long elapsedTime ) ; void testStarted ( String testName ) ; void testEnded ( String testName ) ; void testFailed ( int status , String testName , String trace ) ; }
void testRunEnded ( long elapsedTime ) ; void testRunStopped ( long elapsedTime ) ; void testStarted ( String testName ) ; void testEnded ( String testName ) ; void testFailed ( int status , String testName , String trace ) ; }
void testRunStopped ( long elapsedTime ) ; void testStarted ( String testName ) ; void testEnded ( String testName ) ; void testFailed ( int status , String testName , String trace ) ; }
void testStarted ( String testName ) ; void testEnded ( String testName ) ; void testFailed ( int status , String testName , String trace ) ; }
void testEnded ( String testName ) ; void testFailed ( int status , String testName , String trace ) ; }
void testFailed ( int status , String testName , String trace ) ; }
public static void assumeNotNull ( Object . . . objects ) { assumeThat ( objects , notNullValue ( ) ) ; assumeThat ( asList ( objects ) , everyItem ( notNullValue ( ) ) ) ; }
public void assumeNotNullSingleNullThrowsException ( ) { try { assumeNotNull ( ( Object [ ] ) null ) ;
public void assumeNotNullThrowsExceptionForNullArray ( ) { try { assumeNotNull ( ( Object [ ] ) null ) ;
public void testCapacity ( ) { int size = fFull . size ( ) ; for ( int i = 0 ; i < 100 ; i + + ) { fFull . add ( i ) ; } assertTrue ( fFull . size ( ) = = 100 + size ) ; }
public static < T extends Throwable > T expectThrows ( Class < T > expectedThrowable , ThrowingRunnable runnable ) { try { runnable . run ( ) ; } catch ( Throwable actualThrown ) { if ( expectedThrowable . isInstance ( actualThrown ) ) { @ SuppressWarnings ( " unchecked " ) T retVal = ( T ) actualThrown ; return retVal ; } else { String mismatchMessage = format ( " unexpected exception type thrown ; " , expectedThrowable . getName ( ) , actualThrown . getClass ( ) . getName ( ) ) ; AssertionError assertionError = new AssertionError ( mismatchMessage ) ; assertionError . initCause ( actualThrown ) ; throw assertionError ; } } String message = String . format ( " expected % s to be thrown , but nothing was thrown " , expectedThrowable . getSimpleName ( ) ) ; throw new AssertionError ( message ) ; }
public void usedErrorCollectorCheckThrowsClassMismatchShouldFail ( ) { PrintableResult testResult = testResult ( UsesErrorCollectorCheckThrowsClassMismatch . class ) ; assertThat ( testResult , hasFailureContaining ( " expected : < java . lang . IllegalArgumentException > but was : < java . lang . NullPointerException > " ) ) ;
public void expectThrowsSuppliesACoherentErrorMessageUponTypeMismatch ( ) { NullPointerException npe = new NullPointerException ( ) ; try { expectThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < java . io . IOException > but was : < java . lang . NullPointerException > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } fail ( ) ; }
public void testCapacity ( ) { int size = fullList . size ( ) ; for ( int i = 0 ; i < 100 ; i + + ) { fullList . add ( i ) ; } assertTrue ( fullList . size ( ) = = 100 + size ) ; }
public void testContains ( ) { assertTrue ( fullList . contains ( 1 ) ) ; assertTrue ( ! emptyList . contains ( 1 ) ) ; }
public void testElementAt ( ) { int i = fullList . get ( 0 ) ; assertEquals ( 1 , i ) ; try { fullList . get ( fullList . size ( ) ) ; } catch ( IndexOutOfBoundsException e ) { return ; } fail ( " Should raise an ArrayIndexOutOfBoundsException " ) ; }
public void testRemoveAll ( ) { fullList . removeAll ( fullList ) ; emptyList . removeAll ( emptyList ) ; assertTrue ( fullList . isEmpty ( ) ) ; assertTrue ( emptyList . isEmpty ( ) ) ; }
public void testRemoveElement ( ) { fullList . remove ( 3 ) ; assertTrue ( ! fullList . contains ( 3 ) ) ; }
public abstract Runner getRunner ( ) ; public Request filterWith ( Filter filter ) { return new FilterRequest ( this , filter ) ; } public Request filterWith ( Description desiredDescription ) { return filterWith ( Filter . matchMethodDescription ( desiredDescription ) ) ; } public Request sortWith ( Comparator < Description > comparator ) { return new SortingRequest ( this , comparator ) ; } }
public Request filterWith ( Description desiredDescription ) { return filterWith ( Filter . matchMethodDescription ( desiredDescription ) ) ; }
private static String formatClass ( Class < ? > value ) { String className = value . getCanonicalName ( ) ; return className = = null ? value . getName ( ) : className ; }
public static < T extends Throwable > T expectThrows ( Class < T > expectedThrowable , ThrowingRunnable runnable ) { try { runnable . run ( ) ; } catch ( Throwable actualThrown ) { if ( expectedThrowable . isInstance ( actualThrown ) ) { @ SuppressWarnings ( " unchecked " ) T retVal = ( T ) actualThrown ; return retVal ; } else { String mismatchMessage = format ( " unexpected exception type thrown ; " , formatClass ( expectedThrowable ) , formatClass ( actualThrown ) ) ; AssertionError assertionError = new AssertionError ( mismatchMessage ) ; assertionError . initCause ( actualThrown ) ; throw assertionError ; } } String message = String . format ( " expected % s to be thrown , but nothing was thrown " , formatClass ( expectedThrowable ) ) ; throw new AssertionError ( message ) ; }
public void expectThrowsIncludesAnInformativeDefaultMessage ( ) { try { expectThrows ( Throwable . class , nonThrowingRunnable ( ) ) ; } catch ( AssertionError ex ) { assertEquals ( " expected java . lang . Throwable to be thrown , but nothing was thrown " , ex . getMessage ( ) ) ; return ; } fail ( ) ; }
public void expectThrowsUsesCanonicalNameUponTypeMismatch ( ) { NullPointerException npe = new NullPointerException ( ) ; try { expectThrows ( NestedException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < org . junit . tests . assertion . AssertionTest . NestedException > " + " but was : < java . lang . NullPointerException > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } fail ( ) ; }
public void expectThrowsUsesNameUponTypeMismatchWithAnonymousClass ( ) { NullPointerException npe = new NullPointerException ( ) { } ; try { expectThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < java . io . IOException > " + " but was : < org . junit . tests . assertion . AssertionTest $ 1 > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } fail ( ) ; }
public void expectThrowsUsesCanonicalNameWhenRequiredExceptionNotThrown ( ) { try { expectThrows ( NestedException . class , nonThrowingRunnable ( ) ) ; } catch ( AssertionError error ) { assertEquals ( " expected org . junit . tests . assertion . AssertionTest . NestedException to be thrown , " + " but nothing was thrown " , error . getMessage ( ) ) ; return ; } fail ( ) ; }
public static < T extends Throwable > T expectThrows ( Class < T > expectedThrowable , ThrowingRunnable runnable ) { try { runnable . run ( ) ; } catch ( Throwable actualThrown ) { if ( expectedThrowable . isInstance ( actualThrown ) ) { @ SuppressWarnings ( " unchecked " ) T retVal = ( T ) actualThrown ; return retVal ; } else { String expected = formatClass ( expectedThrowable ) ; Class < ? extends Throwable > actualThrowable = actualThrown . getClass ( ) ; String actual = formatClass ( actualThrowable ) ; if ( expected . equals ( actual ) ) { expected + = " @ " + Integer . toHexString ( System . identityHashCode ( expectedThrowable ) ) ; actual + = " @ " + Integer . toHexString ( System . identityHashCode ( actualThrowable ) ) ; } String mismatchMessage = format ( " unexpected exception type thrown ; " , expected , actual ) ; AssertionError assertionError = new AssertionError ( mismatchMessage ) ; assertionError . initCause ( actualThrown ) ; throw assertionError ; } } String message = String . format ( " expected % s to be thrown , but nothing was thrown " , formatClass ( expectedThrowable ) ) ; throw new AssertionError ( message ) ; }
public static < T extends Throwable > Matcher < T > hasCause ( final Matcher < ? > matcher ) { return new ThrowableCauseMatcher < T > ( matcher ) ; }
public ExpectedException expectCause ( Matcher < ? > expectedCause ) { expect ( hasCause ( expectedCause ) ) ; return this ; }
public List < Failure > failures ( ) { return result . getFailures ( ) ; }
public static Matcher < PrintableResult > hasSingleFailureMatching ( final Matcher < Throwable > matcher ) { return new TypeSafeMatcher < PrintableResult > ( ) { @ Override
public boolean matchesSafely ( PrintableResult item ) { return item . failureCount ( ) = = 1 & & matcher . matches ( item . failures ( ) . get ( 0 ) . getException ( ) ) ; }
public void describeTo ( Description description ) { description . appendText ( " has failure with exception matching " ) ; matcher . describeTo ( description ) ; }
public static Matcher < PrintableResult > hasFailureContaining ( final String string ) { return new TypeSafeMatcher < PrintableResult > ( ) { @ Override
public void addError ( Throwable error ) { if ( error instanceof AssumptionViolatedException ) { AssertionError e = new AssertionError ( error . getMessage ( ) ) ;
public void example ( ) { collector . addError ( new AssumptionViolatedException ( " message " ) ) ; }
public void passingAssumptionViolatedExceptionShouldResultInFailure ( ) { assertThat ( testResult ( PassesAssumptionViolatedExceptionToErrorCollector . class ) , hasSingleFailureMatching ( CoreMatchers . < Throwable > instanceOf ( AssertionError . class ) ) ) ;
public void example ( ) { collector . checkSucceeds ( new Callable < Object > ( ) { public Object call ( ) throws Exception {
public Object call ( ) throws Exception { throw new AssumptionViolatedException ( " message " ) ; }
public void usedErrorCollectorCheckSucceedsWithAssumptionViolatedExceptionShouldFail ( ) { PrintableResult testResult = testResult ( UsesErrorCollectorCheckSucceedsWithAssumptionViolatedException . class ) ; assertThat ( testResult , hasSingleFailureMatching ( CoreMatchers . < Throwable > instanceOf ( AssertionError . class ) ) ) ; assertThat ( testResult , hasFailureContaining ( " Callable threw AssumptionViolatedException " ) ) ; }
public void addError ( Throwable error ) { if ( error = = null ) { throw new NullPointerException ( " Error cannot be null " ) ; } if ( error instanceof AssumptionViolatedException ) { AssertionError e = new AssertionError ( error . getMessage ( ) ) ;
public void shouldWrapAssumptionFailuresWhenClosingResourceFails ( ) throws Throwable { final AtomicReference < Throwable > externalResourceException = new AtomicReference < Throwable > ( ) ; ExternalResource resourceRule = new ExternalResource ( ) { @ Override protected void after ( ) { RuntimeException runtimeException = new RuntimeException ( " simulating resource tear down failure " ) ; externalResourceException . set ( runtimeException ) ; throw runtimeException ; } } ; final AtomicReference < Throwable > assumptionViolatedException = new AtomicReference < Throwable > ( ) ; Statement skippedTest = new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { AssumptionViolatedException assumptionFailure = new AssumptionViolatedException ( " skip it " ) ; assumptionViolatedException . set ( assumptionFailure ) ; throw assumptionFailure ; } } ; Description dummyDescription = Description . createTestDescription ( " dummy test class name " , " dummy test name " ) ; try { resourceRule . apply ( skippedTest , dummyDescription ) . evaluate ( ) ;
protected void after ( ) { RuntimeException runtimeException = new RuntimeException ( " simulating resource tear down failure " ) ; externalResourceException . set ( runtimeException ) ; throw runtimeException ; }
public void evaluate ( ) throws Throwable { AssumptionViolatedException assumptionFailure = new AssumptionViolatedException ( " skip it " ) ; assumptionViolatedException . set ( assumptionFailure ) ; throw assumptionFailure ; }
private Matcher < ? super List < Throwable > > hasItems ( Matcher < ? super Throwable > one , Matcher < ? super Throwable > two ) { return CoreMatchers . hasItems ( one , two ) ; }
public void assertEmptyWrapsAssumptionFailuresForManyThrowables ( ) throws Exception { List < Throwable > errors = new ArrayList < Throwable > ( ) ; AssumptionViolatedException assumptionViolatedException = new AssumptionViolatedException ( " skip it " ) ; errors . add ( assumptionViolatedException ) ; errors . add ( new RuntimeException ( " garlic " ) ) ; try { MultipleFailureException . assertEmpty ( errors ) ;
public static void initLog ( ) { log = new StringBuilder ( ) ; }
public File newFolder ( String folder ) throws IOException { if ( new File ( folder ) . isAbsolute ( ) ) { throw new IOException ( " folder name must be a relative path " ) ; } File file = new File ( getRoot ( ) , folder ) ; if ( ! file . mkdirs ( ) ) { throw new IOException ( " a folder with the name \ ' " + folder + " \ ' already exists " ) ; } return file ; }
public void newFolderWithPathStartingWithFileSeparatorThrowsIOException ( ) throws IOException { tempFolder . create ( ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " folder name must be a relative path " ) ; tempFolder . newFolder ( File . separator + " temp1 " ) ; }
public void newFolderWithPathContainingFileSeparaterCreatesDirectories ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFolder ( " temp1 " + File . separator + " temp2 " ) ; File temp1 = new File ( tempFolder . getRoot ( ) , " temp1 " ) ; assertFileIsDirectory ( temp1 ) ; assertFileIsDirectory ( new File ( temp1 , " temp2 " ) ) ; }
public void newFolderWithPathContainingForwardSlashCreatesDirectories ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFolder ( " temp1 / temp2 " ) ; File temp1 = new File ( tempFolder . getRoot ( ) , " temp1 " ) ; assertFileIsDirectory ( temp1 ) ; assertFileIsDirectory ( new File ( temp1 , " temp2 " ) ) ; }
public void createInitializesRootFolder ( ) throws IOException { tempFolder . create ( ) ; assertFileIsDirectory ( tempFolder . getRoot ( ) ) ; }
public void newRandomFolderIsCreatedUnderRootFolder ( ) throws IOException { tempFolder . create ( ) ; File f = tempFolder . newFolder ( ) ; assertFileIsDirectory ( f ) ; assertFileCreatedUnderRootFolder ( " Random folder " , f ) ; }
public void newNestedFoldersCreatedUnderRootFolder ( ) throws IOException { tempFolder . create ( ) ; File f = tempFolder . newFolder ( " top " , " middle " , " bottom " ) ; assertFileIsDirectory ( f ) ; assertParentFolderForFileIs ( f , new File ( tempFolder . getRoot ( ) , " top / middle " ) ) ; assertParentFolderForFileIs ( f . getParentFile ( ) , new File ( tempFolder . getRoot ( ) , " top " ) ) ; assertFileCreatedUnderRootFolder ( " top " , f . getParentFile ( ) . getParentFile ( ) ) ;
private void checkFileIsDirectory ( String msg , File file , boolean isDirectory ) { assertThat ( " File is null " , file , is ( notNullValue ( ) ) ) ; assertThat ( " File ' " + file . getAbsolutePath ( ) + " ' " + msg , file . isDirectory ( ) , is ( isDirectory ) ) ;
private void assertFileExists ( File file ) { checkFileExists ( " does not exist " , file , true ) ; checkFileIsDirectory ( " is a directory " , file , false ) ; }
private void assertFileIsDirectory ( File file ) { checkFileExists ( " does not exist " , file , true ) ; checkFileIsDirectory ( " is not a directory " , file , true ) ; }
public void newFolderWithPathStartingWithFileSeparatorThrowsIOException ( ) throws IOException { String fileAtRoot ; File [ ] roots = File . listRoots ( ) ; if ( roots ! = null & & roots . length > 0 ) { fileAtRoot = roots [ 0 ] . getAbsolutePath ( ) + " temp1 " ; } else { fileAtRoot = File . separator + " temp1 " ; } tempFolder . create ( ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " folder name must be a relative path " ) ; tempFolder . newFolder ( fileAtRoot ) ; }
protected abstract Filter createFilter ( List < Class < ? > > categories ) ; private List < Class < ? > > parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = Classes . getClass ( category , getClass ( ) ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses ; } }
private List < Class < ? > > parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = Classes . getClass ( category , getClass ( ) ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses ; }
public static Class < ? > getClass ( String className ) throws ClassNotFoundException { return getClass ( className , Classes . class ) ; }
public static Class < ? > getClass ( String className , Class < ? > callingClass ) throws ClassNotFoundException { ClassLoader classLoader = currentThread ( ) . getContextClassLoader ( ) ; return Class . forName ( className , true , classLoader = = null ? callingClass . getClassLoader ( ) : classLoader ) ; }
public static CategoryFilter include ( boolean matchAny , Class < ? > . . . categories ) { return new CategoryFilter ( matchAny , categories , true , null ) ; }
public static CategoryFilter exclude ( boolean matchAny , Class < ? > . . . categories ) { return new CategoryFilter ( true , null , matchAny , categories ) ; }
private static Set < Class < ? > > copyAndRefine ( Set < Class < ? > > classes ) { Set < Class < ? > > c = new LinkedHashSet < Class < ? > > ( ) ; if ( classes ! = null ) { c . addAll ( classes ) ; } c . remove ( null ) ; return c ; }
private static Set < Class < ? > > createSet ( Class < ? > [ ] classes ) { if ( classes = = null | | classes . length = = 0 ) { return Collections . emptySet ( ) ; } for ( Class < ? > category : classes ) { if ( category = = null ) { throw new NullPointerException ( " has null category " ) ; } } return classes . length = = 1 ? Collections . < Class < ? > > singleton ( classes [ 0 ] )
private static Set < Class < ? > > nullableClassToSet ( Class < ? > nullableClass ) { return nullableClass = = null ? Collections . < Class < ? > > emptySet ( )
public void testCountWithExplicitIncludeFilter ( ) throws Throwable { CategoryFilter include = CategoryFilter . include ( SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; }
public void testCountWithExplicitExcludeFilter ( ) throws Throwable { CategoryFilter include = CategoryFilter . exclude ( SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; }
public void testCountWithExplicitExcludeFilter_usingConstructor ( ) throws Throwable { CategoryFilter include = new CategoryFilter ( null , SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; }
public void categoryFilterLeavesOnlyMatchingMethods_usingConstructor ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = new CategoryFilter ( SlowTests . class , null ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( A . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; }
public File newFolder ( String path ) throws IOException { if ( new File ( path ) . isAbsolute ( ) ) { throw new IOException ( " folder path must be a relative path " ) ; } File file = new File ( getRoot ( ) , path ) ; if ( ! file . mkdirs ( ) ) { if ( file . isDirectory ( ) ) { throw new IOException ( " a folder with the path \ ' " + path + " \ ' already exists " ) ; } throw new IOException ( " could not create a folder with the path \ ' " + path + " \ ' " ) ; } return file ; }
public File newFolder ( String . . . paths ) throws IOException { File file = getRoot ( ) ; for ( int i = 0 ; i < paths . length ; i + + ) { String folderName = paths [ i ] ; validateFolderName ( folderName ) ; file = new File ( file , folderName ) ; if ( ! file . mkdir ( ) & & isLastElementInArray ( i , paths ) ) { throw new IOException ( " a folder with the name \ ' " + folderName + " \ ' already exists " ) ; } } return file ; }
public void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFolderExists ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFolder ( " level1 " ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " a folder with the path ' level1 ' already exists " ) ; tempFolder . newFolder ( " level1 " ) ; }
public void newFolderWithGivenFolderThrowsIllegalArgumentExceptionIfFileExists ( ) throws IOException { tempFolder . create ( ) ; File file = new File ( tempFolder . getRoot ( ) , " level1 " ) ; assertTrue ( " Could not create " + file , file . createNewFile ( ) ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " could not create a folder with the path ' level1 ' " ) ; tempFolder . newFolder ( " level1 " ) ; }
public void newFolderWithPathStartingWithFileSeparatorThrowsIOException ( ) throws IOException { String fileAtRoot ; File [ ] roots = File . listRoots ( ) ; if ( roots ! = null & & roots . length > 0 ) { fileAtRoot = roots [ 0 ] . getAbsolutePath ( ) + " temp1 " ; } else { fileAtRoot = File . separator + " temp1 " ; } tempFolder . create ( ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " folder path must be a relative path " ) ; tempFolder . newFolder ( fileAtRoot ) ; }
public File newFolder ( String path ) throws IOException { return newFolder ( new String [ ] { path } ) ; }
public File newFolder ( String . . . paths ) throws IOException { File root = getRoot ( ) ; for ( String path : paths ) { if ( new File ( path ) . isAbsolute ( ) ) { throw new IOException ( " folder path \ ' " + path + " \ ' is not a relative path " ) ; } } File relativePath = null ; File file = root ; boolean lastMkdirsCallSuccessful = true ; for ( int i = 0 ; i < paths . length ; i + + ) { relativePath = new File ( relativePath , paths [ i ] ) ; file = new File ( root , relativePath . getPath ( ) ) ; lastMkdirsCallSuccessful = file . mkdirs ( ) ; if ( ! lastMkdirsCallSuccessful & & ! file . isDirectory ( ) ) { throw new IOException ( " could not create a folder with the path \ ' " + relativePath . getPath ( ) + " \ ' " ) ; } } if ( ! lastMkdirsCallSuccessful ) { throw new IOException ( " a folder with the path \ ' " + relativePath . getPath ( ) + " \ ' already exists " ) ; } return file ; }
public void newFolderWithPathStartingWithFileSeparatorThrowsIOException ( ) throws IOException { String fileAtRoot ; File [ ] roots = File . listRoots ( ) ; if ( roots ! = null & & roots . length > 0 ) { fileAtRoot = roots [ 0 ] . getAbsolutePath ( ) + " temp1 " ; } else { fileAtRoot = File . separator + " temp1 " ; } tempFolder . create ( ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " folder path ' / temp1 ' is not a relative path " ) ; tempFolder . newFolder ( fileAtRoot ) ; }
public void newFolderWithGivenPathThrowsIllegalArgumentExceptionIfFolderExists ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFolder ( " level1 " , " level2 " , " level3 " ) ; thrown . expect ( IOException . class ) ; String path = " level1 " + File . separator + " level2 " + File . separator + " level3 " ; thrown . expectMessage ( " a folder with the path ' " + path + " ' already exists " ) ; tempFolder . newFolder ( " level1 " , " level2 " , " level3 " ) ; }
public void newFolderWithPathsContainingForwardSlashCreatesFullPath ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFolder ( " temp1 " , " temp2 " , " temp3 / temp4 " ) ; File directory = new File ( tempFolder . getRoot ( ) , " temp1 " ) ; assertFileIsDirectory ( directory ) ; directory = new File ( directory , " temp2 / temp3 / temp4 " ) ; assertFileIsDirectory ( directory ) ; }
public void newFolderWithPathsContainingFileSeparatorCreatesFullPath ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFolder ( " temp1 " , " temp2 " , " temp3 " + File . separator + " temp4 " ) ; File directory = new File ( tempFolder . getRoot ( ) , " temp1 " ) ; assertFileIsDirectory ( directory ) ; directory = new File ( directory , " temp2 / temp3 / temp4 " ) ; assertFileIsDirectory ( directory ) ; }
public File newFolder ( String . . . paths ) throws IOException { if ( paths . length = = 0 ) { throw new IllegalArgumentException ( " must pass at least one path " ) ; } File root = getRoot ( ) ; for ( String path : paths ) { if ( new File ( path ) . isAbsolute ( ) ) { throw new IOException ( " folder path \ ' " + path + " \ ' is not a relative path " ) ; } } File relativePath = null ; File file = root ; boolean lastMkdirsCallSuccessful = true ; for ( int i = 0 ; i < paths . length ; i + + ) { relativePath = new File ( relativePath , paths [ i ] ) ; file = new File ( root , relativePath . getPath ( ) ) ; lastMkdirsCallSuccessful = file . mkdirs ( ) ; if ( ! lastMkdirsCallSuccessful & & ! file . isDirectory ( ) ) { throw new IOException ( " could not create a folder with the path \ ' " + relativePath . getPath ( ) + " \ ' " ) ; } } if ( ! lastMkdirsCallSuccessful ) { throw new IOException ( " a folder with the path \ ' " + relativePath . getPath ( ) + " \ ' already exists " ) ; } return file ; }
public void newFolderWithGivenEmptyArrayThrowsIllegalArgumentException ( ) throws IOException { tempFolder . create ( ) ; thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " must pass at least one path " ) ; tempFolder . newFolder ( new String [ 0 ] ) ; }
public void newFileWithGivenFilenameThrowsIOExceptionIfFileExists ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFile ( " MyFile . txt " ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " a file with the name ' MyFile . txt ' already exists in the test folder " ) ; tempFolder . newFile ( " MyFile . txt " ) ; }
public void newFolderWithGivenFolderThrowsIOExceptionIfFolderExists ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFolder ( " level1 " ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " a folder with the path ' level1 ' already exists " ) ; tempFolder . newFolder ( " level1 " ) ; }
public void newFolderWithGivenFolderThrowsIOExceptionIfFileExists ( ) throws IOException { tempFolder . create ( ) ; File file = new File ( tempFolder . getRoot ( ) , " level1 " ) ; assertTrue ( " Could not create " + file , file . createNewFile ( ) ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " could not create a folder with the path ' level1 ' " ) ; tempFolder . newFolder ( " level1 " ) ; }
public void newFolderWithGivenPathThrowsIOExceptionIfFolderExists ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFolder ( " level1 " , " level2 " , " level3 " ) ; thrown . expect ( IOException . class ) ; String path = " level1 " + File . separator + " level2 " + File . separator + " level3 " ; thrown . expectMessage ( " a folder with the path ' " + path + " ' already exists " ) ; tempFolder . newFolder ( " level1 " , " level2 " , " level3 " ) ; }
abstract boolean isShadowedBy ( T otherMember ) ; T handlePossibleBridgeMethod ( List < T > members ) { for ( int i = members . size ( ) - 1 ; i > = 0 ; i - - ) { T otherMember = members . get ( i ) ; if ( isShadowedBy ( otherMember ) ) { if ( otherMember . isBridgeMethod ( ) ) { members . remove ( i ) ; return otherMember ; } return null ; } } return ( T ) this ; } abstract boolean isBridgeMethod ( ) ; protected abstract int getModifiers ( ) ; public boolean isStatic ( ) { return Modifier . isStatic ( getModifiers ( ) ) ; } public boolean isPublic ( ) { return Modifier . isPublic ( getModifiers ( ) ) ; } public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
T handlePossibleBridgeMethod ( List < T > members ) { for ( int i = members . size ( ) - 1 ; i > = 0 ; i - - ) { T otherMember = members . get ( i ) ; if ( isShadowedBy ( otherMember ) ) { if ( otherMember . isBridgeMethod ( ) ) { members . remove ( i ) ; return otherMember ; } return null ; } } return ( T ) this ; }
abstract boolean isBridgeMethod ( ) ; protected abstract int getModifiers ( ) ; public boolean isStatic ( ) { return Modifier . isStatic ( getModifiers ( ) ) ; } public boolean isPublic ( ) { return Modifier . isPublic ( getModifiers ( ) ) ; } public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
boolean isBridgeMethod ( ) { return method . isBridge ( ) ; }
public TestRule rule ( ) { return new ExternalResource ( ) { @ Override
protected void before ( ) throws Throwable { log + = " super . rule ( ) . before ( ) " ; }
protected void after ( ) { log + = " super . rule ( ) . after ( ) " ; }
public void before ( ) { log + = " super . before ( ) " ; }
public void after ( ) { log + = " super . after ( ) " ; }
protected void before ( ) throws Throwable { log + = " sub . rule ( ) . before ( ) " ; }
protected void after ( ) { log + = " sub . rule ( ) . after ( ) " ; }
public void before ( ) { log + = " sub . before ( ) " ; }
public void anotherBefore ( ) { log + = " sub . anotherBefore ( ) " ; }
public void after ( ) { log + = " sub . after ( ) " ; }
public void anotherAfter ( ) { log + = " sub . anotherAfter ( ) " ; }
public void testShadowing ( ) throws Exception { log = " " ; JUnitCore core = new JUnitCore ( ) ; core . run ( SubShadowing . class ) ; assertEquals ( " sub . rule ( ) . before ( ) sub . anotherBefore ( ) sub . before ( ) "
protected void before ( ) throws Throwable { AnnotationTest . log + = " super . rule ( ) . before ( ) " ; }
protected void after ( ) { AnnotationTest . log + = " super . rule ( ) . after ( ) " ; }
public void before ( ) { AnnotationTest . log + = " super . before ( ) " ; }
public void after ( ) { AnnotationTest . log + = " super . after ( ) " ; }
public void testBridge ( ) throws Exception { assertFalse ( Modifier . isPublic ( SubBridge . class . getSuperclass ( ) . getModifiers ( ) ) ) ; Method method = SubBridge . class . getMethod ( " before " ) ; if ( ! method . isBridge ( ) ) { return ; } if ( ! method . isAnnotationPresent ( Before . class ) ) { return ; } log = " " ; PrintableResult testResult = testResult ( SubBridge . class ) ; assertThat ( testResult , isSuccessful ( ) ) ; assertEquals ( " super . rule ( ) . before ( ) super . before ( ) sub . anotherBefore ( ) "
protected void printFailure ( Failure each , String prefix ) { getWriter ( ) . println ( prefix + " ) " + each . getTestHeader ( ) ) ; getWriter ( ) . print ( each . getTrimmedTrace ( ) ) ; }
private static void appendStackTraceLines ( List < String > stackTraceLines , StringBuilder destBuilder ) { for ( String stackTraceLine : stackTraceLines ) { destBuilder . append ( String . format ( " % s % n " , stackTraceLine ) ) ;
private static < T > List < T > asReversedList ( final List < T > list ) { return new AbstractList < T > ( ) {
public T get ( int index ) { return list . get ( list . size ( ) - index - 1 ) ; }
public int size ( ) { return list . size ( ) ; }
@ Override public State processLine ( String methodName ) { if ( isTestFrameworkMethod ( methodName ) ) { return PROCESSING_TEST_FRAMEWORK_CODE ; } return this ; }
@ Override public State processLine ( String methodName ) { if ( isReflectionMethod ( methodName ) ) { return PROCESSING_REFLECTION_CODE ; } else if ( isTestFrameworkMethod ( methodName ) ) { return this ; } return PROCESSING_OTHER_CODE ; }
@ Override public State processLine ( String methodName ) { if ( isReflectionMethod ( methodName ) ) { return this ; } else if ( isTestFrameworkMethod ( methodName ) ) { return PROCESSING_TEST_FRAMEWORK_CODE ; } return DONE ; }
@ Override public State processLine ( String methodName ) { return this ; }
protected abstract State processLine ( String methodName ) ; public final State processStackTraceElement ( StackTraceElement element ) { return processLine ( element . getClassName ( ) + " . " + element . getMethodName ( ) + " ( ) " ) ; } } private static final String [ ] TEST_FRAMEWORK_METHOD_NAME_PREFIXES = { " org . junit . runner . " , " org . junit . runners . " , " org . junit . experimental . runners . " , " org . junit . internal . " , " junit . " , } ; private static final String [ ] TEST_FRAMEWORK_TEST_METHOD_NAME_PREFIXES = { " org . junit . internal . StackTracesTest " , } ; private static boolean isTestFrameworkMethod ( String methodName ) { return isMatchingMethod ( methodName , TEST_FRAMEWORK_METHOD_NAME_PREFIXES ) & & ! isMatchingMethod ( methodName , TEST_FRAMEWORK_TEST_METHOD_NAME_PREFIXES ) ; } private static final String [ ] REFLECTION_METHOD_NAME_PREFIXES = { " sun . reflect . " , " java . lang . reflect . " , " org . junit . rules . RunRules . < init > ( " , " org . junit . rules . RunRules . applyAll ( " , " org . junit . runners . BlockJUnit4ClassRunner . withMethodRules ( " , " junit . framework . TestCase . runBare ( " , } ; private static boolean isReflectionMethod ( String methodName ) { return isMatchingMethod ( methodName , REFLECTION_METHOD_NAME_PREFIXES ) ; } private static boolean isMatchingMethod ( String methodName , String [ ] methodNamePrefixes ) { for ( String methodNamePrefix : methodNamePrefixes ) { if ( methodName . startsWith ( methodNamePrefix ) ) { return true ; } } return false ; } }
public final State processStackTraceElement ( StackTraceElement element ) { return processLine ( element . getClassName ( ) + " . " + element . getMethodName ( ) + " ( ) " ) ; }
private static boolean isTestFrameworkMethod ( String methodName ) { return isMatchingMethod ( methodName , TEST_FRAMEWORK_METHOD_NAME_PREFIXES ) & & ! isMatchingMethod ( methodName , TEST_FRAMEWORK_TEST_METHOD_NAME_PREFIXES ) ;
private static boolean isReflectionMethod ( String methodName ) { return isMatchingMethod ( methodName , REFLECTION_METHOD_NAME_PREFIXES ) ; }
private static boolean isMatchingMethod ( String methodName , String [ ] methodNamePrefixes ) { for ( String methodNamePrefix : methodNamePrefixes ) { if ( methodName . startsWith ( methodNamePrefix ) ) { return true ; } } return false ; }
public static void startExecutorService ( ) { executorService = Executors . newFixedThreadPool ( 1 ) ; }
public static void shutDownExecutorService ( ) { executorService . shutdown ( ) ; executorService = null ; }
public void describeTo ( Description description ) { matcher . describeTo ( description ) ; }
protected boolean matchesSafely ( String line ) { return matcher . matches ( line ) ; }
private static StringMatcher message ( String message ) { return new ExceptionMessageMatcher ( message ) ; }
public void describeTo ( Description description ) { description . appendText ( " A stack trace line for method " + method ) ; }
protected boolean matchesSafely ( String line ) { if ( ! line . startsWith ( " \ t " ) ) { return false ; } line = line . substring ( 1 ) ; java . util . regex . Matcher matcher = PATTERN . matcher ( line ) ; if ( ! matcher . matches ( ) ) { fail ( " Line does not look like a stack trace line : " + line ) ; } String matchedMethod = matcher . group ( 1 ) ; return method . equals ( matchedMethod ) ; }
private static StringMatcher at ( String method ) { return new StackTraceLineMatcher ( method ) ; }
public void describeTo ( Description description ) { description . appendText ( " A line matching \ " . . x " + suffix + " \ " " ) ; }
protected boolean matchesSafely ( String line ) { if ( ! line . startsWith ( " \ t " ) ) { return false ; } line = line . substring ( 1 ) ; java . util . regex . Matcher matcher = PATTERN . matcher ( line ) ; if ( ! matcher . matches ( ) ) { fail ( " Line does not look like a stack trace line : " + line ) ; } return suffix . equals ( matcher . group ( 1 ) ) ; }
private static StringMatcher framesInCommon ( ) { return new FramesRemovedMatcher ( " more " ) ; }
private static StringMatcher framesTrimmed ( ) { return new FramesRemovedMatcher ( " trimmed " ) ; }
private static Result runTest ( final Class < ? > testClass ) { Future < Result > future = executorService . submit ( new Callable < Result > ( ) { public Result call ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; return core . run ( testClass ) ; } } ) ; try { return future . get ( ) ;
public Result call ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; return core . run ( testClass ) ; }
private static void assertHasTrimmedTrace ( Failure failure , StringMatcher . . . matchers ) { String trimmedTrace = failure . getTrimmedTrace ( ) ; String [ ] lines = trimmedTrace . split ( EOL ) ; int index = 0 ; for ( ; index < lines . length & & index < matchers . length ; index + + ) { String line = lines [ index ] ; StringMatcher matcher = matchers [ index ] ; assertThat ( line , matcher ) ; } if ( index < lines . length ) { String extraLine = lines [ index ] ;
public void alwaysThrows ( ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; }
public void testAlwaysThrows ( ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; }
public void alwaysThrows ( ) { new FakeClassUnderTest ( ) . throwsExceptionWithCause ( ) ; }
public void alwaysPasses ( ) { } } public static class JUnit3TestWithThrowingSetUpMethod extends TestCase { @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; } public void testAlwaysPasses ( ) { } } public static class ThrowingTestRule implements TestRule { public Statement apply ( Statement base , org . junit . runner . Description description ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingTestRule { @ Rule public final TestRule rule = new ThrowingTestRule ( ) ; @ Test public void alwaysPasses ( ) { } } public static class ThrowingMethodRule implements MethodRule { public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingMethodRule { @ Rule public final ThrowingMethodRule rule = new ThrowingMethodRule ( ) ; @ Test public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } }
protected void setUp ( ) throws Exception { super . setUp ( ) ; new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; }
public void testAlwaysPasses ( ) { } } public static class ThrowingTestRule implements TestRule { public Statement apply ( Statement base , org . junit . runner . Description description ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingTestRule { @ Rule public final TestRule rule = new ThrowingTestRule ( ) ; @ Test public void alwaysPasses ( ) { } } public static class ThrowingMethodRule implements MethodRule { public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingMethodRule { @ Rule public final ThrowingMethodRule rule = new ThrowingMethodRule ( ) ; @ Test public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } }
public Statement apply ( Statement base , org . junit . runner . Description description ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; }
public void alwaysPasses ( ) { } } public static class ThrowingMethodRule implements MethodRule { public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingMethodRule { @ Rule public final ThrowingMethodRule rule = new ThrowingMethodRule ( ) ; @ Test public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } }
public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; }
public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } }
public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; }
public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; }
private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ;
private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; }
public void before ( ) { super . before ( ) ; log + = " sub . before ( ) " ; }
public void after ( ) { log + = " sub . after ( ) " ; super . after ( ) ; }
public void testShadowing ( ) throws Exception { log = " " ; assertThat ( testResult ( SubShadowing . class ) , isSuccessful ( ) ) ; assertEquals ( " sub . rule ( ) . before ( ) sub . anotherBefore ( ) super . before ( ) sub . before ( ) "
public static TestRule rule ( ) { return new ExternalResource ( ) { @ Override
public void testStaticMethodsNeverTreatedAsShadowed ( ) throws Exception { log = " " ; assertThat ( testResult ( SubStaticMethodShadowing . class ) , isSuccessful ( ) ) ; assertEquals ( " super . rule ( ) . before ( ) sub . rule ( ) . before ( ) "
public boolean isShadowedBy ( FrameworkField otherMember ) { return false ; }
FrameworkField handlePossibleBridgeMethod ( List < FrameworkField > members ) { return this ; }
abstract boolean isShadowedBy ( T otherMember ) ; abstract T handlePossibleBridgeMethod ( List < T > members ) ; abstract boolean isBridgeMethod ( ) ; protected abstract int getModifiers ( ) ; public boolean isStatic ( ) { return Modifier . isStatic ( getModifiers ( ) ) ; } public boolean isPublic ( ) { return Modifier . isPublic ( getModifiers ( ) ) ; } public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
abstract T handlePossibleBridgeMethod ( List < T > members ) ; abstract boolean isBridgeMethod ( ) ; protected abstract int getModifiers ( ) ; public boolean isStatic ( ) { return Modifier . isStatic ( getModifiers ( ) ) ; } public boolean isPublic ( ) { return Modifier . isPublic ( getModifiers ( ) ) ; } public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
FrameworkMethod handlePossibleBridgeMethod ( List < FrameworkMethod > methods ) { for ( int i = methods . size ( ) - 1 ; i > = 0 ; i - - ) { FrameworkMethod otherMethod = methods . get ( i ) ; if ( isShadowedBy ( otherMethod ) ) { if ( otherMethod . isBridgeMethod ( ) ) { methods . remove ( i ) ; return otherMethod ; } return null ; } } return this ; }
public void fieldsOnSubclassesDoNotShadowSuperclasses ( ) { assertThat ( new TestClass ( SubclassWithField . class ) . getAnnotatedFields ( Rule . class ) . size ( ) , is ( 2 ) ) ;
protected void before ( ) throws Throwable { log + = " super . rule . before ( ) " ; }
protected void after ( ) { log + = " super . rule . after ( ) " ; }
protected void before ( ) throws Throwable { log + = " sub . rule . before ( ) " ; }
protected void after ( ) { log + = " sub . rule . after ( ) " ; }
public void testFieldsNeverTreatedAsShadowed ( ) throws Exception { log = " " ; assertThat ( testResult ( SubFieldShadowing . class ) , isSuccessful ( ) ) ; assertEquals ( " super . rule . before ( ) sub . rule . before ( ) "
public void testStaticFieldsNeverTreatedAsShadowed ( ) throws Exception { log = " " ; assertThat ( testResult ( SubStaticFieldShadowing . class ) , isSuccessful ( ) ) ; assertEquals ( " super . rule . before ( ) sub . rule . before ( ) "
protected void collectInitializationErrors ( List < Throwable > errors ) { super . collectInitializationErrors ( errors ) ; validatePublicConstructor ( errors ) ; validateNoNonStaticInnerClass ( errors ) ; validateConstructor ( errors ) ; validateInstanceMethods ( errors ) ; validateFields ( errors ) ; validateMethods ( errors ) ; }
public void pass ( ) { } } public static class TestB { @ Test public void fail ( ) { Assert . fail ( ) ; } } @ RunWith ( Suite . class ) @ SuiteClasses ( { TestA . class , TestB . class } ) public static class All { } @ RunWith ( Suite . class ) @ SuiteClasses ( TestA . class ) static class NonPublicSuite { } @ RunWith ( Suite . class ) @ SuiteClasses ( TestA . class ) static class NonPublicSuiteWithBeforeClass { @ BeforeClass public static void doesNothing ( ) { } } public static class InheritsAll extends All { } @ Test public void ensureTestIsRun ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( All . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void ensureInheritedTestIsRun ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InheritsAll . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void suiteTestCountIsCorrect ( ) throws Exception { Runner runner = Request . aClass ( All . class ) . getRunner ( ) ; assertEquals ( 2 , runner . testCount ( ) ) ; } @ Test public void suiteClassDoesNotNeedToBePublic ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( NonPublicSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } @ Test public void nonPublicSuiteClassWithBeforeClassFailsWithoutRunningTests ( ) { assertThat ( testResult ( NonPublicSuiteWithBeforeClass . class ) , hasSingleFailureContaining ( " can not access " ) ) ; } @ Test public void ensureSuitesWorkWithForwardCompatibility ( ) { junit . framework . Test test = new JUnit4TestAdapter ( All . class ) ; TestResult result = new TestResult ( ) ; test . run ( result ) ; assertEquals ( 2 , result . runCount ( ) ) ; } @ Test public void forwardCompatibilityWorksWithGetTests ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( All . class ) ; List < ? extends junit . framework . Test > tests = adapter . getTests ( ) ; assertEquals ( 2 , tests . size ( ) ) ; } @ Test public void forwardCompatibilityWorksWithTestCount ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( All . class ) ; assertEquals ( 2 , adapter . countTestCases ( ) ) ; } private static String log = " " ; @ RunWith ( Suite . class ) @ SuiteClasses ( { TestA . class , TestB . class } ) public static class AllWithBeforeAndAfterClass { @ BeforeClass public static void before ( ) { log + = " before " ; } @ AfterClass public static void after ( ) { log + = " after " ; } } @ Test public void beforeAndAfterClassRunOnSuite ( ) { log = " " ; JUnitCore . runClasses ( AllWithBeforeAndAfterClass . class ) ; assertEquals ( " before after " , log ) ; } @ RunWith ( Suite . class ) public static class AllWithOutAnnotation { } @ Test public void withoutSuiteClassAnnotationProducesFailure ( ) { Result result = JUnitCore . runClasses ( AllWithOutAnnotation . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; String expected = String . format ( " class ' % s ' must have a SuiteClasses annotation " , AllWithOutAnnotation . class . getName ( ) ) ; assertEquals ( expected , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( InfiniteLoop . class ) static public class InfiniteLoop { } @ Test public void whatHappensWhenASuiteHasACycle ( ) { Result result = JUnitCore . runClasses ( InfiniteLoop . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { BiInfiniteLoop . class , BiInfiniteLoop . class } ) static public class BiInfiniteLoop { } @ Test public void whatHappensWhenASuiteHasAForkingCycle ( ) { Result result = JUnitCore . runClasses ( BiInfiniteLoop . class ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { Hercules . class } ) static public class Hydra { } @ RunWith ( Suite . class ) @ SuiteClasses ( { Hydra . class , Hydra . class } ) static public class Hercules { } @ Test public void whatHappensWhenASuiteContainsItselfIndirectly ( ) { Result result = JUnitCore . runClasses ( Hydra . class ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { } ) public class WithoutDefaultConstructor { public WithoutDefaultConstructor ( int i ) { } } @ Test public void suiteShouldBeOKwithNonDefaultConstructor ( ) throws Exception { Result result = JUnitCore . runClasses ( WithoutDefaultConstructor . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) public class NoSuiteClassesAnnotation { } @ Test public void suiteShouldComplainAboutNoSuiteClassesAnnotation ( ) { assertThat ( testResult ( NoSuiteClassesAnnotation . class ) , hasSingleFailureContaining ( " SuiteClasses " ) ) ; } }
public static void doesNothing ( ) { } } public static class InheritsAll extends All { } @ Test public void ensureTestIsRun ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( All . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void ensureInheritedTestIsRun ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InheritsAll . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void suiteTestCountIsCorrect ( ) throws Exception { Runner runner = Request . aClass ( All . class ) . getRunner ( ) ; assertEquals ( 2 , runner . testCount ( ) ) ; } @ Test public void suiteClassDoesNotNeedToBePublic ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( NonPublicSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } @ Test public void nonPublicSuiteClassWithBeforeClassFailsWithoutRunningTests ( ) { assertThat ( testResult ( NonPublicSuiteWithBeforeClass . class ) , hasSingleFailureContaining ( " can not access " ) ) ; } @ Test public void ensureSuitesWorkWithForwardCompatibility ( ) { junit . framework . Test test = new JUnit4TestAdapter ( All . class ) ; TestResult result = new TestResult ( ) ; test . run ( result ) ; assertEquals ( 2 , result . runCount ( ) ) ; } @ Test public void forwardCompatibilityWorksWithGetTests ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( All . class ) ; List < ? extends junit . framework . Test > tests = adapter . getTests ( ) ; assertEquals ( 2 , tests . size ( ) ) ; } @ Test public void forwardCompatibilityWorksWithTestCount ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( All . class ) ; assertEquals ( 2 , adapter . countTestCases ( ) ) ; } private static String log = " " ; @ RunWith ( Suite . class ) @ SuiteClasses ( { TestA . class , TestB . class } ) public static class AllWithBeforeAndAfterClass { @ BeforeClass public static void before ( ) { log + = " before " ; } @ AfterClass public static void after ( ) { log + = " after " ; } } @ Test public void beforeAndAfterClassRunOnSuite ( ) { log = " " ; JUnitCore . runClasses ( AllWithBeforeAndAfterClass . class ) ; assertEquals ( " before after " , log ) ; } @ RunWith ( Suite . class ) public static class AllWithOutAnnotation { } @ Test public void withoutSuiteClassAnnotationProducesFailure ( ) { Result result = JUnitCore . runClasses ( AllWithOutAnnotation . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; String expected = String . format ( " class ' % s ' must have a SuiteClasses annotation " , AllWithOutAnnotation . class . getName ( ) ) ; assertEquals ( expected , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( InfiniteLoop . class ) static public class InfiniteLoop { } @ Test public void whatHappensWhenASuiteHasACycle ( ) { Result result = JUnitCore . runClasses ( InfiniteLoop . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { BiInfiniteLoop . class , BiInfiniteLoop . class } ) static public class BiInfiniteLoop { } @ Test public void whatHappensWhenASuiteHasAForkingCycle ( ) { Result result = JUnitCore . runClasses ( BiInfiniteLoop . class ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { Hercules . class } ) static public class Hydra { } @ RunWith ( Suite . class ) @ SuiteClasses ( { Hydra . class , Hydra . class } ) static public class Hercules { } @ Test public void whatHappensWhenASuiteContainsItselfIndirectly ( ) { Result result = JUnitCore . runClasses ( Hydra . class ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { } ) public class WithoutDefaultConstructor { public WithoutDefaultConstructor ( int i ) { } } @ Test public void suiteShouldBeOKwithNonDefaultConstructor ( ) throws Exception { Result result = JUnitCore . runClasses ( WithoutDefaultConstructor . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) public class NoSuiteClassesAnnotation { } @ Test public void suiteShouldComplainAboutNoSuiteClassesAnnotation ( ) { assertThat ( testResult ( NoSuiteClassesAnnotation . class ) , hasSingleFailureContaining ( " SuiteClasses " ) ) ; } }
public void suiteClassDoesNotNeedToBePublic ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( NonPublicSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; }
public void nonPublicSuiteClassWithBeforeClassFailsWithoutRunningTests ( ) { assertThat ( testResult ( NonPublicSuiteWithBeforeClass . class ) , hasSingleFailureContaining ( " can not access " ) ) ; }
public void whenExpectingAssumptionViolatedExceptionStatementsThrowingItShouldPass ( ) { Statement delegate = new Fail ( new AssumptionViolatedException ( " expected " ) ) ; ExpectException expectException = new ExpectException ( delegate , AssumptionViolatedException . class ) ; try { expectException . evaluate ( ) ;
public void whenExpectingAssumptionViolatedExceptionStatementsThrowingSubclassShouldPass ( ) { Statement delegate = new Fail ( new AssumptionViolatedExceptionSubclass ( " expected " ) ) ; ExpectException expectException = new ExpectException ( delegate , AssumptionViolatedException . class ) ; try { expectException . evaluate ( ) ;
public void whenExpectingAssumptionViolatedExceptionStatementsThrowingDifferentExceptionShouldFail ( ) { Statement delegate = new Fail ( new SomeException ( " not expected " ) ) ; ExpectException expectException = new ExpectException ( delegate , AssumptionViolatedException . class ) ; try { expectException . evaluate ( ) ;
public void whenExpectingAssumptionViolatedExceptionStatementsPassingShouldFail ( ) throws Exception { ExpectException expectException = new ExpectException ( new PassingStatement ( ) , AssumptionViolatedException . class ) ; try { expectException . evaluate ( ) ; } catch ( AssertionError e ) { assertThat ( e . getMessage ( ) , containsString ( " Expected exception : " + AssumptionViolatedException . class . getName ( ) ) ) ; return ; } fail ( " ExpectException should throw when the given statement passes " ) ; }
public void evaluate ( ) throws Throwable { } } private static class SomeException extends RuntimeException { public SomeException ( String message ) { super ( message ) ; } } private static class AssumptionViolatedExceptionSubclass extends AssumptionViolatedException { public AssumptionViolatedExceptionSubclass ( String assumption ) { super ( assumption ) ; } } }
public void nothing ( ) { } } @ Test public void noneThrown ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( NoneThrown . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; String message = result . getFailures ( ) . get ( 0 ) . getMessage ( ) ; assertTrue ( message . contains ( " Expected exception : java . lang . Exception " ) ) ; } public static class ExpectSuperclass { @ Test ( expected = RuntimeException . class ) public void throwsSubclass ( ) { throw new ClassCastException ( ) ; } } @ Test public void expectsSuperclass ( ) { assertTrue ( new JUnitCore ( ) . run ( ExpectSuperclass . class ) . wasSuccessful ( ) ) ; } public static class ExpectAssumptionViolatedException { @ Test ( expected = AssumptionViolatedException . class ) public void throwsAssumptionViolatedException ( ) { throw new AssumptionViolatedException ( " expected " ) ; } } @ Test public void expectsAssumptionViolatedException ( ) { assertTrue ( new JUnitCore ( ) . run ( ExpectAssumptionViolatedException . class ) . wasSuccessful ( ) ) ; } }
public void throwsAssumptionViolatedException ( ) { throw new AssumptionViolatedException ( " expected " ) ; }
public void expectsAssumptionViolatedException ( ) { assertTrue ( new JUnitCore ( ) . run ( ExpectAssumptionViolatedException . class ) . wasSuccessful ( ) ) ; }
protected void before ( ) throws Throwable { } protected void after ( ) throws Throwable { } }
protected void after ( ) throws Throwable { } }
protected Statement possiblyExpectingExceptions ( FrameworkMethod method , Object test , Statement next ) { Test annotation = method . getAnnotation ( Test . class ) ; Class < ? extends Throwable > expectedExceptionClass = getExpectedException ( annotation ) ; return expectedExceptionClass ! = null ? new ExpectException ( next , expectedExceptionClass ) : next ; }
public void newFolderWithPathStartingWithFileSeparatorThrowsIOException ( ) throws IOException { String fileAtRoot ; File [ ] roots = File . listRoots ( ) ; if ( roots ! = null & & roots . length > 0 ) { fileAtRoot = roots [ 0 ] . getAbsolutePath ( ) + " temp1 " ; } else { fileAtRoot = File . separator + " temp1 " ; } tempFolder . create ( ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " folder path ' " + fileAtRoot + " ' is not a relative path " ) ; tempFolder . newFolder ( fileAtRoot ) ; }
public void evaluate ( ) throws Throwable { List < Throwable > errors = new ArrayList < Throwable > ( ) ; try { next . evaluate ( ) ; } catch ( Throwable e ) { errors . add ( e ) ; } finally { for ( FrameworkMethod each : afters ) { try { invokeMethod ( each ) ; } catch ( Throwable e ) { errors . add ( e ) ; } } } MultipleFailureException . assertEmpty ( errors ) ; }
protected void invokeMethod ( FrameworkMethod method ) throws Throwable { method . invokeExplosively ( target ) ; }
public void evaluate ( ) throws Throwable { for ( FrameworkMethod before : befores ) { invokeMethod ( before ) ; } next . evaluate ( ) ; }
private void validateBeforeParamAndAfterParamMethods ( Integer parameterCount ) throws InvalidTestClassError { List < Throwable > errors = new ArrayList < Throwable > ( ) ; validatePublicStaticVoidMethods ( Parameterized . BeforeParam . class , parameterCount , errors ) ; validatePublicStaticVoidMethods ( Parameterized . AfterParam . class , parameterCount , errors ) ; if ( ! errors . isEmpty ( ) ) { throw new InvalidTestClassError ( getTestClass ( ) . getJavaClass ( ) , errors ) ;
private void validatePublicStaticVoidMethods ( Class < ? extends Annotation > annotation , Integer parameterCount , List < Throwable > errors ) { List < FrameworkMethod > methods = getTestClass ( ) . getAnnotatedMethods ( annotation ) ; for ( FrameworkMethod fm : methods ) { fm . validatePublicVoid ( true , errors ) ;
private List < Runner > createRunners ( ) throws Exception { Parameters parameters = parametersMethod . getAnnotation ( Parameters . class ) ; return Collections . unmodifiableList ( createRunnersForParameters ( allParameters , parameters . name ( ) ,
private TestWithParameters createTestWithNotNormalizedParameters ( String pattern , int index , Object parametersOrSingleParameter ) { Object [ ] parameters = normalizeParameters ( parametersOrSingleParameter ) ; return createTestWithParameters ( testClass , pattern , index , parameters ) ; }
private static Object [ ] normalizeParameters ( Object parametersOrSingleParameter ) { return ( parametersOrSingleParameter instanceof Object [ ] ) ? ( Object [ ] ) parametersOrSingleParameter : new Object [ ] { parametersOrSingleParameter } ;
private static List < Object > allParameters ( TestClass testClass , FrameworkMethod parametersMethod ) throws Throwable { Object parameters = parametersMethod . invokeExplosively ( null ) ; if ( parameters instanceof List ) { return ( List < Object > ) parameters ;
private static FrameworkMethod getParametersMethod ( TestClass testClass ) throws Exception { List < FrameworkMethod > methods = testClass . getAnnotatedMethods ( Parameters . class ) ; for ( FrameworkMethod each : methods ) { if ( each . isStatic ( ) & & each . isPublic ( ) ) { return each ; } } throw new Exception ( " No public static parameters method on class " + testClass . getName ( ) ) ;
private static Exception parametersMethodReturnedWrongType ( TestClass testClass , FrameworkMethod parametersMethod ) throws Exception { String className = testClass . getName ( ) ; String methodName = parametersMethod . getName ( ) ; String message = MessageFormat . format ( " { 0 } . { 1 } ( ) must return an Iterable of arrays . " , className , methodName ) ; return new Exception ( message ) ; }
protected Statement classBlock ( RunNotifier notifier ) { Statement statement = childrenInvoker ( notifier ) ; statement = withBeforeParams ( statement ) ; statement = withAfterParams ( statement ) ; return statement ; }
private Statement withBeforeParams ( Statement statement ) { List < FrameworkMethod > befores = getTestClass ( ) . getAnnotatedMethods ( Parameterized . BeforeParam . class ) ; return befores . isEmpty ( ) ? statement : new RunBeforeParams ( statement , befores ) ; }
protected void invokeMethod ( FrameworkMethod method ) throws Throwable { int paramCount = method . getMethod ( ) . getParameterTypes ( ) . length ; method . invokeExplosively ( null , paramCount = = 0 ? ( Object [ ] ) null : parameters ) ; }
private Statement withAfterParams ( Statement statement ) { List < FrameworkMethod > afters = getTestClass ( ) . getAnnotatedMethods ( Parameterized . AfterParam . class ) ; return afters . isEmpty ( ) ? statement : new RunAfterParams ( statement , afters ) ; }
public static void before ( ) { fLog + = " beforeClass " ; }
public static void beforeParam ( String x ) { fLog + = " before ( " + x + " ) " ; }
public static void afterParam ( ) { fLog + = " afterParam " ; }
public static void after ( ) { fLog + = " afterClass " ; }
public static Collection < String > data ( ) { return Arrays . asList ( " A " , " B " ) ; }
public void first ( ) { fLog + = " first ( " + x + " ) " ; }
public void second ( ) { fLog + = " second ( " + x + " ) " ; }
public void beforeParamAndAfterParamAreRun ( ) { fLog = " " ; Result result = JUnitCore . runClasses ( BeforeParamAndAfterParam . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( " beforeClass before ( A ) first ( A ) second ( A ) afterParam " + " before ( B ) first ( B ) second ( B ) afterParam afterClass " , fLog ) ;
public static void before1 ( ) { fLog + = " before1 ( ) " ; }
public static void before2 ( String x ) { fLog + = " before2 ( " + x + " ) " ; }
public static void after2 ( ) { fLog + = " after2 ( ) " ; }
public static void after1 ( String x ) { fLog + = " after1 ( " + x + " ) " ; }
public void multipleBeforeParamAndAfterParamAreRun ( ) { fLog = " " ; Result result = JUnitCore . runClasses ( MultipleBeforeParamAndAfterParam . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( " before1 ( ) before2 ( A ) first ( A ) second ( A ) after1 ( A ) after2 ( ) " + " before1 ( ) before2 ( B ) first ( B ) second ( B ) after1 ( B ) after2 ( ) " , fLog ) ;
public static void before ( String x , int y ) { fLog + = " before ( " + x + " , " + y + " ) " ; }
public static void after ( String x , int y ) { fLog + = " after ( " + x + " , " + y + " ) " ; }
public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { " A " , 1 } , new Object [ ] { " B " , 2 } ) ; }
public void first ( ) { fLog + = " first ( " + x + " , " + y + " ) " ; }
public void second ( ) { fLog + = " second ( " + x + " , " + y + " ) " ; }
public void multipleParametersBeforeParamAndAfterParamAreRun ( ) { fLog = " " ; Result result = JUnitCore . runClasses ( MultipleParametersBeforeParamAndAfterParam . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( " before ( A , 1 ) first ( A , 1 ) second ( A , 1 ) after ( A , 1 ) " + " before ( B , 2 ) first ( B , 2 ) second ( B , 2 ) after ( B , 2 ) " , fLog ) ;
public void beforeParamAndAfterParamValidation ( ) { fLog = " " ; Result result = JUnitCore . runClasses ( BeforeParamAndAfterParamError . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; List < Failure > failures = result . getFailures ( ) ; assertThat ( failures . get ( 0 ) . getMessage ( ) , containsString ( " beforeParam ( ) should be static " ) ) ; assertThat ( failures . get ( 0 ) . getMessage ( ) , containsString ( " afterParam ( ) should be public " ) ) ; }
public static Collection < String > data ( ) { return Arrays . asList ( " A " , " B " , " C " , " D " ) ; }
public void beforeParamAndAfterParamValidationNumberOfParameters ( ) { fLog = " " ; Result result = JUnitCore . runClasses ( BeforeParamAndAfterParamErrorNumberOfParameters . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; List < Failure > failures = result . getFailures ( ) ; assertThat ( failures . get ( 0 ) . getMessage ( ) , containsString ( " Method beforeParam ( ) should have 0 or 1 parameter ( s ) " ) ) ; assertThat ( failures . get ( 0 ) . getMessage ( ) , containsString ( " Method afterParam ( ) should have 0 or 1 parameter ( s ) " ) ) ;
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersNotPublic ( ) { assertTestCreatesSingleFailureWithMessage ( ProtectedParametersTest . class , " No public static parameters method on class " + ProtectedParametersTest . class . getName ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ParametersNotIterable { @ Parameters public static String data ( ) { return " foo " ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; }
public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; }
public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } }
public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { childrenLock . lock ( ) ; try { List < T > children = new ArrayList < T > ( getFilteredChildren ( ) ) ;
public final boolean isAnyExceptionExpected ( ) { return matcherBuilder . expectsThrowable ( ) ; }
static String format ( String message , Object expected , Object actual ) { String formatted = " " ; if ( message ! = null & & ! " " . equals ( message ) ) { formatted = message + " " ; } String expectedString = String . valueOf ( expected ) ; String actualString = String . valueOf ( actual ) ; if ( equalsRegardingNull ( expectedString , actualString ) ) { return formatted + " expected : "
public String toString ( ) { return null ; }
public void nullToString ( ) { try { assertEquals ( new NullToString ( ) , new NullToString ( ) ) ; } catch ( AssertionError e ) { assertEquals ( " expected : org . junit . tests . assertion . AssertionTest $ NullToString < null > but " + " was : org . junit . tests . assertion . AssertionTest $ NullToString < null > " , e . getMessage ( ) ) ; return ; } fail ( " AssertionError expected " ) ; }
private void assertCompletesNormally ( ) { } @ Test public void assumeTrueWorks ( ) { try { Assume . assumeTrue ( false ) ; fail ( " should throw AssumptionViolatedException " ) ; } catch ( AssumptionViolatedException e ) { } } public static class HasFailingAssumeInBefore { @ Before public void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforePreventsTestRun ( ) { assertThat ( testResult ( HasFailingAssumeInBefore . class ) , isSuccessful ( ) ) ; } public static class HasFailingAssumeInBeforeClass { @ BeforeClass public static void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforeClassIgnoresClass ( ) { assertThat ( testResult ( HasFailingAssumeInBeforeClass . class ) , isSuccessful ( ) ) ; } public static class AssumptionFailureInConstructor { public AssumptionFailureInConstructor ( ) { assumeTrue ( false ) ; } @ Test public void shouldFail ( ) { fail ( ) ; } } @ Test public void failingAssumptionInConstructorIgnoresClass ( ) { assertThat ( testResult ( AssumptionFailureInConstructor . class ) , isSuccessful ( ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void assumeWithExpectedException ( ) { assumeTrue ( false ) ; } final static String message = " Some random message string . " ; final static Throwable e = new Throwable ( ) ; public static class HasAssumeWithMessage { @ Test public void testMethod ( ) { assumeTrue ( message , false ) ; } } @ Test public void assumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessage . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } public static class HasAssumeWithMessageAndCause { @ Test public void testMethod ( ) { assumeNoException ( message , e ) ; } } @ Test public void assumptionsWithMessageAndCause ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessageAndCause . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; assertSame ( failures . get ( 0 ) . getException ( ) . getCause ( ) , e ) ; } public static class HasFailingAssumptionWithMessage { @ Test public void assumptionsFail ( ) { assumeThat ( message , 3 , is ( 4 ) ) ; fail ( ) ; } } @ Test public void failedAssumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasFailingAssumptionWithMessage . class ) ; assertEquals ( 1 , failures . size ( ) ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } private static List < Failure > runAndGetAssumptionFailures ( Class < ? > clazz ) { final List < Failure > failures = new ArrayList < Failure > ( ) ; final JUnitCore core = new JUnitCore ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { failures . add ( failure ) ; } } ) ; core . run ( clazz ) ; return failures ; } }
public void failedAssumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasFailingAssumptionWithMessage . class ) ; assertEquals ( 1 , failures . size ( ) ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; }
public void failWithNoMessageToString ( ) { try { Assert . fail ( ) ; } catch ( AssertionError exception ) { assertEquals ( " java . lang . AssertionError " , exception . toString ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void failWithMessageToString ( ) { try { Assert . fail ( " woops ! " ) ; } catch ( AssertionError exception ) { assertEquals ( " java . lang . AssertionError : woops ! " , exception . toString ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void arraysExpectedNullMessage ( ) { try { assertArrayEquals ( " not equal " , null , new Object [ ] { new Object ( ) } ) ; } catch ( AssertionError exception ) { assertEquals ( " not equal : expected array was null " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void arraysActualNullMessage ( ) { try { assertArrayEquals ( " not equal " , new Object [ ] { new Object ( ) } , null ) ; } catch ( AssertionError exception ) { assertEquals ( " not equal : actual array was null " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
private void assertArrayEqualsFailure ( Object [ ] expecteds , Object [ ] actuals , String expectedMessage ) { try { assertArrayEquals ( expecteds , actuals ) ; } catch ( ArrayComparisonFailure e ) { assertEquals ( expectedMessage , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
private void assertArrayEqualsFailure ( String message , Object [ ] expecteds , Object [ ] actuals , String expectedMessage ) { try { assertArrayEquals ( message , expecteds , actuals ) ; } catch ( ArrayComparisonFailure e ) { assertEquals ( expectedMessage , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void multiDimensionalArraysDifferentLengthMessage ( ) { try { assertArrayEquals ( " message " , new Object [ ] [ ] { { true , true } , { false , false } } , new Object [ ] [ ] { { true , true } , { false } } ) ; } catch ( AssertionError exception ) { assertEquals ( " message : array lengths differed , expected . length = 2 actual . length = 1 ; arrays first differed at element [ 1 ] [ 1 ] ; expected : < false > but was : < end of array > " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void multiDimensionalArraysDifferentLengthNoMessage ( ) { try { assertArrayEquals ( new Object [ ] [ ] { { true , true } , { false , false } } , new Object [ ] [ ] { { true , true } , { false } } ) ; } catch ( AssertionError exception ) { assertEquals ( " array lengths differed , expected . length = 2 actual . length = 1 ; arrays first differed at element [ 1 ] [ 1 ] ; expected : < false > but was : < end of array > " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void stringsDifferWithUserMessage ( ) { try { assertEquals ( " not equal " , " one " , " two " ) ; } catch ( ComparisonFailure exception ) { assertEquals ( " not equal expected : < [ one ] > but was : < [ two ] > " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void notEqualsObjectWithNullWithMessage ( ) { Object o = new Object ( ) ; try { assertEquals ( " message " , null , o ) ; } catch ( AssertionError e ) { assertEquals ( " message expected : < null > but was : < " + o . toString ( ) + " > " , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void notEqualsNullWithObjectWithMessage ( ) { Object o = new Object ( ) ; try { assertEquals ( " message " , o , null ) ; } catch ( AssertionError e ) { assertEquals ( " message expected : < " + o . toString ( ) + " > but was : < null > " , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void nullNullmessage ( ) { try { assertNull ( " junit " ) ; } catch ( AssertionError e ) { assertEquals ( " expected null , but was : < junit > " , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void nullWithMessage ( ) { try { assertNull ( " message " , " hello " ) ; } catch ( AssertionError exception ) { assertEquals ( " message expected null , but was : < hello > " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void sameWithMessage ( ) { try { assertSame ( " not same " , " hello " , " good - bye " ) ; } catch ( AssertionError exception ) { assertEquals ( " not same expected same : < hello > was not : < good - bye > " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void sameNullMessage ( ) { try { assertSame ( " hello " , " good - bye " ) ; } catch ( AssertionError exception ) { assertEquals ( " expected same : < hello > was not : < good - bye > " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void notSameWithMessage ( ) { Object o = new Object ( ) ; try { assertNotSame ( " message " , o , o ) ; } catch ( AssertionError exception ) { assertEquals ( " message expected not same " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void notSameNullMessage ( ) { Object o = new Object ( ) ; try { assertNotSame ( o , o ) ; } catch ( AssertionError exception ) { assertEquals ( " expected not same " , exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void nullMessage ( ) { try { fail ( null ) ; } catch ( AssertionError exception ) { assertNull ( exception . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void nullMessageDisappearsWithStringAssertEquals ( ) { try { assertEquals ( null , " a " , " b " ) ; } catch ( ComparisonFailure e ) { assertEquals ( " expected : < [ a ] > but was : < [ b ] > " , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void nullMessageDisappearsWithAssertEquals ( ) { try { assertEquals ( null , 1 , 2 ) ; } catch ( AssertionError e ) { assertEquals ( " expected : < 1 > but was : < 2 > " , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void errorMessageDistinguishesDifferentValuesWithSameToString ( ) { try { assertEquals ( " 4 " , new Integer ( 4 ) ) ; } catch ( AssertionError e ) { assertEquals ( " expected : java . lang . String < 4 > but was : java . lang . Integer < 4 > " , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThatIncludesDescriptionOfTestedValueInErrorMessage ( ) { String expected = " expected " ; String actual = " actual " ; String expectedMessage = " identifier \ nExpected : \ " expected \ " \ n but : was \ " actual \ " " ; try { assertThat ( " identifier " , actual , equalTo ( expected ) ) ; } catch ( AssertionError e ) { assertEquals ( expectedMessage , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThatIncludesAdvancedMismatch ( ) { String expectedMessage = " identifier \ nExpected : is an instance of java . lang . Integer \ n but : \ " actual \ " is a java . lang . String " ; try { assertThat ( " identifier " , " actual " , is ( instanceOf ( Integer . class ) ) ) ; } catch ( AssertionError e ) { assertEquals ( expectedMessage , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThatDescriptionCanBeElided ( ) { String expected = " expected " ; String actual = " actual " ; String expectedMessage = " \ nExpected : \ " expected \ " \ n but : was \ " actual \ " " ; try { assertThat ( actual , equalTo ( expected ) ) ; } catch ( AssertionError e ) { assertEquals ( expectedMessage , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void nullAndStringNullPrintCorrectError ( ) { try { assertEquals ( null , " null " ) ; } catch ( AssertionError e ) { assertEquals ( " expected : null < null > but was : java . lang . String < null > " , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void nullToString ( ) { try { assertEquals ( new NullToString ( ) , new NullToString ( ) ) ; } catch ( AssertionError e ) { assertEquals ( " expected : org . junit . tests . assertion . AssertionTest $ NullToString < null > but " + " was : org . junit . tests . assertion . AssertionTest $ NullToString < null > " , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertNotEqualsIncludesCorrectMessage ( ) { Integer value1 = new Integer ( 1 ) ; Integer value2 = new Integer ( 1 ) ; String message = " The values should be different " ; try { assertNotEquals ( message , value1 , value2 ) ; } catch ( AssertionError e ) { assertEquals ( message + " . Actual : " + value1 , e . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertNotEqualsIncludesTheValueBeingTested ( ) { Integer value1 = new Integer ( 1 ) ; Integer value2 = new Integer ( 1 ) ; try { assertNotEquals ( value1 , value2 ) ; } catch ( AssertionError e ) { assertTrue ( e . getMessage ( ) . contains ( value1 . toString ( ) ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void expectThrowsIncludesAnInformativeDefaultMessage ( ) { try { expectThrows ( Throwable . class , nonThrowingRunnable ( ) ) ; } catch ( AssertionError ex ) { assertEquals ( " expected java . lang . Throwable to be thrown , but nothing was thrown " , ex . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void expectThrowsWrapsAndPropagatesUnexpectedExceptions ( ) { NullPointerException npe = new NullPointerException ( " inner - message " ) ; try { expectThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError ex ) { assertSame ( npe , ex . getCause ( ) ) ; assertEquals ( " inner - message " , ex . getCause ( ) . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void expectThrowsSuppliesACoherentErrorMessageUponTypeMismatch ( ) { NullPointerException npe = new NullPointerException ( ) ; try { expectThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < java . io . IOException > but was : < java . lang . NullPointerException > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void expectThrowsUsesCanonicalNameUponTypeMismatch ( ) { NullPointerException npe = new NullPointerException ( ) ; try { expectThrows ( NestedException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < org . junit . tests . assertion . AssertionTest . NestedException > " + " but was : < java . lang . NullPointerException > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void expectThrowsUsesNameUponTypeMismatchWithAnonymousClass ( ) { NullPointerException npe = new NullPointerException ( ) { } ; try { expectThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < java . io . IOException > " + " but was : < org . junit . tests . assertion . AssertionTest $ 1 > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void expectThrowsUsesCanonicalNameWhenRequiredExceptionNotThrown ( ) { try { expectThrows ( NestedException . class , nonThrowingRunnable ( ) ) ; } catch ( AssertionError error ) { assertEquals ( " expected org . junit . tests . assertion . AssertionTest . NestedException to be thrown , " + " but nothing was thrown " , error . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public Runner runnerForClass ( Class < ? > testClass ) throws Throwable { return new JUnit4 ( testClass ) ; }
public static < T > T notNull ( T value ) { if ( value = = null ) { throw new NullPointerException ( ) ; } return value ; }
public static < T > T notNull ( T value , String message ) { if ( value = = null ) { throw new NullPointerException ( message ) ; } return value ; }
public void notNullShouldReturnNonNullValues ( ) { Double value = Double . valueOf ( 3 . 14 ) ; Double result = notNull ( value ) ; assertSame ( value , result ) ; }
public void notNullShouldThrowOnNullValues ( ) { try { notNull ( null ) ;
public void notNullWithMessageShouldReturnNonNullValues ( ) { Float value = Float . valueOf ( 3 . 14f ) ; Float result = notNull ( value , " woops " ) ; assertSame ( value , result ) ; }
public void notNullWithMessageShouldThrowOnNullValues ( ) { try { notNull ( null , " woops " ) ;
public void notNullWithNullMessageShouldThrowOnNullValues ( ) { try { notNull ( null , null ) ;
protected void after ( ) { throw new RuntimeException ( " simulating resource1 tear down failure " ) ; }
protected void after ( ) { throw new RuntimeException ( " simulating resource2 tear down failure " ) ; }
public void failingTest ( ) { throw new RuntimeException ( " simulated test failure " ) ; }
private static Method initGetSuppressed ( ) { try { return Throwable . class . getMethod ( " getSuppressed " ) ;
private static boolean hasSuppressed ( Throwable exception ) { if ( getSuppressed = = null ) { return false ; } try { Throwable [ ] suppressed = ( Throwable [ ] ) getSuppressed . invoke ( exception ) ;
public void alwaysPasses ( ) { } } public static class JUnit3TestWithThrowingSetUpMethod extends TestCase { @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; } public void testAlwaysPasses ( ) { } } public static class ThrowingTestRule implements TestRule { public Statement apply ( Statement base , org . junit . runner . Description description ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingTestRule { @ Rule public final TestRule rule = new ThrowingTestRule ( ) ; @ Test public void alwaysPasses ( ) { } } public static class ThrowingMethodRule implements MethodRule { public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingMethodRule { @ Rule public final ThrowingMethodRule rule = new ThrowingMethodRule ( ) ; @ Test public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } public static class TestWithSuppressedException { static final Method addSuppressed = initAddSuppressed ( ) ; static Method initAddSuppressed ( ) { try { return Throwable . class . getMethod ( " addSuppressed " , Throwable . class ) ; } catch ( Throwable e ) { return null ; } } @ Test public void alwaysThrows ( ) throws Exception { final RuntimeException exception = new RuntimeException ( " error " ) ; addSuppressed . invoke ( exception , new RuntimeException ( " suppressed " ) ) ; throw exception ; } } }
public void testAlwaysPasses ( ) { } } public static class ThrowingTestRule implements TestRule { public Statement apply ( Statement base , org . junit . runner . Description description ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingTestRule { @ Rule public final TestRule rule = new ThrowingTestRule ( ) ; @ Test public void alwaysPasses ( ) { } } public static class ThrowingMethodRule implements MethodRule { public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingMethodRule { @ Rule public final ThrowingMethodRule rule = new ThrowingMethodRule ( ) ; @ Test public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } public static class TestWithSuppressedException { static final Method addSuppressed = initAddSuppressed ( ) ; static Method initAddSuppressed ( ) { try { return Throwable . class . getMethod ( " addSuppressed " , Throwable . class ) ; } catch ( Throwable e ) { return null ; } } @ Test public void alwaysThrows ( ) throws Exception { final RuntimeException exception = new RuntimeException ( " error " ) ; addSuppressed . invoke ( exception , new RuntimeException ( " suppressed " ) ) ; throw exception ; } } }
public void alwaysPasses ( ) { } } public static class ThrowingMethodRule implements MethodRule { public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingMethodRule { @ Rule public final ThrowingMethodRule rule = new ThrowingMethodRule ( ) ; @ Test public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } public static class TestWithSuppressedException { static final Method addSuppressed = initAddSuppressed ( ) ; static Method initAddSuppressed ( ) { try { return Throwable . class . getMethod ( " addSuppressed " , Throwable . class ) ; } catch ( Throwable e ) { return null ; } } @ Test public void alwaysThrows ( ) throws Exception { final RuntimeException exception = new RuntimeException ( " error " ) ; addSuppressed . invoke ( exception , new RuntimeException ( " suppressed " ) ) ; throw exception ; } } }
public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } public static class TestWithSuppressedException { static final Method addSuppressed = initAddSuppressed ( ) ; static Method initAddSuppressed ( ) { try { return Throwable . class . getMethod ( " addSuppressed " , Throwable . class ) ; } catch ( Throwable e ) { return null ; } } @ Test public void alwaysThrows ( ) throws Exception { final RuntimeException exception = new RuntimeException ( " error " ) ; addSuppressed . invoke ( exception , new RuntimeException ( " suppressed " ) ) ; throw exception ; } } }
static Method initAddSuppressed ( ) { try { return Throwable . class . getMethod ( " addSuppressed " , Throwable . class ) ;
public void alwaysThrows ( ) throws Exception { final RuntimeException exception = new RuntimeException ( " error " ) ; addSuppressed . invoke ( exception , new RuntimeException ( " suppressed " ) ) ; throw exception ; }
public void evaluate ( ) throws Throwable { methodBlock ( method ) . evaluate ( ) ; }
public void test ( ) { } } } @ Test public void detectNonStaticEnclosedClass ( ) throws Exception { try { new BlockJUnit4ClassRunner ( OuterClass . Enclosed . class ) ; } catch ( InitializationError e ) { List < Throwable > causes = e . getCauses ( ) ; assertEquals ( " Wrong number of causes . " , 1 , causes . size ( ) ) ; assertEquals ( " Wrong exception . " , " The inner class org . junit . tests . running . classes . BlockJUnit4ClassRunnerTest $ OuterClass $ Enclosed is not static . " , causes . get ( 0 ) . getMessage ( ) ) ; } } private static String log ; public static class MethodBlockAfterFireTestStarted { public MethodBlockAfterFireTestStarted ( ) { log + = " init " ; } @ Test public void test ( ) { log + = " test " ; } } @ Test public void methodBlockAfterFireTestStarted ( ) { log = " " ; JUnitCore junit = new JUnitCore ( ) ; junit . addListener ( new RunListener ( ) { @ Override public void testStarted ( Description description ) throws Exception { log + = " testStarted ( " + description . getMethodName ( ) + " ) " ; } @ Override public void testFinished ( Description description ) throws Exception { log + = " testFinished ( " + description . getMethodName ( ) + " ) " ; } } ) ; junit . run ( MethodBlockAfterFireTestStarted . class ) ; assertEquals ( " testStarted ( test ) init test testFinished ( test ) " , log ) ; } }
public void test ( ) { log + = " test " ; }
public void methodBlockAfterFireTestStarted ( ) { log = " " ; JUnitCore junit = new JUnitCore ( ) ; junit . addListener ( new RunListener ( ) { @ Override public void testStarted ( Description description ) throws Exception { log + = " testStarted ( " + description . getMethodName ( ) + " ) " ; } @ Override public void testFinished ( Description description ) throws Exception { log + = " testFinished ( " + description . getMethodName ( ) + " ) " ; } } ) ; junit . run ( MethodBlockAfterFireTestStarted . class ) ; assertEquals ( " testStarted ( test ) init test testFinished ( test ) " , log ) ; }
public void testStarted ( Description description ) throws Exception { log + = " testStarted ( " + description . getMethodName ( ) + " ) " ; }
public void testFinished ( Description description ) throws Exception { log + = " testFinished ( " + description . getMethodName ( ) + " ) " ; }
public void run ( RunNotifier notifier ) { notifier . fireTestAssumptionFailed ( new Failure ( description , exception ) ) ; }
private List < Runner > createRunners ( ) throws Exception { if ( runnerOverride ! = null ) { return Collections . singletonList ( runnerOverride ) ; } Parameters parameters = parametersMethod . getAnnotation ( Parameters . class ) ; return Collections . unmodifiableList ( createRunnersForParameters ( allParameters , parameters . name ( ) ,
public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedAssumtionViolation { static boolean condition ; @ Parameters public static Iterable < String > data ( ) { assumeTrue ( condition ) ; return Collections . singletonList ( " foobar " ) ; } public ParameterizedAssumtionViolation ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void assumtionViolationInParameters ( ) { ParameterizedAssumtionViolation . condition = true ; Result successResult = JUnitCore . runClasses ( ParameterizedAssumtionViolation . class ) ; assertTrue ( successResult . wasSuccessful ( ) ) ; assertEquals ( 2 , successResult . getRunCount ( ) ) ; ParameterizedAssumtionViolation . condition = false ; JUnitCore core = new JUnitCore ( ) ; final List < Failure > assumptionFailures = new ArrayList < Failure > ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; } } ) ; Result failureResult = core . run ( ParameterizedAssumtionViolation . class ) ; assertTrue ( failureResult . wasSuccessful ( ) ) ; assertEquals ( 0 , failureResult . getRunCount ( ) ) ; assertEquals ( 0 , failureResult . getIgnoreCount ( ) ) ; assertEquals ( 1 , assumptionFailures . size ( ) ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedAssumtionViolation { static boolean condition ; @ Parameters public static Iterable < String > data ( ) { assumeTrue ( condition ) ; return Collections . singletonList ( " foobar " ) ; } public ParameterizedAssumtionViolation ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void assumtionViolationInParameters ( ) { ParameterizedAssumtionViolation . condition = true ; Result successResult = JUnitCore . runClasses ( ParameterizedAssumtionViolation . class ) ; assertTrue ( successResult . wasSuccessful ( ) ) ; assertEquals ( 2 , successResult . getRunCount ( ) ) ; ParameterizedAssumtionViolation . condition = false ; JUnitCore core = new JUnitCore ( ) ; final List < Failure > assumptionFailures = new ArrayList < Failure > ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; } } ) ; Result failureResult = core . run ( ParameterizedAssumtionViolation . class ) ; assertTrue ( failureResult . wasSuccessful ( ) ) ; assertEquals ( 0 , failureResult . getRunCount ( ) ) ; assertEquals ( 0 , failureResult . getIgnoreCount ( ) ) ; assertEquals ( 1 , assumptionFailures . size ( ) ) ; } }
public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedAssumtionViolation { static boolean condition ; @ Parameters public static Iterable < String > data ( ) { assumeTrue ( condition ) ; return Collections . singletonList ( " foobar " ) ; } public ParameterizedAssumtionViolation ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void assumtionViolationInParameters ( ) { ParameterizedAssumtionViolation . condition = true ; Result successResult = JUnitCore . runClasses ( ParameterizedAssumtionViolation . class ) ; assertTrue ( successResult . wasSuccessful ( ) ) ; assertEquals ( 2 , successResult . getRunCount ( ) ) ; ParameterizedAssumtionViolation . condition = false ; JUnitCore core = new JUnitCore ( ) ; final List < Failure > assumptionFailures = new ArrayList < Failure > ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; } } ) ; Result failureResult = core . run ( ParameterizedAssumtionViolation . class ) ; assertTrue ( failureResult . wasSuccessful ( ) ) ; assertEquals ( 0 , failureResult . getRunCount ( ) ) ; assertEquals ( 0 , failureResult . getIgnoreCount ( ) ) ; assertEquals ( 1 , assumptionFailures . size ( ) ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedAssumtionViolation { static boolean condition ; @ Parameters public static Iterable < String > data ( ) { assumeTrue ( condition ) ; return Collections . singletonList ( " foobar " ) ; } public ParameterizedAssumtionViolation ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void assumtionViolationInParameters ( ) { ParameterizedAssumtionViolation . condition = true ; Result successResult = JUnitCore . runClasses ( ParameterizedAssumtionViolation . class ) ; assertTrue ( successResult . wasSuccessful ( ) ) ; assertEquals ( 2 , successResult . getRunCount ( ) ) ; ParameterizedAssumtionViolation . condition = false ; JUnitCore core = new JUnitCore ( ) ; final List < Failure > assumptionFailures = new ArrayList < Failure > ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; } } ) ; Result failureResult = core . run ( ParameterizedAssumtionViolation . class ) ; assertTrue ( failureResult . wasSuccessful ( ) ) ; assertEquals ( 0 , failureResult . getRunCount ( ) ) ; assertEquals ( 0 , failureResult . getIgnoreCount ( ) ) ; assertEquals ( 1 , assumptionFailures . size ( ) ) ; } }
public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedAssumtionViolation { static boolean condition ; @ Parameters public static Iterable < String > data ( ) { assumeTrue ( condition ) ; return Collections . singletonList ( " foobar " ) ; } public ParameterizedAssumtionViolation ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void assumtionViolationInParameters ( ) { ParameterizedAssumtionViolation . condition = true ; Result successResult = JUnitCore . runClasses ( ParameterizedAssumtionViolation . class ) ; assertTrue ( successResult . wasSuccessful ( ) ) ; assertEquals ( 2 , successResult . getRunCount ( ) ) ; ParameterizedAssumtionViolation . condition = false ; JUnitCore core = new JUnitCore ( ) ; final List < Failure > assumptionFailures = new ArrayList < Failure > ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; } } ) ; Result failureResult = core . run ( ParameterizedAssumtionViolation . class ) ; assertTrue ( failureResult . wasSuccessful ( ) ) ; assertEquals ( 0 , failureResult . getRunCount ( ) ) ; assertEquals ( 0 , failureResult . getIgnoreCount ( ) ) ; assertEquals ( 1 , assumptionFailures . size ( ) ) ; } }
public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedAssumtionViolation { static boolean condition ; @ Parameters public static Iterable < String > data ( ) { assumeTrue ( condition ) ; return Collections . singletonList ( " foobar " ) ; } public ParameterizedAssumtionViolation ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void assumtionViolationInParameters ( ) { ParameterizedAssumtionViolation . condition = true ; Result successResult = JUnitCore . runClasses ( ParameterizedAssumtionViolation . class ) ; assertTrue ( successResult . wasSuccessful ( ) ) ; assertEquals ( 2 , successResult . getRunCount ( ) ) ; ParameterizedAssumtionViolation . condition = false ; JUnitCore core = new JUnitCore ( ) ; final List < Failure > assumptionFailures = new ArrayList < Failure > ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; } } ) ; Result failureResult = core . run ( ParameterizedAssumtionViolation . class ) ; assertTrue ( failureResult . wasSuccessful ( ) ) ; assertEquals ( 0 , failureResult . getRunCount ( ) ) ; assertEquals ( 0 , failureResult . getIgnoreCount ( ) ) ; assertEquals ( 1 , assumptionFailures . size ( ) ) ; } }
public static Iterable < String > data ( ) { assumeTrue ( condition ) ; return Collections . singletonList ( " foobar " ) ; }
public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void assumtionViolationInParameters ( ) { ParameterizedAssumtionViolation . condition = true ; Result successResult = JUnitCore . runClasses ( ParameterizedAssumtionViolation . class ) ; assertTrue ( successResult . wasSuccessful ( ) ) ; assertEquals ( 2 , successResult . getRunCount ( ) ) ; ParameterizedAssumtionViolation . condition = false ; JUnitCore core = new JUnitCore ( ) ; final List < Failure > assumptionFailures = new ArrayList < Failure > ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; } } ) ; Result failureResult = core . run ( ParameterizedAssumtionViolation . class ) ; assertTrue ( failureResult . wasSuccessful ( ) ) ; assertEquals ( 0 , failureResult . getRunCount ( ) ) ; assertEquals ( 0 , failureResult . getIgnoreCount ( ) ) ; assertEquals ( 1 , assumptionFailures . size ( ) ) ; } }
public void test2 ( ) { } } @ Test public void assumtionViolationInParameters ( ) { ParameterizedAssumtionViolation . condition = true ; Result successResult = JUnitCore . runClasses ( ParameterizedAssumtionViolation . class ) ; assertTrue ( successResult . wasSuccessful ( ) ) ; assertEquals ( 2 , successResult . getRunCount ( ) ) ; ParameterizedAssumtionViolation . condition = false ; JUnitCore core = new JUnitCore ( ) ; final List < Failure > assumptionFailures = new ArrayList < Failure > ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; } } ) ; Result failureResult = core . run ( ParameterizedAssumtionViolation . class ) ; assertTrue ( failureResult . wasSuccessful ( ) ) ; assertEquals ( 0 , failureResult . getRunCount ( ) ) ; assertEquals ( 0 , failureResult . getIgnoreCount ( ) ) ; assertEquals ( 1 , assumptionFailures . size ( ) ) ; } }
public void assumtionViolationInParameters ( ) { ParameterizedAssumtionViolation . condition = true ; Result successResult = JUnitCore . runClasses ( ParameterizedAssumtionViolation . class ) ; assertTrue ( successResult . wasSuccessful ( ) ) ; assertEquals ( 2 , successResult . getRunCount ( ) ) ; ParameterizedAssumtionViolation . condition = false ; JUnitCore core = new JUnitCore ( ) ; final List < Failure > assumptionFailures = new ArrayList < Failure > ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; } } ) ; Result failureResult = core . run ( ParameterizedAssumtionViolation . class ) ; assertTrue ( failureResult . wasSuccessful ( ) ) ; assertEquals ( 0 , failureResult . getRunCount ( ) ) ; assertEquals ( 0 , failureResult . getIgnoreCount ( ) ) ; assertEquals ( 1 , assumptionFailures . size ( ) ) ; }
public void testAssumptionFailure ( Failure failure ) { assumptionFailures . add ( failure ) ; }
private Object createTestUsingFieldInjection ( ) throws Exception { List < FrameworkField > annotatedFieldsByParameter = getAnnotatedFieldsByParameter ( ) ; if ( annotatedFieldsByParameter . size ( ) ! = parameters . length ) { throw new Exception ( " Wrong number of parameters and @ Parameter fields . " + " @ Parameter fields counted : " + annotatedFieldsByParameter . size ( ) + " , available parameters : " + parameters . length + " . " ) ; } Object testClassInstance = getTestClass ( ) . getJavaClass ( ) . newInstance ( ) ; for ( FrameworkField each : annotatedFieldsByParameter ) { Field field = each . getField ( ) ; Parameter annotation = field . getAnnotation ( Parameter . class ) ; int index = annotation . value ( ) ; try { field . set ( testClassInstance , parameters [ index ] ) ; } catch ( IllegalAccessException e ) { IllegalAccessException wrappedException = new IllegalAccessException ( " Cannot set parameter ' " + field . getName ( ) + " ' . Ensure that the field ' " + field . getName ( ) + " ' is public . " ) ; wrappedException . initCause ( e ) ; throw wrappedException ; } catch ( IllegalArgumentException iare ) { throw new Exception ( getTestClass ( ) . getName ( ) + " : Trying to set " + field . getName ( ) + " with the value " + parameters [ index ] + " that is not the right type ( " + parameters [ index ] . getClass ( ) . getSimpleName ( ) + " instead of " + field . getType ( ) . getSimpleName ( ) + " ) . " , iare ) ; } } return testClassInstance ; }
public void dummyTest ( ) { } } @ Test public void hasAllAnnotationsExceptRunWith ( ) throws Exception { TestWithParameters testWithParameters = new TestWithParameters ( " dummy name " , new TestClass ( ClassWithParameterizedAnnotation . class ) , NO_PARAMETERS ) ; BlockJUnit4ClassRunnerWithParameters runner = new BlockJUnit4ClassRunnerWithParameters ( testWithParameters ) ; Annotation [ ] annotations = runner . getRunnerAnnotations ( ) ; assertEquals ( 1 , annotations . length ) ; assertEquals ( annotations [ 0 ] . annotationType ( ) , DummyAnnotation . class ) ; } @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . TYPE ) private static @ interface DummyAnnotation { } @ RunWith ( Parameterized . class ) public static class ClassWithPrivateParameter { @ Parameterized . Parameter private String parameter ; @ Test public void dummyTest ( ) { } } @ Test public void providesHelpfulMessageIfParameterFieldCannotBeSet ( ) throws Exception { TestWithParameters testWithParameters = new TestWithParameters ( " dummy name " , new TestClass ( ClassWithPrivateParameter . class ) , Collections . < Object > singletonList ( " dummy parameter " ) ) ; BlockJUnit4ClassRunnerWithParameters runner = new BlockJUnit4ClassRunnerWithParameters ( testWithParameters ) ; thrown . expect ( IllegalAccessException . class ) ; thrown . expectCause ( instanceOf ( IllegalAccessException . class ) ) ; thrown . expectMessage ( " Cannot set parameter ' parameter ' . Ensure that the field ' parameter ' is public . " ) ; runner . createTest ( ) ; } }
public void dummyTest ( ) { } } @ Test public void providesHelpfulMessageIfParameterFieldCannotBeSet ( ) throws Exception { TestWithParameters testWithParameters = new TestWithParameters ( " dummy name " , new TestClass ( ClassWithPrivateParameter . class ) , Collections . < Object > singletonList ( " dummy parameter " ) ) ; BlockJUnit4ClassRunnerWithParameters runner = new BlockJUnit4ClassRunnerWithParameters ( testWithParameters ) ; thrown . expect ( IllegalAccessException . class ) ; thrown . expectCause ( instanceOf ( IllegalAccessException . class ) ) ; thrown . expectMessage ( " Cannot set parameter ' parameter ' . Ensure that the field ' parameter ' is public . " ) ; runner . createTest ( ) ; } }
public void providesHelpfulMessageIfParameterFieldCannotBeSet ( ) throws Exception { TestWithParameters testWithParameters = new TestWithParameters ( " dummy name " , new TestClass ( ClassWithPrivateParameter . class ) , Collections . < Object > singletonList ( " dummy parameter " ) ) ; BlockJUnit4ClassRunnerWithParameters runner = new BlockJUnit4ClassRunnerWithParameters ( testWithParameters ) ; thrown . expect ( IllegalAccessException . class ) ; thrown . expectCause ( instanceOf ( IllegalAccessException . class ) ) ; thrown . expectMessage ( " Cannot set parameter ' parameter ' . Ensure that the field ' parameter ' is public . " ) ; runner . createTest ( ) ; }
public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override
public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; }
public void ruleIsIntroducedAndEvaluated ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( ExampleTest . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; }
public void ruleIsIntroducedAndEvaluatedOnSubclass ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( SonOfExampleTest . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; }
public void ruleIsIntroducedAndEvaluatedOnSubclassOfNonPublicClass ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( SonOfNonPublicExampleTest . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; }
public void nothing ( ) { } } @ Test public void multipleRulesAreRun ( ) { runCount = 0 ; assertThat ( testResult ( MultipleRuleTest . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class NoRulesTest { public int x ; @ Test public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { assertThat ( testResult ( NoRulesTest . class ) , isSuccessful ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; assertThat ( testResult ( OnFailureTest . class ) , failureCountIs ( 1 ) ) ; assertEquals ( " nothing AssertionError " , log ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; assertThat ( testResult ( WatchmanTest . class ) , failureCountIs ( 1 ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; assertThat ( testResult ( BeforesAndAfters . class ) , isSuccessful ( ) ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void multipleRulesAreRun ( ) { runCount = 0 ; assertThat ( testResult ( MultipleRuleTest . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; }
public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { assertThat ( testResult ( NoRulesTest . class ) , isSuccessful ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; assertThat ( testResult ( OnFailureTest . class ) , failureCountIs ( 1 ) ) ; assertEquals ( " nothing AssertionError " , log ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; assertThat ( testResult ( WatchmanTest . class ) , failureCountIs ( 1 ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; assertThat ( testResult ( BeforesAndAfters . class ) , isSuccessful ( ) ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void ignoreNonRules ( ) { assertThat ( testResult ( NoRulesTest . class ) , isSuccessful ( ) ) ; }
public void onFailure ( ) { log = " " ; assertThat ( testResult ( OnFailureTest . class ) , failureCountIs ( 1 ) ) ; assertEquals ( " nothing AssertionError " , log ) ; }
public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; assertThat ( testResult ( WatchmanTest . class ) , failureCountIs ( 1 ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; assertThat ( testResult ( BeforesAndAfters . class ) , isSuccessful ( ) ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void succeeded ( ) { WatchmanTest . watchedLog = " " ; assertThat ( testResult ( WatchmanTest . class ) , failureCountIs ( 1 ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; }
public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; assertThat ( testResult ( BeforesAndAfters . class ) , isSuccessful ( ) ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; }
public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; }
public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; }
public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; }
public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; }
public void pass ( ) { } } public static class TestB { @ Test public void fail ( ) { Assert . fail ( ) ; } } @ RunWith ( Suite . class ) @ SuiteClasses ( { TestA . class , TestB . class } ) public static class All { } @ RunWith ( Suite . class ) @ SuiteClasses ( TestA . class ) static class NonPublicSuite { } @ RunWith ( Suite . class ) @ SuiteClasses ( TestA . class ) static class NonPublicSuiteWithBeforeClass { @ BeforeClass public static void doesNothing ( ) { } } public static class InheritsAll extends All { } @ Test public void ensureTestIsRun ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( All . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void ensureInheritedTestIsRun ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InheritsAll . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void suiteTestCountIsCorrect ( ) throws Exception { Runner runner = Request . aClass ( All . class ) . getRunner ( ) ; assertEquals ( 2 , runner . testCount ( ) ) ; } @ Test public void suiteClassDoesNotNeedToBePublic ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( NonPublicSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } @ Test public void nonPublicSuiteClassWithBeforeClassPasses ( ) { assertThat ( testResult ( NonPublicSuiteWithBeforeClass . class ) , isSuccessful ( ) ) ; } @ Test public void ensureSuitesWorkWithForwardCompatibility ( ) { junit . framework . Test test = new JUnit4TestAdapter ( All . class ) ; TestResult result = new TestResult ( ) ; test . run ( result ) ; assertEquals ( 2 , result . runCount ( ) ) ; } @ Test public void forwardCompatibilityWorksWithGetTests ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( All . class ) ; List < ? extends junit . framework . Test > tests = adapter . getTests ( ) ; assertEquals ( 2 , tests . size ( ) ) ; } @ Test public void forwardCompatibilityWorksWithTestCount ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( All . class ) ; assertEquals ( 2 , adapter . countTestCases ( ) ) ; } private static String log = " " ; @ RunWith ( Suite . class ) @ SuiteClasses ( { TestA . class , TestB . class } ) public static class AllWithBeforeAndAfterClass { @ BeforeClass public static void before ( ) { log + = " before " ; } @ AfterClass public static void after ( ) { log + = " after " ; } } @ Test public void beforeAndAfterClassRunOnSuite ( ) { log = " " ; JUnitCore . runClasses ( AllWithBeforeAndAfterClass . class ) ; assertEquals ( " before after " , log ) ; } @ RunWith ( Suite . class ) public static class AllWithOutAnnotation { } @ Test public void withoutSuiteClassAnnotationProducesFailure ( ) { Result result = JUnitCore . runClasses ( AllWithOutAnnotation . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; String expected = String . format ( " class ' % s ' must have a SuiteClasses annotation " , AllWithOutAnnotation . class . getName ( ) ) ; assertEquals ( expected , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( InfiniteLoop . class ) static public class InfiniteLoop { } @ Test public void whatHappensWhenASuiteHasACycle ( ) { Result result = JUnitCore . runClasses ( InfiniteLoop . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { BiInfiniteLoop . class , BiInfiniteLoop . class } ) static public class BiInfiniteLoop { } @ Test public void whatHappensWhenASuiteHasAForkingCycle ( ) { Result result = JUnitCore . runClasses ( BiInfiniteLoop . class ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { Hercules . class } ) static public class Hydra { } @ RunWith ( Suite . class ) @ SuiteClasses ( { Hydra . class , Hydra . class } ) static public class Hercules { } @ Test public void whatHappensWhenASuiteContainsItselfIndirectly ( ) { Result result = JUnitCore . runClasses ( Hydra . class ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { } ) public class WithoutDefaultConstructor { public WithoutDefaultConstructor ( int i ) { } } @ Test public void suiteShouldBeOKwithNonDefaultConstructor ( ) throws Exception { Result result = JUnitCore . runClasses ( WithoutDefaultConstructor . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) public class NoSuiteClassesAnnotation { } @ Test public void suiteShouldComplainAboutNoSuiteClassesAnnotation ( ) { assertThat ( testResult ( NoSuiteClassesAnnotation . class ) , hasSingleFailureContaining ( " SuiteClasses " ) ) ; } }
public static void doesNothing ( ) { } } public static class InheritsAll extends All { } @ Test public void ensureTestIsRun ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( All . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void ensureInheritedTestIsRun ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InheritsAll . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void suiteTestCountIsCorrect ( ) throws Exception { Runner runner = Request . aClass ( All . class ) . getRunner ( ) ; assertEquals ( 2 , runner . testCount ( ) ) ; } @ Test public void suiteClassDoesNotNeedToBePublic ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( NonPublicSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } @ Test public void nonPublicSuiteClassWithBeforeClassPasses ( ) { assertThat ( testResult ( NonPublicSuiteWithBeforeClass . class ) , isSuccessful ( ) ) ; } @ Test public void ensureSuitesWorkWithForwardCompatibility ( ) { junit . framework . Test test = new JUnit4TestAdapter ( All . class ) ; TestResult result = new TestResult ( ) ; test . run ( result ) ; assertEquals ( 2 , result . runCount ( ) ) ; } @ Test public void forwardCompatibilityWorksWithGetTests ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( All . class ) ; List < ? extends junit . framework . Test > tests = adapter . getTests ( ) ; assertEquals ( 2 , tests . size ( ) ) ; } @ Test public void forwardCompatibilityWorksWithTestCount ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( All . class ) ; assertEquals ( 2 , adapter . countTestCases ( ) ) ; } private static String log = " " ; @ RunWith ( Suite . class ) @ SuiteClasses ( { TestA . class , TestB . class } ) public static class AllWithBeforeAndAfterClass { @ BeforeClass public static void before ( ) { log + = " before " ; } @ AfterClass public static void after ( ) { log + = " after " ; } } @ Test public void beforeAndAfterClassRunOnSuite ( ) { log = " " ; JUnitCore . runClasses ( AllWithBeforeAndAfterClass . class ) ; assertEquals ( " before after " , log ) ; } @ RunWith ( Suite . class ) public static class AllWithOutAnnotation { } @ Test public void withoutSuiteClassAnnotationProducesFailure ( ) { Result result = JUnitCore . runClasses ( AllWithOutAnnotation . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; String expected = String . format ( " class ' % s ' must have a SuiteClasses annotation " , AllWithOutAnnotation . class . getName ( ) ) ; assertEquals ( expected , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( InfiniteLoop . class ) static public class InfiniteLoop { } @ Test public void whatHappensWhenASuiteHasACycle ( ) { Result result = JUnitCore . runClasses ( InfiniteLoop . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { BiInfiniteLoop . class , BiInfiniteLoop . class } ) static public class BiInfiniteLoop { } @ Test public void whatHappensWhenASuiteHasAForkingCycle ( ) { Result result = JUnitCore . runClasses ( BiInfiniteLoop . class ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { Hercules . class } ) static public class Hydra { } @ RunWith ( Suite . class ) @ SuiteClasses ( { Hydra . class , Hydra . class } ) static public class Hercules { } @ Test public void whatHappensWhenASuiteContainsItselfIndirectly ( ) { Result result = JUnitCore . runClasses ( Hydra . class ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { } ) public class WithoutDefaultConstructor { public WithoutDefaultConstructor ( int i ) { } } @ Test public void suiteShouldBeOKwithNonDefaultConstructor ( ) throws Exception { Result result = JUnitCore . runClasses ( WithoutDefaultConstructor . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) public class NoSuiteClassesAnnotation { } @ Test public void suiteShouldComplainAboutNoSuiteClassesAnnotation ( ) { assertThat ( testResult ( NoSuiteClassesAnnotation . class ) , hasSingleFailureContaining ( " SuiteClasses " ) ) ; } }
public void nonPublicSuiteClassWithBeforeClassPasses ( ) { assertThat ( testResult ( NonPublicSuiteWithBeforeClass . class ) , isSuccessful ( ) ) ; }
protected abstract State processLine ( String methodName ) ; public final State processStackTraceElement ( StackTraceElement element ) { return processLine ( element . getClassName ( ) + " . " + element . getMethodName ( ) + " ( ) " ) ; } } private static final String [ ] TEST_FRAMEWORK_METHOD_NAME_PREFIXES = { " org . junit . runner . " , " org . junit . runners . " , " org . junit . experimental . runners . " , " org . junit . internal . " , " junit . " , } ; private static final String [ ] TEST_FRAMEWORK_TEST_METHOD_NAME_PREFIXES = { " org . junit . internal . StackTracesTest " , } ; private static boolean isTestFrameworkMethod ( String methodName ) { return isMatchingMethod ( methodName , TEST_FRAMEWORK_METHOD_NAME_PREFIXES ) & & ! isMatchingMethod ( methodName , TEST_FRAMEWORK_TEST_METHOD_NAME_PREFIXES ) ; } private static final String [ ] REFLECTION_METHOD_NAME_PREFIXES = { " sun . reflect . " , " java . lang . reflect . " , " org . junit . rules . RunRules . < init > ( " , " org . junit . rules . RunRules . applyAll ( " , " org . junit . runners . RuleContainer . apply ( " , " junit . framework . TestCase . runBare ( " , } ; private static boolean isReflectionMethod ( String methodName ) { return isMatchingMethod ( methodName , REFLECTION_METHOD_NAME_PREFIXES ) ; } private static boolean isMatchingMethod ( String methodName , String [ ] methodNamePrefixes ) { for ( String methodNamePrefix : methodNamePrefixes ) { if ( methodName . startsWith ( methodNamePrefix ) ) { return true ; } } return false ; } }
private Statement withRules ( FrameworkMethod method , Object target , Statement statement ) { RuleContainer ruleContainer = new RuleContainer ( ) ; CURRENT_RULE_CONTAINER . set ( ruleContainer ) ; try { List < TestRule > testRules = getTestRules ( target ) ; for ( MethodRule each : rules ( target ) ) { if ( ! ( each instanceof TestRule & & testRules . contains ( each ) ) ) { ruleContainer . add ( each ) ; } } for ( TestRule rule : testRules ) { ruleContainer . add ( rule ) ; } } finally { CURRENT_RULE_CONTAINER . remove ( ) ; } return ruleContainer . apply ( method , describeChild ( method ) , target , statement ) ; }
protected List < MethodRule > rules ( Object target ) { RuleCollector < MethodRule > collector = new RuleCollector < MethodRule > ( ) ; getTestClass ( ) . collectAnnotatedMethodValues ( target , Rule . class , MethodRule . class , collector ) ; getTestClass ( ) . collectAnnotatedFieldValues ( target , Rule . class , MethodRule . class , collector ) ; return collector . result ; }
public void accept ( FrameworkMember member , T value ) { Rule rule = member . getAnnotation ( Rule . class ) ; if ( rule ! = null ) { RuleContainer container = CURRENT_RULE_CONTAINER . get ( ) ; if ( container ! = null ) { container . setOrder ( value , rule . order ( ) ) ; } } result . add ( value ) ; }
protected List < TestRule > classRules ( ) { ClassRuleCollector collector = new ClassRuleCollector ( ) ; testClass . collectAnnotatedMethodValues ( null , ClassRule . class , TestRule . class , collector ) ; testClass . collectAnnotatedFieldValues ( null , ClassRule . class , TestRule . class , collector ) ; return collector . getOrderedRules ( ) ; }
public void accept ( FrameworkMember member , TestRule value ) { ClassRule rule = member . getAnnotation ( ClassRule . class ) ; entries . add ( new RuleContainer . RuleEntry ( value , RuleContainer . RuleEntry . TYPE_TEST_RULE , rule ! = null ? rule . order ( ) : null ) ) ;
public void add ( MethodRule methodRule ) { methodRules . add ( methodRule ) ; }
public void add ( TestRule testRule ) { testRules . add ( testRule ) ; }
public int compare ( RuleEntry o1 , RuleEntry o2 ) { int result = compareInt ( o1 . order , o2 . order ) ; return result ! = 0 ? result : o1 . type - o2 . type ; }
private int compareInt ( int a , int b ) { return ( a < b ) ? 1 : ( a = = b ? 0 : - 1 ) ; }
public < T > List < T > getAnnotatedFieldValues ( Object test , Class < ? extends Annotation > annotationClass , Class < T > valueClass ) { final List < T > results = new ArrayList < T > ( ) ; collectAnnotatedFieldValues ( test , annotationClass , valueClass , new MemberValueConsumer < T > ( ) { public void accept ( FrameworkMember member , T value ) { results . add ( value ) ; } } ) ; return results ; }
public void accept ( FrameworkMember member , T value ) { results . add ( value ) ; }
public < T > List < T > getAnnotatedMethodValues ( Object test , Class < ? extends Annotation > annotationClass , Class < T > valueClass ) { final List < T > results = new ArrayList < T > ( ) ; collectAnnotatedMethodValues ( test , annotationClass , valueClass , new MemberValueConsumer < T > ( ) { public void accept ( FrameworkMember member , T value ) { results . add ( value ) ; } } ) ; return results ; }
public void alwaysPasses ( ) { } } public static class JUnit3TestWithThrowingSetUpMethod extends TestCase { @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; } public void testAlwaysPasses ( ) { } } public static class ThrowingTestRule implements TestRule { public Statement apply ( Statement base , org . junit . runner . Description description ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingTestRule { @ Rule public final TestRule rule = new ThrowingTestRule ( ) ; @ Test public void alwaysPasses ( ) { } } public static class TestWithThrowingClassRule { @ ClassRule public static final TestRule rule = new ThrowingTestRule ( ) ; @ Test public void alwaysPasses ( ) { } } public static class ThrowingMethodRule implements MethodRule { public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingMethodRule { @ Rule public final ThrowingMethodRule rule = new ThrowingMethodRule ( ) ; @ Test public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } public static class TestWithSuppressedException { static final Method addSuppressed = initAddSuppressed ( ) ; static Method initAddSuppressed ( ) { try { return Throwable . class . getMethod ( " addSuppressed " , Throwable . class ) ; } catch ( Throwable e ) { return null ; } } @ Test public void alwaysThrows ( ) throws Exception { final RuntimeException exception = new RuntimeException ( " error " ) ; addSuppressed . invoke ( exception , new RuntimeException ( " suppressed " ) ) ; throw exception ; } } }
public void testAlwaysPasses ( ) { } } public static class ThrowingTestRule implements TestRule { public Statement apply ( Statement base , org . junit . runner . Description description ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingTestRule { @ Rule public final TestRule rule = new ThrowingTestRule ( ) ; @ Test public void alwaysPasses ( ) { } } public static class TestWithThrowingClassRule { @ ClassRule public static final TestRule rule = new ThrowingTestRule ( ) ; @ Test public void alwaysPasses ( ) { } } public static class ThrowingMethodRule implements MethodRule { public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingMethodRule { @ Rule public final ThrowingMethodRule rule = new ThrowingMethodRule ( ) ; @ Test public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } public static class TestWithSuppressedException { static final Method addSuppressed = initAddSuppressed ( ) ; static Method initAddSuppressed ( ) { try { return Throwable . class . getMethod ( " addSuppressed " , Throwable . class ) ; } catch ( Throwable e ) { return null ; } } @ Test public void alwaysThrows ( ) throws Exception { final RuntimeException exception = new RuntimeException ( " error " ) ; addSuppressed . invoke ( exception , new RuntimeException ( " suppressed " ) ) ; throw exception ; } } }
public void alwaysPasses ( ) { } } public static class TestWithThrowingClassRule { @ ClassRule public static final TestRule rule = new ThrowingTestRule ( ) ; @ Test public void alwaysPasses ( ) { } } public static class ThrowingMethodRule implements MethodRule { public Statement apply ( Statement base , FrameworkMethod method , Object target ) { new FakeClassUnderTest ( ) . throwsExceptionWithoutCause ( ) ; return base ; } } public static class TestWithThrowingMethodRule { @ Rule public final ThrowingMethodRule rule = new ThrowingMethodRule ( ) ; @ Test public void alwaysPasses ( ) { } } private static class FakeClassUnderTest { public void throwsExceptionWithCause ( ) { doThrowExceptionWithCause ( ) ; } public void throwsExceptionWithoutCause ( ) { doThrowExceptionWithoutCause ( ) ; } private void doThrowExceptionWithCause ( ) { try { throwsExceptionWithoutCause ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " outer " , e ) ; } } private void doThrowExceptionWithoutCause ( ) { throw new RuntimeException ( " cause " ) ; } } public static class TestWithSuppressedException { static final Method addSuppressed = initAddSuppressed ( ) ; static Method initAddSuppressed ( ) { try { return Throwable . class . getMethod ( " addSuppressed " , Throwable . class ) ; } catch ( Throwable e ) { return null ; } } @ Test public void alwaysThrows ( ) throws Exception { final RuntimeException exception = new RuntimeException ( " error " ) ; addSuppressed . invoke ( exception , new RuntimeException ( " suppressed " ) ) ; throw exception ; } } }
public static TestRule a ( ) { return new LoggingTestRule ( log , " outer " ) ; }
public static TestRule z ( ) { return new LoggingTestRule ( log , " inner " ) ; }
public void foo ( ) { log . append ( " foo " ) ; }
public void bar ( ) { log . append ( " bar " ) ; }
public void classRuleOrdering ( ) { log . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( ClassRuleOrdering . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( " outer . begin inner . begin bar foo inner . end outer . end " , log . toString ( ) ) ; }
public static TestRule b ( ) { return new LoggingTestRule ( log , " inner " ) ; }
public void classRuleOrderingDefault ( ) { log . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( ClassRuleOrderingDefault . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( " inner . begin outer . begin bar foo outer . end inner . end " , log . toString ( ) ) ; }
public Statement apply ( Statement base , FrameworkMethod method , Object target ) { return new LoggingStatement ( base , log , name ) ; }
public void evaluate ( ) throws Throwable { log . append ( " " ) . append ( name ) . append ( " . begin " ) ; try { base . evaluate ( ) ;
public Statement apply ( Statement base , Description description ) { return new LoggingStatement ( base , log , name ) ; }
public void foo ( ) { ruleLog . append ( " foo " ) ; }
public void testRuleIsAroundMethodRule ( ) { ruleLog . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( TestRuleIsAroundMethodRule . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( " testRule . begin methodRule . begin foo methodRule . end testRule . end " , ruleLog . toString ( ) ) ;
public void testRuleOrdering ( ) { ruleLog . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( TestRuleOrdering . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( " outer . begin inner . begin foo inner . end outer . end " , ruleLog . toString ( ) ) ; }
public void testRuleOrderingWithMethodRule ( ) { ruleLog . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( TestRuleOrderingWithMethodRule . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( " methodRule . begin testRule . begin foo testRule . end methodRule . end " , ruleLog . toString ( ) ) ;
public void methodRulesOnly ( ) { container . add ( MRule . M1 ) ; container . add ( MRule . M2 ) ; assertEquals ( " [ M1 , M2 ] " , container . getSortedRules ( ) . toString ( ) ) ; container . setOrder ( MRule . M2 , 1 ) ; assertEquals ( " [ M2 , M1 ] " , container . getSortedRules ( ) . toString ( ) ) ; }
public void testRuleAroundMethodRule ( ) { container . add ( MRule . M1 ) ; container . add ( Rule . A ) ; assertEquals ( " [ M1 , A ] " , container . getSortedRules ( ) . toString ( ) ) ; }
public void ordering1 ( ) { container . add ( MRule . M1 ) ; container . add ( Rule . A ) ; container . setOrder ( Rule . A , 1 ) ; assertEquals ( " [ A , M1 ] " , container . getSortedRules ( ) . toString ( ) ) ; }
public void ordering2 ( ) { container . add ( Rule . A ) ; container . add ( Rule . B ) ; container . add ( Rule . C ) ; assertEquals ( " [ A , B , C ] " , container . getSortedRules ( ) . toString ( ) ) ; container . setOrder ( Rule . B , 1 ) ; container . setOrder ( Rule . C , 2 ) ; assertEquals ( " [ C , B , A ] " , container . getSortedRules ( ) . toString ( ) ) ; }
public Statement apply ( Statement base , Description description ) { return base ; }
private boolean recursiveDelete ( File file ) { if ( file . delete ( ) ) { return true ; } File [ ] files = file . listFiles ( ) ; if ( files ! = null ) { for ( File each : files ) { if ( ! recursiveDelete ( each ) ) { return false ; } } } return file . delete ( ) ; }
public void expectCause ( Matcher < ? > expectedCause ) { expect ( hasCause ( expectedCause ) ) ; }
public void nothing ( ) { } } @ Test public void multipleRulesAreRun ( ) { runCount = 0 ; assertThat ( testResult ( MultipleRuleTest . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class NoRulesTest { public int x ; @ Test public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { assertThat ( testResult ( NoRulesTest . class ) , isSuccessful ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; assertThat ( testResult ( OnFailureTest . class ) , failureCountIs ( 1 ) ) ; assertEquals ( " nothing AssertionError " , log ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; assertThat ( testResult ( WatchmanTest . class ) , failureCountIs ( 1 ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; assertThat ( testResult ( BeforesAndAfters . class ) , isSuccessful ( ) ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { assertThat ( testResult ( NoRulesTest . class ) , isSuccessful ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; assertThat ( testResult ( OnFailureTest . class ) , failureCountIs ( 1 ) ) ; assertEquals ( " nothing AssertionError " , log ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; assertThat ( testResult ( WatchmanTest . class ) , failureCountIs ( 1 ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; assertThat ( testResult ( BeforesAndAfters . class ) , isSuccessful ( ) ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; assertThat ( testResult ( WatchmanTest . class ) , failureCountIs ( 1 ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; assertThat ( testResult ( BeforesAndAfters . class ) , isSuccessful ( ) ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { ruleWasEvaluated = true ; base . evaluate ( ) ; } } ; } } ; @ Rule public MethodRule methodRule ( ) { return methodRule ; } @ Test public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void doNothing ( ) { } } @ Test public void runsMethodRuleThatIsReturnedByMethod ( ) { ruleWasEvaluated = false ; assertThat ( testResult ( HasMethodReturningMethodRule . class ) , isSuccessful ( ) ) ; assertTrue ( ruleWasEvaluated ) ; } public static class HasMultipleMethodsReturningMethodRule { @ Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @ Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @ Test public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void doNothing ( ) { } } @ Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = 0 ; assertThat ( testResult ( HasMultipleMethodsReturningMethodRule . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = 0 ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } @ Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @ Test public void doNothing ( ) { assertEquals ( 1 , callCount ) ; } } @ Test public void callsMethodReturningRuleOnlyOnce ( ) { assertThat ( testResult ( CallsMethodReturningRuleOnlyOnce . class ) , isSuccessful ( ) ) ; } }
public void wrapIfNotThreadSafeShouldNotWrapThreadSafeListeners ( ) { ThreadSafeListener listener = new ThreadSafeListener ( ) ; assertSame ( listener , new RunNotifier ( ) . wrapIfNotThreadSafe ( listener ) ) ; }
public void theory ( ENUM e ) { } public void theory ( boolean b ) { } } @ Test public void shouldAutomaticallyGenerateEnumDataPoints ( ) throws Throwable { assertEquals ( ENUM . values ( ) . length , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ Test public void shouldAutomaticallyGenerateBooleanDataPoints ( ) throws Throwable { assertEquals ( 2 , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificEnumDataPoint { @ DataPoint public static ENUM value = ENUM . OTHER_VALUE ; public void theory ( ENUM e ) { } } @ Test public void shouldNotAutogenerateEnumDataPointsWhenSpecificDataPointGiven ( ) throws Throwable { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificEnumDataPoint . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificBooleanDataPoint { @ DataPoint public static boolean value = true ; public void theory ( boolean b ) { } } @ Test public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Throwable { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } }
public void theory ( boolean b ) { } } @ Test public void shouldAutomaticallyGenerateEnumDataPoints ( ) throws Throwable { assertEquals ( ENUM . values ( ) . length , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ Test public void shouldAutomaticallyGenerateBooleanDataPoints ( ) throws Throwable { assertEquals ( 2 , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificEnumDataPoint { @ DataPoint public static ENUM value = ENUM . OTHER_VALUE ; public void theory ( ENUM e ) { } } @ Test public void shouldNotAutogenerateEnumDataPointsWhenSpecificDataPointGiven ( ) throws Throwable { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificEnumDataPoint . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificBooleanDataPoint { @ DataPoint public static boolean value = true ; public void theory ( boolean b ) { } } @ Test public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Throwable { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } }
public void shouldAutomaticallyGenerateEnumDataPoints ( ) throws Throwable { assertEquals ( ENUM . values ( ) . length , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ;
public void shouldAutomaticallyGenerateBooleanDataPoints ( ) throws Throwable { assertEquals ( 2 , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ;
public void theory ( ENUM e ) { } } @ Test public void shouldNotAutogenerateEnumDataPointsWhenSpecificDataPointGiven ( ) throws Throwable { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificEnumDataPoint . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificBooleanDataPoint { @ DataPoint public static boolean value = true ; public void theory ( boolean b ) { } } @ Test public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Throwable { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } }
public void shouldNotAutogenerateEnumDataPointsWhenSpecificDataPointGiven ( ) throws Throwable { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificEnumDataPoint . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ;
public void theory ( boolean b ) { } } @ Test public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Throwable { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } }
public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Throwable { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ;
public void someTest ( ) { } } @ RunWith ( JUnit4ClassRunner . class ) public static class BadBeforeMethodWithLegacyRunner { @ Before void before ( ) { } @ Test public void someTest ( ) { } } public static class NoTests { } @ Test public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; } @ Test public void noRunnableMethods ( ) { assertThat ( exceptionMessageFrom ( NoTests . class ) , containsString ( " No runnable methods " ) ) ; } @ Test public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ; } private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; } }
void before ( ) { } @ Test public void someTest ( ) { } } public static class NoTests { } @ Test public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; } @ Test public void noRunnableMethods ( ) { assertThat ( exceptionMessageFrom ( NoTests . class ) , containsString ( " No runnable methods " ) ) ; } @ Test public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ; } private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; } }
public void someTest ( ) { } } public static class NoTests { } @ Test public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; } @ Test public void noRunnableMethods ( ) { assertThat ( exceptionMessageFrom ( NoTests . class ) , containsString ( " No runnable methods " ) ) ; } @ Test public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ; } private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; } }
public void beforesAndAftersAreEnclosedByRule ( ) { BeforesAndAftersAreEnclosedByRule . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAftersAreEnclosedByRule . class ) ; assertThat ( BeforesAndAftersAreEnclosedByRule . watchedLog , is ( " starting before test after succeeded finished " ) ) ; }
public void before ( ) { log . append ( " before " ) ; }
public void after ( ) { log . append ( " after " ) ; }
public void succeeds ( ) { log . append ( " test " ) ; }
public void beforesAndAftersAreEnclosedByRule ( ) { BeforesAndAftersAreEnclosedByRule . log = new StringBuilder ( ) ; JUnitCore . runClasses ( BeforesAndAftersAreEnclosedByRule . class ) ; assertEquals ( " starting before test after succeeded finished " , BeforesAndAftersAreEnclosedByRule . log . toString ( ) ) ;
public void usedErrorCollectorCheckThrowsClassMismatchShouldFail ( ) { PrintableResult testResult = testResult ( UsesErrorCollectorCheckThrowsClassMismatch . class ) ; assertThat ( testResult , hasFailureContaining ( " expected : < java . lang . IllegalArgumentException > but was : < java . lang . NullPointerException > " ) ) ;
public void run ( ) throws Throwable { } } ) ; } } @ Test public void usedErrorCollectorCheckThrowsNothingThrownShouldFail ( ) { PrintableResult testResult = testResult ( UsesErrorCollectorCheckThrowsNothingThrown . class ) ; assertThat ( testResult , hasFailureContaining ( " but nothing was thrown " ) ) ; } }
public static < T extends Throwable > T assertThrows ( Class < T > expectedThrowable , ThrowingRunnable runnable ) { return assertThrows ( null , expectedThrowable , runnable ) ; }
public static < T extends Throwable > T assertThrows ( String message , Class < T > expectedThrowable , ThrowingRunnable runnable ) { try { runnable . run ( ) ; } catch ( Throwable actualThrown ) { if ( expectedThrowable . isInstance ( actualThrown ) ) { @ SuppressWarnings ( " unchecked " ) T retVal = ( T ) actualThrown ; return retVal ; } else { String expected = formatClass ( expectedThrowable ) ; Class < ? extends Throwable > actualThrowable = actualThrown . getClass ( ) ; String actual = formatClass ( actualThrowable ) ; if ( expected . equals ( actual ) ) { expected + = " @ " + Integer . toHexString ( System . identityHashCode ( expectedThrowable ) ) ; actual + = " @ " + Integer . toHexString ( System . identityHashCode ( actualThrowable ) ) ; } String mismatchMessage = buildPrefix ( message ) + format ( " unexpected exception type thrown ; " , expected , actual ) ; AssertionError assertionError = new AssertionError ( mismatchMessage ) ; assertionError . initCause ( actualThrown ) ; throw assertionError ; } } String notThrownMessage = buildPrefix ( message ) + String . format ( " expected % s to be thrown , but nothing was thrown " , formatClass ( expectedThrowable ) ) ; throw new AssertionError ( notThrownMessage ) ; }
private static String buildPrefix ( String message ) { return message ! = null & & message . length ( ) ! = 0 ? message + " : " : " " ; }
public void assertThrowsRequiresAnExceptionToBeThrown ( ) { assertThrows ( Throwable . class , nonThrowingRunnable ( ) ) ; }
public void assertThrowsIncludesAnInformativeDefaultMessage ( ) { try { assertThrows ( Throwable . class , nonThrowingRunnable ( ) ) ; } catch ( AssertionError ex ) { assertEquals ( " expected java . lang . Throwable to be thrown , but nothing was thrown " , ex . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThrowsIncludesTheSpecifiedMessage ( ) { try { assertThrows ( " Foobar " , Throwable . class , nonThrowingRunnable ( ) ) ; } catch ( AssertionError ex ) { assertEquals ( " Foobar : expected java . lang . Throwable to be thrown , but nothing was thrown " , ex . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThrowsReturnsTheSameObjectThrown ( ) { NullPointerException npe = new NullPointerException ( ) ; Throwable throwable = assertThrows ( Throwable . class , throwingRunnable ( npe ) ) ; assertSame ( npe , throwable ) ; }
public void assertThrowsDetectsTypeMismatchesViaExplicitTypeHint ( ) { NullPointerException npe = new NullPointerException ( ) ; assertThrows ( IOException . class , throwingRunnable ( npe ) ) ; }
public void assertThrowsWrapsAndPropagatesUnexpectedExceptions ( ) { NullPointerException npe = new NullPointerException ( " inner - message " ) ; try { assertThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError ex ) { assertSame ( npe , ex . getCause ( ) ) ; assertEquals ( " inner - message " , ex . getCause ( ) . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThrowsSuppliesACoherentErrorMessageUponTypeMismatch ( ) { NullPointerException npe = new NullPointerException ( ) ; try { assertThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < java . io . IOException > but was : < java . lang . NullPointerException > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThrowsSuppliesTheSpecifiedMessageUponTypeMismatch ( ) { NullPointerException npe = new NullPointerException ( ) ; try { assertThrows ( " Foobar " , IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " Foobar : unexpected exception type thrown ; expected : < java . io . IOException > but was : < java . lang . NullPointerException > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThrowsUsesCanonicalNameUponTypeMismatch ( ) { NullPointerException npe = new NullPointerException ( ) ; try { assertThrows ( NestedException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < org . junit . tests . assertion . AssertionTest . NestedException > " + " but was : < java . lang . NullPointerException > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThrowsUsesNameUponTypeMismatchWithAnonymousClass ( ) { NullPointerException npe = new NullPointerException ( ) { } ; try { assertThrows ( IOException . class , throwingRunnable ( npe ) ) ; } catch ( AssertionError error ) { assertEquals ( " unexpected exception type thrown ; expected : < java . io . IOException > " + " but was : < org . junit . tests . assertion . AssertionTest $ 1 > " , error . getMessage ( ) ) ; assertSame ( npe , error . getCause ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public void assertThrowsUsesCanonicalNameWhenRequiredExceptionNotThrown ( ) { try { assertThrows ( NestedException . class , nonThrowingRunnable ( ) ) ; } catch ( AssertionError error ) { assertEquals ( " expected org . junit . tests . assertion . AssertionTest . NestedException to be thrown , " + " but nothing was thrown " , error . getMessage ( ) ) ; return ; } throw new AssertionError ( ASSERTION_ERROR_EXPECTED ) ; }
public static Matcher < EventCollector > hasSingleFailureWithMessage ( String message ) { return hasSingleFailureWithMessage ( equalTo ( message ) ) ; }
public void reportsInitializationErrorThrownWhileCreatingSuite ( ) { EventCollector collector = new EventCollector ( ) ; JUnitCore core = new JUnitCore ( ) ; core . addListener ( collector ) ; core . run ( new FailingComputer ( ) , FooTest . class , BarTest . class ) ; assertThat ( collector , hasSingleFailureWithMessage ( " cannot create suite " ) ) ; }
public Runner getSuite ( RunnerBuilder builder , Class < ? > [ ] classes ) throws InitializationError { throw new InitializationError ( " cannot create suite " ) ; }
public static Object [ ] [ ] testsWithEventMatcher ( ) { return new Object [ ] [ ] { {
public void runTestClassAndVerifyEvents ( ) { EventCollector collector = new EventCollector ( ) ; JUnitCore core = new JUnitCore ( ) ; core . addListener ( collector ) ; core . run ( classUnderTest ) ; assertThat ( collector , matcher ) ; }
public void example ( ) { collector . checkThat ( 3 , is ( 4 ) ) ; }
public void example ( ) { collector . checkThat ( " reason " , 3 , is ( 4 ) ) ; }
public void example ( ) { collector . checkThat ( 3 , is ( 4 ) ) ; collector . checkThat ( " reason " , 7 , is ( 8 ) ) ; }
public void example ( ) { collector . checkSucceeds ( new Callable < Object > ( ) { public Object call ( ) throws Exception { throw new RuntimeException ( " first ! " ) ; } } ) ; collector . checkSucceeds ( new Callable < Integer > ( ) { public Integer call ( ) throws Exception {
public void example ( ) { Object result = collector . checkSucceeds ( new Callable < Object > ( ) { public Object call ( ) throws Exception { return 3 ; } } ) ; assertEquals ( 3 , result ) ; }
public void run ( ) throws Throwable { } } ) ; } } }
static Matcher < EventCollector > hasNumberOfFailures ( final int numberOfFailures ) { return new TypeSafeMatcher < EventCollector > ( ) { @ Override
public void example ( ) { collector . checkThat ( " dummy reason " , 3 , is ( 3 ) ) ; }
public void example ( ) { collector . checkThat ( 3 , is ( 3 ) ) ; }
public Object call ( ) throws Exception { assumeTrue ( false ) ; return null ; }
public void run ( ) throws Throwable { } } ) ; } } public static class ErrorCollectorNotCalledBySuccessfulTest { @ Rule public ErrorCollector collector = new ErrorCollector ( ) ; @ Test public void example ( ) { } } public static class ErrorCollectorNotCalledByFailingTest { @ Rule public ErrorCollector collector = new ErrorCollector ( ) ; @ Test public void example ( ) { fail ( ) ; } } }
public void example ( ) { } } public static class ErrorCollectorNotCalledByFailingTest { @ Rule public ErrorCollector collector = new ErrorCollector ( ) ; @ Test public void example ( ) { fail ( ) ; } } }
public void example ( ) { fail ( ) ; }
protected abstract State processLine ( String methodName ) ; public final State processStackTraceElement ( StackTraceElement element ) { return processLine ( element . getClassName ( ) + " . " + element . getMethodName ( ) + " ( ) " ) ; } } private static final String [ ] TEST_FRAMEWORK_METHOD_NAME_PREFIXES = { " org . junit . runner . " , " org . junit . runners . " , " org . junit . experimental . runners . " , " org . junit . internal . " , " junit . " , } ; private static final String [ ] TEST_FRAMEWORK_TEST_METHOD_NAME_PREFIXES = { " org . junit . internal . StackTracesTest " , } ; private static boolean isTestFrameworkMethod ( String methodName ) { return isMatchingMethod ( methodName , TEST_FRAMEWORK_METHOD_NAME_PREFIXES ) & & ! isMatchingMethod ( methodName , TEST_FRAMEWORK_TEST_METHOD_NAME_PREFIXES ) ; } private static final String [ ] REFLECTION_METHOD_NAME_PREFIXES = { " sun . reflect . " , " java . lang . reflect . " , " jdk . internal . reflect . " , " org . junit . rules . RunRules . < init > ( " , " org . junit . rules . RunRules . applyAll ( " , " org . junit . runners . RuleContainer . apply ( " , " junit . framework . TestCase . runBare ( " , } ; private static boolean isReflectionMethod ( String methodName ) { return isMatchingMethod ( methodName , REFLECTION_METHOD_NAME_PREFIXES ) ; } private static boolean isMatchingMethod ( String methodName , String [ ] methodNamePrefixes ) { for ( String methodNamePrefix : methodNamePrefixes ) { if ( methodName . startsWith ( methodNamePrefix ) ) { return true ; } } return false ; } }
public int methodB ( ) { return 0 ; }
public void providesAnnotatedMethodsSortedByName ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; List < FrameworkMethod > annotatedMethods = tc . getAnnotatedMethods ( ) ; assertThat ( " Wrong number of annotated methods . " , annotatedMethods . size ( ) , is ( 3 ) ) ; assertThat ( " First annotated method is wrong . " , annotatedMethods . iterator ( ) . next ( ) . getName ( ) , is ( " methodA " ) ) ;
public void annotatedMethodValues ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; List < String > values = tc . getAnnotatedMethodValues ( new MethodsAnnotated ( ) , Ignore . class , String . class ) ; assertThat ( values , hasItem ( " jupiter " ) ) ; assertThat ( values . size ( ) , is ( 1 ) ) ; }
public int methodWithoutAnnotation ( ) { return 0 ; }
public void providesAnnotatedMethodsSortedByName ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; List < FrameworkMethod > annotatedMethods = tc . getAnnotatedMethods ( ) ; assertThat ( " First annotated method is wrong . " , annotatedMethods . iterator ( ) . next ( ) . getName ( ) , is ( " methodA " ) ) ;
private List < String > extractNames ( List < FrameworkMethod > methods ) { List < String > names = new ArrayList < String > ( ) ; for ( FrameworkMethod method : methods ) { names . add ( method . getName ( ) ) ; } return names ; }
public void providesAnnotatedMethodsSortedByName ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; List < FrameworkMethod > annotatedMethods = tc . getAnnotatedMethods ( ) ; List < String > methodNames = extractNames ( annotatedMethods ) ; assertThat ( methodNames . indexOf ( " methodA " ) , lessThan ( methodNames . indexOf ( " methodB " ) ) ) ;
protected void skipped ( org . junit . internal . AssumptionViolatedException e , Description description ) { log . append ( " deprecated skipped " ) ; }
public static Object [ ] [ ] parameters ( ) { return new Object [ ] [ ] { {
public void correctCallbacksCalled ( ) { StringBuilder log = new StringBuilder ( ) ; selectedRule = new LoggingTestWatcher ( log ) ; JUnitCore . runClasses ( testClass ) ; assertEquals ( expectedCallbacks , log . toString ( ) ) ; }
public void resultHasAllFailuresThrownByCallbacks ( ) { selectedRule = new ErroneousTestWatcher ( ) ; PrintableResult result = testResult ( testClass ) ; assertThat ( result , failureCountIs ( expectedFailures . size ( ) ) ) ; for ( String expectedFailure : expectedFailures ) { assertThat ( result , hasFailureContaining ( expectedFailure ) ) ;
public void testWatcherDoesNotModifyResult ( ) { selectedRule = new NoOpRule ( ) ; Result resultNoOpRule = JUnitCore . runClasses ( testClass ) ; selectedRule = new LoggingTestWatcher ( new StringBuilder ( ) ) ; Result resultTestWatcher = JUnitCore . runClasses ( testClass ) ; assertEquals ( " was successful " , resultNoOpRule . wasSuccessful ( ) , resultTestWatcher . wasSuccessful ( ) ) ; assertEquals ( " failure count " , resultNoOpRule . getFailureCount ( ) , resultTestWatcher . getFailureCount ( ) ) ; assertEquals ( " ignore count " , resultNoOpRule . getIgnoreCount ( ) , resultTestWatcher . getIgnoreCount ( ) ) ; assertEquals ( " run count " ,
public Statement apply ( Statement base , Description description ) { return base ; }
protected void succeeded ( Description description ) { throw new RuntimeException ( " succeeded failed " ) ; }
protected void failed ( Throwable e , Description description ) { throw new RuntimeException ( " failed failed " ) ; }
protected void skipped ( org . junit . AssumptionViolatedException e , Description description ) { throw new RuntimeException ( " skipped failed " ) ; }
protected void skipped ( AssumptionViolatedException e , Description description ) { throw new RuntimeException ( " deprecated skipped failed " ) ; }
protected void starting ( Description description ) { throw new RuntimeException ( " starting failed " ) ; }
protected void finished ( Description description ) { throw new RuntimeException ( " finished failed " ) ; }
public void test ( ) { fail ( " test failed " ) ; }
public void test ( ) { throw new AssumptionViolatedException ( " don ' t run " ) ; }
public void test ( ) { } } public static class ViolatedAssumptionTest { @ Rule public TestRule watcher = selectedRule ; @ Test public void test ( ) { assumeTrue ( false ) ; } } } public static class CallbackArguments { public static class Succeeded { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void succeeded ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void succeeded ( ) { JUnitCore . runClasses ( Succeeded . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Succeeded ) " , Succeeded . catchedDescription . getDisplayName ( ) ) ; } public static class Failed { private static Description catchedDescription ; private static Throwable catchedThrowable ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void failed ( Throwable e , Description description ) { catchedDescription = description ; catchedThrowable = e ; } } ; @ Test public void test ( ) { fail ( " test failed " ) ; } } @ Test public void failed ( ) { JUnitCore . runClasses ( Failed . class ) ; assertEquals ( " test failed " , Failed . catchedThrowable . getMessage ( ) ) ; assertEquals ( AssertionError . class , Failed . catchedThrowable . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Failed ) " , Failed . catchedDescription . getDisplayName ( ) ) ; } public static class Skipped { private static Description catchedDescription ; private static org . junit . AssumptionViolatedException catchedException ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void skipped ( org . junit . AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; } } ; @ Test public void test ( ) { assumeTrue ( " test skipped " , false ) ; } } @ Test public void skipped ( ) { JUnitCore . runClasses ( Skipped . class ) ; assertEquals ( " test skipped " , Skipped . catchedException . getMessage ( ) ) ; assertEquals ( org . junit . AssumptionViolatedException . class , Skipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Skipped ) " , Skipped . catchedDescription . getDisplayName ( ) ) ; } public static class DeprecatedSkipped { private static Description catchedDescription ; private static AssumptionViolatedException catchedException ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override @ SuppressWarnings ( " deprecation " ) protected void skipped ( AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; } } ; @ SuppressWarnings ( " deprecation " ) @ Test public void test ( ) { throw new AssumptionViolatedException ( " test skipped " ) ; } } @ Test public void deprecatedSkipped ( ) { JUnitCore . runClasses ( DeprecatedSkipped . class ) ; assertEquals ( " test skipped " , DeprecatedSkipped . catchedException . getMessage ( ) ) ; assertEquals ( AssumptionViolatedException . class , DeprecatedSkipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ DeprecatedSkipped ) " , DeprecatedSkipped . catchedDescription . getDisplayName ( ) ) ; } public static class Starting { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void starting ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void starting ( ) { JUnitCore . runClasses ( Starting . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Starting ) " , Starting . catchedDescription . getDisplayName ( ) ) ; } public static class Finished { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void finished ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void finished ( ) { JUnitCore . runClasses ( Finished . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Finished ) " , Finished . catchedDescription . getDisplayName ( ) ) ; } } }
public void test ( ) { assumeTrue ( false ) ; }
protected void succeeded ( Description description ) { catchedDescription = description ; }
public void test ( ) { } } @ Test public void succeeded ( ) { JUnitCore . runClasses ( Succeeded . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Succeeded ) " , Succeeded . catchedDescription . getDisplayName ( ) ) ; } public static class Failed { private static Description catchedDescription ; private static Throwable catchedThrowable ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void failed ( Throwable e , Description description ) { catchedDescription = description ; catchedThrowable = e ; } } ; @ Test public void test ( ) { fail ( " test failed " ) ; } } @ Test public void failed ( ) { JUnitCore . runClasses ( Failed . class ) ; assertEquals ( " test failed " , Failed . catchedThrowable . getMessage ( ) ) ; assertEquals ( AssertionError . class , Failed . catchedThrowable . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Failed ) " , Failed . catchedDescription . getDisplayName ( ) ) ; } public static class Skipped { private static Description catchedDescription ; private static org . junit . AssumptionViolatedException catchedException ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void skipped ( org . junit . AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; } } ; @ Test public void test ( ) { assumeTrue ( " test skipped " , false ) ; } } @ Test public void skipped ( ) { JUnitCore . runClasses ( Skipped . class ) ; assertEquals ( " test skipped " , Skipped . catchedException . getMessage ( ) ) ; assertEquals ( org . junit . AssumptionViolatedException . class , Skipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Skipped ) " , Skipped . catchedDescription . getDisplayName ( ) ) ; } public static class DeprecatedSkipped { private static Description catchedDescription ; private static AssumptionViolatedException catchedException ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override @ SuppressWarnings ( " deprecation " ) protected void skipped ( AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; } } ; @ SuppressWarnings ( " deprecation " ) @ Test public void test ( ) { throw new AssumptionViolatedException ( " test skipped " ) ; } } @ Test public void deprecatedSkipped ( ) { JUnitCore . runClasses ( DeprecatedSkipped . class ) ; assertEquals ( " test skipped " , DeprecatedSkipped . catchedException . getMessage ( ) ) ; assertEquals ( AssumptionViolatedException . class , DeprecatedSkipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ DeprecatedSkipped ) " , DeprecatedSkipped . catchedDescription . getDisplayName ( ) ) ; } public static class Starting { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void starting ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void starting ( ) { JUnitCore . runClasses ( Starting . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Starting ) " , Starting . catchedDescription . getDisplayName ( ) ) ; } public static class Finished { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void finished ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void finished ( ) { JUnitCore . runClasses ( Finished . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Finished ) " , Finished . catchedDescription . getDisplayName ( ) ) ; } } }
public void succeeded ( ) { JUnitCore . runClasses ( Succeeded . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Succeeded ) " , Succeeded . catchedDescription . getDisplayName ( ) ) ;
protected void failed ( Throwable e , Description description ) { catchedDescription = description ; catchedThrowable = e ; }
public void failed ( ) { JUnitCore . runClasses ( Failed . class ) ; assertEquals ( " test failed " , Failed . catchedThrowable . getMessage ( ) ) ; assertEquals ( AssertionError . class , Failed . catchedThrowable . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Failed ) " , Failed . catchedDescription . getDisplayName ( ) ) ;
protected void skipped ( org . junit . AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; }
public void test ( ) { assumeTrue ( " test skipped " , false ) ; }
public void skipped ( ) { JUnitCore . runClasses ( Skipped . class ) ; assertEquals ( " test skipped " , Skipped . catchedException . getMessage ( ) ) ; assertEquals ( org . junit . AssumptionViolatedException . class , Skipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Skipped ) " , Skipped . catchedDescription . getDisplayName ( ) ) ;
protected void skipped ( AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; }
public void test ( ) { throw new AssumptionViolatedException ( " test skipped " ) ; }
public void deprecatedSkipped ( ) { JUnitCore . runClasses ( DeprecatedSkipped . class ) ; assertEquals ( " test skipped " , DeprecatedSkipped . catchedException . getMessage ( ) ) ; assertEquals ( AssumptionViolatedException . class , DeprecatedSkipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ DeprecatedSkipped ) " , DeprecatedSkipped . catchedDescription . getDisplayName ( ) ) ;
protected void starting ( Description description ) { catchedDescription = description ; }
public void test ( ) { } } @ Test public void starting ( ) { JUnitCore . runClasses ( Starting . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Starting ) " , Starting . catchedDescription . getDisplayName ( ) ) ; } public static class Finished { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void finished ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void finished ( ) { JUnitCore . runClasses ( Finished . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Finished ) " , Finished . catchedDescription . getDisplayName ( ) ) ; } } }
public void starting ( ) { JUnitCore . runClasses ( Starting . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Starting ) " , Starting . catchedDescription . getDisplayName ( ) ) ;
protected void finished ( Description description ) { catchedDescription = description ; }
public void test ( ) { } } @ Test public void finished ( ) { JUnitCore . runClasses ( Finished . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Finished ) " , Finished . catchedDescription . getDisplayName ( ) ) ; } } }
public void finished ( ) { JUnitCore . runClasses ( Finished . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Finished ) " , Finished . catchedDescription . getDisplayName ( ) ) ;
public void test ( ) { } } public static class ViolatedAssumptionTest { @ Rule public TestRule watcher = selectedRule ; @ Test public void test ( ) { assumeTrue ( false ) ; } } } public static class CallbackArguments { public static class Succeeded { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void succeeded ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void succeeded ( ) { JUnitCore . runClasses ( Succeeded . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Succeeded ) " , Succeeded . catchedDescription . getDisplayName ( ) ) ; } public static class Failed { private static Description catchedDescription ; private static Throwable catchedThrowable ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void failed ( Throwable e , Description description ) { catchedDescription = description ; catchedThrowable = e ; } } ; @ Test public void test ( ) { fail ( " test failed " ) ; } } @ Test public void failed ( ) { JUnitCore . runClasses ( Failed . class ) ; assertEquals ( " test failed " , Failed . catchedThrowable . getMessage ( ) ) ; assertEquals ( AssertionError . class , Failed . catchedThrowable . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Failed ) " , Failed . catchedDescription . getDisplayName ( ) ) ; } public static class Skipped { private static Description catchedDescription ; private static org . junit . AssumptionViolatedException catchedException ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void skipped ( org . junit . AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; } } ; @ Test public void test ( ) { assumeTrue ( " test skipped " , false ) ; } } @ Test public void skipped ( ) { JUnitCore . runClasses ( Skipped . class ) ; assertEquals ( " test skipped " , Skipped . catchedException . getMessage ( ) ) ; assertEquals ( org . junit . AssumptionViolatedException . class , Skipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Skipped ) " , Skipped . catchedDescription . getDisplayName ( ) ) ; } public static class DeprecatedSkipped { private static Description catchedDescription ; private static AssumptionViolatedException catchedException ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override @ SuppressWarnings ( " deprecation " ) protected void skipped ( AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; } } ; @ SuppressWarnings ( " deprecation " ) @ Test public void test ( ) { throw new AssumptionViolatedException ( " test skipped " ) ; } } @ Test public void deprecatedSkipped ( ) { JUnitCore . runClasses ( DeprecatedSkipped . class ) ; assertEquals ( " test skipped " , DeprecatedSkipped . catchedException . getMessage ( ) ) ; assertEquals ( AssumptionViolatedException . class , DeprecatedSkipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ DeprecatedSkipped ) " , DeprecatedSkipped . catchedDescription . getDisplayName ( ) ) ; } public static class Starting { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void starting ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void starting ( ) { JUnitCore . runClasses ( Starting . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Starting ) " , Starting . catchedDescription . getDisplayName ( ) ) ; } public static class Finished { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void finished ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void finished ( ) { JUnitCore . runClasses ( Finished . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Finished ) " , Finished . catchedDescription . getDisplayName ( ) ) ; } } public static class InterplayWithOtherRules { private static StringBuilder log ; public static class ExpectedExceptionTest { @ Rule ( order = Integer . MIN_VALUE ) public final TestRule a = new LoggingTestWatcher ( log ) ; @ Rule public final ExpectedException thrown = none ( ) ; @ Test public void testWithExpectedException ( ) { thrown . expect ( RuntimeException . class ) ; throw new RuntimeException ( " expected exception " ) ; } } @ Test public void expectedExceptionIsSeenAsSuccessfulTest ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ExpectedExceptionTest . class ) ; assertEquals ( " starting succeeded finished " , log . toString ( ) ) ; } public static class ErrorCollectorTest { @ Rule ( order = Integer . MIN_VALUE ) public final TestRule a = new LoggingTestWatcher ( log ) ; @ Rule public final ErrorCollector collector = new ErrorCollector ( ) ; @ Test public void test ( ) { collector . addError ( new RuntimeException ( " expected exception " ) ) ; } } @ Test public void testIsSeenAsFailedBecauseOfCollectedError ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ErrorCollectorTest . class ) ; assertEquals ( " starting failed finished " , log . toString ( ) ) ; } } }
public void test ( ) { } } @ Test public void succeeded ( ) { JUnitCore . runClasses ( Succeeded . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Succeeded ) " , Succeeded . catchedDescription . getDisplayName ( ) ) ; } public static class Failed { private static Description catchedDescription ; private static Throwable catchedThrowable ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void failed ( Throwable e , Description description ) { catchedDescription = description ; catchedThrowable = e ; } } ; @ Test public void test ( ) { fail ( " test failed " ) ; } } @ Test public void failed ( ) { JUnitCore . runClasses ( Failed . class ) ; assertEquals ( " test failed " , Failed . catchedThrowable . getMessage ( ) ) ; assertEquals ( AssertionError . class , Failed . catchedThrowable . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Failed ) " , Failed . catchedDescription . getDisplayName ( ) ) ; } public static class Skipped { private static Description catchedDescription ; private static org . junit . AssumptionViolatedException catchedException ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void skipped ( org . junit . AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; } } ; @ Test public void test ( ) { assumeTrue ( " test skipped " , false ) ; } } @ Test public void skipped ( ) { JUnitCore . runClasses ( Skipped . class ) ; assertEquals ( " test skipped " , Skipped . catchedException . getMessage ( ) ) ; assertEquals ( org . junit . AssumptionViolatedException . class , Skipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Skipped ) " , Skipped . catchedDescription . getDisplayName ( ) ) ; } public static class DeprecatedSkipped { private static Description catchedDescription ; private static AssumptionViolatedException catchedException ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override @ SuppressWarnings ( " deprecation " ) protected void skipped ( AssumptionViolatedException e , Description description ) { catchedDescription = description ; catchedException = e ; } } ; @ SuppressWarnings ( " deprecation " ) @ Test public void test ( ) { throw new AssumptionViolatedException ( " test skipped " ) ; } } @ Test public void deprecatedSkipped ( ) { JUnitCore . runClasses ( DeprecatedSkipped . class ) ; assertEquals ( " test skipped " , DeprecatedSkipped . catchedException . getMessage ( ) ) ; assertEquals ( AssumptionViolatedException . class , DeprecatedSkipped . catchedException . getClass ( ) ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ DeprecatedSkipped ) " , DeprecatedSkipped . catchedDescription . getDisplayName ( ) ) ; } public static class Starting { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void starting ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void starting ( ) { JUnitCore . runClasses ( Starting . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Starting ) " , Starting . catchedDescription . getDisplayName ( ) ) ; } public static class Finished { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void finished ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void finished ( ) { JUnitCore . runClasses ( Finished . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Finished ) " , Finished . catchedDescription . getDisplayName ( ) ) ; } } public static class InterplayWithOtherRules { private static StringBuilder log ; public static class ExpectedExceptionTest { @ Rule ( order = Integer . MIN_VALUE ) public final TestRule a = new LoggingTestWatcher ( log ) ; @ Rule public final ExpectedException thrown = none ( ) ; @ Test public void testWithExpectedException ( ) { thrown . expect ( RuntimeException . class ) ; throw new RuntimeException ( " expected exception " ) ; } } @ Test public void expectedExceptionIsSeenAsSuccessfulTest ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ExpectedExceptionTest . class ) ; assertEquals ( " starting succeeded finished " , log . toString ( ) ) ; } public static class ErrorCollectorTest { @ Rule ( order = Integer . MIN_VALUE ) public final TestRule a = new LoggingTestWatcher ( log ) ; @ Rule public final ErrorCollector collector = new ErrorCollector ( ) ; @ Test public void test ( ) { collector . addError ( new RuntimeException ( " expected exception " ) ) ; } } @ Test public void testIsSeenAsFailedBecauseOfCollectedError ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ErrorCollectorTest . class ) ; assertEquals ( " starting failed finished " , log . toString ( ) ) ; } } }
public void test ( ) { } } @ Test public void starting ( ) { JUnitCore . runClasses ( Starting . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Starting ) " , Starting . catchedDescription . getDisplayName ( ) ) ; } public static class Finished { private static Description catchedDescription ; @ Rule public final TestRule watcher = new TestWatcher ( ) { @ Override protected void finished ( Description description ) { catchedDescription = description ; } } ; @ Test public void test ( ) { } } @ Test public void finished ( ) { JUnitCore . runClasses ( Finished . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Finished ) " , Finished . catchedDescription . getDisplayName ( ) ) ; } } public static class InterplayWithOtherRules { private static StringBuilder log ; public static class ExpectedExceptionTest { @ Rule ( order = Integer . MIN_VALUE ) public final TestRule a = new LoggingTestWatcher ( log ) ; @ Rule public final ExpectedException thrown = none ( ) ; @ Test public void testWithExpectedException ( ) { thrown . expect ( RuntimeException . class ) ; throw new RuntimeException ( " expected exception " ) ; } } @ Test public void expectedExceptionIsSeenAsSuccessfulTest ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ExpectedExceptionTest . class ) ; assertEquals ( " starting succeeded finished " , log . toString ( ) ) ; } public static class ErrorCollectorTest { @ Rule ( order = Integer . MIN_VALUE ) public final TestRule a = new LoggingTestWatcher ( log ) ; @ Rule public final ErrorCollector collector = new ErrorCollector ( ) ; @ Test public void test ( ) { collector . addError ( new RuntimeException ( " expected exception " ) ) ; } } @ Test public void testIsSeenAsFailedBecauseOfCollectedError ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ErrorCollectorTest . class ) ; assertEquals ( " starting failed finished " , log . toString ( ) ) ; } } }
public void test ( ) { } } @ Test public void finished ( ) { JUnitCore . runClasses ( Finished . class ) ; assertEquals ( " test ( org . junit . rules . TestWatcherTest $ CallbackArguments $ Finished ) " , Finished . catchedDescription . getDisplayName ( ) ) ; } } public static class InterplayWithOtherRules { private static StringBuilder log ; public static class ExpectedExceptionTest { @ Rule ( order = Integer . MIN_VALUE ) public final TestRule a = new LoggingTestWatcher ( log ) ; @ Rule public final ExpectedException thrown = none ( ) ; @ Test public void testWithExpectedException ( ) { thrown . expect ( RuntimeException . class ) ; throw new RuntimeException ( " expected exception " ) ; } } @ Test public void expectedExceptionIsSeenAsSuccessfulTest ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ExpectedExceptionTest . class ) ; assertEquals ( " starting succeeded finished " , log . toString ( ) ) ; } public static class ErrorCollectorTest { @ Rule ( order = Integer . MIN_VALUE ) public final TestRule a = new LoggingTestWatcher ( log ) ; @ Rule public final ErrorCollector collector = new ErrorCollector ( ) ; @ Test public void test ( ) { collector . addError ( new RuntimeException ( " expected exception " ) ) ; } } @ Test public void testIsSeenAsFailedBecauseOfCollectedError ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ErrorCollectorTest . class ) ; assertEquals ( " starting failed finished " , log . toString ( ) ) ; } } }
public void testWithExpectedException ( ) { thrown . expect ( RuntimeException . class ) ; throw new RuntimeException ( " expected exception " ) ; }
public void expectedExceptionIsSeenAsSuccessfulTest ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ExpectedExceptionTest . class ) ; assertEquals ( " starting succeeded finished " , log . toString ( ) ) ; }
public void test ( ) { collector . addError ( new RuntimeException ( " expected exception " ) ) ; }
public void testIsSeenAsFailedBecauseOfCollectedError ( ) { log = new StringBuilder ( ) ; JUnitCore . runClasses ( ErrorCollectorTest . class ) ; assertEquals ( " starting failed finished " , log . toString ( ) ) ; }
public boolean isShadowedBy ( FrameworkField otherMember ) { return isStatic ( ) & & otherMember . getName ( ) . equals ( getName ( ) ) ; }
abstract boolean isShadowedBy ( T otherMember ) ; final T handlePossibleShadowedMember ( List < T > members ) { for ( int i = members . size ( ) - 1 ; i > = 0 ; i - - ) { T otherMember = members . get ( i ) ; if ( isShadowedBy ( otherMember ) ) { if ( otherMember . isBridgeMethod ( ) ) { members . remove ( i ) ; return otherMember ; } return null ; } } return self ( ) ; } @ SuppressWarnings ( " unchecked " ) private T self ( ) { return ( T ) this ; } abstract boolean isBridgeMethod ( ) ; protected abstract int getModifiers ( ) ; public boolean isStatic ( ) { return Modifier . isStatic ( getModifiers ( ) ) ; } public boolean isPublic ( ) { return Modifier . isPublic ( getModifiers ( ) ) ; } public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
final T handlePossibleShadowedMember ( List < T > members ) { for ( int i = members . size ( ) - 1 ; i > = 0 ; i - - ) { T otherMember = members . get ( i ) ; if ( isShadowedBy ( otherMember ) ) { if ( otherMember . isBridgeMethod ( ) ) { members . remove ( i ) ; return otherMember ; } return null ; } } return self ( ) ; }
public void testStaticMethodsCanBeTreatedAsShadowed ( ) throws Exception { log = " " ; assertThat ( testResult ( SubStaticMethodShadowing . class ) , isSuccessful ( ) ) ; assertEquals ( " sub . rule ( ) . before ( ) "
public void testStaticFieldsCanBeTreatedAsShadowed ( ) throws Exception { log = " " ; assertThat ( testResult ( SubStaticFieldShadowing . class ) , isSuccessful ( ) ) ; assertEquals ( " sub . rule . before ( ) "
public void throwsNothing ( ) { } } public static class ThrowExceptionWithExpectedType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new NullPointerException ( ) ; } } public static class ThrowExceptionWithExpectedPartOfMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerExceptionWithMessage ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( ARBITRARY_MESSAGE ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " something else " ) ; } } public static class ThrowExceptionWithWrongType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new IllegalArgumentException ( ) ; } } public static class HasWrongMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expectMessage ( " expectedMessage " ) ; throw new IllegalArgumentException ( " actualMessage " ) ; } } public static class ThrowNoExceptionButExpectExceptionWithType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; } } public static class WronglyExpectsExceptionMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowAnything ( ) { thrown . expectMessage ( " anything ! " ) ; } } public static class ExpectsSubstring { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( " This could throw anything ! ( as long as it has the right substring ) " ) ; } } public static class ExpectsSubstringNullMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( ) ; } } public static class ExpectsMessageMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( startsWith ( ARBITRARY_MESSAGE ) ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " ! " ) ; } } public static class ExpectedMessageMatcherFails { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( equalTo ( " Wrong start " ) ) ; throw new NullPointerException ( " Back ! " ) ; } } public static class ExpectsMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( any ( Exception . class ) ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class ExpectsMultipleMatchers { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class ExpectAssertionErrorWhichIsNotThrown { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void fails ( ) { thrown . expect ( AssertionError . class ) ; } } public static class FailBeforeExpectingException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void fails ( ) { fail ( ARBITRARY_MESSAGE ) ; thrown . expect ( IllegalArgumentException . class ) ; } } public static class FailedAssumptionAndExpectException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void failedAssumption ( ) { assumeTrue ( false ) ; thrown . expect ( NullPointerException . class ) ; } } public static class ThrowExceptionWithMatchingCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExceptionWithMatchingCause ( ) { NullPointerException expectedCause = new NullPointerException ( " expected cause " ) ; thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( expectedCause ) ) ; throw new IllegalArgumentException ( " Ack ! " , expectedCause ) ; } } public static class ThrowExpectedNullCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExpectedNullCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( nullValue ( Throwable . class ) ) ; throw new IllegalArgumentException ( " Ack ! " ) ; } } public static class ThrowUnexpectedCause { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void throwWithCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( new NullPointerException ( " expected cause " ) ) ) ; throw new IllegalArgumentException ( " Ack ! " , new NullPointerException ( " an unexpected cause " ) ) ; } } public static class UseNoCustomMessage { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; } } public static class UseCustomMessageWithPlaceHolder { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . reportMissingExceptionWithMessage ( ARBITRARY_MESSAGE + " - % s " ) ; } } public static class UseCustomMessageWithoutPlaceHolder { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . reportMissingExceptionWithMessage ( ARBITRARY_MESSAGE ) ; } } public static class ErrorCollectorShouldFailAlthoughExpectedExceptionDoesNot { @ Rule public ErrorCollector collector = new ErrorCollector ( ) ; @ Rule ( order = Integer . MAX_VALUE ) public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void test ( ) { collector . addError ( new AssertionError ( ARBITRARY_MESSAGE ) ) ; thrown . expect ( Exception . class ) ; throw new RuntimeException ( ) ; } } }
public void test ( ) { collector . addError ( new AssertionError ( ARBITRARY_MESSAGE ) ) ; thrown . expect ( Exception . class ) ; throw new RuntimeException ( ) ; }
public void testContains ( ) { assertTrue ( fullList . contains ( 1 ) ) ; assertFalse ( emptyList . contains ( 1 ) ) ; }
public void testRemoveElement ( ) { fullList . remove ( 3 ) ; assertFalse ( fullList . contains ( 3 ) ) ; }
public void testRemoveElement ( ) { fullList . remove ( Integer . valueOf ( 3 ) ) ; assertFalse ( fullList . contains ( 3 ) ) ; }
public void throwsTestTimedOutException ( ) { assertThrows ( TestTimedOutException . class ,
public void throwExceptionWithNiceMessageOnTimeout ( ) { TestTimedOutException e = assertThrows ( TestTimedOutException . class , evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ) ; assertEquals ( " test timed out after 100 milliseconds " , e . getMessage ( ) ) ; }
public void sendUpExceptionThrownByStatement ( ) { RuntimeException exception = new RuntimeException ( ) ; RuntimeException e = assertThrows ( RuntimeException . class , evaluateWithException ( exception ) ) ; assertSame ( exception , e ) ; }
public void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime ( ) throws Throwable { evaluateWithWaitDuration ( 0 ) . run ( ) ; assertThrows ( TestTimedOutException . class ,
public void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException ( ) { try { evaluateWithException ( new RuntimeException ( ) ) . run ( ) ; } catch ( Throwable expected ) { } TestTimedOutException e = assertThrows ( TestTimedOutException . class , evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ) ; assertEquals ( " test timed out after 100 milliseconds " , e . getMessage ( ) ) ; }
public void throwsExceptionWithTimeoutValueAndTimeUnitSet ( ) { TestTimedOutException e = assertThrows ( TestTimedOutException . class , evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ) ; assertEquals ( TIMEOUT , e . getTimeout ( ) ) ; assertEquals ( TimeUnit . MILLISECONDS , e . getTimeUnit ( ) ) ; }
private ThrowingRunnable evaluateWithException ( final Exception exception ) { return new ThrowingRunnable ( ) { public void run ( ) throws Throwable {
public void run ( ) throws Throwable { statement . nextException = exception ; statement . waitDuration = 0 ; failOnTimeout . evaluate ( ) ; }
private ThrowingRunnable evaluateWithWaitDuration ( final long waitDuration ) { return new ThrowingRunnable ( ) { public void run ( ) throws Throwable {
public void run ( ) throws Throwable { statement . nextException = null ; statement . waitDuration = waitDuration ; failOnTimeout . evaluate ( ) ; }
public void serialize ( ObjectOutputStream s ) throws IOException { ObjectOutputStream . PutField fields = s . putFields ( ) ; fields . put ( " fCount " , fCount ) ; fields . put ( " fIgnoreCount " , fIgnoreCount ) ; fields . put ( " fFailures " , fFailures ) ; fields . put ( " fRunTime " , fRunTime ) ; fields . put ( " fStartTime " , fStartTime ) ; fields . put ( " assumptionFailureCount " , assumptionFailureCount ) ; s . writeFields ( ) ; }
public void testRunFailureResultCanBeReserialised_v4_12 ( ) throws Exception { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( AnnotationTest . FailureTest . class ) ; assertResultReserializable ( result , SerializationFormat . V4_12 ) ; }
public void testRunAssumptionFailedResultCanBeSerialised ( ) throws Exception { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( AssumptionFailedTest . class ) ; assertResultSerializable ( result ) ; }
public void testRunAssumptionFailedResultCanBeReserialised_v4_12 ( ) throws Exception { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( AssumptionFailedTest . class ) ; assertResultReserializable ( result , SerializationFormat . V4_12 ) ; }
public void testRunAssumptionFailedResultCanBeReserialised_v4_13 ( ) throws Exception { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( AssumptionFailedTest . class ) ; assertResultReserializable ( result , SerializationFormat . V4_13 ) ; }
public void testRunSuccessResultCanBeReserialised_v4_12 ( ) throws Exception { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( Success . class ) ; assertResultReserializable ( result , SerializationFormat . V4_12 ) ; }
public void testRunSuccessResultCanBeReserialised_v4_13 ( ) throws Exception { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( Success . class ) ; assertResultReserializable ( result , SerializationFormat . V4_13 ) ; }
private void assertResultSerializable ( Result result ) throws IOException , ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; ObjectOutputStream objectOutputStream = new ObjectOutputStream ( byteArrayOutputStream ) ; objectOutputStream . writeObject ( result ) ; objectOutputStream . flush ( ) ; byte [ ] bytes = byteArrayOutputStream . toByteArray ( ) ; ObjectInputStream objectInputStream = new ObjectInputStream ( new ByteArrayInputStream ( bytes ) ) ; Result fromStream = ( Result ) objectInputStream . readObject ( ) ; assertSerializedCorrectly ( result , fromStream , SerializationFormat . V4_13 ) ; }
private void assertResultReserializable ( Result result , SerializationFormat resourceSerializationFormat ) throws IOException , ClassNotFoundException { String resourceName = getName ( ) ; InputStream resource = getClass ( ) . getResourceAsStream ( resourceName ) ; assertNotNull ( " Could not read resource " + resourceName , resource ) ; ObjectInputStream objectInputStream = new ObjectInputStream ( resource ) ; fromStream = ( Result ) objectInputStream . readObject ( ) ; assertSerializedCorrectly ( new ResultWithFixedRunTime ( result ) , fromStream , resourceSerializationFormat ) ;
public void assumptionFailed ( ) throws Exception { org . junit . Assume . assumeTrue ( false ) ; }
public Integer runWithCheckForSystemExit ( Runnable runnable ) { SecurityManager oldSecurityManager = System . getSecurityManager ( ) ; System . setSecurityManager ( new NoExitSecurityManager ( ) ) ; PrintStream oldOut = System . out ; System . setOut ( new PrintStream ( new ByteArrayOutputStream ( ) ) ) ; try { runnable . run ( ) ;
public void evaluate ( ) throws Throwable { CallableStatement callable = new CallableStatement ( ) ; FutureTask < Throwable > task = new FutureTask < Throwable > ( callable ) ; ThreadGroup threadGroup = new ThreadGroup ( " FailOnTimeoutGroup " ) ; Thread thread = new Thread ( threadGroup , task , " Time - limited test " ) ; try { thread . setDaemon ( true ) ;
private Collection < ThreadGroup > subGroupsOfCurrentThread ( ) { ThreadGroup [ ] subGroups = new ThreadGroup [ 256 ] ; int numGroups = currentThread ( ) . getThreadGroup ( ) . enumerate ( subGroups ) ; return Arrays . asList ( subGroups ) . subList ( 0 , numGroups ) ; }
public void order ( Orderer orderer ) throws InvalidOrderingException { orderer . apply ( fRunner ) ; }
protected Runner createRunner ( ) { return new CustomAllDefaultPossibilitiesBuilder ( ) . safeRunnerForClass ( fTestClass ) ; }
protected Runner createRunner ( ) { Runner runner = request . getRunner ( ) ; try { ordering . apply ( runner ) ; } catch ( InvalidOrderingException e ) { return new ErrorReportingRunner ( ordering . getClass ( ) , e ) ; } return runner ; }
public abstract Runner getRunner ( ) ; public Request filterWith ( Filter filter ) { return new FilterRequest ( this , filter ) ; } public Request filterWith ( Description desiredDescription ) { return filterWith ( Filter . matchMethodDescription ( desiredDescription ) ) ; } public Request sortWith ( Comparator < Description > comparator ) { return new SortingRequest ( this , comparator ) ; } public Request orderWith ( Ordering ordering ) { return new OrderingRequest ( this , ordering ) ; } }
public Request orderWith ( Ordering ordering ) { return new OrderingRequest ( this , ordering ) ; }
public Ordering create ( Context context ) { return this ; }
public int compare ( Description o1 , Description o2 ) { return o1 . getDisplayName ( ) . compareTo ( o2 . getDisplayName ( ) ) ; }
void order ( Orderer orderer ) throws InvalidOrderingException ; }
public List < Description > order ( Collection < Description > descriptions ) throws InvalidOrderingException { List < Description > inOrder = ordering . orderItems ( Collections . unmodifiableCollection ( descriptions ) ) ; if ( ! ordering . validateOrderingIsCorrect ( ) ) { return inOrder ; } Set < Description > uniqueDescriptions = new HashSet < Description > ( descriptions ) ; if ( ! uniqueDescriptions . containsAll ( inOrder ) ) { throw new InvalidOrderingException ( " Ordering added items " ) ; } Set < Description > resultAsSet = new HashSet < Description > ( inOrder ) ; if ( resultAsSet . size ( ) ! = inOrder . size ( ) ) { throw new InvalidOrderingException ( " Ordering duplicated items " ) ; } else if ( ! resultAsSet . containsAll ( uniqueDescriptions ) ) { throw new InvalidOrderingException ( " Ordering removed items " ) ; } return inOrder ; }
public void apply ( Object target ) throws InvalidOrderingException { if ( target instanceof Orderable ) { Orderable orderable = ( Orderable ) target ;
public static Ordering shuffledBy ( final Random random ) { return new Ordering ( ) { @ Override
boolean validateOrderingIsCorrect ( ) { return false ; }
protected List < Description > orderItems ( Collection < Description > descriptions ) { List < Description > shuffled = new ArrayList < Description > ( descriptions ) ; Collections . shuffle ( shuffled , random ) ; return shuffled ; }
public static Ordering definedBy ( Class < ? extends Ordering . Factory > factoryClass , Description annotatedTestClass ) throws InvalidOrderingException { if ( factoryClass = = null ) { throw new NullPointerException ( " factoryClass cannot be null " ) ; } if ( annotatedTestClass = = null ) { throw new NullPointerException ( " annotatedTestClass cannot be null " ) ; } Ordering . Factory factory ; try { Constructor < ? extends Ordering . Factory > constructor = factoryClass . getConstructor ( ) ; factory = constructor . newInstance ( ) ; } catch ( NoSuchMethodException e ) { throw new InvalidOrderingException ( String . format ( CONSTRUCTOR_ERROR_FORMAT , getClassName ( factoryClass ) , factoryClass . getSimpleName ( ) ) ) ; } catch ( Exception e ) { throw new InvalidOrderingException ( " Could not create ordering for " + annotatedTestClass , e ) ; } return definedBy ( factory , annotatedTestClass ) ; }
public static Ordering definedBy ( Ordering . Factory factory , Description annotatedTestClass ) throws InvalidOrderingException { if ( factory = = null ) { throw new NullPointerException ( " factory cannot be null " ) ; } if ( annotatedTestClass = = null ) { throw new NullPointerException ( " annotatedTestClass cannot be null " ) ; } return factory . create ( new Ordering . Context ( annotatedTestClass ) ) ; }
public void apply ( Object target ) throws InvalidOrderingException { if ( target instanceof Orderable ) { Orderable orderable = ( Orderable ) target ;
boolean validateOrderingIsCorrect ( ) { return true ; }
public void apply ( Object target ) { if ( target instanceof Sortable ) { Sortable sortable = ( Sortable ) target ;
protected final List < Description > orderItems ( Collection < Description > descriptions ) { List < Description > sorted = new ArrayList < Description > ( descriptions ) ; Collections . sort ( sorted , this ) ; return sorted ; }
boolean validateOrderingIsCorrect ( ) { return false ; }
public void order ( Orderer orderer ) throws InvalidOrderingException { childrenLock . lock ( ) ; try { List < T > children = getFilteredChildren ( ) ;
public abstract Runner runnerForClass ( Class < ? > testClass ) throws Throwable ; public Runner safeRunnerForClass ( Class < ? > testClass ) { try { Runner runner = runnerForClass ( testClass ) ; if ( runner ! = null ) { configureRunner ( runner ) ; } return runner ; } catch ( Throwable e ) { return new ErrorReportingRunner ( testClass , e ) ; } } private void configureRunner ( Runner runner ) throws InvalidOrderingException { Description description = runner . getDescription ( ) ; OrderWith orderWith = description . getAnnotation ( OrderWith . class ) ; if ( orderWith ! = null ) { Ordering ordering = Ordering . definedBy ( orderWith . value ( ) , description ) ; ordering . apply ( runner ) ; } } Class < ? > addParent ( Class < ? > parent ) throws InitializationError { if ( ! parents . add ( parent ) ) { throw new InitializationError ( String . format ( " class ' % s ' ( possibly indirectly ) contains itself as a SuiteClass " , parent . getName ( ) ) ) ; } return parent ; } void removeParent ( Class < ? > klass ) { parents . remove ( klass ) ; } public List < Runner > runners ( Class < ? > parent , Class < ? > [ ] children ) throws InitializationError { addParent ( parent ) ; try { return runners ( children ) ; } finally { removeParent ( parent ) ; } } public List < Runner > runners ( Class < ? > parent , List < Class < ? > > children ) throws InitializationError { return runners ( parent , children . toArray ( new Class < ? > [ 0 ] ) ) ; } private List < Runner > runners ( Class < ? > [ ] children ) { List < Runner > runners = new ArrayList < Runner > ( ) ; for ( Class < ? > each : children ) { Runner childRunner = safeRunnerForClass ( each ) ; if ( childRunner ! = null ) { runners . add ( childRunner ) ; } } return runners ; } }
public Runner safeRunnerForClass ( Class < ? > testClass ) { try { Runner runner = runnerForClass ( testClass ) ;
private void configureRunner ( Runner runner ) throws InvalidOrderingException { Description description = runner . getDescription ( ) ; OrderWith orderWith = description . getAnnotation ( OrderWith . class ) ; if ( orderWith ! = null ) { Ordering ordering = Ordering . definedBy ( orderWith . value ( ) , description ) ;
public Ordering create ( Ordering . Context context ) { return INSTANCE ; }
protected List < Description > orderItems ( Collection < Description > descriptions ) { List < Description > ordered = new ArrayList < Description > ( descriptions ) ; Collections . sort ( ordered , comparator ) ; return ordered ; }
public static Comparator < Description > alphanumeric ( ) { return ALPHANUMERIC ; }
public void orderingForwardWorksOnTestClassRunner ( ) { Request forward = Request . aClass ( OrderedAlphanumerically . class ) ; new JUnitCore ( ) . run ( forward ) ; assertEquals ( " abc " , log ) ; }
public void orderingBackwardWorksOnTestClassRunner ( ) { Request backward = Request . aClass ( OrderedReverseAlphanumerically . class ) ; new JUnitCore ( ) . run ( backward ) ; assertEquals ( " cba " , log ) ; }
public void orderingForwardWorksOnSuite ( ) { Request forward = Request . aClass ( SuiteOrderedAlphanumerically . class ) ; new JUnitCore ( ) . run ( forward ) ; assertEquals ( " AaAbAcBaBbBc " , log ) ; }
public void orderingBackwardWorksOnSuite ( ) { Request backward = Request . aClass ( SuiteOrderedReverseAlphanumerically . class ) ; new JUnitCore ( ) . run ( backward ) ; assertEquals ( " BcBbBaAcAbAa " , log ) ; }
public void sortingForwardWorksOnTestClassRunner ( ) { Request forward = Request . aClass ( SortedAlphanumerically . class ) ; new JUnitCore ( ) . run ( forward ) ; assertEquals ( " abc " , log ) ; }
public void sortingBackwardWorksOnTestClassRunner ( ) { Request backward = Request . aClass ( SortedReverseAlphanumerically . class ) ; new JUnitCore ( ) . run ( backward ) ; assertEquals ( " cba " , log ) ; }
public static junit . framework . Test suite ( ) { return new JUnit4TestAdapter ( OrderedAlphanumerically . class ) ; }
public static junit . framework . Test suite ( ) { return new JUnit4TestAdapter ( OrderedReverseAlphanumerically . class ) ; }
public void run ( RunNotifier notifier ) { } } @ RunWith ( UnOrderableRunner . class ) public static class UnOrderable { @ Test public void a ( ) { } } @ Test public void unOrderablesAreHandledWithoutCrashing ( ) { Request unordered = Request . aClass ( UnOrderable . class ) . orderWith ( AlphanumericOrdering . INSTANCE ) ; new JUnitCore ( ) . run ( unordered ) ; } } }
public void a ( ) { } } @ Test public void unOrderablesAreHandledWithoutCrashing ( ) { Request unordered = Request . aClass ( UnOrderable . class ) . orderWith ( AlphanumericOrdering . INSTANCE ) ; new JUnitCore ( ) . run ( unordered ) ; } } }
public void unOrderablesAreHandledWithoutCrashing ( ) { Request unordered = Request . aClass ( UnOrderable . class ) . orderWith ( AlphanumericOrdering . INSTANCE ) ; new JUnitCore ( ) . run ( unordered ) ; }
public void orderingForwardWorksOnTestClassRunner ( ) { Request forward = Request . aClass ( OrderMe . class ) . orderWith ( AlphanumericOrdering . INSTANCE ) ; new JUnitCore ( ) . run ( forward ) ; assertEquals ( " abc " , log ) ; }
public void orderingBackwardWorksOnTestClassRunner ( ) { Request backward = Request . aClass ( OrderMe . class ) . orderWith ( new ReverseAlphanumericOrdering ( ) ) ; new JUnitCore ( ) . run ( backward ) ; assertEquals ( " cba " , log ) ; }
public void orderingForwardWorksOnSuite ( ) { Request forward = Request . aClass ( Enclosing . class ) . orderWith ( AlphanumericOrdering . INSTANCE ) ; new JUnitCore ( ) . run ( forward ) ; assertEquals ( " AaAbAcBaBbBc " , log ) ; }
public void orderingBackwardWorksOnSuite ( ) { Request backward = Request . aClass ( Enclosing . class ) . orderWith ( new ReverseAlphanumericOrdering ( ) ) ; new JUnitCore ( ) . run ( backward ) ; assertEquals ( " BcBbBaAcAbAa " , log ) ; }
public void run ( RunNotifier notifier ) { delegate . run ( notifier ) ; }
public void order ( Orderer orderer ) throws InvalidOrderingException { delegate . order ( orderer ) ; }
public void sort ( Sorter sorter ) { delegate . sort ( sorter ) ; }
public void orderingorwardWorksOnTestClassRunner ( ) { Request forward = Request . aClass ( OrderMe . class ) . orderWith ( AlphanumericOrdering . INSTANCE ) ; new JUnitCore ( ) . run ( forward ) ; assertEquals ( " abc " , log ) ; }
public void orderedBackwardWorksOnTestClassRunner ( ) { Request backward = Request . aClass ( OrderMe . class ) . orderWith ( new ReverseAlphanumericOrdering ( ) ) ; new JUnitCore ( ) . run ( backward ) ; assertEquals ( " cba " , log ) ; }
public static junit . framework . Test suite ( ) { return new JUnit4TestAdapter ( OrderMe . class ) ; }
public void orderingForwardWorksOnTestClassRunner ( ) { Request forward = Request . aClass ( OrderMe . class ) . orderWith ( AlphanumericOrdering . INSTANCE ) ; new JUnitCore ( ) . run ( forward ) ; assertEquals ( " abc " , log ) ; }
public Ordering create ( Ordering . Context context ) { return new Sorter ( reverseOrder ( Comparators . alphanumeric ( ) ) ) ; }
private static Comparator < Description > forward ( ) { return Comparators . alphanumeric ( ) ; }
private static Comparator < Description > backward ( ) { return reverseOrder ( Comparators . alphanumeric ( ) ) ; }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static abstract class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; }
public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; }
public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; }
private void save ( ) throws IOException { ObjectOutputStream stream = null ; try { stream = new ObjectOutputStream ( new FileOutputStream ( fHistoryStore ) ) ;
private static boolean isDebugging ( List < String > arguments ) { for ( final String argument : arguments ) { if ( " - Xdebug " . equals ( argument ) | | argument . startsWith ( " - agentlib : jdwp " ) ) { return true ; } } return false ; }
public void alwaysPassesButDeletesRootFolder ( ) { folder . getRoot ( ) . delete ( ) ; }
public void testFailsWhenCreatedFolderCannotBeDeletedButDeletionIsAssured ( ) { TestClass . injectedRule = TemporaryFolder . builder ( ) . assureDeletion ( ) . build ( ) ; PrintableResult result = testResult ( TestClass . class ) ; assertThat ( result , failureCountIs ( 1 ) ) ; assertThat ( result . toString ( ) , containsString ( " Unable to clean up temporary folder " ) ) ; }
public void byDefaultTestDoesNotFailWhenCreatedFolderCannotBeDeleted ( ) { TestClass . injectedRule = new TemporaryFolder ( ) ; PrintableResult result = testResult ( TestClass . class ) ; assertThat ( result , isSuccessful ( ) ) ; }
private boolean tryDelete ( ) { if ( folder = = null ) { return true ; } return recursiveDelete ( folder ) ; }
public void newFolderWithPathContainingFileSeparatorCreatesDirectories ( ) throws IOException { tempFolder . create ( ) ; tempFolder . newFolder ( " temp1 " + File . separator + " temp2 " ) ; File temp1 = new File ( tempFolder . getRoot ( ) , " temp1 " ) ; assertFileIsDirectory ( temp1 ) ; assertFileIsDirectory ( new File ( temp1 , " temp2 " ) ) ; }
public File newFolder ( String . . . paths ) throws IOException { if ( paths . length = = 0 ) { throw new IllegalArgumentException ( " must pass at least one path " ) ; } File root = getRoot ( ) ; for ( String path : paths ) { if ( new File ( path ) . isAbsolute ( ) ) { throw new IOException ( " folder path \ ' " + path + " \ ' is not a relative path " ) ; } } File relativePath = null ; File file = root ; boolean lastMkdirsCallSuccessful = true ; for ( String path : paths ) { relativePath = new File ( relativePath , path ) ; file = new File ( root , relativePath . getPath ( ) ) ; lastMkdirsCallSuccessful = file . mkdirs ( ) ; if ( ! lastMkdirsCallSuccessful & & ! file . isDirectory ( ) ) { throw new IOException ( " could not create a folder with the path \ ' " + relativePath . getPath ( ) + " \ ' " ) ; } } if ( ! lastMkdirsCallSuccessful ) { throw new IOException ( " a folder with the path \ ' " + relativePath . getPath ( ) + " \ ' already exists " ) ; } return file ; }
public void newFolderWithGivenFolderThrowsIOExceptionWhenFolderCannotBeCreated ( ) throws IOException { tempFolder . create ( ) ; assertTrue ( " Could not make folder " + tempFolder . getRoot ( ) + " read only . " , tempFolder . getRoot ( ) . setReadOnly ( ) ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " could not create a folder with the path ' level1 ' " ) ; tempFolder . newFolder ( " level1 " ) ; }
public File newFolder ( String . . . paths ) throws IOException { if ( paths . length = = 0 ) { throw new IllegalArgumentException ( " must pass at least one path " ) ; } File root = getRoot ( ) ; for ( String path : paths ) { if ( new File ( path ) . isAbsolute ( ) ) { throw new IOException ( " folder path \ ' " + path + " \ ' is not a relative path " ) ; } } File relativePath = null ; File file = root ; boolean lastMkdirsCallSuccessful = true ; for ( String path : paths ) { relativePath = new File ( relativePath , path ) ; file = new File ( root , relativePath . getPath ( ) ) ; lastMkdirsCallSuccessful = file . mkdirs ( ) ; if ( ! lastMkdirsCallSuccessful & & ! file . isDirectory ( ) ) { if ( file . exists ( ) ) { throw new IOException ( " a file with the path \ ' " + relativePath . getPath ( ) + " \ ' exists " ) ; } else { throw new IOException ( " could not create a folder with the path \ ' " + relativePath . getPath ( ) + " \ ' " ) ; } } } if ( ! lastMkdirsCallSuccessful ) { throw new IOException ( " a folder with the path \ ' " + relativePath . getPath ( ) + " \ ' already exists " ) ; } return file ; }
public void newFolderWithGivenFolderThrowsIOExceptionIfFileExists ( ) throws IOException { tempFolder . create ( ) ; File file = new File ( tempFolder . getRoot ( ) , " level1 " ) ; assertTrue ( " Could not create " + file , file . createNewFile ( ) ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " a file with the path ' level1 ' exists " ) ; tempFolder . newFolder ( " level1 " ) ; }
protected List < TestRule > classRules ( ) { final List < TestRule > rules = super . classRules ( ) ; rules . add ( new LoggingTestRule ( log , " fromCode " ) ) ; return rules ; }
public void test ( ) { log . append ( " test " ) ; }
public void classRulesModifiableListEmpty ( ) { log . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( ClassRulesModifiableListEmpty . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( " fromCode . begin test fromCode . end " , log . toString ( ) ) ; }
public static TestRule classRule ( ) { return new LoggingTestRule ( log , " classRule " ) ; }
public void classRulesModifiableList ( ) { log . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( ClassRulesModifiableList . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( " fromCode . begin classRule . begin test classRule . end fromCode . end " , log . toString ( ) ) ; }
protected Statement methodBlock ( final FrameworkMethod method ) { Object test ; try { test = new ReflectiveCallable ( ) { @ Override protected Object runReflectiveCall ( ) throws Throwable { return createTest ( method ) ; } } . run ( ) ; } catch ( Throwable e ) { return new Fail ( e ) ; } Statement statement = methodInvoker ( method , test ) ; statement = possiblyExpectingExceptions ( method , test , statement ) ; statement = withPotentialTimeout ( method , test , statement ) ; statement = withBefores ( method , test , statement ) ; statement = withAfters ( method , test , statement ) ; statement = withRules ( method , test , statement ) ; statement = withInterruptIsolation ( statement ) ; return statement ; }
protected Statement classBlock ( final RunNotifier notifier ) { Statement statement = childrenInvoker ( notifier ) ; if ( ! areAllChildrenIgnored ( ) ) { statement = withBeforeClasses ( statement ) ; statement = withAfterClasses ( statement ) ; statement = withClassRules ( statement ) ; statement = withInterruptIsolation ( statement ) ; } return statement ; }
protected final Statement withInterruptIsolation ( final Statement statement ) { return new Statement ( ) { @ Override
public void evaluate ( ) throws Throwable { try { statement . evaluate ( ) ;
public void interruptCurrentThread ( ) { Thread . currentThread ( ) . interrupt ( ) ; }
public void otherTestCaseInterruptingCurrentThread ( ) { Thread . currentThread ( ) . interrupt ( ) ; }
public void currentThreadInterruptedStatusIsClearedAfterEachTestExecution ( ) { log = " " ; JUnitCore jUnitCore = new JUnitCore ( ) ; jUnitCore . addListener ( new RunListener ( ) { @ Override public void testFinished ( Description description ) { log + = Thread . currentThread ( ) . isInterrupted ( ) + " " ; } } ) ; Result result = jUnitCore . run ( TestWithInterrupt . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( " false false " , log ) ; }
public void testFinished ( Description description ) { log + = Thread . currentThread ( ) . isInterrupted ( ) + " " ; }
public static void interruptCurrentThread ( ) { Thread . currentThread ( ) . interrupt ( ) ; }
public void testSuiteFinished ( Description description ) throws Exception { log + = Thread . currentThread ( ) . isInterrupted ( ) ; }
public void currentThreadInterruptedStatusIsClearedAfterEachTestExecution ( ) { core . addListener ( new RunListener ( ) { @ Override public void testFinished ( Description description ) { interruptedFlags . add ( Thread . currentThread ( ) . isInterrupted ( ) ) ; } } ) ; Result result = core . run ( TestWithInterrupt . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( asList ( false , false ) , interruptedFlags ) ; }
public void testFinished ( Description description ) { interruptedFlags . add ( Thread . currentThread ( ) . isInterrupted ( ) ) ; }
public void test ( ) { } } @ Test public void currentThreadInterruptStatusIsClearedAfterSuiteExecution ( ) { core . addListener ( new RunListener ( ) { @ Override public void testSuiteFinished ( Description description ) { interruptedFlags . add ( Thread . currentThread ( ) . isInterrupted ( ) ) ; } } ) ; Request request = Request . aClass ( TestWithInterruptFromAfterClass . class ) ; Result result = core . run ( request ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( singletonList ( false ) , interruptedFlags ) ; } }
public void currentThreadInterruptStatusIsClearedAfterSuiteExecution ( ) { core . addListener ( new RunListener ( ) { @ Override public void testSuiteFinished ( Description description ) { interruptedFlags . add ( Thread . currentThread ( ) . isInterrupted ( ) ) ; } } ) ; Request request = Request . aClass ( TestWithInterruptFromAfterClass . class ) ; Result result = core . run ( request ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( singletonList ( false ) , interruptedFlags ) ; }
public void testSuiteFinished ( Description description ) { interruptedFlags . add ( Thread . currentThread ( ) . isInterrupted ( ) ) ; }
public void accept ( FrameworkMember < ? > member , T value ) { Rule rule = member . getAnnotation ( Rule . class ) ; if ( rule ! = null ) { RuleContainer container = CURRENT_RULE_CONTAINER . get ( ) ; if ( container ! = null ) { container . setOrder ( value , rule . order ( ) ) ; } } result . add ( value ) ; }
public void accept ( FrameworkMember < ? > member , TestRule value ) { ClassRule rule = member . getAnnotation ( ClassRule . class ) ; entries . add ( new RuleContainer . RuleEntry ( value , RuleContainer . RuleEntry . TYPE_TEST_RULE , rule ! = null ? rule . order ( ) : null ) ) ;
public < T > List < T > getAnnotatedFieldValues ( Object test , Class < ? extends Annotation > annotationClass , Class < T > valueClass ) { final List < T > results = new ArrayList < T > ( ) ; collectAnnotatedFieldValues ( test , annotationClass , valueClass , new MemberValueConsumer < T > ( ) { public void accept ( FrameworkMember < ? > member , T value ) { results . add ( value ) ; } } ) ; return results ; }
public void accept ( FrameworkMember < ? > member , T value ) { results . add ( value ) ; }
public < T > List < T > getAnnotatedMethodValues ( Object test , Class < ? extends Annotation > annotationClass , Class < T > valueClass ) { final List < T > results = new ArrayList < T > ( ) ; collectAnnotatedMethodValues ( test , annotationClass , valueClass , new MemberValueConsumer < T > ( ) { public void accept ( FrameworkMember < ? > member , T value ) { results . add ( value ) ; } } ) ; return results ; }
public void objectsWithDifferentReferencesAreNotEqual ( ) { assertNotEquals ( new Object ( ) , new Object ( ) ) ; }
public void rejectClassRuleThatIsImplementationOfMethodRule ( ) { TestClass target = new TestClass ( TestWithClassRuleIsImplementationOfMethodRule . class ) ; CLASS_RULE_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ ClassRule ' classRule ' must implement TestRule . " ) ; }
public void testSuiteFilteringWithUnmodifiableChildList ( ) throws Exception { Runner runner = Request . aClass ( ExampleSuiteWithUnmodifiableChildList . class ) . getRunner ( ) ; Filter filter = notThisMethodName ( " test1 " ) ; try { filter . apply ( runner ) ; } catch ( NoTestsRemainException e ) { return ; } fail ( " Expected ' NoTestsRemainException ' due to complete filtering " ) ; }
public void testFieldsShadowFieldsFromParent ( ) throws Exception { log = " " ; assertThat ( testResult ( SubFieldShadowing . class ) , isSuccessful ( ) ) ; assertEquals ( " sub . rule . before ( ) "
public static void assumeFalse ( boolean b ) { assumeThat ( b , is ( false ) ) ; }
private void assertCompletesNormally ( ) { } @ Test public void assumeTrueWorks ( ) { try { Assume . assumeTrue ( false ) ; fail ( " should throw AssumptionViolatedException " ) ; } catch ( AssumptionViolatedException e ) { assertEquals ( " got : < false > , expected : is < true > " , e . getMessage ( ) ) ; } } @ Test public void assumeFalseWorks ( ) { try { Assume . assumeFalse ( true ) ; fail ( " should throw AssumptionViolatedException " ) ; } catch ( AssumptionViolatedException e ) { assertEquals ( " got : < true > , expected : is < false > " , e . getMessage ( ) ) ; } } public static class HasFailingAssumeInBefore { @ Before public void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforePreventsTestRun ( ) { assertThat ( testResult ( HasFailingAssumeInBefore . class ) , isSuccessful ( ) ) ; } public static class HasFailingAssumeInBeforeClass { @ BeforeClass public static void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforeClassIgnoresClass ( ) { assertThat ( testResult ( HasFailingAssumeInBeforeClass . class ) , isSuccessful ( ) ) ; } public static class AssumptionFailureInConstructor { public AssumptionFailureInConstructor ( ) { assumeTrue ( false ) ; } @ Test public void shouldFail ( ) { fail ( ) ; } } @ Test public void failingAssumptionInConstructorIgnoresClass ( ) { assertThat ( testResult ( AssumptionFailureInConstructor . class ) , isSuccessful ( ) ) ; } public static class TestClassWithAssumptionFailure { @ Test ( expected = IllegalArgumentException . class ) public void assumeWithExpectedException ( ) { assumeTrue ( false ) ; } } @ Test public void assumeWithExpectedExceptionShouldThrowAssumptionViolatedException ( ) { Result result = JUnitCore . runClasses ( TestClassWithAssumptionFailure . class ) ; assertThat ( result . getAssumptionFailureCount ( ) , is ( 1 ) ) ; } final static String message = " Some random message string . " ; final static Throwable e = new Throwable ( ) ; public static class HasAssumeWithMessage { @ Test public void testMethod ( ) { assumeTrue ( message , false ) ; } } @ Test public void assumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessage . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } public static class HasAssumeWithMessageAndCause { @ Test public void testMethod ( ) { assumeNoException ( message , e ) ; } } @ Test public void assumptionsWithMessageAndCause ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessageAndCause . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; assertSame ( failures . get ( 0 ) . getException ( ) . getCause ( ) , e ) ; } public static class HasFailingAssumptionWithMessage { @ Test public void assumptionsFail ( ) { assumeThat ( message , 3 , is ( 4 ) ) ; fail ( ) ; } } @ Test public void failedAssumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasFailingAssumptionWithMessage . class ) ; assertEquals ( 1 , failures . size ( ) ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } private static List < Failure > runAndGetAssumptionFailures ( Class < ? > clazz ) { final List < Failure > failures = new ArrayList < Failure > ( ) ; final JUnitCore core = new JUnitCore ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { failures . add ( failure ) ; } } ) ; core . run ( clazz ) ; return failures ; } }
public void assumeFalseWorks ( ) { try { Assume . assumeFalse ( true ) ;
public void newFolderWithGivenFolderThrowsIOExceptionWhenFolderCannotBeCreated ( ) throws IOException { tempFolder . create ( ) ; assumeTrue ( " Could not make folder " + tempFolder . getRoot ( ) + " read only . " , tempFolder . getRoot ( ) . setReadOnly ( ) ) ; thrown . expect ( IOException . class ) ; thrown . expectMessage ( " could not create a folder with the path ' level1 ' " ) ; tempFolder . newFolder ( " level1 " ) ; }
public void createAnnotationValidator ( ) { ValidateWith validateWith = SampleAnnotationWithValidator . class . getAnnotation ( ValidateWith . class ) ; AnnotationValidator annotationValidator = new AnnotationValidatorFactory ( ) . createAnnotationValidator ( validateWith ) ; assertThat ( annotationValidator , is ( instanceOf ( Validator . class ) ) ) ; }
public void exceptionWhenAnnotationValidatorCantBeCreated ( ) { ValidateWith validateWith = SampleAnnotationWithValidatorThatThrowsException . class . getAnnotation ( ValidateWith . class ) ; exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Exception received when creating AnnotationValidator class " + " org . junit . validator . AnnotationValidatorFactoryTest $ ValidatorThatThrowsException " ) ; new AnnotationValidatorFactory ( ) . createAnnotationValidator ( validateWith ) ; }
public void order ( Orderer orderer ) throws InvalidOrderingException { if ( shouldNotReorder ( ) ) { return ; } childrenLock . lock ( ) ; try { List < T > children = getFilteredChildren ( ) ;
private boolean shouldNotReorder ( ) { return getDescription ( ) . getAnnotation ( FixMethodOrder . class ) ! = null ; }
public void orderingBackwardDoesNothingOnTestClassRunnerWithFixMethodOrder ( ) { Request backward = Request . aClass ( DoNotOrderMe . class ) . orderWith ( new ReverseAlphanumericOrdering ( ) ) ; new JUnitCore ( ) . run ( backward ) ; assertEquals ( " abc " , log ) ; }
public void sortingBackwardDoesNothingOnTestClassRunnerWithFixMethodOrder ( ) { Request backward = Request . aClass ( DoNotSortMe . class ) . sortWith ( backward ( ) ) ; new JUnitCore ( ) . run ( backward ) ; assertEquals ( " abc " , log ) ; }
public void passes ( ) { } } @ RunWith ( JUnit4 . class ) @ OrderWith ( Alphanumeric . class ) @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) public static class TestAnnotatedWithFixMethodOrder { @ Test public void passes ( ) { } } @ Test public void noErrorIsAddedForTestWithoutValdationErrors ( ) { List < Exception > errors = validator . validateAnnotatedClass ( new TestClass ( TestWithNoValidationErrors . class ) ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } @ Test public void errorIsAddedWhenTestAnnotatedWithFixMethodOrder ( ) { List < Exception > errors = validator . validateAnnotatedClass ( new TestClass ( TestAnnotatedWithFixMethodOrder . class ) ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( " @ FixMethodOrder cannot be combined with @ OrderWith " ) ) ; } }
public void passes ( ) { } } @ Test public void noErrorIsAddedForTestWithoutValdationErrors ( ) { List < Exception > errors = validator . validateAnnotatedClass ( new TestClass ( TestWithNoValidationErrors . class ) ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } @ Test public void errorIsAddedWhenTestAnnotatedWithFixMethodOrder ( ) { List < Exception > errors = validator . validateAnnotatedClass ( new TestClass ( TestAnnotatedWithFixMethodOrder . class ) ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( " @ FixMethodOrder cannot be combined with @ OrderWith " ) ) ; } }
public void noErrorIsAddedForTestWithoutValdationErrors ( ) { List < Exception > errors = validator . validateAnnotatedClass ( new TestClass ( TestWithNoValidationErrors . class ) ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; }
public void errorIsAddedWhenTestAnnotatedWithFixMethodOrder ( ) { List < Exception > errors = validator . validateAnnotatedClass ( new TestClass ( TestAnnotatedWithFixMethodOrder . class ) ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( " @ FixMethodOrder cannot be combined with @ OrderWith " ) ) ; }
public static void assertNotEquals ( String message , float unexpected , float actual , float delta ) { if ( ! floatIsDifferent ( unexpected , actual , delta ) ) { failEquals ( message , Float . valueOf ( actual ) ) ;
private static File createTemporaryFolderIn ( File parentFolder ) throws IOException { try { return createTemporaryFolderWithNioApi ( parentFolder ) ;
private static File createTemporaryFolderWithNioApi ( File parentFolder ) throws ClassNotFoundException , NoSuchMethodException , InvocationTargetException , IllegalAccessException { Class < ? > filesClass = Class . forName ( " java . nio . file . Files " ) ; Object fileAttributeArray = Array . newInstance ( Class . forName ( " java . nio . file . attribute . FileAttribute " ) , 0 ) ; Class < ? > pathClass = Class . forName ( " java . nio . file . Path " ) ; Object tempDir ; if ( parentFolder ! = null ) { Method createTempDirectoryMethod = filesClass . getDeclaredMethod ( " createTempDirectory " , pathClass , String . class , fileAttributeArray . getClass ( ) ) ; Object parentPath = File . class . getDeclaredMethod ( " toPath " ) . invoke ( parentFolder ) ; tempDir = createTempDirectoryMethod . invoke ( null , parentPath , TMP_PREFIX , fileAttributeArray ) ; } else { Method createTempDirectoryMethod = filesClass . getDeclaredMethod ( " createTempDirectory " , String . class , fileAttributeArray . getClass ( ) ) ; tempDir = createTempDirectoryMethod . invoke ( null , TMP_PREFIX , fileAttributeArray ) ; } return ( File ) pathClass . getDeclaredMethod ( " toFile " ) . invoke ( tempDir ) ; }
private static File createTemporaryFolderWithFileApi ( File parentFolder ) throws IOException { File createdFolder = null ; for ( int i = 0 ; i < TEMP_DIR_ATTEMPTS ; + + i ) { String suffix = " . tmp " ; File tmpFile = File . createTempFile ( TMP_PREFIX , suffix , parentFolder ) ; String tmpName = tmpFile . toString ( ) ; String folderName = tmpName . substring ( 0 , tmpName . length ( ) - suffix . length ( ) ) ; createdFolder = new File ( folderName ) ; if ( createdFolder . mkdir ( ) ) { tmpFile . delete ( ) ; return createdFolder ; } tmpFile . delete ( ) ; } throw new IOException ( " Unable to create temporary directory in : " + parentFolder . toString ( ) + " . Tried " + TEMP_DIR_ATTEMPTS + " times . "
public void tempFolderIsOnlyAccessibleByOwner ( ) throws IOException { TemporaryFolder folder = new TemporaryFolder ( ) ; folder . create ( ) ; Set < String > expectedPermissions = new TreeSet < String > ( Arrays . asList ( " OWNER_READ " , " OWNER_WRITE " , " OWNER_EXECUTE " ) ) ; Set < String > actualPermissions = getPosixFilePermissions ( folder . getRoot ( ) ) ; assertEquals ( expectedPermissions , actualPermissions ) ; }
public static String id ( ) { return " 4 . 13 . 1 - SNAPSHOT " ; }
public static String id ( ) { return " 4 . 13 . 2 - SNAPSHOT " ; }
public void testAssertEqualsNaNFails ( ) { try { assertEquals ( 1 . 234 , Double . NaN , 0 . 0 ) ; } catch ( AssertionFailedError e ) { return ; } fail ( ) ; }
public void testAssertNaNEqualsFails ( ) { try { assertEquals ( Double . NaN , 1 . 234 , 0 . 0 ) ; } catch ( AssertionFailedError e ) { return ; } fail ( ) ; }
public void testAssertPosInfinityNotEqualsNegInfinity ( ) { try { assertEquals ( Double . POSITIVE_INFINITY , Double . NEGATIVE_INFINITY , 0 . 0 ) ; } catch ( AssertionFailedError e ) { return ; } fail ( ) ; }
public void testAssertPosInfinityNotEquals ( ) { try { assertEquals ( Double . POSITIVE_INFINITY , 1 . 23 , 0 . 0 ) ; } catch ( AssertionFailedError e ) { return ; } fail ( ) ; }
public void testAssertEqualsNaNFails ( ) { try { assertEquals ( 1 . 234f , Float . NaN , 0 . 0 ) ; } catch ( AssertionFailedError e ) { return ; } fail ( ) ; }
public void testAssertNaNEqualsFails ( ) { try { assertEquals ( Float . NaN , 1 . 234f , 0 . 0 ) ; } catch ( AssertionFailedError e ) { return ; } fail ( ) ; }
public void testAssertPosInfinityNotEqualsNegInfinity ( ) { try { assertEquals ( Float . POSITIVE_INFINITY , Float . NEGATIVE_INFINITY , 0 . 0 ) ; } catch ( AssertionFailedError e ) { return ; } fail ( ) ; }
public void testAssertPosInfinityNotEquals ( ) { try { assertEquals ( Float . POSITIVE_INFINITY , 1 . 23f , 0 . 0 ) ; } catch ( AssertionFailedError e ) { return ; } fail ( ) ; }
public void testAllInfinities ( ) { assertEquals ( Float . POSITIVE_INFINITY , Float . NEGATIVE_INFINITY , Float . POSITIVE_INFINITY ) ; }
public void evaluate ( ) throws Throwable { CallableStatement callable = new CallableStatement ( ) ; FutureTask < Throwable > task = new FutureTask < Throwable > ( callable ) ; ThreadGroup threadGroup = new ThreadGroup ( " FailOnTimeoutGroup " ) ; if ( ! threadGroup . isDaemon ( ) ) { try { threadGroup . setDaemon ( true ) ; } catch ( SecurityException e ) { } } Thread thread = new Thread ( threadGroup , task , " Time - limited test " ) ; thread . setDaemon ( true ) ; thread . start ( ) ; callable . awaitStarted ( ) ; Throwable throwable = getResult ( task , thread ) ; if ( throwable ! = null ) { throw throwable ;
private ThrowingRunnable evaluateWithDelegate ( final Statement delegate ) { return new ThrowingRunnable ( ) { public void run ( ) throws Throwable {
public void run ( ) throws Throwable { statement . nextStatement = delegate ; statement . waitDuration = 0 ; failOnTimeout . evaluate ( ) ; }
private ThrowingRunnable evaluateWithException ( Exception exception ) { return evaluateWithDelegate ( new Fail ( exception ) ) ; }
public void run ( ) throws Throwable { statement . nextStatement = null ; statement . waitDuration = waitDuration ; failOnTimeout . evaluate ( ) ; }
public void evaluate ( ) throws Throwable { sleep ( waitDuration ) ; if ( nextStatement ! = null ) { nextStatement . evaluate ( ) ;
public void threadGroupNotLeaked ( ) throws Throwable { final AtomicReference < ThreadGroup > innerThreadGroup = new AtomicReference < ThreadGroup > ( ) ; final AtomicReference < Thread > innerThread = new AtomicReference < Thread > ( ) ; ThrowingRunnable runnable = evaluateWithDelegate ( new Statement ( ) { @ Override public void evaluate ( ) { innerThread . set ( currentThread ( ) ) ; ThreadGroup group = currentThread ( ) . getThreadGroup ( ) ; innerThreadGroup . set ( group ) ; assertTrue ( " the ' FailOnTimeoutGroup ' thread group should be a daemon thread group " , group . isDaemon ( ) ) ; } } ) ; runnable . run ( ) ; assertTrue ( " the Statement was never run " , innerThread . get ( ) ! = null ) ; innerThread . get ( ) . join ( ) ; assertTrue ( " the ' FailOnTimeoutGroup ' thread group should be destroyed after running the test " , innerThreadGroup . get ( ) . isDestroyed ( ) ) ; }
public void evaluate ( ) { innerThread . set ( currentThread ( ) ) ; ThreadGroup group = currentThread ( ) . getThreadGroup ( ) ; innerThreadGroup . set ( group ) ; assertTrue ( " the ' FailOnTimeoutGroup ' thread group should be a daemon thread group " , group . isDaemon ( ) ) ; }
void execTest ( String testClass , boolean success ) throws Exception { String java = System . getProperty ( " java . home " ) + File . separator + " bin " + File . separator + " java " ; String cp = System . getProperty ( " java . class . path " ) ; String [ ] cmd = { java , " - classpath " , cp , " junit . textui . TestRunner " , testClass } ; Process p = Runtime . getRuntime ( ) . exec ( cmd ) ; InputStream i = p . getInputStream ( ) ; while ( ( i . read ( ) ) ! = - 1 ) ; assertTrue ( ( p . waitFor ( ) = = 0 ) = = success ) ; if ( success ) { assertTrue ( p . exitValue ( ) = = 0 ) ;
public synchronized void runFinished ( ) { fActiveTestDeathCount + + ; notifyAll ( ) ; }
public static void fail ( String message ) { if ( message = = null ) { throw new AssertionFailedError ( ) ; } throw new AssertionFailedError ( message ) ; }
public static void assertEquals ( String message , Object expected , Object actual ) { if ( expected = = null & & actual = = null ) { return ; } if ( expected ! = null & & expected . equals ( actual ) ) { return ; } failNotEquals ( message , expected , actual ) ; }
public static void assertEquals ( String message , String expected , String actual ) { if ( expected = = null & & actual = = null ) { return ; } if ( expected ! = null & & expected . equals ( actual ) ) { return ; } String cleanMessage = message = = null ? " " : message ; throw new ComparisonFailure ( cleanMessage , expected , actual ) ; }
public static void assertEquals ( String expected , String actual ) { assertEquals ( null , expected , actual ) ; }
public static void assertEquals ( String message , double expected , double actual , double delta ) { if ( Double . compare ( expected , actual ) = = 0 ) { return ; } if ( ! ( Math . abs ( expected - actual ) < = delta ) ) { failNotEquals ( message , Double . valueOf ( expected ) , Double . valueOf ( actual ) ) ;
public static void assertEquals ( String message , float expected , float actual , float delta ) { if ( Float . compare ( expected , actual ) = = 0 ) { return ; } if ( ! ( Math . abs ( expected - actual ) < = delta ) ) { failNotEquals ( message , Float . valueOf ( expected ) , Float . valueOf ( actual ) ) ;
public static void assertEquals ( String message , long expected , long actual ) { assertEquals ( message , Long . valueOf ( expected ) , Long . valueOf ( actual ) ) ; }
public static void assertEquals ( String message , boolean expected , boolean actual ) { assertEquals ( message , Boolean . valueOf ( expected ) , Boolean . valueOf ( actual ) ) ; }
public static void assertEquals ( boolean expected , boolean actual ) { assertEquals ( null , expected , actual ) ; }
public static void assertEquals ( String message , byte expected , byte actual ) { assertEquals ( message , Byte . valueOf ( expected ) , Byte . valueOf ( actual ) ) ; }
public static void assertEquals ( byte expected , byte actual ) { assertEquals ( null , expected , actual ) ; }
public static void assertEquals ( String message , char expected , char actual ) { assertEquals ( message , Character . valueOf ( expected ) , Character . valueOf ( actual ) ) ; }
public static void assertEquals ( char expected , char actual ) { assertEquals ( null , expected , actual ) ; }
public static void assertEquals ( String message , short expected , short actual ) { assertEquals ( message , Short . valueOf ( expected ) , Short . valueOf ( actual ) ) ; }
public static void assertEquals ( short expected , short actual ) { assertEquals ( null , expected , actual ) ; }
public static void assertEquals ( String message , int expected , int actual ) { assertEquals ( message , Integer . valueOf ( expected ) , Integer . valueOf ( actual ) ) ; }
public static void assertEquals ( int expected , int actual ) { assertEquals ( null , expected , actual ) ; }
public static void assertNull ( Object object ) { if ( object ! = null ) { assertNull ( " Expected : < null > but was : " + object . toString ( ) , object ) ;
public static void assertNull ( String message , Object object ) { assertTrue ( message , object = = null ) ; }
public static void assertNotSame ( String message , Object expected , Object actual ) { if ( expected = = actual ) { failSame ( message ) ;
public static void assertNotSame ( Object expected , Object actual ) { assertNotSame ( null , expected , actual ) ; }
public static void failSame ( String message ) { String formatted = ( message ! = null ) ? message + " " : " " ; fail ( formatted + " expected not same " ) ; }
public static void failNotSame ( String message , Object expected , Object actual ) { String formatted = ( message ! = null ) ? message + " " : " " ; fail ( formatted + " expected same : < " + expected + " > was not : < " + actual + " > " ) ; }
public static void failNotEquals ( String message , Object expected , Object actual ) { fail ( format ( message , expected , actual ) ) ; }
protected abstract void notifyListener ( RunListener each ) throws Exception ; } public void fireTestRunStarted ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testRunStarted ( description ) ; } } . run ( ) ; } public void fireTestRunFinished ( final Result result ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testRunFinished ( result ) ; } } . run ( ) ; } public void fireTestSuiteStarted ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testSuiteStarted ( description ) ; } } . run ( ) ; } public void fireTestSuiteFinished ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testSuiteFinished ( description ) ; } } . run ( ) ; } public void fireTestStarted ( final Description description ) throws StoppedByUserException { if ( pleaseStop ) { throw new StoppedByUserException ( ) ; } new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testStarted ( description ) ; } } . run ( ) ; } public void fireTestFailure ( Failure failure ) { fireTestFailures ( listeners , asList ( failure ) ) ; } private void fireTestFailures ( List < RunListener > listeners , final List < Failure > failures ) { if ( ! failures . isEmpty ( ) ) { new SafeNotifier ( listeners ) { @ Override protected void notifyListener ( RunListener listener ) throws Exception { for ( Failure each : failures ) { listener . testFailure ( each ) ; } } } . run ( ) ; } } public void fireTestAssumptionFailed ( final Failure failure ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testAssumptionFailure ( failure ) ; } } . run ( ) ; } public void fireTestIgnored ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testIgnored ( description ) ; } } . run ( ) ; } public void fireTestFinished ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testFinished ( description ) ; } } . run ( ) ; } public void pleaseStop ( ) { pleaseStop = true ; } public void addFirstListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot add a null listener " ) ; } listeners . add ( 0 , wrapIfNotThreadSafe ( listener ) ) ; } }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public interface MultiA { } public interface MultiB { } public interface MultiC { } @ RunWith ( Categories . class ) @ IncludeCategory ( value = { MultiA . class , MultiB . class } , matchAny = false ) @ SuiteClasses ( AllIncludedMustMatched . class ) public static class AllIncludedMustBeMatchedSuite { } public static class AllIncludedMustMatched { @ Test @ Category ( { MultiA . class , MultiB . class } ) public void a ( ) { } @ Test @ Category ( MultiB . class ) public void b ( ) { fail ( " When multiple categories are included in a Suite , " + " @ Test method must match all include categories " ) ; } } @ Test public void allIncludedSuiteCategoriesMustBeMatched ( ) { Result result = JUnitCore . runClasses ( AllIncludedMustBeMatchedSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( { MultiA . class , MultiB . class } ) @ ExcludeCategory ( MultiC . class ) @ SuiteClasses ( MultipleIncludesAndExcludeOnMethod . class ) public static class MultiIncludeWithExcludeCategorySuite { } public static class MultipleIncludesAndExcludeOnMethod { @ Test @ Category ( { MultiA . class , MultiB . class } ) public void a ( ) { } @ Test @ Category ( { MultiA . class , MultiB . class , MultiC . class } ) public void b ( ) { fail ( " When multiple categories are included and excluded in a Suite , " + " @ Test method must match all include categories and contain non of the excluded " ) ; } } @ Test public void anyMethodWithExcludedCategoryWillBeExcluded ( ) { Result result = JUnitCore . runClasses ( MultiIncludeWithExcludeCategorySuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public abstract static class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { } ) public static class EmptyCategoriesSuite { } @ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; } @ Category ( Runnable . class ) public static class NoTest { } @ Category ( Runnable . class ) public static class IgnoredTest { @ Ignore @ Test public void test ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ SuiteClasses ( { NoTest . class , IgnoredTest . class } ) public static class IgnoredTestCategoriesSuite { } @ Test public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; } @ Category ( Runnable . class ) public static class ExcludedTest1 { @ Test public void test ( ) { fail ( ) ; } } @ Category ( Runnable . class ) public static class ExcludedTest2 { @ Test @ Category ( Runnable . class ) public void test ( ) { fail ( ) ; } } public static class IncludedTest { @ Test @ Category ( Object . class ) public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
public void a ( ) { } @ Test @ Category ( MultiB . class ) public void b ( ) { fail ( " When multiple categories are included in a Suite , " + " @ Test method must match all include categories " ) ; } } @ Test public void allIncludedSuiteCategoriesMustBeMatched ( ) { Result result = JUnitCore . runClasses ( AllIncludedMustBeMatchedSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( { MultiA . class , MultiB . class } ) @ ExcludeCategory ( MultiC . class ) @ SuiteClasses ( MultipleIncludesAndExcludeOnMethod . class ) public static class MultiIncludeWithExcludeCategorySuite { } public static class MultipleIncludesAndExcludeOnMethod { @ Test @ Category ( { MultiA . class , MultiB . class } ) public void a ( ) { } @ Test @ Category ( { MultiA . class , MultiB . class , MultiC . class } ) public void b ( ) { fail ( " When multiple categories are included and excluded in a Suite , " + " @ Test method must match all include categories and contain non of the excluded " ) ; } } @ Test public void anyMethodWithExcludedCategoryWillBeExcluded ( ) { Result result = JUnitCore . runClasses ( MultiIncludeWithExcludeCategorySuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public abstract static class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { } ) public static class EmptyCategoriesSuite { } @ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; } @ Category ( Runnable . class ) public static class NoTest { } @ Category ( Runnable . class ) public static class IgnoredTest { @ Ignore @ Test public void test ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ SuiteClasses ( { NoTest . class , IgnoredTest . class } ) public static class IgnoredTestCategoriesSuite { } @ Test public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; } @ Category ( Runnable . class ) public static class ExcludedTest1 { @ Test public void test ( ) { fail ( ) ; } } @ Category ( Runnable . class ) public static class ExcludedTest2 { @ Test @ Category ( Runnable . class ) public void test ( ) { fail ( ) ; } } public static class IncludedTest { @ Test @ Category ( Object . class ) public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
public void a ( ) { } @ Test @ Category ( { MultiA . class , MultiB . class , MultiC . class } ) public void b ( ) { fail ( " When multiple categories are included and excluded in a Suite , " + " @ Test method must match all include categories and contain non of the excluded " ) ; } } @ Test public void anyMethodWithExcludedCategoryWillBeExcluded ( ) { Result result = JUnitCore . runClasses ( MultiIncludeWithExcludeCategorySuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public abstract static class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { } ) public static class EmptyCategoriesSuite { } @ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; } @ Category ( Runnable . class ) public static class NoTest { } @ Category ( Runnable . class ) public static class IgnoredTest { @ Ignore @ Test public void test ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ SuiteClasses ( { NoTest . class , IgnoredTest . class } ) public static class IgnoredTestCategoriesSuite { } @ Test public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; } @ Category ( Runnable . class ) public static class ExcludedTest1 { @ Test public void test ( ) { fail ( ) ; } } @ Category ( Runnable . class ) public static class ExcludedTest2 { @ Test @ Category ( Runnable . class ) public void test ( ) { fail ( ) ; } } public static class IncludedTest { @ Test @ Category ( Object . class ) public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public abstract static class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { } ) public static class EmptyCategoriesSuite { } @ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; } @ Category ( Runnable . class ) public static class NoTest { } @ Category ( Runnable . class ) public static class IgnoredTest { @ Ignore @ Test public void test ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ SuiteClasses ( { NoTest . class , IgnoredTest . class } ) public static class IgnoredTestCategoriesSuite { } @ Test public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; } @ Category ( Runnable . class ) public static class ExcludedTest1 { @ Test public void test ( ) { fail ( ) ; } } @ Category ( Runnable . class ) public static class ExcludedTest2 { @ Test @ Category ( Runnable . class ) public void test ( ) { fail ( ) ; } } public static class IncludedTest { @ Test @ Category ( Object . class ) public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
private void assertCompletesNormally ( ) { } @ Test public void assumeTrueWorks ( ) { try { Assume . assumeTrue ( false ) ; fail ( " should throw AssumptionViolatedException " ) ; } catch ( AssumptionViolatedException e ) { assertEquals ( " got : < false > , expected : is < true > " , e . getMessage ( ) ) ; } } @ Test public void assumeFalseWorks ( ) { try { Assume . assumeFalse ( true ) ; fail ( " should throw AssumptionViolatedException " ) ; } catch ( AssumptionViolatedException e ) { assertEquals ( " got : < true > , expected : is < false > " , e . getMessage ( ) ) ; } } public static class HasFailingAssumeInBefore { @ Before public void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforePreventsTestRun ( ) { assertThat ( testResult ( HasFailingAssumeInBefore . class ) , isSuccessful ( ) ) ; } public static class HasFailingAssumeInBeforeClass { @ BeforeClass public static void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforeClassIgnoresClass ( ) { assertThat ( testResult ( HasFailingAssumeInBeforeClass . class ) , isSuccessful ( ) ) ; } public static class AssumptionFailureInConstructor { public AssumptionFailureInConstructor ( ) { assumeTrue ( false ) ; } @ Test public void shouldFail ( ) { fail ( ) ; } } @ Test public void failingAssumptionInConstructorIgnoresClass ( ) { assertThat ( testResult ( AssumptionFailureInConstructor . class ) , isSuccessful ( ) ) ; } public static class TestClassWithAssumptionFailure { @ Test ( expected = IllegalArgumentException . class ) public void assumeWithExpectedException ( ) { assumeTrue ( false ) ; } } @ Test public void assumeWithExpectedExceptionShouldThrowAssumptionViolatedException ( ) { Result result = JUnitCore . runClasses ( TestClassWithAssumptionFailure . class ) ; assertThat ( result . getAssumptionFailureCount ( ) , is ( 1 ) ) ; } static final String message = " Some random message string . " ; static final Throwable e = new Throwable ( ) ; public static class HasAssumeWithMessage { @ Test public void testMethod ( ) { assumeTrue ( message , false ) ; } } @ Test public void assumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessage . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } public static class HasAssumeWithMessageAndCause { @ Test public void testMethod ( ) { assumeNoException ( message , e ) ; } } @ Test public void assumptionsWithMessageAndCause ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessageAndCause . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; assertSame ( failures . get ( 0 ) . getException ( ) . getCause ( ) , e ) ; } public static class HasFailingAssumptionWithMessage { @ Test public void assumptionsFail ( ) { assumeThat ( message , 3 , is ( 4 ) ) ; fail ( ) ; } } @ Test public void failedAssumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasFailingAssumptionWithMessage . class ) ; assertEquals ( 1 , failures . size ( ) ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } private static List < Failure > runAndGetAssumptionFailures ( Class < ? > clazz ) { final List < Failure > failures = new ArrayList < Failure > ( ) ; final JUnitCore core = new JUnitCore ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { failures . add ( failure ) ; } } ) ; core . run ( clazz ) ; return failures ; } }
public void yesIndeed ( String a ) { } } @ RunWith ( Theories . class ) public static class BeforeAndAfterEachTime { public static int befores = 0 ; @ DataPoint public static String A = " A " ; @ DataPoint public static String B = " B " ; @ Before public void incrementBefore ( ) { befores + + ; } @ BeforeClass public static void resetCalls ( ) { befores = 0 ; } @ Theory public void stringsAreOK ( String string ) { } @ AfterClass public static void calledTwice ( ) { assertEquals ( 2 , befores ) ; } } @ RunWith ( Theories . class ) public static class OneTestTwoAnnotations { public static int tests = 0 ; @ DataPoint public static String A = " A " ; @ BeforeClass public static void resetCalls ( ) { tests = 0 ; } @ Theory @ Test public void stringsAreOK ( String string ) { tests + + ; } @ AfterClass public static void calledTwice ( ) { assertEquals ( 1 , tests ) ; } } @ RunWith ( Theories . class ) public static class StaticPublicNonDataPoints { @ DataPoint public static int ZERO = 0 ; public static int ONE = 1 ; @ Theory public void onlyAnnotatedFields ( int i ) { assertTrue ( i = = 0 ) ; } } }
public void stringsAreOK ( String string ) { } @ AfterClass public static void calledTwice ( ) { assertEquals ( 2 , befores ) ; } } @ RunWith ( Theories . class ) public static class OneTestTwoAnnotations { public static int tests = 0 ; @ DataPoint public static String A = " A " ; @ BeforeClass public static void resetCalls ( ) { tests = 0 ; } @ Theory @ Test public void stringsAreOK ( String string ) { tests + + ; } @ AfterClass public static void calledTwice ( ) { assertEquals ( 1 , tests ) ; } } @ RunWith ( Theories . class ) public static class StaticPublicNonDataPoints { @ DataPoint public static int ZERO = 0 ; public static int ONE = 1 ; @ Theory public void onlyAnnotatedFields ( int i ) { assertTrue ( i = = 0 ) ; } } }
public static junit . framework . Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( OneTest . class ) ; return suite ; }
public static junit . framework . Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( new JUnit4TestAdapter ( JUnit4Test . class ) ) ; return suite ; }
public static Test suite ( ) { return junit . tests . AllTests . suite ( ) ; }
public void ignored ( ) { } public static junit . framework . Test suite ( ) { return new JUnit4TestAdapter ( CompatibilityTest . class ) ; } } @ Test public void descriptionAndRunNotificationsAreConsistent ( ) { Result result = JUnitCore . runClasses ( CompatibilityTest . class ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; Description description = Request . aClass ( CompatibilityTest . class ) . getRunner ( ) . getDescription ( ) ; assertEquals ( 0 , description . getChildren ( ) . size ( ) ) ; } public static class NewTestSuiteFails { @ Test public void sample ( ) { wasRun = true ; } public static junit . framework . Test suite ( ) { fail ( " called with JUnit 4 runner " ) ; return null ; } } @ Test public void suiteIsUsedWithJUnit4Classes ( ) { wasRun = false ; Result result = JUnitCore . runClasses ( NewTestSuiteFails . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertFalse ( wasRun ) ; } public static class NewTestSuiteNotUsed { private static boolean wasIgnoredRun ; @ Test public void sample ( ) { wasRun = true ; } @ Ignore @ Test public void ignore ( ) { wasIgnoredRun = true ; } public static junit . framework . Test suite ( ) { return new JUnit4TestAdapter ( NewTestSuiteNotUsed . class ) ; } } @ Test public void makeSureSuiteNotUsedWithJUnit4Classes2 ( ) { wasRun = false ; NewTestSuiteNotUsed . wasIgnoredRun = false ; Result res = JUnitCore . runClasses ( NewTestSuiteNotUsed . class ) ; assertTrue ( wasRun ) ; assertFalse ( NewTestSuiteNotUsed . wasIgnoredRun ) ; assertEquals ( 0 , res . getFailureCount ( ) ) ; assertEquals ( 1 , res . getRunCount ( ) ) ; assertEquals ( 0 , res . getIgnoreCount ( ) ) ; } }
public void one ( ) { } @ Test public void two ( ) { } } @ Test public void oneTimeSetup ( ) throws Exception { count = 0 ; Runner runner = Request . method ( OneTimeSetup . class , " one " ) . getRunner ( ) ; Result result = new JUnitCore ( ) . run ( runner ) ; assertEquals ( 1 , count ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedOneTimeSetup { @ Parameters public static List < Object [ ] > params ( ) { return Arrays . asList ( new Object [ ] { 1 } , new Object [ ] { 2 } ) ; } public ParameterizedOneTimeSetup ( int x ) { } @ Test public void one ( ) { } } @ Test public void parameterizedFilterToSingleMethod ( ) throws Exception { count = 0 ; Runner runner = Request . method ( ParameterizedOneTimeSetup . class , " one [ 0 ] " ) . getRunner ( ) ; Result result = new JUnitCore ( ) . run ( runner ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedOneTimeBeforeClass { @ Parameters public static List < Object [ ] > params ( ) { return Arrays . asList ( new Object [ ] { 1 } , new Object [ ] { 2 } ) ; } public ParameterizedOneTimeBeforeClass ( int x ) { } @ BeforeClass public static void once ( ) { count + + ; } @ Test public void one ( ) { } } @ Test public void parameterizedBeforeClass ( ) throws Exception { count = 0 ; JUnitCore . runClasses ( ParameterizedOneTimeBeforeClass . class ) ; assertEquals ( 1 , count ) ; } @ Test public void filteringAffectsPlan ( ) throws Exception { Runner runner = Request . method ( OneTimeSetup . class , " one " ) . getRunner ( ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } @ Test public void nonexistentMethodCreatesFailure ( ) throws Exception { assertEquals ( 1 , new JUnitCore ( ) . run ( Request . method ( OneTimeSetup . class , " thisMethodDontExist " ) ) . getFailureCount ( ) ) ; } @ Test ( expected = NoTestsRemainException . class ) public void filteringAwayEverythingThrowsException ( ) throws NoTestsRemainException { Filterable runner = ( Filterable ) Request . aClass ( OneTimeSetup . class ) . getRunner ( ) ; runner . filter ( new Filter ( ) { @ Override public boolean shouldRun ( Description description ) { return false ; } @ Override public String describe ( ) { return null ; } } ) ; } public static class TestOne { @ Test public void a ( ) { } @ Test public void b ( ) { } } public static class TestTwo { @ Test public void a ( ) { } @ Test public void b ( ) { } } @ RunWith ( Suite . class ) @ SuiteClasses ( { TestOne . class , TestTwo . class } ) public static class OneTwoSuite { } @ Test public void eliminateUnnecessaryTreeBranches ( ) throws Exception { Runner runner = Request . aClass ( OneTwoSuite . class ) . filterWith ( Description . createTestDescription ( TestOne . class , " a " ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) ; assertEquals ( 1 , description . getChildren ( ) . size ( ) ) ; } public static class HasSuiteMethod { @ Test public void a ( ) { } @ Test public void b ( ) { } public static junit . framework . Test suite ( ) { return new JUnit4TestAdapter ( HasSuiteMethod . class ) ; } } @ Test public void classesWithSuiteMethodsAreFiltered ( ) { int testCount = Request . method ( HasSuiteMethod . class , " a " ) . getRunner ( ) . getDescription ( ) . testCount ( ) ; assertThat ( testCount , is ( 1 ) ) ; } }
public void two ( ) { } } @ Test public void oneTimeSetup ( ) throws Exception { count = 0 ; Runner runner = Request . method ( OneTimeSetup . class , " one " ) . getRunner ( ) ; Result result = new JUnitCore ( ) . run ( runner ) ; assertEquals ( 1 , count ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedOneTimeSetup { @ Parameters public static List < Object [ ] > params ( ) { return Arrays . asList ( new Object [ ] { 1 } , new Object [ ] { 2 } ) ; } public ParameterizedOneTimeSetup ( int x ) { } @ Test public void one ( ) { } } @ Test public void parameterizedFilterToSingleMethod ( ) throws Exception { count = 0 ; Runner runner = Request . method ( ParameterizedOneTimeSetup . class , " one [ 0 ] " ) . getRunner ( ) ; Result result = new JUnitCore ( ) . run ( runner ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedOneTimeBeforeClass { @ Parameters public static List < Object [ ] > params ( ) { return Arrays . asList ( new Object [ ] { 1 } , new Object [ ] { 2 } ) ; } public ParameterizedOneTimeBeforeClass ( int x ) { } @ BeforeClass public static void once ( ) { count + + ; } @ Test public void one ( ) { } } @ Test public void parameterizedBeforeClass ( ) throws Exception { count = 0 ; JUnitCore . runClasses ( ParameterizedOneTimeBeforeClass . class ) ; assertEquals ( 1 , count ) ; } @ Test public void filteringAffectsPlan ( ) throws Exception { Runner runner = Request . method ( OneTimeSetup . class , " one " ) . getRunner ( ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } @ Test public void nonexistentMethodCreatesFailure ( ) throws Exception { assertEquals ( 1 , new JUnitCore ( ) . run ( Request . method ( OneTimeSetup . class , " thisMethodDontExist " ) ) . getFailureCount ( ) ) ; } @ Test ( expected = NoTestsRemainException . class ) public void filteringAwayEverythingThrowsException ( ) throws NoTestsRemainException { Filterable runner = ( Filterable ) Request . aClass ( OneTimeSetup . class ) . getRunner ( ) ; runner . filter ( new Filter ( ) { @ Override public boolean shouldRun ( Description description ) { return false ; } @ Override public String describe ( ) { return null ; } } ) ; } public static class TestOne { @ Test public void a ( ) { } @ Test public void b ( ) { } } public static class TestTwo { @ Test public void a ( ) { } @ Test public void b ( ) { } } @ RunWith ( Suite . class ) @ SuiteClasses ( { TestOne . class , TestTwo . class } ) public static class OneTwoSuite { } @ Test public void eliminateUnnecessaryTreeBranches ( ) throws Exception { Runner runner = Request . aClass ( OneTwoSuite . class ) . filterWith ( Description . createTestDescription ( TestOne . class , " a " ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) ; assertEquals ( 1 , description . getChildren ( ) . size ( ) ) ; } public static class HasSuiteMethod { @ Test public void a ( ) { } @ Test public void b ( ) { } public static junit . framework . Test suite ( ) { return new JUnit4TestAdapter ( HasSuiteMethod . class ) ; } } @ Test public void classesWithSuiteMethodsAreFiltered ( ) { int testCount = Request . method ( HasSuiteMethod . class , " a " ) . getRunner ( ) . getDescription ( ) . testCount ( ) ; assertThat ( testCount , is ( 1 ) ) ; } }
public void one ( ) { } } @ Test public void parameterizedFilterToSingleMethod ( ) throws Exception { count = 0 ; Runner runner = Request . method ( ParameterizedOneTimeSetup . class , " one [ 0 ] " ) . getRunner ( ) ; Result result = new JUnitCore ( ) . run ( runner ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class ParameterizedOneTimeBeforeClass { @ Parameters public static List < Object [ ] > params ( ) { return Arrays . asList ( new Object [ ] { 1 } , new Object [ ] { 2 } ) ; } public ParameterizedOneTimeBeforeClass ( int x ) { } @ BeforeClass public static void once ( ) { count + + ; } @ Test public void one ( ) { } } @ Test public void parameterizedBeforeClass ( ) throws Exception { count = 0 ; JUnitCore . runClasses ( ParameterizedOneTimeBeforeClass . class ) ; assertEquals ( 1 , count ) ; } @ Test public void filteringAffectsPlan ( ) throws Exception { Runner runner = Request . method ( OneTimeSetup . class , " one " ) . getRunner ( ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } @ Test public void nonexistentMethodCreatesFailure ( ) throws Exception { assertEquals ( 1 , new JUnitCore ( ) . run ( Request . method ( OneTimeSetup . class , " thisMethodDontExist " ) ) . getFailureCount ( ) ) ; } @ Test ( expected = NoTestsRemainException . class ) public void filteringAwayEverythingThrowsException ( ) throws NoTestsRemainException { Filterable runner = ( Filterable ) Request . aClass ( OneTimeSetup . class ) . getRunner ( ) ; runner . filter ( new Filter ( ) { @ Override public boolean shouldRun ( Description description ) { return false ; } @ Override public String describe ( ) { return null ; } } ) ; } public static class TestOne { @ Test public void a ( ) { } @ Test public void b ( ) { } } public static class TestTwo { @ Test public void a ( ) { } @ Test public void b ( ) { } } @ RunWith ( Suite . class ) @ SuiteClasses ( { TestOne . class , TestTwo . class } ) public static class OneTwoSuite { } @ Test public void eliminateUnnecessaryTreeBranches ( ) throws Exception { Runner runner = Request . aClass ( OneTwoSuite . class ) . filterWith ( Description . createTestDescription ( TestOne . class , " a " ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) ; assertEquals ( 1 , description . getChildren ( ) . size ( ) ) ; } public static class HasSuiteMethod { @ Test public void a ( ) { } @ Test public void b ( ) { } public static junit . framework . Test suite ( ) { return new JUnit4TestAdapter ( HasSuiteMethod . class ) ; } } @ Test public void classesWithSuiteMethodsAreFiltered ( ) { int testCount = Request . method ( HasSuiteMethod . class , " a " ) . getRunner ( ) . getDescription ( ) . testCount ( ) ; assertThat ( testCount , is ( 1 ) ) ; } }
public void a ( ) { } @ Test public void b ( ) { } } public static class B { @ Test public void a ( ) { } @ Test public void b ( ) { } @ Test public void c ( ) { } } public abstract static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void b ( ) { } } public static class B { @ Test public void a ( ) { } @ Test public void b ( ) { } @ Test public void c ( ) { } } public abstract static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void a ( ) { } @ Test public void b ( ) { } @ Test public void c ( ) { } } public abstract static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void b ( ) { } @ Test public void c ( ) { } } public abstract static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void c ( ) { } } public abstract static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) public static class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } public static class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public abstract static class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) public static class AdditionTestWithArray { @ Parameters ( name = " { index } : { 0 } + { 1 } = { 2 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 , 0 } , { 1 , 1 , 2 } , { 3 , 2 , 5 } , { 4 , 3 , 7 } } ; } @ Parameter ( 0 ) public int firstSummand ; @ Parameter ( 1 ) public int secondSummand ; @ Parameter ( 2 ) public int sum ; @ Test public void test ( ) { assertEquals ( sum , firstSummand + secondSummand ) ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( AdditionTestWithArray . class ) ; assertEquals ( 4 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } public static class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public abstract static class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class SingleArgumentTestWithIterable { private static final AtomicBoolean dataCalled = new AtomicBoolean ( false ) ; @ Parameters public static Iterable < ? extends Object > data ( ) { if ( ! dataCalled . compareAndSet ( false , true ) ) { fail ( " Should not call @ Parameters method more than once " ) ; } return new OneShotIterable < String > ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } public static class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public abstract static class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } private static class OneShotIterable < T > implements Iterable < T > { private final Iterable < T > delegate ; private final AtomicBoolean iterated = new AtomicBoolean ( false ) ; OneShotIterable ( Iterable < T > delegate ) { this . delegate = delegate ; } public Iterator < T > iterator ( ) { if ( iterated . compareAndSet ( false , true ) ) { return delegate . iterator ( ) ; } throw new IllegalStateException ( " Cannot call iterator ( ) more than once " ) ; } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) public static class SingleArgumentTestWithCollection { @ Parameters public static Iterable < ? extends Object > data ( ) { return Collections . unmodifiableCollection ( asList ( " first test " , " second test " ) ) ; } public SingleArgumentTestWithCollection ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfCollection ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithCollection . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } public static class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public static class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) public abstract static class UseParameterizedFactoryAbstractTest { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } } public static class UseParameterizedFactoryTest extends UseParameterizedFactoryAbstractTest { public UseParameterizedFactoryTest ( String parameter ) { } @ Test public void parameterizedTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotationInSuperClass ( ) { assertTestCreatesSingleFailureWithMessage ( UseParameterizedFactoryTest . class , " Called ExceptionThrowingRunnerFactory . " ) ; } @ RunWith ( Parameterized . class ) public static class AssumptionInParametersMethod { static boolean assumptionFails ; @ Parameters public static Iterable < String > data ( ) { assumeFalse ( assumptionFails ) ; return Collections . singletonList ( " foobar " ) ; } public AssumptionInParametersMethod ( String parameter ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } } @ Test public void testsAreExecutedWhenAssumptionInParametersMethodDoesNotFail ( ) { AssumptionInParametersMethod . assumptionFails = false ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 0 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void testsAreNotExecutedWhenAssumptionInParametersMethodFails ( ) { AssumptionInParametersMethod . assumptionFails = true ; Result result = JUnitCore . runClasses ( AssumptionInParametersMethod . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getAssumptionFailureCount ( ) ) ; assertEquals ( 0 , result . getIgnoreCount ( ) ) ; assertEquals ( 0 , result . getRunCount ( ) ) ; } }
