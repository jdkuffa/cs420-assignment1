public void notPublic ( ) { } } @ Test public void dontValidateShadowedMethods ( ) throws Exception { List < Throwable > problems = validateAllMethods ( SubShadows . class ) ; assertTrue ( problems . isEmpty ( ) ) ; } private List < Throwable > validateAllMethods ( Class < ? > clazz ) { try { new BlockJUnit4ClassRunner ( clazz ) ; } catch ( InitializationError e ) { return e . getCauses ( ) ; } return Collections . emptyList ( ) ; } static public class IgnoredTest { @ Test public void valid ( ) { } @ Ignore @ Test public void ignored ( ) { } @ Ignore ( " For testing purposes " ) @ Test public void withReason ( ) { } } @ Test public void ignoreRunner ( ) { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( IgnoredTest . class ) ; assertEquals ( 2 , result . getIgnoreCount ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( IgnoredTest . class ) . run ( result ) ; assertEquals ( 1 , result . runCount ( ) ) ; } public static class Confused { @ Test public void a ( Object b ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void overloaded ( ) throws InitializationError { new BlockJUnit4ClassRunner ( Confused . class ) ; } public static class ConstructorParameter { public ConstructorParameter ( Object something ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void constructorParameter ( ) throws InitializationError { new BlockJUnit4ClassRunner ( ConstructorParameter . class ) ; } public static class OnlyTestIsIgnored { @ Ignore @ Test public void ignored ( ) { } } @ Test public void onlyIgnoredMethodsIsStillFineTestClass ( ) { Result result = JUnitCore . runClasses ( OnlyTestIsIgnored . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 1 , result . getIgnoreCount ( ) ) ; } }
public void dontValidateShadowedMethods ( ) throws Exception { List < Throwable > problems = validateAllMethods ( SubShadows . class ) ; assertTrue ( problems . isEmpty ( ) ) ; }
public void valid ( ) { } @ Ignore @ Test public void ignored ( ) { } @ Ignore ( " For testing purposes " ) @ Test public void withReason ( ) { } } @ Test public void ignoreRunner ( ) { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( IgnoredTest . class ) ; assertEquals ( 2 , result . getIgnoreCount ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( IgnoredTest . class ) . run ( result ) ; assertEquals ( 1 , result . runCount ( ) ) ; } public static class Confused { @ Test public void a ( Object b ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void overloaded ( ) throws InitializationError { new BlockJUnit4ClassRunner ( Confused . class ) ; } public static class ConstructorParameter { public ConstructorParameter ( Object something ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void constructorParameter ( ) throws InitializationError { new BlockJUnit4ClassRunner ( ConstructorParameter . class ) ; } public static class OnlyTestIsIgnored { @ Ignore @ Test public void ignored ( ) { } } @ Test public void onlyIgnoredMethodsIsStillFineTestClass ( ) { Result result = JUnitCore . runClasses ( OnlyTestIsIgnored . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 1 , result . getIgnoreCount ( ) ) ; } }
public void ignored ( ) { } @ Ignore ( " For testing purposes " ) @ Test public void withReason ( ) { } } @ Test public void ignoreRunner ( ) { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( IgnoredTest . class ) ; assertEquals ( 2 , result . getIgnoreCount ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( IgnoredTest . class ) . run ( result ) ; assertEquals ( 1 , result . runCount ( ) ) ; } public static class Confused { @ Test public void a ( Object b ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void overloaded ( ) throws InitializationError { new BlockJUnit4ClassRunner ( Confused . class ) ; } public static class ConstructorParameter { public ConstructorParameter ( Object something ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void constructorParameter ( ) throws InitializationError { new BlockJUnit4ClassRunner ( ConstructorParameter . class ) ; } public static class OnlyTestIsIgnored { @ Ignore @ Test public void ignored ( ) { } } @ Test public void onlyIgnoredMethodsIsStillFineTestClass ( ) { Result result = JUnitCore . runClasses ( OnlyTestIsIgnored . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 1 , result . getIgnoreCount ( ) ) ; } }
public void withReason ( ) { } } @ Test public void ignoreRunner ( ) { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( IgnoredTest . class ) ; assertEquals ( 2 , result . getIgnoreCount ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( IgnoredTest . class ) . run ( result ) ; assertEquals ( 1 , result . runCount ( ) ) ; } public static class Confused { @ Test public void a ( Object b ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void overloaded ( ) throws InitializationError { new BlockJUnit4ClassRunner ( Confused . class ) ; } public static class ConstructorParameter { public ConstructorParameter ( Object something ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void constructorParameter ( ) throws InitializationError { new BlockJUnit4ClassRunner ( ConstructorParameter . class ) ; } public static class OnlyTestIsIgnored { @ Ignore @ Test public void ignored ( ) { } } @ Test public void onlyIgnoredMethodsIsStillFineTestClass ( ) { Result result = JUnitCore . runClasses ( OnlyTestIsIgnored . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 1 , result . getIgnoreCount ( ) ) ; } }
public void ignoreRunner ( ) { JUnitCore runner = new JUnitCore ( ) ; Result result = runner . run ( IgnoredTest . class ) ; assertEquals ( 2 , result . getIgnoreCount ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; }
public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( IgnoredTest . class ) . run ( result ) ; assertEquals ( 1 , result . runCount ( ) ) ; }
public void a ( Object b ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void overloaded ( ) throws InitializationError { new BlockJUnit4ClassRunner ( Confused . class ) ; } public static class ConstructorParameter { public ConstructorParameter ( Object something ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void constructorParameter ( ) throws InitializationError { new BlockJUnit4ClassRunner ( ConstructorParameter . class ) ; } public static class OnlyTestIsIgnored { @ Ignore @ Test public void ignored ( ) { } } @ Test public void onlyIgnoredMethodsIsStillFineTestClass ( ) { Result result = JUnitCore . runClasses ( OnlyTestIsIgnored . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 1 , result . getIgnoreCount ( ) ) ; } }
public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void overloaded ( ) throws InitializationError { new BlockJUnit4ClassRunner ( Confused . class ) ; } public static class ConstructorParameter { public ConstructorParameter ( Object something ) { } @ Test public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void constructorParameter ( ) throws InitializationError { new BlockJUnit4ClassRunner ( ConstructorParameter . class ) ; } public static class OnlyTestIsIgnored { @ Ignore @ Test public void ignored ( ) { } } @ Test public void onlyIgnoredMethodsIsStillFineTestClass ( ) { Result result = JUnitCore . runClasses ( OnlyTestIsIgnored . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 1 , result . getIgnoreCount ( ) ) ; } }
public void overloaded ( ) throws InitializationError { new BlockJUnit4ClassRunner ( Confused . class ) ; }
public void a ( ) { } } @ Test ( expected = InitializationError . class ) public void constructorParameter ( ) throws InitializationError { new BlockJUnit4ClassRunner ( ConstructorParameter . class ) ; } public static class OnlyTestIsIgnored { @ Ignore @ Test public void ignored ( ) { } } @ Test public void onlyIgnoredMethodsIsStillFineTestClass ( ) { Result result = JUnitCore . runClasses ( OnlyTestIsIgnored . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 1 , result . getIgnoreCount ( ) ) ; } }
public void constructorParameter ( ) throws InitializationError { new BlockJUnit4ClassRunner ( ConstructorParameter . class ) ; }
public void ignored ( ) { } } @ Test public void onlyIgnoredMethodsIsStillFineTestClass ( ) { Result result = JUnitCore . runClasses ( OnlyTestIsIgnored . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 1 , result . getIgnoreCount ( ) ) ; } }
public void onlyIgnoredMethodsIsStillFineTestClass ( ) { Result result = JUnitCore . runClasses ( OnlyTestIsIgnored . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertEquals ( 1 , result . getIgnoreCount ( ) ) ; }
public void failureWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( FailureWithTimeoutTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertEquals ( AssertionError . class , result . getFailures ( ) . get ( 0 ) . getException ( ) . getClass ( ) ) ; }
public void failure ( ) { throw new NullPointerException ( ) ; }
public void failureWithTimeoutRunTimeException ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( FailureWithTimeoutRunTimeExceptionTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertEquals ( NullPointerException . class , result . getFailures ( ) . get ( 0 ) . getException ( ) . getClass ( ) ) ; }
public void success ( ) { } } @ Test public void successWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( SuccessWithTimeoutTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } static public class TimeoutFailureTest { @ Test ( timeout = 100 ) public void success ( ) throws InterruptedException { Thread . sleep ( 40000 ) ; } } @ Ignore ( " was breaking gump " ) @ Test public void timeoutFailure ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeoutFailureTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertEquals ( InterruptedException . class , result . getFailures ( ) . get ( 0 ) . getException ( ) . getClass ( ) ) ; } static public class InfiniteLoopTest { @ Test ( timeout = 100 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { } } } } @ Test public void infiniteLoop ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertTrue ( exception . getMessage ( ) . contains ( " test timed out after 100 milliseconds " ) ) ; } static public class ImpatientLoopTest { @ Test ( timeout = 1 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) ; } } @ Ignore ( " This breaks sporadically with time differences just slightly more than 200ms " ) @ Test public void infiniteLoopRunsForApproximatelyLengthOfTimeout ( ) throws Exception { JUnitCore . runClasses ( InfiniteLoopTest . class , ImpatientLoopTest . class ) ; long longTime = runAndTime ( InfiniteLoopTest . class ) ; long shortTime = runAndTime ( ImpatientLoopTest . class ) ; long difference = longTime - shortTime ; assertTrue ( String . format ( " Difference was % sms " , difference ) , difference < 200 ) ; } private long runAndTime ( Class < ? > clazz ) { JUnitCore core = new JUnitCore ( ) ; long startTime = System . currentTimeMillis ( ) ; core . run ( clazz ) ; long totalTime = System . currentTimeMillis ( ) - startTime ; return totalTime ; } @ Test public void stalledThreadAppearsInStackTrace ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; assertThat ( buffer . toString ( ) , containsString ( " infiniteLoop " ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( InfiniteLoopTest . class ) . run ( result ) ; assertEquals ( 1 , result . errorCount ( ) ) ; } public static class WillTimeOut { static boolean afterWasCalled = false ; @ Test ( timeout = 1 ) public void test ( ) { for ( ; ; ) { try { Thread . sleep ( 10000 ) ; } catch ( InterruptedException e ) { } } } @ After public void after ( ) { afterWasCalled = true ; } } @ Test public void makeSureAfterIsCalledAfterATimeout ( ) { JUnitCore . runClasses ( WillTimeOut . class ) ; assertThat ( WillTimeOut . afterWasCalled , is ( true ) ) ; } }
public void successWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( SuccessWithTimeoutTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; }
public void success ( ) throws InterruptedException { Thread . sleep ( 40000 ) ; }
public void timeoutFailure ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeoutFailureTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertEquals ( InterruptedException . class , result . getFailures ( ) . get ( 0 ) . getException ( ) . getClass ( ) ) ; }
public void failure ( ) { infiniteLoop ( ) ; }
private void infiniteLoop ( ) { for ( ; ; ) { try {
public void infiniteLoop ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertTrue ( exception . getMessage ( ) . contains ( " test timed out after 100 milliseconds " ) ) ; }
private void infiniteLoop ( ) { for ( ; ; ) ; }
public void infiniteLoopRunsForApproximatelyLengthOfTimeout ( ) throws Exception { JUnitCore . runClasses ( InfiniteLoopTest . class , ImpatientLoopTest . class ) ; long longTime = runAndTime ( InfiniteLoopTest . class ) ; long shortTime = runAndTime ( ImpatientLoopTest . class ) ; long difference = longTime - shortTime ; assertTrue ( String . format ( " Difference was % sms " , difference ) , difference < 200 ) ; }
private long runAndTime ( Class < ? > clazz ) { JUnitCore core = new JUnitCore ( ) ; long startTime = System . currentTimeMillis ( ) ; core . run ( clazz ) ; long totalTime = System . currentTimeMillis ( ) - startTime ; return totalTime ; }
public void stalledThreadAppearsInStackTrace ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; assertThat ( buffer . toString ( ) , containsString ( " infiniteLoop " ) ) ; }
public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( InfiniteLoopTest . class ) . run ( result ) ; assertEquals ( 1 , result . errorCount ( ) ) ; }
public void test ( ) { for ( ; ; ) { try {
public void after ( ) { afterWasCalled = true ; }
public void makeSureAfterIsCalledAfterATimeout ( ) { JUnitCore . runClasses ( WillTimeOut . class ) ; assertThat ( WillTimeOut . afterWasCalled , is ( true ) ) ; }
public void someTest ( ) { } } ; @ RunWith ( JUnit4ClassRunner . class ) public static class BadBeforeMethodWithLegacyRunner { @ Before void before ( ) { } @ Test public void someTest ( ) { } } ; public static class NoTests { } @ Test public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; } @ Test public void noRunnableMethods ( ) { assertEquals ( " No runnable methods " , exceptionMessageFrom ( NoTests . class ) ) ; } @ Test public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ; } private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; } }
void before ( ) { } @ Test public void someTest ( ) { } } ; public static class NoTests { } @ Test public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; } @ Test public void noRunnableMethods ( ) { assertEquals ( " No runnable methods " , exceptionMessageFrom ( NoTests . class ) ) ; } @ Test public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ; } private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; } }
public void someTest ( ) { } } ; public static class NoTests { } @ Test public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; } @ Test public void noRunnableMethods ( ) { assertEquals ( " No runnable methods " , exceptionMessageFrom ( NoTests . class ) ) ; } @ Test public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ; } private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; } }
public void constructorException ( ) { String message = exceptionMessageFrom ( FaultyConstructor . class ) ; assertEquals ( " Thrown during construction " , message ) ; }
public void noRunnableMethods ( ) { assertEquals ( " No runnable methods " , exceptionMessageFrom ( NoTests . class ) ) ; }
public void badBeforeMethodWithLegacyRunner ( ) { assertEquals ( " Method before should be public " , exceptionMessageFrom ( BadBeforeMethodWithLegacyRunner . class ) ) ;
private String exceptionMessageFrom ( Class < ? > testClass ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( testClass ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; String message = failure . getException ( ) . getMessage ( ) ; return message ; }
public void foo ( ) { } } @ Test public void failedConstructionIsTestFailure ( ) { Result result = JUnitCore . runClasses ( CantConstruct . class ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; Description expected = Description . createTestDescription ( CantConstruct . class , " foo " ) ; Assert . assertEquals ( expected , failure . getDescription ( ) ) ; } }
public void failedConstructionIsTestFailure ( ) { Result result = JUnitCore . runClasses ( CantConstruct . class ) ; Failure failure = result . getFailures ( ) . get ( 0 ) ; Description expected = Description . createTestDescription ( CantConstruct . class , " foo " ) ; Assert . assertEquals ( expected , failure . getDescription ( ) ) ; }
public void inaccessibleBaseClassIsCaughtAtValidation ( ) throws InitializationError { new BlockJUnit4ClassRunner ( Sub . class ) ; }
protected int a ( ) { return 0 ; }
public void initializationErrorIsOnCorrectClass ( ) { assertEquals ( WrongBeforeClass . class . getName ( ) , Request . aClass ( WrongBeforeClass . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ;
public void before ( ) { } @ Test public void hereBecauseEveryTestClassNeedsATest ( ) { } } @ Test public void nonStaticBeforeClass ( ) { Result result = JUnitCore . runClasses ( NonStaticBeforeClass . class ) ; assertEquals ( " Method before ( ) should be static " , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } }
public void hereBecauseEveryTestClassNeedsATest ( ) { } } @ Test public void nonStaticBeforeClass ( ) { Result result = JUnitCore . runClasses ( NonStaticBeforeClass . class ) ; assertEquals ( " Method before ( ) should be static " , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } }
public void nonStaticBeforeClass ( ) { Result result = JUnitCore . runClasses ( NonStaticBeforeClass . class ) ; assertEquals ( " Method before ( ) should be static " , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; }
public boolean canAcceptValue ( Object candidate ) { return ( candidate = = null ) ? ! type . isPrimitive ( ) : canAcceptType ( candidate . getClass ( ) ) ; }
public void dataPointsArrayFieldMayContainNullValue ( ) throws SecurityException , NoSuchMethodException { List < PotentialAssignment > valueSources = new AllMembersSupplier ( new TestClass ( HasDataPointsFieldWithNullValue . class ) ) . getValueSources ( ParameterSignature . signatures ( HasDataPointsFieldWithNullValue . class . getConstructor ( Object . class ) ) . get ( 0 ) ) ; assertThat ( valueSources . size ( ) , is ( 2 ) ) ; }
public void dataPointsArrayMethodMayContainNullValue ( ) throws SecurityException , NoSuchMethodException { List < PotentialAssignment > valueSources = new AllMembersSupplier ( new TestClass ( HasDataPointsMethodWithNullValue . class ) ) . getValueSources ( ParameterSignature . signatures ( HasDataPointsMethodWithNullValue . class . getConstructor ( Integer . class ) ) . get ( 0 ) ) ; assertThat ( valueSources . size ( ) , is ( 2 ) ) ; }
private void skippedQuietly ( AssumptionViolatedException e , Description description , List < Throwable > errors ) { try { skipped ( e , description ) ;
public void evaluate ( ) throws Throwable { List < Throwable > errors = new ArrayList < Throwable > ( ) ; startingQuietly ( description , errors ) ; try { base . evaluate ( ) ; succeededQuietly ( description , errors ) ; } catch ( AssumptionViolatedException e ) { errors . add ( e ) ; skippedQuietly ( e , description , errors ) ; } catch ( Throwable t ) { errors . add ( t ) ; failedQuietly ( t , description , errors ) ; } finally { finishedQuietly ( description , errors ) ; } MultipleFailureException . assertEmpty ( errors ) ; }
private void skippedQuietly ( AssumptionViolatedException e , Description description , List < Throwable > errors ) { try { skipped ( e , description ) ;
protected void skipped ( AssumptionViolatedException e , Description description ) { throw new RuntimeException ( " watcher failure " ) ; }
public void fails ( ) { throw new AssumptionViolatedException ( " test failure " ) ; }
public void testWatcherSkippedThrowsException ( ) { PrintableResult result = testResult ( TestWatcherSkippedThrowsExceptionTest . class ) ; assertThat ( result , failureCountIs ( 2 ) ) ; assertThat ( result , hasFailureContaining ( " test failure " ) ) ; assertThat ( result , hasFailureContaining ( " watcher failure " ) ) ; }
public void testRunStarted ( Description description ) throws Exception { fStartTime . set ( System . currentTimeMillis ( ) ) ; }
public void testRunFinished ( Result result ) throws Exception { long endTime = System . currentTimeMillis ( ) ; fRunTime . addAndGet ( endTime - fStartTime . get ( ) ) ; }
private void failDueToMissingException ( ) throws AssertionError { String failureMessage ; if ( isMissingExceptionMessageEmpty ( ) ) { String expectation = StringDescription . toString ( fMatcherBuilder . build ( ) ) ; failureMessage = " Expected test to throw " + expectation ; } else { failureMessage = missingExceptionMessage ; } fail ( failureMessage ) ; }
private boolean isMissingExceptionMessageEmpty ( ) { return missingExceptionMessage = = null | | missingExceptionMessage . isEmpty ( ) ; }
public void throwsNothing ( ) { } } public static class ThrowExceptionWithExpectedType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new NullPointerException ( ) ; } } public static class ThrowExceptionWithExpectedPartOfMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerExceptionWithMessage ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( ARBITRARY_MESSAGE ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " something else " ) ; } } public static class ThrowExceptionWithWrongType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new IllegalArgumentException ( ) ; } } public static class HasWrongMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expectMessage ( " expectedMessage " ) ; throw new IllegalArgumentException ( " actualMessage " ) ; } } public static class ThrowNoExceptionButExpectExceptionWithType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; } } public static class WronglyExpectsExceptionMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowAnything ( ) { thrown . expectMessage ( " anything ! " ) ; } } public static class ExpectsSubstring { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( " This could throw anything ! ( as long as it has the right substring ) " ) ; } } public static class ExpectsSubstringNullMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( ) ; } } public static class ExpectsMessageMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( startsWith ( ARBITRARY_MESSAGE ) ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " ! " ) ; } } public static class ExpectedMessageMatcherFails { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( equalTo ( " Wrong start " ) ) ; throw new NullPointerException ( " Back ! " ) ; } } public static class ExpectsMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( any ( Exception . class ) ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class ExpectsMultipleMatchers { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class FailAndDontHandleAssertinErrors { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void violatedAssumption ( ) { thrown . expect ( IllegalArgumentException . class ) ; fail ( ARBITRARY_MESSAGE ) ; } } public static class ThrowUnexpectedAssertionError { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void wrongException ( ) { thrown . handleAssertionErrors ( ) ; thrown . expect ( NullPointerException . class ) ; throw new AssertionError ( " the unexpected assertion error " ) ; } } public static class ThrowExpectedAssertionError { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void wrongException ( ) { thrown . handleAssertionErrors ( ) ; thrown . expect ( AssertionError . class ) ; throw new AssertionError ( " the expected assertion error " ) ; } } public static class ViolateAssumptionAndExpectException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void violatedAssumption ( ) { thrown . expect ( NullPointerException . class ) ; assumeTrue ( false ) ; } } public static class ThrowAssumptionViolatedExceptionButExpectOtherType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void wrongException ( ) { thrown . handleAssumptionViolatedExceptions ( ) ; thrown . expect ( NullPointerException . class ) ; throw new AssumptionViolatedException ( " " ) ; } } public static class ThrowExpectedAssumptionViolatedException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExpectAssumptionViolatedException ( ) { thrown . handleAssumptionViolatedExceptions ( ) ; thrown . expect ( AssumptionViolatedException . class ) ; throw new AssumptionViolatedException ( " " ) ; } } public static class ThrowExceptionWithMatchingCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExceptionWithMatchingCause ( ) { NullPointerException expectedCause = new NullPointerException ( " expected cause " ) ; thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( expectedCause ) ) ; throw new IllegalArgumentException ( " Ack ! " , expectedCause ) ; } } public static class ThrowExpectedNullCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExpectedNullCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( nullValue ( Throwable . class ) ) ; throw new IllegalArgumentException ( " Ack ! " ) ; } } public static class ThrowUnexpectedCause { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void throwWithCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( new NullPointerException ( " expected cause " ) ) ) ; throw new IllegalArgumentException ( " Ack ! " , new NullPointerException ( " an unexpected cause " ) ) ; } } public static class CustomMessageWithoutExpectedException { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void throwWithCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . setMissingExceptionMessage ( ARBITRARY_MESSAGE ) ; } } }
public void throwWithCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . setMissingExceptionMessage ( ARBITRARY_MESSAGE ) ; }
public void throwsNothing ( ) { } } public static class ThrowExceptionWithExpectedType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new NullPointerException ( ) ; } } public static class ThrowExceptionWithExpectedPartOfMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerExceptionWithMessage ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( ARBITRARY_MESSAGE ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " something else " ) ; } } public static class ThrowExceptionWithWrongType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new IllegalArgumentException ( ) ; } } public static class HasWrongMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expectMessage ( " expectedMessage " ) ; throw new IllegalArgumentException ( " actualMessage " ) ; } } public static class ThrowNoExceptionButExpectExceptionWithType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; } } public static class WronglyExpectsExceptionMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowAnything ( ) { thrown . expectMessage ( " anything ! " ) ; } } public static class ExpectsSubstring { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( " This could throw anything ! ( as long as it has the right substring ) " ) ; } } public static class ExpectsSubstringNullMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( ) ; } } public static class ExpectsMessageMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( startsWith ( ARBITRARY_MESSAGE ) ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " ! " ) ; } } public static class ExpectedMessageMatcherFails { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( equalTo ( " Wrong start " ) ) ; throw new NullPointerException ( " Back ! " ) ; } } public static class ExpectsMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( any ( Exception . class ) ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class ExpectsMultipleMatchers { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class FailAndDontHandleAssertinErrors { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void violatedAssumption ( ) { thrown . expect ( IllegalArgumentException . class ) ; fail ( ARBITRARY_MESSAGE ) ; } } public static class ThrowUnexpectedAssertionError { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void wrongException ( ) { thrown . handleAssertionErrors ( ) ; thrown . expect ( NullPointerException . class ) ; throw new AssertionError ( " the unexpected assertion error " ) ; } } public static class ThrowExpectedAssertionError { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void wrongException ( ) { thrown . handleAssertionErrors ( ) ; thrown . expect ( AssertionError . class ) ; throw new AssertionError ( " the expected assertion error " ) ; } } public static class ViolateAssumptionAndExpectException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void violatedAssumption ( ) { thrown . expect ( NullPointerException . class ) ; assumeTrue ( false ) ; } } public static class ThrowAssumptionViolatedExceptionButExpectOtherType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void wrongException ( ) { thrown . handleAssumptionViolatedExceptions ( ) ; thrown . expect ( NullPointerException . class ) ; throw new AssumptionViolatedException ( " " ) ; } } public static class ThrowExpectedAssumptionViolatedException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExpectAssumptionViolatedException ( ) { thrown . handleAssumptionViolatedExceptions ( ) ; thrown . expect ( AssumptionViolatedException . class ) ; throw new AssumptionViolatedException ( " " ) ; } } public static class ThrowExceptionWithMatchingCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExceptionWithMatchingCause ( ) { NullPointerException expectedCause = new NullPointerException ( " expected cause " ) ; thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( expectedCause ) ) ; throw new IllegalArgumentException ( " Ack ! " , expectedCause ) ; } } public static class ThrowExpectedNullCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExpectedNullCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( nullValue ( Throwable . class ) ) ; throw new IllegalArgumentException ( " Ack ! " ) ; } } public static class ThrowUnexpectedCause { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void throwWithCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( new NullPointerException ( " expected cause " ) ) ) ; throw new IllegalArgumentException ( " Ack ! " , new NullPointerException ( " an unexpected cause " ) ) ; } } public static class CustomMessageWithoutExpectedException { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . setMissingExceptionMessage ( ARBITRARY_MESSAGE ) ; } } }
public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . setMissingExceptionMessage ( ARBITRARY_MESSAGE ) ; }
public ExpectedException reportMissingExceptionWithMessage ( String providedMessage ) { missingExceptionMessage = providedMessage ; return this ; }
public void throwsNothing ( ) { } } public static class ThrowExceptionWithExpectedType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new NullPointerException ( ) ; } } public static class ThrowExceptionWithExpectedPartOfMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerExceptionWithMessage ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( ARBITRARY_MESSAGE ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " something else " ) ; } } public static class ThrowExceptionWithWrongType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new IllegalArgumentException ( ) ; } } public static class HasWrongMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expectMessage ( " expectedMessage " ) ; throw new IllegalArgumentException ( " actualMessage " ) ; } } public static class ThrowNoExceptionButExpectExceptionWithType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; } } public static class WronglyExpectsExceptionMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowAnything ( ) { thrown . expectMessage ( " anything ! " ) ; } } public static class ExpectsSubstring { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( " This could throw anything ! ( as long as it has the right substring ) " ) ; } } public static class ExpectsSubstringNullMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( ) ; } } public static class ExpectsMessageMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( startsWith ( ARBITRARY_MESSAGE ) ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " ! " ) ; } } public static class ExpectedMessageMatcherFails { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( equalTo ( " Wrong start " ) ) ; throw new NullPointerException ( " Back ! " ) ; } } public static class ExpectsMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( any ( Exception . class ) ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class ExpectsMultipleMatchers { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class FailAndDontHandleAssertinErrors { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void violatedAssumption ( ) { thrown . expect ( IllegalArgumentException . class ) ; fail ( ARBITRARY_MESSAGE ) ; } } public static class ThrowUnexpectedAssertionError { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void wrongException ( ) { thrown . handleAssertionErrors ( ) ; thrown . expect ( NullPointerException . class ) ; throw new AssertionError ( " the unexpected assertion error " ) ; } } public static class ThrowExpectedAssertionError { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void wrongException ( ) { thrown . handleAssertionErrors ( ) ; thrown . expect ( AssertionError . class ) ; throw new AssertionError ( " the expected assertion error " ) ; } } public static class ViolateAssumptionAndExpectException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void violatedAssumption ( ) { thrown . expect ( NullPointerException . class ) ; assumeTrue ( false ) ; } } public static class ThrowAssumptionViolatedExceptionButExpectOtherType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void wrongException ( ) { thrown . handleAssumptionViolatedExceptions ( ) ; thrown . expect ( NullPointerException . class ) ; throw new AssumptionViolatedException ( " " ) ; } } public static class ThrowExpectedAssumptionViolatedException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExpectAssumptionViolatedException ( ) { thrown . handleAssumptionViolatedExceptions ( ) ; thrown . expect ( AssumptionViolatedException . class ) ; throw new AssumptionViolatedException ( " " ) ; } } public static class ThrowExceptionWithMatchingCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExceptionWithMatchingCause ( ) { NullPointerException expectedCause = new NullPointerException ( " expected cause " ) ; thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( expectedCause ) ) ; throw new IllegalArgumentException ( " Ack ! " , expectedCause ) ; } } public static class ThrowExpectedNullCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExpectedNullCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( nullValue ( Throwable . class ) ) ; throw new IllegalArgumentException ( " Ack ! " ) ; } } public static class ThrowUnexpectedCause { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void throwWithCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( new NullPointerException ( " expected cause " ) ) ) ; throw new IllegalArgumentException ( " Ack ! " , new NullPointerException ( " an unexpected cause " ) ) ; } } public static class CustomMessageWithoutExpectedException { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . reportMissingExceptionWithMessage ( ARBITRARY_MESSAGE ) ; } } }
public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . reportMissingExceptionWithMessage ( ARBITRARY_MESSAGE ) ; }
public ExpectedException reportMissingExceptionWithMessage ( String providedMessage ) { missingExceptionMessage = providedMessage ; return this ; }
private void failDueToMissingException ( ) throws AssertionError { String failureMessage ; if ( isMissingExceptionMessageEmpty ( ) ) { String expectation = StringDescription . toString ( fMatcherBuilder . build ( ) ) ; failureMessage = " Expected test to throw " + expectation ; } else { failureMessage = missingExceptionMessage ; } fail ( failureMessage ) ; }
private boolean isMissingExceptionMessageEmpty ( ) { return missingExceptionMessage = = null | | missingExceptionMessage . isEmpty ( ) ; }
public ExpectedException reportMissingExceptionWithMessage ( String message ) { missingExceptionMessage = message ; return this ; }
private StatementThread evaluateStatement ( ) throws InterruptedException { StatementThread thread = new StatementThread ( fOriginalStatement ) ; thread . start ( ) ; fTimeUnit . timedJoin ( thread , fTimeout ) ; if ( ! thread . fFinished ) { thread . recordStackTrace ( ) ; } thread . interrupt ( ) ; return thread ; }
private void throwTimeoutException ( StatementThread thread ) throws Exception { Exception exception = new Exception ( String . format ( " test timed out after % d milliseconds " , TimeUnit . MILLISECONDS . convert ( fTimeout , fTimeUnit ) ) ) ; exception . setStackTrace ( thread . getRecordedStackTrace ( ) ) ; throw exception ; }
public Statement apply ( Statement base , Description description ) { return new FailOnTimeout ( base , fTimeout , fTimeUnit ) ; }
public void run1 ( ) throws InterruptedException { logger . append ( " run1 " ) ; TimeoutRuleTest . run1Lock . lockInterruptibly ( ) ; TimeoutRuleTest . run1Lock . unlock ( ) ; }
public void run2 ( ) throws InterruptedException { logger . append ( " run2 " ) ; Thread . currentThread ( ) . join ( ) ; }
public synchronized void run3 ( ) throws InterruptedException { logger . append ( " run3 " ) ; wait ( ) ; }
@ Before public void before ( ) { run1Lock . lock ( ) ; }
@ After public void after ( ) { run1Lock . unlock ( ) ; }
public void timeUnitTimeout ( ) throws InterruptedException { HasGlobalTimeUnitTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalTimeUnitTimeout . class ) ; assertEquals ( 3 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; }
public void longTimeout ( ) throws InterruptedException { HasGlobalLongTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalLongTimeout . class ) ; assertEquals ( 3 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; }
private void throwTimeoutException ( StatementThread thread ) throws Exception { Exception exception = new Exception ( String . format ( " test timed out after % d % s " , fTimeout , fTimeUnit . name ( ) . toLowerCase ( ) ) ) ; exception . setStackTrace ( thread . getRecordedStackTrace ( ) ) ; throw exception ; }
public void run4 ( ) { logger . append ( " run4 " ) ; while ( ! run4done ) { }
@ Before public void before ( ) { run4done = false ; run1Lock . lock ( ) ; }
@ After public void after ( ) { run4done = true ; run1Lock . unlock ( ) ; }
public void timeUnitTimeout ( ) throws InterruptedException { HasGlobalTimeUnitTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalTimeUnitTimeout . class ) ; assertEquals ( 4 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run4 " ) ) ; }
public void longTimeout ( ) throws InterruptedException { HasGlobalLongTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalLongTimeout . class ) ; assertEquals ( 4 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run4 " ) ) ; }
private void failDueToMissingException ( ) throws AssertionError { fail ( missingExceptionMessage ( ) ) ; }
private String missingExceptionMessage ( ) { if ( isMissingExceptionMessageEmpty ( ) ) { String expectation = StringDescription . toString ( fMatcherBuilder . build ( ) ) ;
private String missingExceptionMessage ( ) { if ( isMissingExceptionMessageEmpty ( ) ) { String expectation = StringDescription . toString ( fMatcherBuilder . build ( ) ) ;
private boolean isMissingExceptionMessageEmpty ( ) { return missingExceptionMessage = = null | | missingExceptionMessage . length ( ) = = 0 ; }
public static Timeout millis ( long millis ) { return new Timeout ( millis , TimeUnit . MILLISECONDS ) ; }
public static Timeout seconds ( long seconds ) { return new Timeout ( seconds , TimeUnit . SECONDS ) ; }
public void before ( ) { run4done = false ; run1Lock . lock ( ) ; }
public void after ( ) { run4done = true ; run1Lock . unlock ( ) ; }
private String declaredMethods ( Class < ? > clazz ) { return toString ( clazz , MethodSorter . getDeclaredMethods ( clazz ) ) ; }
private StatementThread evaluateStatement ( ) throws InterruptedException { StatementThread thread = new StatementThread ( fOriginalStatement ) ; thread . setDaemon ( true ) ; thread . start ( ) ; fTimeUnit . timedJoin ( thread , fTimeout ) ; if ( ! thread . fFinished ) { thread . recordStackTrace ( ) ; } thread . interrupt ( ) ; return thread ; }
public void run5 ( ) throws IOException { logger . append ( " run5 " ) ; Random rnd = new Random ( ) ; byte [ ] data = new byte [ 1024 ] ; while ( true ) { File tmp = File . createTempFile ( " dummy " , " . tmp " ) ;
public void run6 ( ) throws InterruptedIOException { logger . append ( " run6 " ) ; throw new InterruptedIOException ( ) ; }
public void timeUnitTimeout ( ) throws InterruptedException { HasGlobalTimeUnitTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalTimeUnitTimeout . class ) ; assertEquals ( 6 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run4 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run5 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run6 " ) ) ; }
public void longTimeout ( ) throws InterruptedException { HasGlobalLongTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalLongTimeout . class ) ; assertEquals ( 6 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run4 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run5 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run6 " ) ) ; }
public void run5 ( ) throws IOException { logger . append ( " run5 " ) ; Random rnd = new Random ( ) ; byte [ ] data = new byte [ 1024 ] ; File tmp = File . createTempFile ( " dummy " , " . tmp " ) ; tmp . deleteOnExit ( ) ; while ( true ) { FileChannel channel = new RandomAccessFile ( tmp , " rw " ) . getChannel ( ) ;
public void run5 ( ) throws IOException { logger . append ( " run5 " ) ; Random rnd = new Random ( ) ; byte [ ] data = new byte [ 1024 ] ; File tmp = tmpFile . newFile ( ) ; tmp . deleteOnExit ( ) ; while ( true ) { FileChannel channel = new RandomAccessFile ( tmp , " rw " ) . getChannel ( ) ;
public void getMethodsNullSorter ( ) throws Exception { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( Dummy . class ) ) ; assertEquals ( " [ void superMario ( ) ] " , declaredMethods ( Super . class ) ) ; assertEquals ( " [ void subBowser ( ) ] " , declaredMethods ( Sub . class ) ) ; }
public void testMethodsNullSorterSelf ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( Dummy . class , expected ) ; assertEquals ( expected , actual ) ; }
public void testMethodsNullSorterSuper ( ) { List < String > expected = Arrays . asList ( new String [ ] { SUPER_METHOD } ) ; List < String > actual = getDeclaredFilteredMethods ( Super . class , expected ) ; assertEquals ( expected , actual ) ; }
public void testMethodsNullSorterSub ( ) { List < String > expected = Arrays . asList ( new String [ ] { SUB_METHOD } ) ; List < String > actual = getDeclaredFilteredMethods ( Sub . class , expected ) ; assertEquals ( expected , actual ) ; }
public void testMethodsNullSorterSelf ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( ClassWithoutSorterAnnotation . class , expected ) ; assertEquals ( expected , actual ) ; }
public void getMethodsNullSorter ( ) throws Exception { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( ClassWithoutSorterAnnotation . class ) ) ; assertEquals ( " [ void superMario ( ) ] " , declaredMethods ( Super . class ) ) ; assertEquals ( " [ void subBowser ( ) ] " , declaredMethods ( Sub . class ) ) ; }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void epsilon ( ) { } } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; }
public void testMethodsNullSorterSelf ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithoutAnnotation . class , expected ) ; assertEquals ( expected , actual ) ; }
public void getMethodsNullSorter ( ) throws Exception { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithoutAnnotation . class ) ) ; assertEquals ( " [ void superMario ( ) ] " , declaredMethods ( Super . class ) ) ; assertEquals ( " [ void subBowser ( ) ] " , declaredMethods ( Sub . class ) ) ; }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testDefaultSorter ( ) { String [ ] expected = new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithDefault . class ) ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ Test public void testSortWithJvm ( ) { Class < ? > clazz = DummySortJvm . class ; String actual = toString ( clazz , clazz . getDeclaredMethods ( ) ) ; assertEquals ( actual , declaredMethods ( clazz ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } @ Test public void testNameAsc ( ) { String [ ] expected = new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ; assertEquals ( Arrays . asList ( expected ) . toString ( ) , declaredMethods ( DummySortWithNameAsc . class ) ) ; } }
public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertEquals ( Arrays . asList ( fromJvm ) , Arrays . asList ( sorted ) ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvm , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvm , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvm , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithDefault . class , expected ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvm , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvm , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvm , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvm , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvm , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( new String [ ] { ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN } ) ; List < String > actual = getDeclaredFilteredMethods ( DummySortWithNameAsc . class , expected ) ; assertEquals ( expected , actual ) ; } }
public void testJvmMethodSorter ( ) { Method [ ] fromJvm = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvm , sorted ) ; }
public static long micros ( long nanos ) { return nanos / ( long ) 1E3 ; }
public static long millis ( long nanos ) { return nanos / ( long ) 1E6 ; }
public static long seconds ( long nanos ) { return nanos / ( long ) 1E9 ; }
@ Override final protected void succeeded ( Description description ) { endTime = System . nanoTime ( ) ; succeeded ( getNanos ( ) , description ) ; }
@ Override final protected void failed ( Throwable e , Description description ) { endTime = System . nanoTime ( ) ; failed ( getNanos ( ) , e , description ) ; }
@ Override final protected void skipped ( AssumptionViolatedException e , Description description ) { endTime = System . nanoTime ( ) ; skipped ( getNanos ( ) , e , description ) ; }
@ Override final protected void starting ( Description description ) { startTime = System . nanoTime ( ) ; }
@ Override final protected void finished ( Description description ) { } }
private static void logInfo ( ) { logger . info ( String . format ( " Test ' % s ' % s , spent % d microseconds " , testName , status , TimeWatcher . micros ( timeSpent ) ) ) ;
protected void succeeded ( long nanos , Description description ) { timeSpent = nanos ; status = TestStatus . SUCCEEDED ; testName = description . getMethodName ( ) ;
protected void failed ( long nanos , Throwable e , Description description ) { timeSpent = nanos ; status = TestStatus . FAILED ; testName = description . getMethodName ( ) ;
protected void skipped ( long nanos , AssumptionViolatedException e , Description description ) { timeSpent = nanos ; status = TestStatus . SKIPPED ; testName = description . getMethodName ( ) ;
public void successfulTest ( ) { } } public static class FailedTest extends AbstractTimeWatcherTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractTimeWatcherTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } @ Before public void init ( ) { AbstractTimeWatcherTest . testName = null ; AbstractTimeWatcherTest . status = null ; AbstractTimeWatcherTest . timeSpent = 0 ; } @ Test public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , equalTo ( " successfulTest " ) ) ; assertThat ( AbstractTimeWatcherTest . status , equalTo ( TestStatus . SUCCEEDED ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; } @ Test public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , equalTo ( " failedTest " ) ) ; assertThat ( AbstractTimeWatcherTest . status , equalTo ( TestStatus . FAILED ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; } @ Test public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , equalTo ( " skippedTest " ) ) ; assertThat ( AbstractTimeWatcherTest . status , equalTo ( TestStatus . SKIPPED ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; } }
public void failedTest ( ) { fail ( ) ; }
public void skippedTest ( ) { assumeTrue ( false ) ; }
public void init ( ) { AbstractTimeWatcherTest . testName = null ; AbstractTimeWatcherTest . status = null ; AbstractTimeWatcherTest . timeSpent = 0 ; }
public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , equalTo ( " successfulTest " ) ) ; assertThat ( AbstractTimeWatcherTest . status , equalTo ( TestStatus . SUCCEEDED ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; }
public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , equalTo ( " failedTest " ) ) ; assertThat ( AbstractTimeWatcherTest . status , equalTo ( TestStatus . FAILED ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; }
public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , equalTo ( " skippedTest " ) ) ; assertThat ( AbstractTimeWatcherTest . status , equalTo ( TestStatus . SKIPPED ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; }
public static long toMicros ( long nanos ) { return nanos / ( 1000 ) ; }
public static long toMillis ( long nanos ) { return nanos / ( 1000 * 1000 ) ; }
public static long toSeconds ( long nanos ) { return nanos / ( 1000 * 1000 * 1000 ) ; }
@ Override final protected void succeeded ( Description description ) { endNanos = System . nanoTime ( ) ; succeeded ( getNanos ( ) , description ) ; }
@ Override final protected void failed ( Throwable e , Description description ) { endNanos = System . nanoTime ( ) ; failed ( getNanos ( ) , e , description ) ; }
@ Override final protected void skipped ( AssumptionViolatedException e , Description description ) { endNanos = System . nanoTime ( ) ; skipped ( getNanos ( ) , e , description ) ; }
@ Override final protected void starting ( Description description ) { startNanos = System . nanoTime ( ) ; }
private static void logInfo ( ) { logger . info ( String . format ( " Test ' % s ' % s , spent % d microseconds " , testName , status , TimeWatcher . toMicros ( timeSpent ) ) ) ;
protected void succeeded ( long nanos , Description description ) { timeSpent = nanos ; status = TestStatus . PASSED ; testName = description . getMethodName ( ) ;
public void successfulTest ( ) { } } public static class FailedTest extends AbstractTimeWatcherTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractTimeWatcherTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } @ Before public void init ( ) { AbstractTimeWatcherTest . testName = null ; AbstractTimeWatcherTest . status = null ; AbstractTimeWatcherTest . timeSpent = 0 ; } @ Test public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " successfulTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . PASSED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; } @ Test public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " failedTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . FAILED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; } @ Test public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " skippedTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . SKIPPED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; } }
public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " successfulTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . PASSED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; }
public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " failedTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . FAILED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; }
public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " skippedTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . SKIPPED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; }
@ Override final protected void finished ( Description description ) { finished ( getNanos ( ) , description ) ; }
private static void logInfo ( String name , String status , long nanos ) { logger . info ( String . format ( " Test ' % s ' % s , spent % d microseconds " , name , status , TimeWatcher . toMicros ( nanos ) ) ) ;
protected void finished ( long nanos , Description description ) { timeSpentIfFinished = nanos ; testNameIfFinished = description . getMethodName ( ) ;
public void successfulTest ( ) { } } public static class FailedTest extends AbstractTimeWatcherTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractTimeWatcherTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } @ Before public void init ( ) { AbstractTimeWatcherTest . testName = null ; AbstractTimeWatcherTest . testNameIfFinished = null ; AbstractTimeWatcherTest . status = null ; AbstractTimeWatcherTest . timeSpent = 0 ; AbstractTimeWatcherTest . timeSpentIfFinished = 0 ; } @ Test public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " successfulTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( AbstractTimeWatcherTest . testNameIfFinished ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . PASSED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( equalTo ( AbstractTimeWatcherTest . timeSpentIfFinished ) ) ) ; } @ Test public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " failedTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( AbstractTimeWatcherTest . testNameIfFinished ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . FAILED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( equalTo ( AbstractTimeWatcherTest . timeSpentIfFinished ) ) ) ; } @ Test public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " skippedTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( AbstractTimeWatcherTest . testNameIfFinished ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . SKIPPED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( equalTo ( AbstractTimeWatcherTest . timeSpentIfFinished ) ) ) ; } }
public void init ( ) { AbstractTimeWatcherTest . testName = null ; AbstractTimeWatcherTest . testNameIfFinished = null ; AbstractTimeWatcherTest . status = null ; AbstractTimeWatcherTest . timeSpent = 0 ; AbstractTimeWatcherTest . timeSpentIfFinished = 0 ; }
public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " successfulTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( AbstractTimeWatcherTest . testNameIfFinished ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . PASSED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( equalTo ( AbstractTimeWatcherTest . timeSpentIfFinished ) ) ) ; }
public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " failedTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( AbstractTimeWatcherTest . testNameIfFinished ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . FAILED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( equalTo ( AbstractTimeWatcherTest . timeSpentIfFinished ) ) ) ; }
public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( " skippedTest " ) ) ) ; assertThat ( AbstractTimeWatcherTest . testName , is ( equalTo ( AbstractTimeWatcherTest . testNameIfFinished ) ) ) ; assertThat ( AbstractTimeWatcherTest . status , is ( equalTo ( TestStatus . SKIPPED ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( not ( 0L ) ) ) ; assertThat ( AbstractTimeWatcherTest . timeSpent , is ( equalTo ( AbstractTimeWatcherTest . timeSpentIfFinished ) ) ) ; }
public static long toMicros ( long nanos ) { return TimeUnit . NANOSECONDS . toMicros ( nanos ) ; }
public static long toMillis ( long nanos ) { return TimeUnit . NANOSECONDS . toMillis ( nanos ) ; }
public static long toSeconds ( long nanos ) { return TimeUnit . NANOSECONDS . toSeconds ( nanos ) ; }
private void starting ( ) { startNanos = System . nanoTime ( ) ; }
private void stopping ( ) { endNanos = System . nanoTime ( ) ; }
@ Override final protected void succeeded ( Description description ) { stopping ( ) ; succeeded ( getNanos ( ) , description ) ; }
@ Override final protected void failed ( Throwable e , Description description ) { stopping ( ) ; failed ( getNanos ( ) , e , description ) ; }
@ Override final protected void skipped ( AssumptionViolatedException e , Description description ) { stopping ( ) ; skipped ( getNanos ( ) , e , description ) ; }
@ Override final protected void starting ( Description description ) { starting ( ) ; }
protected void succeeded ( long nanos , Description description ) { timeSpent = nanos ; status = TestStatus . SUCCEEDED ; testName = description . getMethodName ( ) ; }
protected void failed ( long nanos , Throwable e , Description description ) { timeSpent = nanos ; status = TestStatus . FAILED ; testName = description . getMethodName ( ) ; }
protected void skipped ( long nanos , AssumptionViolatedException e , Description description ) { timeSpent = nanos ; status = TestStatus . SKIPPED ; testName = description . getMethodName ( ) ; }
protected void finished ( long nanos , Description description ) { timeSpentIfFinished = nanos ; testNameIfFinished = description . getMethodName ( ) ; }
public void successfulTest ( ) { } } public static class FailedTest extends AbstractStopwatchTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractStopwatchTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } @ Before public void init ( ) { AbstractStopwatchTest . testName = null ; AbstractStopwatchTest . testNameIfFinished = null ; AbstractStopwatchTest . status = null ; AbstractStopwatchTest . timeSpent = 0 ; AbstractStopwatchTest . timeSpentIfFinished = 0 ; } @ Test public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( " successfulTest " ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( AbstractStopwatchTest . testNameIfFinished ) ) ; assertThat ( AbstractStopwatchTest . status , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , AbstractStopwatchTest . timeSpent > 0 ) ; assertThat ( AbstractStopwatchTest . timeSpent , is ( AbstractStopwatchTest . timeSpentIfFinished ) ) ; } @ Test public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( " failedTest " ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( AbstractStopwatchTest . testNameIfFinished ) ) ; assertThat ( AbstractStopwatchTest . status , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , AbstractStopwatchTest . timeSpent > 0 ) ; assertThat ( AbstractStopwatchTest . timeSpent , is ( AbstractStopwatchTest . timeSpentIfFinished ) ) ; } @ Test public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( " skippedTest " ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( AbstractStopwatchTest . testNameIfFinished ) ) ; assertThat ( AbstractStopwatchTest . status , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , AbstractStopwatchTest . timeSpent > 0 ) ; assertThat ( AbstractStopwatchTest . timeSpent , is ( AbstractStopwatchTest . timeSpentIfFinished ) ) ; } }
public void init ( ) { AbstractStopwatchTest . testName = null ; AbstractStopwatchTest . testNameIfFinished = null ; AbstractStopwatchTest . status = null ; AbstractStopwatchTest . timeSpent = 0 ; AbstractStopwatchTest . timeSpentIfFinished = 0 ; }
public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( " successfulTest " ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( AbstractStopwatchTest . testNameIfFinished ) ) ; assertThat ( AbstractStopwatchTest . status , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , AbstractStopwatchTest . timeSpent > 0 ) ; assertThat ( AbstractStopwatchTest . timeSpent , is ( AbstractStopwatchTest . timeSpentIfFinished ) ) ; }
public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( " failedTest " ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( AbstractStopwatchTest . testNameIfFinished ) ) ; assertThat ( AbstractStopwatchTest . status , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , AbstractStopwatchTest . timeSpent > 0 ) ; assertThat ( AbstractStopwatchTest . timeSpent , is ( AbstractStopwatchTest . timeSpentIfFinished ) ) ; }
public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( " skippedTest " ) ) ; assertThat ( AbstractStopwatchTest . testName , is ( AbstractStopwatchTest . testNameIfFinished ) ) ; assertThat ( AbstractStopwatchTest . status , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , AbstractStopwatchTest . timeSpent > 0 ) ; assertThat ( AbstractStopwatchTest . timeSpent , is ( AbstractStopwatchTest . timeSpentIfFinished ) ) ; }
protected void succeeded ( long nanos , Description description ) { StopwatchTest . record = new Record ( nanos , TestStatus . SUCCEEDED , description . getMethodName ( ) ) ; }
protected void failed ( long nanos , Throwable e , Description description ) { StopwatchTest . record = new Record ( nanos , TestStatus . FAILED , description . getMethodName ( ) ) ; }
protected void skipped ( long nanos , AssumptionViolatedException e , Description description ) { StopwatchTest . record = new Record ( nanos , TestStatus . SKIPPED , description . getMethodName ( ) ) ; }
protected void finished ( long nanos , Description description ) { StopwatchTest . finishedRecord = new Record ( nanos , description . getMethodName ( ) ) ; }
public void successfulTest ( ) { } } public static class FailedTest extends AbstractStopwatchTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractStopwatchTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } @ Before public void init ( ) { record = new Record ( ) ; finishedRecord = new Record ( ) ; } @ Test public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . fName , is ( " successfulTest " ) ) ; assertThat ( record . fName , is ( finishedRecord . fName ) ) ; assertThat ( record . fStatus , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , record . fDuration > 0 ) ; assertThat ( record . fDuration , is ( finishedRecord . fDuration ) ) ; } @ Test public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( record . fName , is ( " failedTest " ) ) ; assertThat ( record . fName , is ( finishedRecord . fName ) ) ; assertThat ( record . fStatus , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , record . fDuration > 0 ) ; assertThat ( record . fDuration , is ( finishedRecord . fDuration ) ) ; } @ Test public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . fName , is ( " skippedTest " ) ) ; assertThat ( record . fName , is ( finishedRecord . fName ) ) ; assertThat ( record . fStatus , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , record . fDuration > 0 ) ; assertThat ( record . fDuration , is ( finishedRecord . fDuration ) ) ; } }
public void init ( ) { record = new Record ( ) ; finishedRecord = new Record ( ) ; }
public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . fName , is ( " successfulTest " ) ) ; assertThat ( record . fName , is ( finishedRecord . fName ) ) ; assertThat ( record . fStatus , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , record . fDuration > 0 ) ; assertThat ( record . fDuration , is ( finishedRecord . fDuration ) ) ; }
public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( record . fName , is ( " failedTest " ) ) ; assertThat ( record . fName , is ( finishedRecord . fName ) ) ; assertThat ( record . fStatus , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , record . fDuration > 0 ) ; assertThat ( record . fDuration , is ( finishedRecord . fDuration ) ) ; }
public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( record . fName , is ( " skippedTest " ) ) ; assertThat ( record . fName , is ( finishedRecord . fName ) ) ; assertThat ( record . fStatus , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , record . fDuration > 0 ) ; assertThat ( record . fDuration , is ( finishedRecord . fDuration ) ) ; }
private void starting ( ) { fStartNanos = System . nanoTime ( ) ; }
private void stopping ( ) { fEndNanos = System . nanoTime ( ) ; }
protected void succeeded ( long nanos , Description description ) { StopwatchTest . fRecord = new Record ( nanos , TestStatus . SUCCEEDED , description . getMethodName ( ) ) ; }
protected void failed ( long nanos , Throwable e , Description description ) { StopwatchTest . fRecord = new Record ( nanos , TestStatus . FAILED , description . getMethodName ( ) ) ; }
protected void skipped ( long nanos , AssumptionViolatedException e , Description description ) { StopwatchTest . fRecord = new Record ( nanos , TestStatus . SKIPPED , description . getMethodName ( ) ) ; }
protected void finished ( long nanos , Description description ) { StopwatchTest . fFinishedRecord = new Record ( nanos , description . getMethodName ( ) ) ; }
public void successfulTest ( ) { } } public static class FailedTest extends AbstractStopwatchTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractStopwatchTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } @ Before public void init ( ) { fRecord = new Record ( ) ; fFinishedRecord = new Record ( ) ; } @ Test public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " successfulTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; } @ Test public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " failedTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; } @ Test public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " skippedTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; } }
public void init ( ) { fRecord = new Record ( ) ; fFinishedRecord = new Record ( ) ; }
public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " successfulTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; }
public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " failedTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; }
public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " skippedTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; }
@ Test public void a ( ) { } @ Test public void b ( ) { } } public static class B { @ Test public void a ( ) { } @ Test public void b ( ) { } @ Test public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
@ Test public void b ( ) { } } public static class B { @ Test public void a ( ) { } @ Test public void b ( ) { } @ Test public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
@ Test public void a ( ) { } @ Test public void b ( ) { } @ Test public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
@ Test public void b ( ) { } @ Test public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
@ Test public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
@ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
@ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; }
@ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; }
@ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ;
public void a ( ) { } @ Test public void b ( ) { } } public static class B { @ Test public void a ( ) { } @ Test public void b ( ) { } @ Test public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void b ( ) { } } public static class B { @ Test public void a ( ) { } @ Test public void b ( ) { } @ Test public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void a ( ) { } @ Test public void b ( ) { } @ Test public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void b ( ) { } @ Test public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void c ( ) { } } abstract public static class C { @ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
@ Test public void a ( ) { } } } @ Test public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; } @ Test public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; } @ Test public void enclosedRunnerIsNamedForEnclosingClass ( ) throws Exception { assertEquals ( Enclosing . class . getName ( ) , Request . aClass ( Enclosing . class ) . getRunner ( ) . getDescription ( ) . getDisplayName ( ) ) ; } }
public void enclosedRunnerPlansConcreteEnclosedClasses ( ) throws Exception { Runner runner = Request . aClass ( Enclosing . class ) . getRunner ( ) ; assertEquals ( 5 , runner . testCount ( ) ) ; }
public void enclosedRunnerRunsConcreteEnclosedClasses ( ) throws Exception { Result result = JUnitCore . runClasses ( Enclosing . class ) ; assertEquals ( 5 , result . getRunCount ( ) ) ; }
protected Runner createRunner ( String pattern , int index , Object [ ] parameters ) throws InitializationError { return new TestClassRunnerForParameters ( getTestClass ( ) . getJavaClass ( ) , pattern , index , parameters ) ; }
private void createRunnersForParameters ( Iterable < Object [ ] > allParameters , String namePattern ) throws Exception { try { int i = 0 ;
public void b ( ) { } } @ Category ( SlowTests . class ) public static class B { @ Test public void c ( ) { } } public static class C { @ Test public void d ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { A . class , B . class , C . class } ) public static class SlowTestSuite { } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { A . class } ) public static class JustA { } @ Test public void testCountOnJustA ( ) { assertThat ( testResult ( JustA . class ) , isSuccessful ( ) ) ; } @ Test public void testCount ( ) { assertThat ( testResult ( SlowTestSuite . class ) , isSuccessful ( ) ) ; } public static class Category1 { } public static class Category2 { } public static class SomeAreSlow { @ Test public void noCategory ( ) { } @ Category ( Category1 . class ) @ Test public void justCategory1 ( ) { } @ Category ( Category2 . class ) @ Test public void justCategory2 ( ) { } @ Category ( { Category1 . class , Category2 . class } ) @ Test public void both ( ) { } @ Category ( { Category2 . class , Category1 . class } ) @ Test public void bothReversed ( ) { } } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class SomeAreSlowSuite { } @ Test public void testCountOnAWithoutSlowTests ( ) { Result result = JUnitCore . runClasses ( SomeAreSlowSuite . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ IncludeCategory ( Category2 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class IncludeAndExcludeSuite { } @ Test public void testsThatAreBothIncludedAndExcludedAreExcluded ( ) { Result result = JUnitCore . runClasses ( IncludeAndExcludeSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { A . class , B . class , C . class } ) public static class TestSuiteWithNoCategories { } @ Test public void testCountWithExplicitFilter ( ) throws Throwable { CategoryFilter include = CategoryFilter . include ( SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void categoryFilterLeavesOnlyMatchingMethods ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( A . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFastOneSlow { @ Category ( FastTests . class ) @ Test public void a ( ) { } @ Category ( SlowTests . class ) @ Test public void b ( ) { } } @ Test public void categoryFilterRejectsIncompatibleCategory ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( OneFastOneSlow . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFast { @ Category ( FastTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void c ( ) { } } public static class C { @ Test public void d ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { A . class , B . class , C . class } ) public static class SlowTestSuite { } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { A . class } ) public static class JustA { } @ Test public void testCountOnJustA ( ) { assertThat ( testResult ( JustA . class ) , isSuccessful ( ) ) ; } @ Test public void testCount ( ) { assertThat ( testResult ( SlowTestSuite . class ) , isSuccessful ( ) ) ; } public static class Category1 { } public static class Category2 { } public static class SomeAreSlow { @ Test public void noCategory ( ) { } @ Category ( Category1 . class ) @ Test public void justCategory1 ( ) { } @ Category ( Category2 . class ) @ Test public void justCategory2 ( ) { } @ Category ( { Category1 . class , Category2 . class } ) @ Test public void both ( ) { } @ Category ( { Category2 . class , Category1 . class } ) @ Test public void bothReversed ( ) { } } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class SomeAreSlowSuite { } @ Test public void testCountOnAWithoutSlowTests ( ) { Result result = JUnitCore . runClasses ( SomeAreSlowSuite . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ IncludeCategory ( Category2 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class IncludeAndExcludeSuite { } @ Test public void testsThatAreBothIncludedAndExcludedAreExcluded ( ) { Result result = JUnitCore . runClasses ( IncludeAndExcludeSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { A . class , B . class , C . class } ) public static class TestSuiteWithNoCategories { } @ Test public void testCountWithExplicitFilter ( ) throws Throwable { CategoryFilter include = CategoryFilter . include ( SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void categoryFilterLeavesOnlyMatchingMethods ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( A . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFastOneSlow { @ Category ( FastTests . class ) @ Test public void a ( ) { } @ Category ( SlowTests . class ) @ Test public void b ( ) { } } @ Test public void categoryFilterRejectsIncompatibleCategory ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( OneFastOneSlow . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFast { @ Category ( FastTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void noCategory ( ) { } @ Category ( Category1 . class ) @ Test public void justCategory1 ( ) { } @ Category ( Category2 . class ) @ Test public void justCategory2 ( ) { } @ Category ( { Category1 . class , Category2 . class } ) @ Test public void both ( ) { } @ Category ( { Category2 . class , Category1 . class } ) @ Test public void bothReversed ( ) { } } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class SomeAreSlowSuite { } @ Test public void testCountOnAWithoutSlowTests ( ) { Result result = JUnitCore . runClasses ( SomeAreSlowSuite . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ IncludeCategory ( Category2 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class IncludeAndExcludeSuite { } @ Test public void testsThatAreBothIncludedAndExcludedAreExcluded ( ) { Result result = JUnitCore . runClasses ( IncludeAndExcludeSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { A . class , B . class , C . class } ) public static class TestSuiteWithNoCategories { } @ Test public void testCountWithExplicitFilter ( ) throws Throwable { CategoryFilter include = CategoryFilter . include ( SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void categoryFilterLeavesOnlyMatchingMethods ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( A . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFastOneSlow { @ Category ( FastTests . class ) @ Test public void a ( ) { } @ Category ( SlowTests . class ) @ Test public void b ( ) { } } @ Test public void categoryFilterRejectsIncompatibleCategory ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( OneFastOneSlow . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFast { @ Category ( FastTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void justCategory1 ( ) { } @ Category ( Category2 . class ) @ Test public void justCategory2 ( ) { } @ Category ( { Category1 . class , Category2 . class } ) @ Test public void both ( ) { } @ Category ( { Category2 . class , Category1 . class } ) @ Test public void bothReversed ( ) { } } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class SomeAreSlowSuite { } @ Test public void testCountOnAWithoutSlowTests ( ) { Result result = JUnitCore . runClasses ( SomeAreSlowSuite . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ IncludeCategory ( Category2 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class IncludeAndExcludeSuite { } @ Test public void testsThatAreBothIncludedAndExcludedAreExcluded ( ) { Result result = JUnitCore . runClasses ( IncludeAndExcludeSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { A . class , B . class , C . class } ) public static class TestSuiteWithNoCategories { } @ Test public void testCountWithExplicitFilter ( ) throws Throwable { CategoryFilter include = CategoryFilter . include ( SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void categoryFilterLeavesOnlyMatchingMethods ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( A . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFastOneSlow { @ Category ( FastTests . class ) @ Test public void a ( ) { } @ Category ( SlowTests . class ) @ Test public void b ( ) { } } @ Test public void categoryFilterRejectsIncompatibleCategory ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( OneFastOneSlow . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFast { @ Category ( FastTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void justCategory2 ( ) { } @ Category ( { Category1 . class , Category2 . class } ) @ Test public void both ( ) { } @ Category ( { Category2 . class , Category1 . class } ) @ Test public void bothReversed ( ) { } } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class SomeAreSlowSuite { } @ Test public void testCountOnAWithoutSlowTests ( ) { Result result = JUnitCore . runClasses ( SomeAreSlowSuite . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ IncludeCategory ( Category2 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class IncludeAndExcludeSuite { } @ Test public void testsThatAreBothIncludedAndExcludedAreExcluded ( ) { Result result = JUnitCore . runClasses ( IncludeAndExcludeSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { A . class , B . class , C . class } ) public static class TestSuiteWithNoCategories { } @ Test public void testCountWithExplicitFilter ( ) throws Throwable { CategoryFilter include = CategoryFilter . include ( SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void categoryFilterLeavesOnlyMatchingMethods ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( A . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFastOneSlow { @ Category ( FastTests . class ) @ Test public void a ( ) { } @ Category ( SlowTests . class ) @ Test public void b ( ) { } } @ Test public void categoryFilterRejectsIncompatibleCategory ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( OneFastOneSlow . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFast { @ Category ( FastTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void both ( ) { } @ Category ( { Category2 . class , Category1 . class } ) @ Test public void bothReversed ( ) { } } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class SomeAreSlowSuite { } @ Test public void testCountOnAWithoutSlowTests ( ) { Result result = JUnitCore . runClasses ( SomeAreSlowSuite . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ IncludeCategory ( Category2 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class IncludeAndExcludeSuite { } @ Test public void testsThatAreBothIncludedAndExcludedAreExcluded ( ) { Result result = JUnitCore . runClasses ( IncludeAndExcludeSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { A . class , B . class , C . class } ) public static class TestSuiteWithNoCategories { } @ Test public void testCountWithExplicitFilter ( ) throws Throwable { CategoryFilter include = CategoryFilter . include ( SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void categoryFilterLeavesOnlyMatchingMethods ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( A . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFastOneSlow { @ Category ( FastTests . class ) @ Test public void a ( ) { } @ Category ( SlowTests . class ) @ Test public void b ( ) { } } @ Test public void categoryFilterRejectsIncompatibleCategory ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( OneFastOneSlow . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFast { @ Category ( FastTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void bothReversed ( ) { } } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class SomeAreSlowSuite { } @ Test public void testCountOnAWithoutSlowTests ( ) { Result result = JUnitCore . runClasses ( SomeAreSlowSuite . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ ExcludeCategory ( Category1 . class ) @ IncludeCategory ( Category2 . class ) @ SuiteClasses ( { SomeAreSlow . class } ) public static class IncludeAndExcludeSuite { } @ Test public void testsThatAreBothIncludedAndExcludedAreExcluded ( ) { Result result = JUnitCore . runClasses ( IncludeAndExcludeSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Suite . class ) @ SuiteClasses ( { A . class , B . class , C . class } ) public static class TestSuiteWithNoCategories { } @ Test public void testCountWithExplicitFilter ( ) throws Throwable { CategoryFilter include = CategoryFilter . include ( SlowTests . class ) ; Request baseRequest = Request . aClass ( TestSuiteWithNoCategories . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( include ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ Test public void categoryFilterLeavesOnlyMatchingMethods ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( A . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFastOneSlow { @ Category ( FastTests . class ) @ Test public void a ( ) { } @ Category ( SlowTests . class ) @ Test public void b ( ) { } } @ Test public void categoryFilterRejectsIncompatibleCategory ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( OneFastOneSlow . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFast { @ Category ( FastTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void a ( ) { } @ Category ( SlowTests . class ) @ Test public void b ( ) { } } @ Test public void categoryFilterRejectsIncompatibleCategory ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( OneFastOneSlow . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFast { @ Category ( FastTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void b ( ) { } } @ Test public void categoryFilterRejectsIncompatibleCategory ( ) throws InitializationError , NoTestsRemainException { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner ( OneFastOneSlow . class ) ; filter . apply ( runner ) ; assertEquals ( 1 , runner . testCount ( ) ) ; } public static class OneFast { @ Category ( FastTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneFast . class } ) public static class OneFastSuite { } @ Test public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ Test public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " category " + SlowTests . class , filter . describe ( ) ) ; } public static class OneThatIsBothFastAndSlow { @ Category ( { FastTests . class , SlowTests . class } ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneThatIsBothFastAndSlow . class } ) public static class ChooseSlowFromBoth { } @ Test public void runMethodWithTwoCategories ( ) { assertThat ( testResult ( ChooseSlowFromBoth . class ) , isSuccessful ( ) ) ; } public interface VerySlowTests extends SlowTests { } public static class OneVerySlowTest { @ Category ( VerySlowTests . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; }
public void testMethodsNullSorterSelf ( ) { List < String > expected = Arrays . asList ( EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithoutAnnotation . class ) ; assertEquals ( expected , actual ) ; }
public void testMethodsNullSorterSuper ( ) { List < String > expected = Arrays . asList ( SUPER_METHOD ) ; List < String > actual = getDeclaredMethodNames ( Super . class ) ; assertEquals ( expected , actual ) ; }
public void testMethodsNullSorterSub ( ) { List < String > expected = Arrays . asList ( new String [ ] { SUB_METHOD } ) ; List < String > actual = getDeclaredMethodNames ( Sub . class ) ; assertEquals ( expected , actual ) ; }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithDefault . class ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvmWithSynthetics = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvmWithSynthetics , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithDefault . class ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvmWithSynthetics = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvmWithSynthetics , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithDefault . class ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvmWithSynthetics = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvmWithSynthetics , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithDefault . class ) ; assertEquals ( expected , actual ) ; } @ FixMethodOrder ( MethodSorters . JVM ) static class DummySortJvm { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvmWithSynthetics = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvmWithSynthetics , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
public void testDefaultMethodSorter ( ) { List < String > expected = Arrays . asList ( EPSILON , BETA , ALPHA , DELTA , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithDefault . class ) ; assertEquals ( expected , actual ) ; }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvmWithSynthetics = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvmWithSynthetics , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvmWithSynthetics = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvmWithSynthetics , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvmWithSynthetics = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvmWithSynthetics , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testJvmMethodSorter ( ) { Method [ ] fromJvmWithSynthetics = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvmWithSynthetics , sorted ) ; } @ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) static class DummySortWithNameAsc { Object alpha ( int i , double d , Thread t ) { return null ; } void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
public void testJvmMethodSorter ( ) { Method [ ] fromJvmWithSynthetics = DummySortJvm . class . getDeclaredMethods ( ) ; Method [ ] sorted = MethodSorter . getDeclaredMethods ( DummySortJvm . class ) ; assertArrayEquals ( fromJvmWithSynthetics , sorted ) ; }
void beta ( int [ ] [ ] x ) { } int gamma ( ) { return 0 ; } void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
void gamma ( boolean b ) { } void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
void delta ( ) { } void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
void epsilon ( ) { } } @ Test public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; } }
public void testAscendingMethodSorter ( ) { List < String > expected = Arrays . asList ( ALPHA , BETA , DELTA , EPSILON , GAMMA_VOID , GAMMA_BOOLEAN ) ; List < String > actual = getDeclaredMethodNames ( DummySortWithNameAsc . class ) ; assertEquals ( expected , actual ) ; }
public void testMethodsNullSorterSub ( ) { List < String > expected = Arrays . asList ( SUB_METHOD ) ; List < String > actual = getDeclaredMethodNames ( Sub . class ) ; assertEquals ( expected , actual ) ; }
protected String nameFor ( String pattern , int index , Object [ ] parameters ) { String finalPattern = pattern . replaceAll ( " \ \ { index \ \ } " , Integer . toString ( index ) ) ; String name = MessageFormat . format ( finalPattern , parameters ) ; return " [ " + name + " ] " ; }
public long runtime ( TimeUnit unit ) { return unit . convert ( currentNanoTime ( ) - fStartNanos , TimeUnit . NANOSECONDS ) ; }
private void starting ( ) { fStartNanos = currentNanoTime ( ) ; }
private void stopping ( ) { fEndNanos = currentNanoTime ( ) ; }
private long currentNanoTime ( ) { return System . nanoTime ( ) ; }
public void successfulTest ( ) { } } public static class FailedTest extends AbstractStopwatchTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractStopwatchTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } public static class WrongDurationTest extends AbstractStopwatchTest { @ Test public void wrongDuration ( ) throws InterruptedException { Thread . sleep ( 500L ) ; assertNotEquals ( fStopwatch . runtime ( MILLISECONDS ) , 300d , 100d ) ; } } public static class DurationTest extends AbstractStopwatchTest { @ Test public void duration ( ) throws InterruptedException { Thread . sleep ( 300L ) ; assertEquals ( fStopwatch . runtime ( MILLISECONDS ) , 300d , 100d ) ; Thread . sleep ( 500L ) ; assertEquals ( fStopwatch . runtime ( MILLISECONDS ) , 800d , 250d ) ; } } @ Before public void init ( ) { fRecord = new Record ( ) ; fFinishedRecord = new Record ( ) ; } @ Test public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " successfulTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; } @ Test public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " failedTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; } @ Test public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " skippedTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; } @ Test public void wrongDuration ( ) { Result result = JUnitCore . runClasses ( WrongDurationTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test public void duration ( ) { Result result = JUnitCore . runClasses ( DurationTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void wrongDuration ( ) throws InterruptedException { Thread . sleep ( 500L ) ; assertNotEquals ( fStopwatch . runtime ( MILLISECONDS ) , 300d , 100d ) ; }
public void duration ( ) throws InterruptedException { Thread . sleep ( 300L ) ; assertEquals ( fStopwatch . runtime ( MILLISECONDS ) , 300d , 100d ) ; Thread . sleep ( 500L ) ; assertEquals ( fStopwatch . runtime ( MILLISECONDS ) , 800d , 250d ) ; }
public void wrongDuration ( ) { Result result = JUnitCore . runClasses ( WrongDurationTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; }
public void duration ( ) { Result result = JUnitCore . runClasses ( DurationTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; }
public static CategoryFilter include ( boolean matchAny , Class < ? > . . . categories ) { if ( hasNull ( categories ) ) { throw new NullPointerException ( " has null category " ) ; } return categoryFilter ( matchAny , createSet ( categories ) , true , null ) ; }
public static CategoryFilter include ( Class < ? > category ) { return include ( true , category ) ; }
public static CategoryFilter include ( Class < ? > . . . categories ) { return include ( true , categories ) ; }
public static CategoryFilter exclude ( boolean matchAny , Class < ? > . . . categories ) { if ( hasNull ( categories ) ) { throw new NullPointerException ( " has null category " ) ; } return categoryFilter ( true , null , matchAny , createSet ( categories ) ) ; }
public static CategoryFilter exclude ( Class < ? > category ) { return exclude ( true , category ) ; }
public static CategoryFilter exclude ( Class < ? > . . . categories ) { return exclude ( true , categories ) ; }
public static CategoryFilter categoryFilter ( boolean matchAnyInclusions , Set < Class < ? > > inclusions , boolean matchAnyExclusions , Set < Class < ? > > exclusions ) { return new CategoryFilter ( matchAnyInclusions , inclusions , matchAnyExclusions , exclusions ) ; }
public String describe ( ) { return toString ( ) ; }
@ Override public String toString ( ) { StringBuilder description = new StringBuilder ( " categories " ) . append ( fIncluded . isEmpty ( ) ? " [ all ] " : fIncluded ) ; if ( ! fExcluded . isEmpty ( ) ) { description . append ( " - " ) . append ( fExcluded ) ; } return description . toString ( ) ; }
private boolean hasCorrectCategoryAnnotation ( Description description ) { final Set < Class < ? > > childCategories = categories ( description ) ; if ( childCategories . isEmpty ( ) ) { return fIncluded . isEmpty ( ) ; } if ( ! fExcluded . isEmpty ( ) ) { if ( fExcludedAny ) { if ( matchesAnyParentCategories ( childCategories , fExcluded ) ) { return false ; } } else { if ( matchesAllParentCategories ( childCategories , fExcluded ) ) { return false ; } } } if ( fIncluded . isEmpty ( ) ) { return true ; } if ( ! fIncluded . isEmpty ( ) ) { if ( fIncludedAny ) { return matchesAnyParentCategories ( childCategories , fIncluded ) ; } else { return matchesAllParentCategories ( childCategories , fIncluded ) ; } } return false ; }
private boolean matchesAnyParentCategories ( Set < Class < ? > > childCategories , Set < Class < ? > > parentCategories ) { for ( Class < ? > parentCategory : parentCategories ) { if ( hasAssignableTo ( childCategories , parentCategory ) ) { return true ; } } return false ; }
private boolean matchesAllParentCategories ( Set < Class < ? > > childCategories , Set < Class < ? > > parentCategories ) { for ( Class < ? > parentCategory : parentCategories ) { if ( ! hasAssignableTo ( childCategories , parentCategory ) ) { return false ; } } return true ; }
private static Set < Class < ? > > categories ( Description description ) { Set < Class < ? > > categories = new HashSet < Class < ? > > ( ) ; Collections . addAll ( categories , directCategories ( description ) ) ; Collections . addAll ( categories , directCategories ( parentDescription ( description ) ) ) ; return categories ; }
private static Description parentDescription ( Description description ) { Class < ? > testClass = description . getTestClass ( ) ; return testClass = = null ? null : Description . createSuiteDescription ( testClass ) ; }
private static Class < ? > [ ] directCategories ( Description description ) { if ( description = = null ) { return new Class < ? > [ 0 ] ; } Category annotation = description . getAnnotation ( Category . class ) ; return annotation = = null ? new Class < ? > [ 0 ] : annotation . value ( ) ; }
private static Set < Class < ? > > copyAndRefine ( Set < Class < ? > > classes ) { HashSet < Class < ? > > c = new HashSet < Class < ? > > ( ) ; if ( classes ! = null ) { c . addAll ( classes ) ; } c . remove ( null ) ; return c ; }
private static boolean hasNull ( Class < ? > . . . classes ) { if ( classes = = null ) return false ; for ( Class < ? > clazz : classes ) { if ( clazz = = null ) { return true ; } } return false ; }
private static Set < Class < ? > > getIncludedCategory ( Class < ? > klass ) throws ClassNotFoundException { IncludeCategory annotation = klass . getAnnotation ( IncludeCategory . class ) ; return createSet ( annotation = = null ? null : annotation . value ( ) ) ; }
private static boolean isAnyIncluded ( Class < ? > klass ) { IncludeCategory annotation = klass . getAnnotation ( IncludeCategory . class ) ; return annotation = = null | | annotation . matchAny ( ) ; }
private static Set < Class < ? > > getExcludedCategory ( Class < ? > klass ) throws ClassNotFoundException { ExcludeCategory annotation = klass . getAnnotation ( ExcludeCategory . class ) ; return createSet ( annotation = = null ? null : annotation . value ( ) ) ; }
private static boolean isAnyExcluded ( Class < ? > klass ) { ExcludeCategory annotation = klass . getAnnotation ( ExcludeCategory . class ) ; return annotation = = null | | annotation . matchAny ( ) ; }
private static boolean hasAssignableTo ( Set < Class < ? > > assigns , Class < ? > to ) { for ( final Class < ? > from : assigns ) { if ( to . isAssignableFrom ( from ) ) { return true ; } } return false ; }
private static Set < Class < ? > > createSet ( Class < ? > . . . t ) { final Set < Class < ? > > set = new HashSet < Class < ? > > ( ) ; if ( t ! = null ) { Collections . addAll ( set , t ) ; } return set ; }
public void testCountOnAWithoutSlowTests ( ) { Result result = JUnitCore . runClasses ( SomeAreSlowSuite . class ) ; assertThat ( testResult ( SomeAreSlowSuite . class ) , isSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; }
public void ifNoTestsToRunUseErrorRunner ( ) { Result result = JUnitCore . runClasses ( OneFastSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertFalse ( result . wasSuccessful ( ) ) ; }
public void describeACategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( SlowTests . class ) ; assertEquals ( " categories [ " + SlowTests . class + " ] " , filter . describe ( ) ) ; }
public void describeMultipleCategoryFilter ( ) { CategoryFilter filter = CategoryFilter . include ( FastTests . class , SlowTests . class ) ; String d1 = format ( " categories [ % s , % s ] " , FastTests . class , SlowTests . class ) ; String d2 = format ( " categories [ % s , % s ] " , SlowTests . class , FastTests . class ) ; assertThat ( filter . describe ( ) , is ( anyOf ( equalTo ( d1 ) , equalTo ( d2 ) ) ) ) ; }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( { OneVerySlowTest . class } ) public static class RunSlowFromVerySlow { } @ Test public void subclassesOfIncludedCategoriesAreRun ( ) { assertThat ( testResult ( RunSlowFromVerySlow . class ) , isSuccessful ( ) ) ; } public interface MultiA { } public interface MultiB { } public interface MultiC { } @ RunWith ( Categories . class ) @ IncludeCategory ( value = { MultiA . class , MultiB . class } , matchAny = false ) @ SuiteClasses ( AllIncludedMustMatched . class ) public static class AllIncludedMustBeMatchedSuite { } public static class AllIncludedMustMatched { @ Test @ Category ( { MultiA . class , MultiB . class } ) public void a ( ) { } @ Test @ Category ( MultiB . class ) public void b ( ) { fail ( " When multiple categories are included in a Suite , " + " @ Test method must match all include categories " ) ; } } @ Test public void allIncludedSuiteCategoriesMustBeMatched ( ) { Result result = JUnitCore . runClasses ( AllIncludedMustBeMatchedSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( { MultiA . class , MultiB . class } ) @ ExcludeCategory ( MultiC . class ) @ SuiteClasses ( MultipleIncludesAndExcludeOnMethod . class ) public static class MultiIncludeWithExcludeCategorySuite { } public static class MultipleIncludesAndExcludeOnMethod { @ Test @ Category ( { MultiA . class , MultiB . class } ) public void a ( ) { } @ Test @ Category ( { MultiA . class , MultiB . class , MultiC . class } ) public void b ( ) { fail ( " When multiple categories are included and excluded in a Suite , " + " @ Test method must match all include categories and contain non of the excluded " ) ; } } @ Test public void anyMethodWithExcludedCategoryWillBeExcluded ( ) { Result result = JUnitCore . runClasses ( MultiIncludeWithExcludeCategorySuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { } ) public static class EmptyCategoriesSuite { } @ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; } @ Category ( Runnable . class ) public static class NoTest { } @ Category ( Runnable . class ) public static class IgnoredTest { @ Ignore @ Test public void test ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ SuiteClasses ( { NoTest . class , IgnoredTest . class } ) public static class IgnoredTestCategoriesSuite { } @ Test public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; } @ Category ( Runnable . class ) public static class ExcludedTest1 { @ Test public void test ( ) { fail ( ) ; } } @ Category ( Runnable . class ) public static class ExcludedTest2 { @ Test @ Category ( Runnable . class ) public void test ( ) { fail ( ) ; } } public static class IncludedTest { @ Test @ Category ( Object . class ) public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
public void a ( ) { } @ Test @ Category ( MultiB . class ) public void b ( ) { fail ( " When multiple categories are included in a Suite , " + " @ Test method must match all include categories " ) ; } } @ Test public void allIncludedSuiteCategoriesMustBeMatched ( ) { Result result = JUnitCore . runClasses ( AllIncludedMustBeMatchedSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( { MultiA . class , MultiB . class } ) @ ExcludeCategory ( MultiC . class ) @ SuiteClasses ( MultipleIncludesAndExcludeOnMethod . class ) public static class MultiIncludeWithExcludeCategorySuite { } public static class MultipleIncludesAndExcludeOnMethod { @ Test @ Category ( { MultiA . class , MultiB . class } ) public void a ( ) { } @ Test @ Category ( { MultiA . class , MultiB . class , MultiC . class } ) public void b ( ) { fail ( " When multiple categories are included and excluded in a Suite , " + " @ Test method must match all include categories and contain non of the excluded " ) ; } } @ Test public void anyMethodWithExcludedCategoryWillBeExcluded ( ) { Result result = JUnitCore . runClasses ( MultiIncludeWithExcludeCategorySuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { } ) public static class EmptyCategoriesSuite { } @ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; } @ Category ( Runnable . class ) public static class NoTest { } @ Category ( Runnable . class ) public static class IgnoredTest { @ Ignore @ Test public void test ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ SuiteClasses ( { NoTest . class , IgnoredTest . class } ) public static class IgnoredTestCategoriesSuite { } @ Test public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; } @ Category ( Runnable . class ) public static class ExcludedTest1 { @ Test public void test ( ) { fail ( ) ; } } @ Category ( Runnable . class ) public static class ExcludedTest2 { @ Test @ Category ( Runnable . class ) public void test ( ) { fail ( ) ; } } public static class IncludedTest { @ Test @ Category ( Object . class ) public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
public void b ( ) { fail ( " When multiple categories are included in a Suite , " + " @ Test method must match all include categories " ) ;
public void allIncludedSuiteCategoriesMustBeMatched ( ) { Result result = JUnitCore . runClasses ( AllIncludedMustBeMatchedSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; }
public void a ( ) { } @ Test @ Category ( { MultiA . class , MultiB . class , MultiC . class } ) public void b ( ) { fail ( " When multiple categories are included and excluded in a Suite , " + " @ Test method must match all include categories and contain non of the excluded " ) ; } } @ Test public void anyMethodWithExcludedCategoryWillBeExcluded ( ) { Result result = JUnitCore . runClasses ( MultiIncludeWithExcludeCategorySuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } public static class ClassAsCategory { } public static class OneMoreTest { @ Category ( ClassAsCategory . class ) @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { } ) public static class EmptyCategoriesSuite { } @ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; } @ Category ( Runnable . class ) public static class NoTest { } @ Category ( Runnable . class ) public static class IgnoredTest { @ Ignore @ Test public void test ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ SuiteClasses ( { NoTest . class , IgnoredTest . class } ) public static class IgnoredTestCategoriesSuite { } @ Test public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; } @ Category ( Runnable . class ) public static class ExcludedTest1 { @ Test public void test ( ) { fail ( ) ; } } @ Category ( Runnable . class ) public static class ExcludedTest2 { @ Test @ Category ( Runnable . class ) public void test ( ) { fail ( ) ; } } public static class IncludedTest { @ Test @ Category ( Object . class ) public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
public void b ( ) { fail ( " When multiple categories are included and excluded in a Suite , " + " @ Test method must match all include categories and contain non of the excluded " ) ;
public void anyMethodWithExcludedCategoryWillBeExcluded ( ) { Result result = JUnitCore . runClasses ( MultiIncludeWithExcludeCategorySuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( ClassAsCategory . class ) @ SuiteClasses ( { OneMoreTest . class } ) public static class RunClassAsCategory { } @ Test public void classesCanBeCategories ( ) { assertThat ( testResult ( RunClassAsCategory . class ) , isSuccessful ( ) ) ; } @ Category ( SlowTests . class ) public static abstract class Ancestor { } public static class Inherited extends Ancestor { @ Test public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { } ) public static class EmptyCategoriesSuite { } @ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; } @ Category ( Runnable . class ) public static class NoTest { } @ Category ( Runnable . class ) public static class IgnoredTest { @ Ignore @ Test public void test ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ SuiteClasses ( { NoTest . class , IgnoredTest . class } ) public static class IgnoredTestCategoriesSuite { } @ Test public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; } @ Category ( Runnable . class ) public static class ExcludedTest1 { @ Test public void test ( ) { fail ( ) ; } } @ Category ( Runnable . class ) public static class ExcludedTest2 { @ Test @ Category ( Runnable . class ) public void test ( ) { fail ( ) ; } } public static class IncludedTest { @ Test @ Category ( Object . class ) public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
public void a ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( SlowTests . class ) @ SuiteClasses ( Inherited . class ) public interface InheritanceSuite { } @ Test public void testInheritance ( ) { Result result = JUnitCore . runClasses ( InheritanceSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { } ) public static class EmptyCategoriesSuite { } @ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; } @ Category ( Runnable . class ) public static class NoTest { } @ Category ( Runnable . class ) public static class IgnoredTest { @ Ignore @ Test public void test ( ) { fail ( ) ; } } @ RunWith ( Categories . class ) @ IncludeCategory ( Runnable . class ) @ SuiteClasses ( { NoTest . class , IgnoredTest . class } ) public static class IgnoredTestCategoriesSuite { } @ Test public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; } @ Category ( Runnable . class ) public static class ExcludedTest1 { @ Test public void test ( ) { fail ( ) ; } } @ Category ( Runnable . class ) public static class ExcludedTest2 { @ Test @ Category ( Runnable . class ) public void test ( ) { fail ( ) ; } } public static class IncludedTest { @ Test @ Category ( Object . class ) public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
@ Test public void emptyCategoriesSuite ( ) { assertThat ( testResult ( EmptyCategoriesSuite . class ) , failureCountIs ( 1 ) ) ; }
public void ignoredTest ( ) { Result result = JUnitCore . runClasses ( IgnoredTestCategoriesSuite . class ) ; assertFalse ( result . wasSuccessful ( ) ) ; assertThat ( result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getIgnoreCount ( ) , is ( 1 ) ) ; }
public void test ( ) { } } @ RunWith ( Categories . class ) @ IncludeCategory ( { Runnable . class , Object . class } ) @ ExcludeCategory ( Runnable . class ) @ SuiteClasses ( { ExcludedTest1 . class , ExcludedTest2 . class , IncludedTest . class } ) public static class IncludedExcludedSameSuite { } @ Test public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test @ SuppressWarnings ( " unchecked " ) public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; } @ Test public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class NoIncludeCategoryAnnotationSuite { } @ Category ( CharSequence . class ) public static class NoIncludeCategoryAnnotationTest { @ Test public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
public void oneRunnableOthersAvoided ( ) { Result result = JUnitCore . runClasses ( IncludedExcludedSameSuite . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; }
public void testCountWithMultipleExcludeFilter ( ) throws Throwable { Set < Class < ? > > exclusions = new HashSet < Class < ? > > ( 2 ) ; Collections . addAll ( exclusions , SlowTests . class , FastTests . class ) ; CategoryFilter exclude = CategoryFilter . categoryFilter ( true , null , true , exclusions ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; }
public void testCountWithMultipleIncludeFilter ( ) throws Throwable { CategoryFilter exclude = CategoryFilter . include ( true , SlowTests . class , FastTests . class ) ; Request baseRequest = Request . aClass ( OneOfEach . class ) ; Result result = new JUnitCore ( ) . run ( baseRequest . filterWith ( exclude ) ) ; assertTrue ( result . wasSuccessful ( ) ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; }
public void test2 ( ) { } @ Test @ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
@ Category ( String . class ) public void test1 ( ) { } } @ Test public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( CharSequence . class ) @ Categories . ExcludeCategory ( String . class ) @ Suite . SuiteClasses ( NoIncludeCategoryAnnotationTest . class ) public static class SameAsNoIncludeCategoryAnnotationSuite { } @ Test public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; } }
public void noIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( NoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; }
public void sameAsNoIncludeCategoryAnnotation ( ) { Result testResult = JUnitCore . runClasses ( SameAsNoIncludeCategoryAnnotationSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertEquals ( 1 , testResult . getRunCount ( ) ) ; }
public void b ( ) { } @ Category ( { FastTests . class , SmokeTests . class } ) @ Test public void c ( ) { } } @ Category ( { SlowTests . class , FastTests . class } ) public static class B { @ Test public void d ( ) { } } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( SlowTests . class ) @ Suite . SuiteClasses ( { A . class , B . class } ) public static class SlowTestSuite { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( { FastTests . class , SmokeTests . class } ) @ Suite . SuiteClasses ( { A . class , B . class } ) public static class FastOrSmokeTestSuite { } @ Test public void slowTests ( ) { Result testResult = JUnitCore . runClasses ( SlowTestSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( 0 ) ) ; } @ Test public void fastSmokeTests ( ) { Result testResult = JUnitCore . runClasses ( FastOrSmokeTestSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( 0 ) ) ; } }
public void c ( ) { } } @ Category ( { SlowTests . class , FastTests . class } ) public static class B { @ Test public void d ( ) { } } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( SlowTests . class ) @ Suite . SuiteClasses ( { A . class , B . class } ) public static class SlowTestSuite { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( { FastTests . class , SmokeTests . class } ) @ Suite . SuiteClasses ( { A . class , B . class } ) public static class FastOrSmokeTestSuite { } @ Test public void slowTests ( ) { Result testResult = JUnitCore . runClasses ( SlowTestSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( 0 ) ) ; } @ Test public void fastSmokeTests ( ) { Result testResult = JUnitCore . runClasses ( FastOrSmokeTestSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( 0 ) ) ; } }
public void d ( ) { } } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( SlowTests . class ) @ Suite . SuiteClasses ( { A . class , B . class } ) public static class SlowTestSuite { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( { FastTests . class , SmokeTests . class } ) @ Suite . SuiteClasses ( { A . class , B . class } ) public static class FastOrSmokeTestSuite { } @ Test public void slowTests ( ) { Result testResult = JUnitCore . runClasses ( SlowTestSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( 0 ) ) ; } @ Test public void fastSmokeTests ( ) { Result testResult = JUnitCore . runClasses ( FastOrSmokeTestSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( 0 ) ) ; } }
public void slowTests ( ) { Result testResult = JUnitCore . runClasses ( SlowTestSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( 0 ) ) ; }
public void fastSmokeTests ( ) { Result testResult = JUnitCore . runClasses ( FastOrSmokeTestSuite . class ) ; assertTrue ( testResult . wasSuccessful ( ) ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( 0 ) ) ; }
public void runSuite ( ) { Result testResult = JUnitCore . runClasses ( MultiCategorySuite . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 2 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; }
public void a ( ) { } @ Test @ Category ( B . class ) public void b ( ) { } @ Test @ Category ( C . class ) public void c ( ) { fail ( ) ; } @ Test public void anything ( ) { fail ( ) ; } } @ Test public void inheritanceAnyIncluded ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAny . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 3 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; } @ Test public void inheritanceAllIncluded ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAll . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 1 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; } @ Test public void inheritanceAnyAll ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAnyAll . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 3 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; } @ Test public void inheritanceAllAny ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAllAny . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 1 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 1 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; assertFalse ( testResult . wasSuccessful ( ) ) ; } public static class X implements A { } public static class Y implements B { } public static class Z implements A , B { } public static class W implements A , B , C { } public static class Q implements A , C { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( { A . class , B . class } ) @ Categories . ExcludeCategory ( C . class ) @ Suite . SuiteClasses ( { InheritanceAnyTest . class } ) public static final class InheritanceAny { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( value = { A . class , B . class } , matchAny = false ) @ Categories . ExcludeCategory ( C . class ) @ Suite . SuiteClasses ( { InheritanceAllTest . class } ) public static final class InheritanceAll { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( { A . class , B . class } ) @ Categories . ExcludeCategory ( value = { A . class , C . class } , matchAny = false ) @ Suite . SuiteClasses ( { InheritanceAnyAllTest . class } ) public static final class InheritanceAnyAll { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( value = { A . class , B . class } , matchAny = false ) @ Categories . ExcludeCategory ( { A . class , C . class } ) @ Suite . SuiteClasses ( { InheritanceAllAnyTest . class } ) public static final class InheritanceAllAny { } public static final class InheritanceAnyTest { @ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAnyAllTest { @ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllAnyTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } }
public void b ( ) { } @ Test @ Category ( C . class ) public void c ( ) { fail ( ) ; } @ Test public void anything ( ) { fail ( ) ; } } @ Test public void inheritanceAnyIncluded ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAny . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 3 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; } @ Test public void inheritanceAllIncluded ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAll . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 1 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; } @ Test public void inheritanceAnyAll ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAnyAll . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 3 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; } @ Test public void inheritanceAllAny ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAllAny . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 1 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 1 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; assertFalse ( testResult . wasSuccessful ( ) ) ; } public static class X implements A { } public static class Y implements B { } public static class Z implements A , B { } public static class W implements A , B , C { } public static class Q implements A , C { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( { A . class , B . class } ) @ Categories . ExcludeCategory ( C . class ) @ Suite . SuiteClasses ( { InheritanceAnyTest . class } ) public static final class InheritanceAny { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( value = { A . class , B . class } , matchAny = false ) @ Categories . ExcludeCategory ( C . class ) @ Suite . SuiteClasses ( { InheritanceAllTest . class } ) public static final class InheritanceAll { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( { A . class , B . class } ) @ Categories . ExcludeCategory ( value = { A . class , C . class } , matchAny = false ) @ Suite . SuiteClasses ( { InheritanceAnyAllTest . class } ) public static final class InheritanceAnyAll { } @ RunWith ( Categories . class ) @ Categories . IncludeCategory ( value = { A . class , B . class } , matchAny = false ) @ Categories . ExcludeCategory ( { A . class , C . class } ) @ Suite . SuiteClasses ( { InheritanceAllAnyTest . class } ) public static final class InheritanceAllAny { } public static final class InheritanceAnyTest { @ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAnyAllTest { @ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllAnyTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } }
public void anything ( ) { fail ( ) ; }
public void inheritanceAnyIncluded ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAny . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 3 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; }
public void inheritanceAllIncluded ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAll . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 1 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; }
public void inheritanceAnyAll ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAnyAll . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 3 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 0 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; }
public void inheritanceAllAny ( ) { Result testResult = JUnitCore . runClasses ( InheritanceAllAny . class ) ; assertThat ( " unexpected run count " , testResult . getRunCount ( ) , is ( equalTo ( 1 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getFailureCount ( ) , is ( equalTo ( 1 ) ) ) ; assertThat ( " unexpected failure count " , testResult . getIgnoreCount ( ) , is ( equalTo ( 0 ) ) ) ; assertFalse ( testResult . wasSuccessful ( ) ) ; }
@ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAnyAllTest { @ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllAnyTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } }
@ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAnyAllTest { @ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllAnyTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } }
@ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAnyAllTest { @ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllAnyTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } }
@ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; }
@ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; }
@ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; }
@ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; }
@ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { }
@ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAnyAllTest { @ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllAnyTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } }
@ Test @ Category ( X . class ) public void x ( ) { } @ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllAnyTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } }
@ Test @ Category ( Y . class ) public void y ( ) { } @ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllAnyTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } }
@ Test @ Category ( Z . class ) public void z ( ) { } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } public static final class InheritanceAllAnyTest { @ Test @ Category ( X . class ) public void x ( ) { fail ( ) ; } @ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; } @ Test @ Category ( Q . class ) public void q ( ) { fail ( ) ; } @ Test @ Category ( Runnable . class ) public void runnable ( ) { fail ( ) ; } @ Test public void t ( ) { fail ( ) ; } } }
@ Test @ Category ( Y . class ) public void y ( ) { fail ( ) ; } @ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; }
@ Test @ Category ( Z . class ) public void z ( ) { fail ( ) ; } @ Test @ Category ( W . class ) public void w ( ) { fail ( ) ; }
private boolean hasCorrectCategoryAnnotation ( Description description ) { final Set < Class < ? > > childCategories = categories ( description ) ; if ( childCategories . isEmpty ( ) ) { return fIncluded . isEmpty ( ) ; } if ( ! fExcluded . isEmpty ( ) ) { if ( fExcludedAny ) { if ( matchesAnyParentCategories ( childCategories , fExcluded ) ) { return false ; } } else { if ( matchesAllParentCategories ( childCategories , fExcluded ) ) { return false ; } } } if ( fIncluded . isEmpty ( ) ) { return true ; } else { if ( fIncludedAny ) { return matchesAnyParentCategories ( childCategories , fIncluded ) ; } else { return matchesAllParentCategories ( childCategories , fIncluded ) ; } } return false ; }
private boolean hasCorrectCategoryAnnotation ( Description description ) { final Set < Class < ? > > childCategories = categories ( description ) ; if ( childCategories . isEmpty ( ) ) { return fIncluded . isEmpty ( ) ; } if ( ! fExcluded . isEmpty ( ) ) { if ( fExcludedAny ) { if ( matchesAnyParentCategories ( childCategories , fExcluded ) ) { return false ; } } else { if ( matchesAllParentCategories ( childCategories , fExcluded ) ) { return false ; } } } if ( fIncluded . isEmpty ( ) ) {
private StatementThread evaluateStatement ( ) throws InterruptedException { StatementThread thread = new StatementThread ( fOriginalStatement ) ; thread . setDaemon ( true ) ; thread . start ( ) ; fTimeUnit . timedJoin ( thread , fTimeout ) ; if ( ! thread . fFinished ) { thread . recordStackTrace ( ) ; } thread . interrupt ( ) ; return thread ; }
public void run5 ( ) throws IOException { logger . append ( " run5 " ) ; Random rnd = new Random ( ) ; byte [ ] data = new byte [ 1024 ] ; File tmp = tmpFile . newFile ( ) ; while ( true ) { FileChannel channel = new RandomAccessFile ( tmp , " rw " ) . getChannel ( ) ;
public void after ( ) { run4done = true ; run1Lock . unlock ( ) ; }
public void differentMatchersHaveDifferentDescriptions ( Matcher matcher1 , Matcher matcher2 , Object value ) { assumeThat ( value , matcher1 ) ; assumeThat ( value , not ( matcher2 ) ) ; assertThat ( matcher1 . toString ( ) , not ( matcher2 . toString ( ) ) ) ; }
public void successfulTest ( ) { } } public static class FailedTest extends AbstractStopwatchTest { @ Test public void failedTest ( ) { fail ( ) ; } } public static class SkippedTest extends AbstractStopwatchTest { @ Test public void skippedTest ( ) { assumeTrue ( false ) ; } } public static class WrongDurationTest extends AbstractStopwatchTest { @ Test public void wrongDuration ( ) throws InterruptedException { Thread . sleep ( 500L ) ; assertNotEquals ( fStopwatch . runtime ( MILLISECONDS ) , 300d , 100d ) ; } } public static class DurationTest extends AbstractStopwatchTest { @ Test public void duration ( ) throws InterruptedException { Thread . sleep ( 300L ) ; assertEquals ( 300d , fStopwatch . runtime ( MILLISECONDS ) , 100d ) ; Thread . sleep ( 500L ) ; assertEquals ( 800d , fStopwatch . runtime ( MILLISECONDS ) , 250d ) ; } } @ Before public void init ( ) { fRecord = new Record ( ) ; fFinishedRecord = new Record ( ) ; } @ Test public void succeeded ( ) { Result result = JUnitCore . runClasses ( SuccessfulTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " successfulTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . SUCCEEDED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; } @ Test public void failed ( ) { Result result = JUnitCore . runClasses ( FailedTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " failedTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . FAILED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; } @ Test public void skipped ( ) { Result result = JUnitCore . runClasses ( SkippedTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; assertThat ( fRecord . fName , is ( " skippedTest " ) ) ; assertThat ( fRecord . fName , is ( fFinishedRecord . fName ) ) ; assertThat ( fRecord . fStatus , is ( TestStatus . SKIPPED ) ) ; assertTrue ( " timeSpent > 0 " , fRecord . fDuration > 0 ) ; assertThat ( fRecord . fDuration , is ( fFinishedRecord . fDuration ) ) ; } @ Test public void wrongDuration ( ) { Result result = JUnitCore . runClasses ( WrongDurationTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } @ Test public void duration ( ) { Result result = JUnitCore . runClasses ( DurationTest . class ) ; assertTrue ( result . wasSuccessful ( ) ) ; } }
public void duration ( ) throws InterruptedException { Thread . sleep ( 300L ) ; assertEquals ( 300d , fStopwatch . runtime ( MILLISECONDS ) , 100d ) ; Thread . sleep ( 500L ) ; assertEquals ( 800d , fStopwatch . runtime ( MILLISECONDS ) , 250d ) ; }
public void evaluate ( ) throws Throwable { try { fNext . evaluate ( ) ; } catch ( AssumptionViolatedException e ) { optionallyHandleException ( e , handleAssumptionViolatedExceptions ) ; return ; } catch ( AssertionError e ) { optionallyHandleException ( e , handleAssertionErrors ) ; return ; } catch ( Throwable e ) { handleException ( e ) ; return ; } if ( fMatcherBuilder . expectsThrowable ( ) ) { failDueToMissingException ( ) ;
public void assertionErrorExpectedButNonIsThrown ( ) { thrown . handleAssertionErrors ( ) ; thrown . expect ( AssertionError . class ) ; }
public static Constructor < ? > getTestConstructor ( Class < ? > theClass ) throws NoSuchMethodException { try { return theClass . getConstructor ( String . class ) ; } catch ( NoSuchMethodException e ) { } return theClass . getConstructor ( ) ; }
private Result runMain ( JUnitSystem system , String . . . args ) { system . out ( ) . println ( " JUnit version " + Version . id ( ) ) ; List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; List < Failure > missingClasses = new ArrayList < Failure > ( ) ; for ( String each : args ) { try { classes . add ( Class . forName ( each ) ) ; } catch ( ClassNotFoundException e ) { system . out ( ) . println ( " Could not find class : " + each ) ; Description description = Description . createSuiteDescription ( each ) ; Failure failure = new Failure ( description , e ) ; missingClasses . add ( failure ) ; } } RunListener listener = new TextListener ( system ) ; addListener ( listener ) ; Result result = run ( classes . toArray ( new Class < ? > [ 0 ] ) ) ; for ( Failure each : missingClasses ) { result . getFailures ( ) . add ( each ) ; } return result ; }
public void evaluate ( ) throws Throwable { runWithAssignment ( Assignments . allUnassigned ( fTestMethod . getMethod ( ) , getTestClass ( ) ) ) ; boolean hasTheoryAnnotation = fTestMethod . getAnnotation ( Theory . class ) ! = null ; if ( successes = = 0 & & hasTheoryAnnotation ) { Assert
public void noTheoryAnnotationMeansAssumeShouldIgnore ( ) { Assume . assumeTrue ( false ) ; }
public void theoryMeansOnlyAssumeShouldFail ( ) throws InitializationError { JUnitCore junitRunner = new JUnitCore ( ) ; Runner theoryRunner = new Theories ( TheoryWithNoUnassumedParameters . class ) ; Request request = Request . runner ( theoryRunner ) ; Result result = junitRunner . run ( request ) ; Assert . assertEquals ( " A theory with no valid parameters did not fail . " , 1 , result . getFailureCount ( ) ) ;
public void theoryWithNoUnassumedParameters ( boolean value ) { Assume . assumeTrue ( value ) ; }
public void noTheoryAnnotationMeansAssumeShouldIgnore ( ) { Assume . assumeTrue ( false ) ; }
public void theoryMeansOnlyAssumeShouldFail ( ) throws InitializationError { JUnitCore junitRunner = new JUnitCore ( ) ; Runner theoryRunner = new Theories ( TheoryWithNoUnassumedParameters . class ) ; Request request = Request . runner ( theoryRunner ) ; Result result = junitRunner . run ( request ) ; Assert . assertEquals ( 1 , result . getFailureCount ( ) ) ; }
public void theoryWithNoUnassumedParameters ( boolean value ) { Assume . assumeTrue ( value ) ; }
public void enumErrorsUseEnumNameWithSingleValues ( ) throws InitializationError { Result result = runTheoryTest ( EnumTestWithBadValue . class ) ; Assert . assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable ex = result . getFailures ( ) . get ( 0 ) . getException ( ) ; Assert . assertThat ( ex . getMessage ( ) , containsString ( EnumValue . BAD_VALUE . toString ( ) ) ) ; return ; }
public void enumErrorsUseEnumNameWithArrays ( ) throws InitializationError { Result result = runTheoryTest ( EnumTestWithBadValueInArray . class ) ; Assert . assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable ex = result . getFailures ( ) . get ( 0 ) . getException ( ) ; Assert . assertThat ( ex . getMessage ( ) , containsString ( EnumValue . BAD_VALUE . toString ( ) ) ) ; return ; }
private Result runTheoryTest ( Class < ? > testClass ) throws InitializationError { JUnitCore junitRunner = new JUnitCore ( ) ; Runner theoryRunner = new Theories ( testClass ) ; Request request = Request . runner ( theoryRunner ) ; return junitRunner . run ( request ) ; }
private static void methodUnderTest ( EnumValue param ) { if ( param = = EnumValue . BAD_VALUE ) { throw new IllegalArgumentException ( " Bad param " ) ;
public void theoryTest ( EnumValue param ) { methodUnderTest ( param ) ; }
public String getDescription ( ) throws CouldNotGenerateValueException { return String . format ( " % s : % s " , name , value . toString ( ) ) ; }
public void failuresUseNameAndValueWithSingleValues ( ) throws InitializationError { Result result = runTheoryTest ( TestWithBadValue . class ) ; Assert . assertEquals ( 1 , result . getFailureCount ( ) ) ; String errorMessage = result . getFailures ( ) . get ( 0 ) . getException ( ) . getMessage ( ) ; Assert . assertThat ( errorMessage , containsString ( " badDatapoint " ) ) ; Assert . assertThat ( errorMessage , containsString ( BAD_VALUE ) ) ; }
public void failuresUseNameAndValueWithArrays ( ) throws InitializationError { Result result = runTheoryTest ( TestWithBadValueInArray . class ) ; Assert . assertEquals ( 1 , result . getFailureCount ( ) ) ; String errorMessage = result . getFailures ( ) . get ( 0 ) . getException ( ) . getMessage ( ) ; Assert . assertThat ( errorMessage , containsString ( " allValues [ 1 ] " ) ) ; Assert . assertThat ( errorMessage , containsString ( BAD_VALUE ) ) ; return ; }
private static void methodUnderTest ( String param ) { if ( param . equals ( BAD_VALUE ) ) { throw new IllegalArgumentException ( " Bad param " ) ;
public void theoryTest ( String param ) { methodUnderTest ( param ) ; }
public String getDescription ( ) throws CouldNotGenerateValueException { return String . format ( " % s : % s " , name , ( value ! = null ? value . toString ( ) : " null " ) ) ; }
public void failuresUseNameAndValueWithNullValues ( ) throws InitializationError { Result result = runTheoryTest ( TestWithBadNullValue . class ) ; Assert . assertEquals ( 1 , result . getFailureCount ( ) ) ; String errorMessage = result . getFailures ( ) . get ( 0 ) . getException ( ) . getMessage ( ) ; Assert . assertThat ( errorMessage , containsString ( " badDatapoint " ) ) ; Assert . assertThat ( errorMessage , containsString ( " null " ) ) ; }
static public void assertNotEquals ( String message , double expected , double actual , double delta ) { if ( ! doubleIsDifferent ( expected , actual , delta ) ) { failEquals ( message , new Double ( expected ) ) ;
static public void assertNotEquals ( double expected , double actual , double delta ) { assertNotEquals ( null , expected , actual , delta ) ; }
static public void assertNotEquals ( float expected , float actual , float delta ) { assertNotEquals ( null , expected , actual , delta ) ; }
static public void assertEquals ( String message , float expected , float actual , float delta ) { if ( floatIsDifferent ( expected , actual , delta ) ) { failNotEquals ( message , new Float ( expected ) , new Float ( actual ) ) ;
static public void assertNotEquals ( String message , float expected , float actual , float delta ) { if ( ! floatIsDifferent ( expected , actual , delta ) ) { failEquals ( message , new Float ( expected ) ) ;
static private boolean floatIsDifferent ( float f1 , float f2 , float delta ) { if ( Float . compare ( f1 , f2 ) = = 0 ) { return false ; } if ( ( Math . abs ( f1 - f2 ) < = delta ) ) { return false ; } return true ; }
public void assertNotEqualsWorksWithPrimitiveTypes ( ) { assertNotEquals ( 1L , 2L ) ; assertNotEquals ( " The values should be different " , 1L , 2L ) ; assertNotEquals ( 1 . 0 , 2 . 0 , 0 ) ; assertNotEquals ( " The values should be different " , 1 . 0 , 2 . 0 , 0 ) ; assertNotEquals ( 1 . 0f , 2 . 0f , 0f ) ; assertNotEquals ( " The values should be different " , 1 . 0f , 2 . 0f , 0f ) ; }
public void assertNotEqualsConsidersFloatDeltaCorrectly ( ) { assertNotEquals ( 1 . 0f , 0 . 75f , 0 . 25f ) ; }
public void assertNotEqualsIgnoresFloatDeltaOnNaN ( ) { assertNotEquals ( Float . NaN , Float . NaN , 1f ) ; }
static public void assertNotEquals ( String message , Object unexpected , Object actual ) { if ( equalsRegardingNull ( unexpected , actual ) ) { failEquals ( message , actual ) ;
static public void assertNotEquals ( Object unexpected , Object actual ) { assertNotEquals ( null , unexpected , actual ) ; }
static public void assertNotEquals ( String message , long unexpected , long actual ) { assertNotEquals ( message , ( Long ) unexpected , ( Long ) actual ) ; }
static public void assertNotEquals ( long unexpected , long actual ) { assertNotEquals ( null , unexpected , actual ) ; }
static public void assertNotEquals ( String message , double unexpected , double actual , double delta ) { if ( ! doubleIsDifferent ( unexpected , actual , delta ) ) { failEquals ( message , new Double ( actual ) ) ;
static public void assertNotEquals ( double unexpected , double actual , double delta ) { assertNotEquals ( null , unexpected , actual , delta ) ; }
static public void assertNotEquals ( float unexpected , float actual , float delta ) { assertNotEquals ( null , unexpected , actual , delta ) ; }
static public void assertNotEquals ( String message , float unexpected , float actual , float delta ) { if ( ! floatIsDifferent ( unexpected , actual , delta ) ) { failEquals ( message , new Float ( actual ) ) ;
public void foo ( @ TestedOn ( ints = { 1 } ) int x ) { } @ Test public void descriptionStatesParameterName ( ) throws Exception { TestedOnSupplier supplier = new TestedOnSupplier ( ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signatureOfFoo ( ) ) ; assertThat ( assignments . get ( 0 ) . getDescription ( ) , is ( " ints : 1 " ) ) ; } private ParameterSignature signatureOfFoo ( ) throws NoSuchMethodException { Method method = getClass ( ) . getMethod ( " foo " , int . class ) ; return ParameterSignature . signatures ( method ) . get ( 0 ) ; } }
public void descriptionStatesParameterName ( ) throws Exception { TestedOnSupplier supplier = new TestedOnSupplier ( ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signatureOfFoo ( ) ) ; assertThat ( assignments . get ( 0 ) . getDescription ( ) , is ( " ints : 1 " ) ) ; }
public void reportBadParams ( ) throws Exception { assertThat ( testResult ( DoesntUseParams . class ) , hasSingleFailureContaining ( " everythingIsZero ( ONE : 1 , ONE : 1 ) " ) ) ;
public String getDescription ( ) throws CouldNotGenerateValueException { return String . format ( " % s : % s " , name , value ) ; }
public String toString ( ) { return format ( " [ % s ] " , value ) ; }
public void shouldUseQuotedValueInDescription ( ) throws CouldNotGenerateValueException { String name = " stringDatapoint " ; Object value = new Object ( ) { @ Override public String toString ( ) { return " string value " ; } } ; PotentialAssignment assignment = PotentialAssignment . forValue ( name , value ) ; assertEquals ( " \ " string value \ " < from stringDatapoint > " , assignment . getDescription ( ) ) ; }
public String toString ( ) { return " string value " ; }
public void shouldNotUseQuotesForNullValueDescriptions ( ) throws CouldNotGenerateValueException { String name = " nullDatapoint " ; Object value = null ; PotentialAssignment assignment = PotentialAssignment . forValue ( name , value ) ; assertEquals ( " null < from nullDatapoint > " , assignment . getDescription ( ) ) ; }
public void shouldIncludeFailureInDescriptionIfToStringFails ( ) throws CouldNotGenerateValueException { String name = " explodingValue " ; Object value = new Object ( ) { @ Override public String toString ( ) { throw new RuntimeException ( " Oh no ! " ) ; } } ; PotentialAssignment assignment = PotentialAssignment . forValue ( name , value ) ; assertEquals ( " [ toString ( ) threw RuntimeException : Oh no ! ] < from explodingValue > " , assignment . getDescription ( ) ) ; }
public String toString ( ) { throw new RuntimeException ( " Oh no ! " ) ; }
public void shouldReturnGivenValue ( ) throws CouldNotGenerateValueException { Object value = new Object ( ) ; PotentialAssignment assignment = PotentialAssignment . forValue ( " name " , value ) ; assertEquals ( value , assignment . getValue ( ) ) ; }
public void foo ( @ TestedOn ( ints = { 1 } ) int x ) { } @ Test public void descriptionStatesParameterName ( ) throws Exception { TestedOnSupplier supplier = new TestedOnSupplier ( ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signatureOfFoo ( ) ) ; assertThat ( assignments . get ( 0 ) . getDescription ( ) , is ( " \ " 1 \ " < from ints > " ) ) ; } private ParameterSignature signatureOfFoo ( ) throws NoSuchMethodException { Method method = getClass ( ) . getMethod ( " foo " , int . class ) ; return ParameterSignature . signatures ( method ) . get ( 0 ) ; } }
public void descriptionStatesParameterName ( ) throws Exception { TestedOnSupplier supplier = new TestedOnSupplier ( ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signatureOfFoo ( ) ) ; assertThat ( assignments . get ( 0 ) . getDescription ( ) , is ( " \ " 1 \ " < from ints > " ) ) ; }
public void reportBadParams ( ) throws Exception { assertThat ( testResult ( DoesntUseParams . class ) , hasSingleFailureContaining ( " everythingIsZero ( \ " 1 \ " < from ONE > , \ " 1 \ " < from ONE > ) " ) ) ;
public void shouldUseQuotedValueInDescription ( ) throws CouldNotGenerateValueException { String name = " stringDatapoint " ; Object value = new Object ( ) { @ Override public String toString ( ) { return " string value " ; } } ; PotentialAssignment assignment = PotentialAssignment . forValue ( name , value ) ; assertEquals ( " \ " string value \ " < from stringDatapoint > " , assignment . getDescription ( ) ) ; }
public String toString ( ) { return " string value " ; }
public void shouldNotUseQuotesForNullValueDescriptions ( ) throws CouldNotGenerateValueException { String name = " nullDatapoint " ; Object value = null ; PotentialAssignment assignment = PotentialAssignment . forValue ( name , value ) ; assertEquals ( " null < from nullDatapoint > " , assignment . getDescription ( ) ) ; }
public void shouldIncludeFailureInDescriptionIfToStringFails ( ) throws CouldNotGenerateValueException { String name = " explodingValue " ; Object value = new Object ( ) { @ Override public String toString ( ) { throw new RuntimeException ( " Oh no ! " ) ; } } ; PotentialAssignment assignment = PotentialAssignment . forValue ( name , value ) ; assertEquals ( " [ toString ( ) threw RuntimeException : Oh no ! ] < from explodingValue > " , assignment . getDescription ( ) ) ; }
public String toString ( ) { throw new RuntimeException ( " Oh no ! " ) ; }
public void shouldReturnGivenValue ( ) throws CouldNotGenerateValueException { Object value = new Object ( ) ; PotentialAssignment assignment = PotentialAssignment . forValue ( " name " , value ) ; assertEquals ( value , assignment . getValue ( ) ) ; }
protected void collectInitializationErrors ( List < Throwable > errors ) { super . collectInitializationErrors ( errors ) ; validateDataPointFields ( errors ) ; validateDataPointMethods ( errors ) ; }
public void theoryClassMethodsShowUp ( ) throws Exception { assertThat ( new Theories ( HasAFailingTheory . class ) . getDescription ( ) . getChildren ( ) . size ( ) , is ( 1 ) ) ;
public void theoryAnnotationsAreRetained ( ) throws Exception { assertThat ( new TestClass ( HasAFailingTheory . class ) . getAnnotatedMethods ( Theory . class ) . size ( ) , is ( 1 ) ) ;
public void canRunTheories ( ) throws Exception { assertThat ( testResult ( HasAFailingTheory . class ) , hasSingleFailureContaining ( " Expected " ) ) ;
void numbers ( int x ) { } } @ Test public void theoriesMustBePublic ( ) { assertThat ( testResult ( TheoriesMustBePublic . class ) , hasSingleFailureContaining ( " public " ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBeStatic { @ DataPoint public int THREE = 3 ; @ DataPoints public int [ ] FOURS = new int [ ] { 4 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBeStatic ( ) { assertThat ( testResult ( DataPointFieldsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( failureCountIs ( 2 ) ) . and ( hasFailureContaining ( " DataPoint field THREE must be static " ) ) . and ( hasFailureContaining ( " DataPoint field FOURS must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBeStatic { @ DataPoint public int singleDataPointMethod ( ) { return 1 ; } @ DataPoints public int [ ] dataPointArrayMethod ( ) { return new int [ ] { 1 , 2 , 3 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( failureCountIs ( 2 ) ) . and ( hasFailureContaining ( " DataPoint method singleDataPointMethod must be static " ) ) . and ( hasFailureContaining ( " DataPoint method dataPointArrayMethod must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBePublic { @ DataPoint static int THREE = 3 ; @ DataPoints static int [ ] THREES = new int [ ] { 3 } ; @ DataPoint protected static int FOUR = 4 ; @ DataPoints protected static int [ ] FOURS = new int [ ] { 4 } ; @ DataPoint private static int FIVE = 5 ; @ DataPoints private static int [ ] FIVES = new int [ ] { 5 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBeStatic ( ) { assertThat ( testResult ( DataPointFieldsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( failureCountIs ( 2 ) ) . and ( hasFailureContaining ( " DataPoint field THREE must be static " ) ) . and ( hasFailureContaining ( " DataPoint field FOURS must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBeStatic { @ DataPoint public int singleDataPointMethod ( ) { return 1 ; } @ DataPoints public int [ ] dataPointArrayMethod ( ) { return new int [ ] { 1 , 2 , 3 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( failureCountIs ( 2 ) ) . and ( hasFailureContaining ( " DataPoint method singleDataPointMethod must be static " ) ) . and ( hasFailureContaining ( " DataPoint method dataPointArrayMethod must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBePublic { @ DataPoint static int THREE = 3 ; @ DataPoints static int [ ] THREES = new int [ ] { 3 } ; @ DataPoint protected static int FOUR = 4 ; @ DataPoints protected static int [ ] FOURS = new int [ ] { 4 } ; @ DataPoint private static int FIVE = 5 ; @ DataPoints private static int [ ] FIVES = new int [ ] { 5 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void dataPointFieldsMustBeStatic ( ) { assertThat ( testResult ( DataPointFieldsMustBeStatic . class ) ,
public int singleDataPointMethod ( ) { return 1 ; }
public int [ ] dataPointArrayMethod ( ) { return new int [ ] { 1 , 2 , 3 } ; }
public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( failureCountIs ( 2 ) ) . and ( hasFailureContaining ( " DataPoint method singleDataPointMethod must be static " ) ) . and ( hasFailureContaining ( " DataPoint method dataPointArrayMethod must be static " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointFieldsMustBePublic { @ DataPoint static int THREE = 3 ; @ DataPoints static int [ ] THREES = new int [ ] { 3 } ; @ DataPoint protected static int FOUR = 4 ; @ DataPoints protected static int [ ] FOURS = new int [ ] { 4 } ; @ DataPoint private static int FIVE = 5 ; @ DataPoints private static int [ ] FIVES = new int [ ] { 5 } ; @ Theory public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) ,
public void numbers ( int x ) { } } @ Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) , hasFailureContaining ( " DataPoint field THREES must be public " ) , hasFailureContaining ( " DataPoint field FOUR must be public " ) , hasFailureContaining ( " DataPoint field FOURS must be public " ) , hasFailureContaining ( " DataPoint field FIVE must be public " ) , hasFailureContaining ( " DataPoint field FIVES must be public " ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @ DataPoint static int three ( ) { return 3 ; } @ DataPoints static int [ ] threes ( ) { return new int [ ] { 3 } ; } @ DataPoint protected static int four ( ) { return 4 ; } @ DataPoints protected static int [ ] fours ( ) { return new int [ ] { 4 } ; } @ DataPoint private static int five ( ) { return 5 ; } @ DataPoints private static int [ ] fives ( ) { return new int [ ] { 5 } ; } @ Theory public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint field THREE must be public " ) ,
static int three ( ) { return 3 ; }
static int [ ] threes ( ) { return new int [ ] { 3 } ; }
protected static int four ( ) { return 4 ; }
protected static int [ ] fours ( ) { return new int [ ] { 4 } ; }
private static int five ( ) { return 5 ; }
private static int [ ] fives ( ) { return new int [ ] { 5 } ; }
public void numbers ( int x ) { } } @ Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) , hasFailureContaining ( " DataPoint method threes must be public " ) , hasFailureContaining ( " DataPoint method four must be public " ) , hasFailureContaining ( " DataPoint method fours must be public " ) , hasFailureContaining ( " DataPoint method five must be public " ) , hasFailureContaining ( " DataPoint method fives must be public " ) ) ) ; } }
public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertEquals ( 6 , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( " DataPoint method three must be public " ) ,
public ParameterSupplier getSupplier ( ParameterSignature unassigned ) throws InstantiationException , IllegalAccessException { ParameterSupplier supplier = getSupplierFromAnnotation ( unassigned ) ; if ( supplier ! = null ) { return supplier ; } return new AllMembersSupplier ( fClass ) ; }
private ParameterSupplier getSupplierFromAnnotation ( ParameterSignature unassigned ) throws InstantiationException , IllegalAccessException { ParametersSuppliedBy parameterSupplierAnnotation = unassigned . findDeepAnnotation ( ParametersSuppliedBy . class ) ; if ( parameterSupplierAnnotation ! = null ) { return parameterSupplierAnnotation . value ( ) . newInstance ( ) ; } FromDataPoints fromDataPointsAnnotation = unassigned . getAnnotation ( FromDataPoints . class ) ; if ( fromDataPointsAnnotation ! = null ) { return new SpecificDataPointsSupplier ( fClass ) ; } return null ; }
public void shouldReturnOnlyTheNamedDataPoints ( ) throws Exception { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingAllNamedStrings " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 4 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItems ( " named field " , " named method " , " named single value " , " named single method value " ) ) ; }
public void shouldReturnOnlyTheNamedFieldDataPoints ( ) throws Exception { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingNamedFieldString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 1 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( " named field " ) ) ; }
public void shouldReturnOnlyTheNamedMethodDataPoints ( ) throws Exception { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingNamedMethodString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 1 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( " named method " ) ) ; }
public void shouldReturnOnlyTheNamedSingleFieldDataPoints ( ) throws Exception { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingNamedSingleFieldString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 1 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( " named single value " ) ) ; }
public void shouldReturnOnlyTheNamedSingleMethodDataPoints ( ) throws Exception { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingNamedSingleMethodString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 1 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( " named single method value " ) ) ; }
public void shouldReturnNothingIfTheNamedDataPointsAreMissing ( ) throws Exception { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingWrongNamedString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 0 , assignedStrings . size ( ) ) ; }
private List < String > getStringValuesFromAssignments ( List < PotentialAssignment > assignments ) throws CouldNotGenerateValueException { List < String > stringValues = new ArrayList < String > ( ) ; for ( PotentialAssignment assignment : assignments ) { stringValues . add ( ( String ) assignment . getValue ( ) ) ; } return stringValues ; }
private ParameterSignature signature ( String methodName ) throws Exception { return ParameterSignature . signatures ( this . getClass ( ) . getMethod ( methodName , String . class ) ) . get ( 0 ) ; }
public void methodWantingAnyString ( String input ) { } public void methodWantingNamedFieldString ( @ FromDataPoints ( " field " ) String input ) { } public void methodWantingNamedMethodString ( @ FromDataPoints ( " method " ) String input ) { } public void methodWantingNamedSingleFieldString ( @ FromDataPoints ( " single " ) String input ) { } public void methodWantingNamedSingleMethodString ( @ FromDataPoints ( " singlemethod " ) String input ) { } public void methodWantingAllNamedStrings ( @ FromDataPoints ( " named " ) String input ) { } public void methodWantingWrongNamedString ( @ FromDataPoints ( " invalid name " ) String input ) { } }
public void methodWantingNamedFieldString ( @ FromDataPoints ( " field " ) String input ) { } public void methodWantingNamedMethodString ( @ FromDataPoints ( " method " ) String input ) { } public void methodWantingNamedSingleFieldString ( @ FromDataPoints ( " single " ) String input ) { } public void methodWantingNamedSingleMethodString ( @ FromDataPoints ( " singlemethod " ) String input ) { } public void methodWantingAllNamedStrings ( @ FromDataPoints ( " named " ) String input ) { } public void methodWantingWrongNamedString ( @ FromDataPoints ( " invalid name " ) String input ) { } }
public void methodWantingNamedMethodString ( @ FromDataPoints ( " method " ) String input ) { } public void methodWantingNamedSingleFieldString ( @ FromDataPoints ( " single " ) String input ) { } public void methodWantingNamedSingleMethodString ( @ FromDataPoints ( " singlemethod " ) String input ) { } public void methodWantingAllNamedStrings ( @ FromDataPoints ( " named " ) String input ) { } public void methodWantingWrongNamedString ( @ FromDataPoints ( " invalid name " ) String input ) { } }
public void methodWantingNamedSingleFieldString ( @ FromDataPoints ( " single " ) String input ) { } public void methodWantingNamedSingleMethodString ( @ FromDataPoints ( " singlemethod " ) String input ) { } public void methodWantingAllNamedStrings ( @ FromDataPoints ( " named " ) String input ) { } public void methodWantingWrongNamedString ( @ FromDataPoints ( " invalid name " ) String input ) { } }
public void methodWantingNamedSingleMethodString ( @ FromDataPoints ( " singlemethod " ) String input ) { } public void methodWantingAllNamedStrings ( @ FromDataPoints ( " named " ) String input ) { } public void methodWantingWrongNamedString ( @ FromDataPoints ( " invalid name " ) String input ) { } }
public void methodWantingAllNamedStrings ( @ FromDataPoints ( " named " ) String input ) { } public void methodWantingWrongNamedString ( @ FromDataPoints ( " invalid name " ) String input ) { } }
public void methodWantingWrongNamedString ( @ FromDataPoints ( " invalid name " ) String input ) { } }
public void allIntsOk ( int x ) { } } @ RunWith ( Theories . class ) public static class HasUglyDataPointMethod { @ DataPoint public static int oneHundred ( ) { return 100 ; } @ DataPoint public static int oneUglyHundred ( ) { throw new RuntimeException ( ) ; } @ Theory public void allIntsOk ( int x ) { } } @ Test public void pickUpDataPointMethods ( ) { assertThat ( testResult ( HasDataPointMethod . class ) , isSuccessful ( ) ) ; } @ Test public void ignoreExceptionsFromDataPointMethods ( ) { assertThat ( testResult ( HasUglyDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodReturnsMutableObject { @ DataPoint public static List < Object > empty ( ) { return new ArrayList < Object > ( ) ; } @ DataPoint public static int ONE = 1 ; @ DataPoint public static int TWO = 2 ; @ Theory public void everythingsEmpty ( List < Object > first , int number ) { assertThat ( first . size ( ) , is ( 0 ) ) ; first . add ( " a " ) ; } } @ Test public void mutableObjectsAreCreatedAfresh ( ) { assertThat ( failures ( DataPointMethodReturnsMutableObject . class ) , empty ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public int oneHundred ( ) { return 100 ; } public Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } @ RunWith ( Theories . class ) public static class HasSpecificDatapointsParameters { @ DataPoints public static String [ ] badStrings = new String [ ] { " bad " } ; @ DataPoint public static String badString = " also bad " ; @ DataPoints ( " named " ) public static String [ ] goodStrings = new String [ ] { " expected " , " also expected " } ; @ DataPoint ( " named " ) public static String goodString = " expected single value " ; @ DataPoints ( " named " ) public static String [ ] methodStrings ( ) { return new String [ ] { " expected method value " } ; } @ DataPoint ( " named " ) public static String methodString ( ) { return " expected single method string " ; } @ DataPoints public static String [ ] otherMethod ( ) { return new String [ ] { " other method value " } ; } @ DataPoint public static String otherSingleValueMethod ( ) { return " other single value string " ; } @ Theory public void testMethod ( @ FromDataPoints ( " named " ) String x ) { } } @ Test public void onlyUseSpecificDataPointsIfSpecified ( ) throws Exception { List < PotentialAssignment > assignments = potentialValues ( HasSpecificDatapointsParameters . class . getMethod ( " testMethod " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ; } } private List < PotentialAssignment > potentialValues ( Method method ) throws Exception { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) ) . potentialsForNextUnassigned ( ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void allIntsOk ( int x ) { } } @ Test public void pickUpDataPointMethods ( ) { assertThat ( testResult ( HasDataPointMethod . class ) , isSuccessful ( ) ) ; } @ Test public void ignoreExceptionsFromDataPointMethods ( ) { assertThat ( testResult ( HasUglyDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodReturnsMutableObject { @ DataPoint public static List < Object > empty ( ) { return new ArrayList < Object > ( ) ; } @ DataPoint public static int ONE = 1 ; @ DataPoint public static int TWO = 2 ; @ Theory public void everythingsEmpty ( List < Object > first , int number ) { assertThat ( first . size ( ) , is ( 0 ) ) ; first . add ( " a " ) ; } } @ Test public void mutableObjectsAreCreatedAfresh ( ) { assertThat ( failures ( DataPointMethodReturnsMutableObject . class ) , empty ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public int oneHundred ( ) { return 100 ; } public Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } @ RunWith ( Theories . class ) public static class HasSpecificDatapointsParameters { @ DataPoints public static String [ ] badStrings = new String [ ] { " bad " } ; @ DataPoint public static String badString = " also bad " ; @ DataPoints ( " named " ) public static String [ ] goodStrings = new String [ ] { " expected " , " also expected " } ; @ DataPoint ( " named " ) public static String goodString = " expected single value " ; @ DataPoints ( " named " ) public static String [ ] methodStrings ( ) { return new String [ ] { " expected method value " } ; } @ DataPoint ( " named " ) public static String methodString ( ) { return " expected single method string " ; } @ DataPoints public static String [ ] otherMethod ( ) { return new String [ ] { " other method value " } ; } @ DataPoint public static String otherSingleValueMethod ( ) { return " other single value string " ; } @ Theory public void testMethod ( @ FromDataPoints ( " named " ) String x ) { } } @ Test public void onlyUseSpecificDataPointsIfSpecified ( ) throws Exception { List < PotentialAssignment > assignments = potentialValues ( HasSpecificDatapointsParameters . class . getMethod ( " testMethod " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ; } } private List < PotentialAssignment > potentialValues ( Method method ) throws Exception { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) ) . potentialsForNextUnassigned ( ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } @ RunWith ( Theories . class ) public static class HasSpecificDatapointsParameters { @ DataPoints public static String [ ] badStrings = new String [ ] { " bad " } ; @ DataPoint public static String badString = " also bad " ; @ DataPoints ( " named " ) public static String [ ] goodStrings = new String [ ] { " expected " , " also expected " } ; @ DataPoint ( " named " ) public static String goodString = " expected single value " ; @ DataPoints ( " named " ) public static String [ ] methodStrings ( ) { return new String [ ] { " expected method value " } ; } @ DataPoint ( " named " ) public static String methodString ( ) { return " expected single method string " ; } @ DataPoints public static String [ ] otherMethod ( ) { return new String [ ] { " other method value " } ; } @ DataPoint public static String otherSingleValueMethod ( ) { return " other single value string " ; } @ Theory public void testMethod ( @ FromDataPoints ( " named " ) String x ) { } } @ Test public void onlyUseSpecificDataPointsIfSpecified ( ) throws Exception { List < PotentialAssignment > assignments = potentialValues ( HasSpecificDatapointsParameters . class . getMethod ( " testMethod " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ; } } private List < PotentialAssignment > potentialValues ( Method method ) throws Exception { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) ) . potentialsForNextUnassigned ( ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } @ RunWith ( Theories . class ) public static class HasSpecificDatapointsParameters { @ DataPoints public static String [ ] badStrings = new String [ ] { " bad " } ; @ DataPoint public static String badString = " also bad " ; @ DataPoints ( " named " ) public static String [ ] goodStrings = new String [ ] { " expected " , " also expected " } ; @ DataPoint ( " named " ) public static String goodString = " expected single value " ; @ DataPoints ( " named " ) public static String [ ] methodStrings ( ) { return new String [ ] { " expected method value " } ; } @ DataPoint ( " named " ) public static String methodString ( ) { return " expected single method string " ; } @ DataPoints public static String [ ] otherMethod ( ) { return new String [ ] { " other method value " } ; } @ DataPoint public static String otherSingleValueMethod ( ) { return " other single value string " ; } @ Theory public void testMethod ( @ FromDataPoints ( " named " ) String x ) { } } @ Test public void onlyUseSpecificDataPointsIfSpecified ( ) throws Exception { List < PotentialAssignment > assignments = potentialValues ( HasSpecificDatapointsParameters . class . getMethod ( " testMethod " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ; } } private List < PotentialAssignment > potentialValues ( Method method ) throws Exception { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) ) . potentialsForNextUnassigned ( ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialValues ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } @ RunWith ( Theories . class ) public static class HasSpecificDatapointsParameters { @ DataPoints public static String [ ] badStrings = new String [ ] { " bad " } ; @ DataPoint public static String badString = " also bad " ; @ DataPoints ( " named " ) public static String [ ] goodStrings = new String [ ] { " expected " , " also expected " } ; @ DataPoint ( " named " ) public static String goodString = " expected single value " ; @ DataPoints ( " named " ) public static String [ ] methodStrings ( ) { return new String [ ] { " expected method value " } ; } @ DataPoint ( " named " ) public static String methodString ( ) { return " expected single method string " ; } @ DataPoints public static String [ ] otherMethod ( ) { return new String [ ] { " other method value " } ; } @ DataPoint public static String otherSingleValueMethod ( ) { return " other single value string " ; } @ Theory public void testMethod ( @ FromDataPoints ( " named " ) String x ) { } } @ Test public void onlyUseSpecificDataPointsIfSpecified ( ) throws Exception { List < PotentialAssignment > assignments = potentialValues ( HasSpecificDatapointsParameters . class . getMethod ( " testMethod " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ; } } private List < PotentialAssignment > potentialValues ( Method method ) throws Exception { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) ) . potentialsForNextUnassigned ( ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public static String [ ] methodStrings ( ) { return new String [ ] { " expected method value " } ; }
public static String methodString ( ) { return " expected single method string " ; }
public static String [ ] otherMethod ( ) { return new String [ ] { " other method value " } ; }
public static String otherSingleValueMethod ( ) { return " other single value string " ; }
public void testMethod ( @ FromDataPoints ( " named " ) String x ) { } } @ Test public void onlyUseSpecificDataPointsIfSpecified ( ) throws Exception { List < PotentialAssignment > assignments = potentialValues ( HasSpecificDatapointsParameters . class . getMethod ( " testMethod " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ; } } private List < PotentialAssignment > potentialValues ( Method method ) throws Exception { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) ) . potentialsForNextUnassigned ( ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void onlyUseSpecificDataPointsIfSpecified ( ) throws Exception { List < PotentialAssignment > assignments = potentialValues ( HasSpecificDatapointsParameters . class . getMethod ( " testMethod " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ;
private List < PotentialAssignment > potentialValues ( Method method ) throws Exception { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) )
public List < PotentialAssignment > potentialsForNextUnassigned ( ) throws ReflectiveOperationException { ParameterSignature unassigned = nextUnassigned ( ) ; return getSupplier ( unassigned ) . getValueSources ( unassigned ) ; }
private ParameterSupplier getSupplier ( ParameterSignature unassigned ) throws ReflectiveOperationException { ParameterSupplier supplier = getAnnotatedSupplier ( unassigned ) ; if ( supplier ! = null ) { return supplier ; } return new AllMembersSupplier ( fClass ) ; }
private ParameterSupplier getAnnotatedSupplier ( ParameterSignature unassigned ) throws ReflectiveOperationException { ParametersSuppliedBy annotation = unassigned . findDeepAnnotation ( ParametersSuppliedBy . class ) ; if ( annotation ! = null ) { return buildParameterSupplierFromClass ( annotation . value ( ) ) ;
private ParameterSupplier buildParameterSupplierFromClass ( Class < ? extends ParameterSupplier > cls ) throws ReflectiveOperationException { Constructor < ? > [ ] supplierConstructors = cls . getConstructors ( ) ; for ( Constructor < ? > constructor : supplierConstructors ) { Class < ? > [ ] parameterTypes = constructor . getParameterTypes ( ) ; if ( parameterTypes . length = = 1 & & parameterTypes [ 0 ] . equals ( TestClass . class ) ) { return ( ParameterSupplier ) constructor . newInstance ( fClass ) ; } } return cls . newInstance ( ) ; }
private GuesserQueue createGuesserQueue ( Assignments incomplete ) throws ReflectiveOperationException { ParameterSignature nextUnassigned = incomplete . nextUnassigned ( ) ; if ( nextUnassigned . hasAnnotation ( Stub . class ) ) { GuesserQueue queue = new GuesserQueue ( ) ; queue . add ( new Guesser < Object > ( nextUnassigned . getType ( ) ) ) ; return queue ; } return GuesserQueue . forSingleValues ( incomplete . potentialsForNextUnassigned ( ) ) ; }
public Object getValue ( ) throws CouldNotGenerateValueException { return value ; }
public String getDescription ( ) throws CouldNotGenerateValueException { return description ; }
public void theoryMethod ( @ ParametersSuppliedBy ( Supplier . class ) String parameter ) { } } @ Test public void shouldPickUpDataPointsFromParameterSupplier ( ) throws Exception { List < PotentialAssignment > assignments = potentialValues ( TestClassUsingParameterSupplier . class . getMethod ( " theoryMethod " , String . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; assertEquals ( DATAPOINTS . get ( 0 ) , assignments . get ( 0 ) . getValue ( ) ) ; assertEquals ( DATAPOINTS . get ( 1 ) , assignments . get ( 1 ) . getValue ( ) ) ; } private List < PotentialAssignment > potentialValues ( Method method ) throws Exception { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) ) . potentialsForNextUnassigned ( ) ; } }
public void shouldPickUpDataPointsFromParameterSupplier ( ) throws Exception { List < PotentialAssignment > assignments = potentialValues ( TestClassUsingParameterSupplier . class . getMethod ( " theoryMethod " , String . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; assertEquals ( DATAPOINTS . get ( 0 ) , assignments . get ( 0 ) . getValue ( ) ) ; assertEquals ( DATAPOINTS . get ( 1 ) , assignments . get ( 1 ) . getValue ( ) ) ; }
private ParameterSupplier getSupplier ( ParameterSignature unassigned ) throws ReflectiveOperationException { ParametersSuppliedBy annotation = unassigned . findDeepAnnotation ( ParametersSuppliedBy . class ) ; if ( annotation ! = null ) { return buildParameterSupplierFromClass ( annotation . value ( ) ) ;
private void validateParameterSupplier ( Class < ? extends ParameterSupplier > supplierClass , List < Throwable > errors ) { Constructor < ? > [ ] constructors = supplierClass . getConstructors ( ) ; if ( constructors . length ! = 1 ) { errors . add ( new Error ( " ParameterSupplier " + supplierClass . getName ( ) +
public static List < PotentialAssignment > potentialAssignments ( Method method ) throws Exception { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) )
public void allIntsOk ( int x ) { } } @ RunWith ( Theories . class ) public static class HasUglyDataPointMethod { @ DataPoint public static int oneHundred ( ) { return 100 ; } @ DataPoint public static int oneUglyHundred ( ) { throw new RuntimeException ( ) ; } @ Theory public void allIntsOk ( int x ) { } } @ Test public void pickUpDataPointMethods ( ) { assertThat ( testResult ( HasDataPointMethod . class ) , isSuccessful ( ) ) ; } @ Test public void ignoreExceptionsFromDataPointMethods ( ) { assertThat ( testResult ( HasUglyDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodReturnsMutableObject { @ DataPoint public static List < Object > empty ( ) { return new ArrayList < Object > ( ) ; } @ DataPoint public static int ONE = 1 ; @ DataPoint public static int TWO = 2 ; @ Theory public void everythingsEmpty ( List < Object > first , int number ) { assertThat ( first . size ( ) , is ( 0 ) ) ; first . add ( " a " ) ; } } @ Test public void mutableObjectsAreCreatedAfresh ( ) { assertThat ( failures ( DataPointMethodReturnsMutableObject . class ) , empty ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public int oneHundred ( ) { return 100 ; } public Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void allIntsOk ( int x ) { } } @ Test public void pickUpDataPointMethods ( ) { assertThat ( testResult ( HasDataPointMethod . class ) , isSuccessful ( ) ) ; } @ Test public void ignoreExceptionsFromDataPointMethods ( ) { assertThat ( testResult ( HasUglyDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodReturnsMutableObject { @ DataPoint public static List < Object > empty ( ) { return new ArrayList < Object > ( ) ; } @ DataPoint public static int ONE = 1 ; @ DataPoint public static int TWO = 2 ; @ Theory public void everythingsEmpty ( List < Object > first , int number ) { assertThat ( first . size ( ) , is ( 0 ) ) ; first . add ( " a " ) ; } } @ Test public void mutableObjectsAreCreatedAfresh ( ) { assertThat ( failures ( DataPointMethodReturnsMutableObject . class ) , empty ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public int oneHundred ( ) { return 100 ; } public Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) )
public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) )
public void theory ( @ FromDataPoints ( " named " ) String param ) { } } @ Test public void onlyUseSpecificDataPointsIfSpecified ( ) throws Exception { List < PotentialAssignment > assignments = potentialAssignments ( HasSpecificDatapointsParameters . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ; } } }
public void onlyUseSpecificDataPointsIfSpecified ( ) throws Exception { List < PotentialAssignment > assignments = potentialAssignments ( HasSpecificDatapointsParameters . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ;
public void shouldPickUpDataPointsFromParameterSupplier ( ) throws Exception { List < PotentialAssignment > assignments = potentialAssignments ( TestClassUsingParameterSupplier . class . getMethod ( " theoryMethod " , String . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; assertEquals ( DATAPOINTS . get ( 0 ) , assignments . get ( 0 ) . getValue ( ) ) ; assertEquals ( DATAPOINTS . get ( 1 ) , assignments . get ( 1 ) . getValue ( ) ) ; }
public void shouldRejectSuppliersWithUnknownConstructors ( ) throws Exception { expected . expect ( InitializationError . class ) ; new Theories ( TestClassUsingSupplierWithUnknownConstructor . class ) ; }
public void shouldRejectSuppliersWithTwoConstructors ( ) throws Exception { expected . expect ( InitializationError . class ) ; new Theories ( TestClassUsingSupplierWithTwoConstructors . class ) ; }
public void theory ( @ ParametersSuppliedBy ( SupplierWithTestClassConstructor . class ) String param ) { } } @ Test public void shouldAcceptSuppliersWithTestClassConstructor ( ) throws Exception { new Theories ( TestClassUsingSupplierWithTestClassConstructor . class ) ; } }
public void shouldAcceptSuppliersWithTestClassConstructor ( ) throws Exception { new Theories ( TestClassUsingSupplierWithTestClassConstructor . class ) ; }
public static void assertArrayEquals ( String message , boolean [ ] expecteds , boolean [ ] actuals ) throws ArrayComparisonFailure { internalArrayEquals ( message , expecteds , actuals ) ; }
public static void assertArrayEquals ( boolean [ ] expecteds , boolean [ ] actuals ) { assertArrayEquals ( null , expecteds , actuals ) ; }
public void oneDimensionalPrimitiveArraysAreEqual ( ) { assertArrayEquals ( new boolean [ ] { true } , new boolean [ ] { true } ) ; assertArrayEquals ( new byte [ ] { 1 } , new byte [ ] { 1 } ) ; assertArrayEquals ( new char [ ] { 1 } , new char [ ] { 1 } ) ; assertArrayEquals ( new short [ ] { 1 } , new short [ ] { 1 } ) ; assertArrayEquals ( new int [ ] { 1 } , new int [ ] { 1 } ) ; assertArrayEquals ( new long [ ] { 1 } , new long [ ] { 1 } ) ; assertArrayEquals ( new double [ ] { 1 . 0 } , new double [ ] { 1 . 0 } , 1 . 0 ) ; assertArrayEquals ( new float [ ] { 1 . 0f } , new float [ ] { 1 . 0f } , 1 . 0f ) ; }
public void oneDimensionalBooleanArraysAreNotEqual ( ) { assertArrayEquals ( new boolean [ ] { true } , new boolean [ ] { false } ) ; }
public Assignments assignNext ( PotentialAssignment source ) { List < PotentialAssignment > assigned = new ArrayList < PotentialAssignment > ( fAssigned ) ; assigned . add ( source ) ; return new Assignments ( assigned , fUnassigned . subList ( 1 , fUnassigned . size ( ) ) , fClass ) ;
public List < PotentialAssignment > potentialsForNextUnassigned ( ) throws Exception { ParameterSignature unassigned = nextUnassigned ( ) ; return getSupplier ( unassigned ) . getValueSources ( unassigned ) ; }
private ParameterSupplier getSupplier ( ParameterSignature unassigned ) throws Exception { ParametersSuppliedBy annotation = unassigned . findDeepAnnotation ( ParametersSuppliedBy . class ) ; if ( annotation ! = null ) { return buildParameterSupplierFromClass ( annotation . value ( ) ) ;
private ParameterSupplier buildParameterSupplierFromClass ( Class < ? extends ParameterSupplier > cls ) throws Exception { Constructor < ? > [ ] supplierConstructors = cls . getConstructors ( ) ; for ( Constructor < ? > constructor : supplierConstructors ) { Class < ? > [ ] parameterTypes = constructor . getParameterTypes ( ) ; if ( parameterTypes . length = = 1 & & parameterTypes [ 0 ] . equals ( TestClass . class ) ) { return ( ParameterSupplier ) constructor . newInstance ( fClass ) ; } } return cls . newInstance ( ) ; }
private GuesserQueue createGuesserQueue ( Assignments incomplete ) throws Exception { ParameterSignature nextUnassigned = incomplete . nextUnassigned ( ) ; if ( nextUnassigned . hasAnnotation ( Stub . class ) ) { GuesserQueue queue = new GuesserQueue ( ) ; queue . add ( new Guesser < Object > ( nextUnassigned . getType ( ) ) ) ; return queue ; } return GuesserQueue . forSingleValues ( incomplete . potentialsForNextUnassigned ( ) ) ; }
protected Description describeChild ( FrameworkMethod method ) { Description description = fMethodDescriptions . get ( method ) ; if ( description = = null ) { description = Description . createTestDescription ( getTestClass ( ) . getJavaClass ( ) , testName ( method ) , method . getAnnotations ( ) ) ; fMethodDescriptions . put ( method , description ) ; } return description ; }
protected Description describeChild ( FrameworkMethod method ) { Description description = fMethodDescriptions . get ( method ) ; if ( description = = null ) { description = Description . createTestDescription ( getTestClass ( ) . getJavaClass ( ) , testName ( method ) , method . getAnnotations ( ) ) ; fMethodDescriptions . putIfAbsent ( method , description ) ; } return description ; }
public boolean shouldRun ( Description description ) { return categoryFilter . shouldRun ( description ) ; }
public String describe ( ) { return categoryFilter . describe ( ) ; }
public Filter createFilter ( String categories ) throws FilterNotFoundException { try { return createFilter ( parseCategories ( categories ) ) ;
public Class < ? > [ ] parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = Class . forName ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses . toArray ( new Class [ ] { } ) ; }
public Filter createFilter ( Class < ? > [ ] categories ) throws FilterNotFoundException { return new CategoryFilterWrapper ( CategoryFilter . include ( categories ) ) ; }
public Filter createFilter ( Class < ? > [ ] categories ) throws ClassNotFoundException { return new CategoryFilterWrapper ( CategoryFilter . exclude ( categories ) ) ; }
public boolean shouldRun ( final Description description ) { return true ; }
public String describe ( ) { return " Pass - Through Filter " ; }
public Filter intersect ( final Filter second ) { return second ; }
public Filter createFilter ( ) throws FilterNotFoundException { throw new NotImplementedException ( ) ; }
public Filter createFilter ( final String args ) throws FilterNotFoundException { throw new NotImplementedException ( ) ; }
public Filter apply ( final String filterSpec ) throws FilterFactoryNotFoundException , FilterFactory . FilterNotFoundException { if ( filterSpec . contains ( " = " ) ) { final String [ ] tuple = filterSpec . split ( " = " , 2 ) ;
private FilterFactory create ( final String filterFactoryFqcn ) throws FilterFactoryNotFoundException { try { final Class < ? extends FilterFactory > filterFactoryClass =
public static Result runClasses ( Class < ? > . . . classes ) { return runClasses ( defaultComputer ( ) , classes ) ; }
public Result runMain ( JUnitSystem system , String . . . args ) { system . out ( ) . println ( " JUnit version " + Version . id ( ) ) ; List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; List < Failure > failures = new ArrayList < Failure > ( ) ; FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; for ( String each : args ) { try { if ( each . startsWith ( " - - " ) ) { if ( each . startsWith ( " - - filter " ) ) { String filterSpec = each . substring ( each . indexOf ( ' = ' ) + 1 ) ; Filter filter = filterFactoryFactory . apply ( filterSpec ) ; addFilter ( filter ) ; } else { system . out ( ) . println ( " JUnit knows nothing about the " + each + " option " ) ; return new Result ( ) { @ Override public boolean wasSuccessful ( ) { return false ; } } ; } } else { classes . add ( Class . forName ( each ) ) ; } } catch ( FilterFactory . FilterNotFoundException e ) { system . out ( ) . println ( " Could not find filter : " + e . getMessage ( ) ) ; Description description = Description . createSuiteDescription ( each ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } catch ( FilterFactoryFactory . FilterFactoryNotFoundException e ) { system . out ( ) . println ( " Could not find filter factory : " + e . getMessage ( ) ) ; Description description = Description . createSuiteDescription ( each ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } catch ( ClassNotFoundException e ) { system . out ( ) . println ( " Could not find class : " + each ) ; Description description = Description . createSuiteDescription ( each ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } } RunListener listener = new TextListener ( system ) ; addListener ( listener ) ; Result result = run ( classes . toArray ( new Class < ? > [ 0 ] ) ) ; for ( Failure each : failures ) { result . getFailures ( ) . add ( each ) ; } return result ; }
public boolean wasSuccessful ( ) { return false ; }
public Result run ( Class < ? > . . . classes ) { return run ( defaultComputer ( ) , classes ) ; }
public Result run ( Computer computer , Class < ? > . . . classes ) { final Request request = Request . classes ( computer , classes ) . filterWith ( filter ) ; return run ( request ) ; }
public void addFilter ( Filter filter ) { this . filter = this . filter . intersect ( filter ) ; }
public void shouldRunAllTests ( ) { final Result result = runJUnit ( DummyTestClass . class . getName ( ) , DummyTestClass0 . class . getName ( ) , DummyTestClass1 . class . getName ( ) , DummyTestClass01 . class . getName ( ) , DummyTestClass0TestMethod1 . class . getName ( ) ) ; assertFinished ( DummyTestClass . class ) ; assertFinished ( DummyTestClass0 . class ) ; assertFinished ( DummyTestClass1 . class ) ; assertFinished ( DummyTestClass01 . class ) ; assertFinished ( DummyTestClass0TestMethod1 . class ) ; assertThat ( " runCount does not match " , result . getRunCount ( ) , is ( 5 ) ) ; assertThat ( " failureCount does not match " , result . getFailureCount ( ) , is ( 0 ) ) ; }
public void shouldExcludeSomeTests ( ) { final Result result = runJUnit ( EXCLUDES_DUMMY_CATEGORY_1 , DummyTestClass . class . getName ( ) , DummyTestClass0 . class . getName ( ) , DummyTestClass1 . class . getName ( ) , DummyTestClass01 . class . getName ( ) , DummyTestClass0TestMethod1 . class . getName ( ) ) ; assertFinished ( DummyTestClass . class ) ; assertFinished ( DummyTestClass0 . class ) ; assertNotStarted ( DummyTestClass1 . class ) ; assertNotStarted ( DummyTestClass01 . class ) ; assertNotStarted ( DummyTestClass0TestMethod1 . class ) ; assertThat ( " runCount does not match " , result . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " failureCount does not match " , result . getFailureCount ( ) , is ( 0 ) ) ; }
public void shouldIncludeSomeTests ( ) { final Result result = runJUnit ( INCLUDES_DUMMY_CATEGORY_0 , DummyTestClass . class . getName ( ) , DummyTestClass0 . class . getName ( ) , DummyTestClass1 . class . getName ( ) , DummyTestClass01 . class . getName ( ) , DummyTestClass0TestMethod1 . class . getName ( ) ) ; assertNotStarted ( DummyTestClass . class ) ; assertFinished ( DummyTestClass0 . class ) ; assertNotStarted ( DummyTestClass1 . class ) ; assertFinished ( DummyTestClass01 . class ) ; assertFinished ( DummyTestClass0TestMethod1 . class ) ; assertThat ( " runCount does not match " , result . getRunCount ( ) , is ( 3 ) ) ; assertThat ( " failureCount does not match " , result . getFailureCount ( ) , is ( 0 ) ) ; }
public void shouldCombineFilters ( ) { final Result result = runJUnit ( INCLUDES_DUMMY_CATEGORY_0 , EXCLUDES_DUMMY_CATEGORY_1 , DummyTestClass . class . getName ( ) , DummyTestClass0 . class . getName ( ) , DummyTestClass1 . class . getName ( ) , DummyTestClass01 . class . getName ( ) , DummyTestClass0TestMethod1 . class . getName ( ) ) ; assertNotStarted ( DummyTestClass . class ) ; assertFinished ( DummyTestClass0 . class ) ; assertNotStarted ( DummyTestClass1 . class ) ; assertNotStarted ( DummyTestClass01 . class ) ; assertNotStarted ( DummyTestClass0TestMethod1 . class ) ; assertThat ( " runCount does not match " , result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( " failureCount does not match " , result . getFailureCount ( ) , is ( 0 ) ) ; }
private Result runJUnit ( final String . . . args ) { return jUnitCore . runMain ( new RealSystem ( ) , args ) ; }
private void assertFinished ( Class < ? > testClass ) { assertTrue ( testClass . getName ( ) + " expected to finish but did not " , testListener . testFinished ( testClass ) ) ; }
private void assertNotStarted ( Class < ? > testClass ) { assertFalse ( testClass . getName ( ) + " expected not to have been started but was " ,
public void testFinished ( final Description description ) { finishedTests . add ( description . getClassName ( ) ) ; }
public boolean testFinished ( final Class < ? > testClass ) { return finishedTests . contains ( testClass . getName ( ) ) ; }
public void testStarted ( final Description description ) { startedTests . add ( description . getClassName ( ) ) ; }
public boolean testStarted ( final Class < ? > testClass ) { return startedTests . contains ( testClass . getName ( ) ) ; }
public void dummyTest ( ) { } } @ Category ( DummyCategory0 . class ) public static class DummyTestClass0 { @ Test public void dummyTest ( ) { } } @ Category ( DummyCategory1 . class ) public static class DummyTestClass1 { @ Test public void dummyTest ( ) { } } @ Category ( { DummyCategory0 . class , DummyCategory1 . class } ) public static class DummyTestClass01 { @ Test public void dummyTest ( ) { } } @ Category ( DummyCategory0 . class ) public static class DummyTestClass0TestMethod1 { @ Category ( DummyCategory1 . class ) @ Test public void dummyTest ( ) { } } public static interface DummyCategory0 { } public static interface DummyCategory1 { } }
public void dummyTest ( ) { } } @ Category ( DummyCategory1 . class ) public static class DummyTestClass1 { @ Test public void dummyTest ( ) { } } @ Category ( { DummyCategory0 . class , DummyCategory1 . class } ) public static class DummyTestClass01 { @ Test public void dummyTest ( ) { } } @ Category ( DummyCategory0 . class ) public static class DummyTestClass0TestMethod1 { @ Category ( DummyCategory1 . class ) @ Test public void dummyTest ( ) { } } public static interface DummyCategory0 { } public static interface DummyCategory1 { } }
public void dummyTest ( ) { } } @ Category ( { DummyCategory0 . class , DummyCategory1 . class } ) public static class DummyTestClass01 { @ Test public void dummyTest ( ) { } } @ Category ( DummyCategory0 . class ) public static class DummyTestClass0TestMethod1 { @ Category ( DummyCategory1 . class ) @ Test public void dummyTest ( ) { } } public static interface DummyCategory0 { } public static interface DummyCategory1 { } }
public void dummyTest ( ) { } } @ Category ( DummyCategory0 . class ) public static class DummyTestClass0TestMethod1 { @ Category ( DummyCategory1 . class ) @ Test public void dummyTest ( ) { } } public static interface DummyCategory0 { } public static interface DummyCategory1 { } }
public void dummyTest ( ) { } } public static interface DummyCategory0 { } public static interface DummyCategory1 { } }
public Filter createFilter ( String categories ) throws FilterNotCreatedException { try { return createFilter ( parseCategories ( categories ) ) ;
public Filter createFilter ( Class < ? > [ ] categories ) throws ClassNotFoundException { return new CategoryFilter . ExcludesAny ( categories ) ; }
public Filter createFilter ( Class < ? > [ ] categories ) throws FilterNotCreatedException { return new CategoryFilter . IncludesAny ( categories ) ; }
public Filter createFilter ( ) throws FilterNotCreatedException { throw new NotImplementedException ( ) ; }
public Filter createFilter ( String args ) throws FilterNotCreatedException { throw new NotImplementedException ( ) ; }
public Filter createFilterFromFilterSpec ( String filterSpec ) throws FilterFactoryNotFoundException , FilterFactory . FilterNotCreatedException { String filterFactoryFqcn ; FilterFactoryParams args ; if ( filterSpec . contains ( " = " ) ) { String [ ] tuple = filterSpec . split ( " = " , 2 ) ; filterFactoryFqcn = tuple [ 0 ] ; args = new FilterFactoryParams . OneArg ( tuple [ 1 ] ) ; } else { filterFactoryFqcn = filterSpec ; args = new FilterFactoryParams . ZeroArg ( ) ; } return createFilter ( filterFactoryFqcn , args ) ; }
public Filter createFilter ( Class < ? extends FilterFactory > filterFactoryClass , FilterFactoryParams args ) throws FilterFactory . FilterNotCreatedException , FilterFactoryNotFoundException { return createFilter ( filterFactoryClass . getName ( ) , args ) ; }
public Filter createFilter ( String filterFactoryFqcn , FilterFactoryParams args ) throws FilterFactory . FilterNotCreatedException , FilterFactoryNotFoundException { return args . apply ( filterFactoryFqcn ) ; }
public Filter apply ( String filterFactoryFqcn ) throws FilterFactory . FilterNotCreatedException , FilterFactoryFactory . FilterFactoryNotFoundException { try { return apply ( Class . forName ( filterFactoryFqcn , true , Thread . currentThread ( ) . getContextClassLoader ( ) )
abstract public Filter apply ( FilterFactory filterFactory ) throws Exception ; public static class ZeroArg extends FilterFactoryParams { @ Override public Filter apply ( FilterFactory filterFactory ) throws FilterFactory . FilterNotCreatedException { return filterFactory . createFilter ( ) ; } } public static class OneArg extends FilterFactoryParams { private final String args ; public OneArg ( String args ) { this . args = args ; } @ Override public Filter apply ( FilterFactory filterFactory ) throws FilterFactory . FilterNotCreatedException { return filterFactory . createFilter ( args ) ; } } }
public Filter apply ( FilterFactory filterFactory ) throws FilterFactory . FilterNotCreatedException { return filterFactory . createFilter ( ) ; }
public Filter apply ( FilterFactory filterFactory ) throws FilterFactory . FilterNotCreatedException { return filterFactory . createFilter ( args ) ; }
Result runMain ( JUnitSystem system , String . . . args ) { system . out ( ) . println ( " JUnit version " + Version . id ( ) ) ; List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; List < Failure > failures = new ArrayList < Failure > ( ) ; FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; for ( String each : args ) { try { if ( each . startsWith ( " - - " ) ) { if ( each . startsWith ( " - - filter " ) ) { String filterSpec = each . substring ( each . indexOf ( ' = ' ) + 1 ) ; Filter filter = filterFactoryFactory . createFilterFromFilterSpec ( filterSpec ) ; addFilter ( filter ) ; } else { system . out ( ) . println ( " JUnit knows nothing about the " + each + " option " ) ; return new Result ( ) { @ Override public boolean wasSuccessful ( ) { return false ; } } ; } } else { classes . add ( Class . forName ( each ) ) ; } } catch ( FilterFactory . FilterNotCreatedException e ) { system . out ( ) . println ( " Could not find filter : " + e . getMessage ( ) ) ; Description description = Description . createSuiteDescription ( each ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } catch ( FilterFactoryFactory . FilterFactoryNotFoundException e ) { system . out ( ) . println ( " Could not find filter factory : " + e . getMessage ( ) ) ; Description description = Description . createSuiteDescription ( each ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } catch ( ClassNotFoundException e ) { system . out ( ) . println ( " Could not find class : " + each ) ; Description description = Description . createSuiteDescription ( each ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } } RunListener listener = new TextListener ( system ) ; addListener ( listener ) ; Result result = run ( classes . toArray ( new Class < ? > [ 0 ] ) ) ; for ( Failure each : failures ) { result . getFailures ( ) . add ( each ) ; } return result ; }
private Result runJUnit ( final String . . . args ) { return jUnitCore . runMain ( new TestSystem ( ) , args ) ; }
public Filter createFilter ( String categories ) throws FilterNotCreatedException { try { return createFilter ( parseCategories ( categories ) ) ;
protected abstract Filter createFilter ( Class < ? > [ ] categories ) ; Class < ? > [ ] parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = ClassUtil . getClass ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses . toArray ( new Class [ ] { } ) ; } }
Class < ? > [ ] parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = ClassUtil . getClass ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses . toArray ( new Class [ ] { } ) ; }
public Filter createFilter ( Class < ? > [ ] categories ) { return new ExcludesAny ( categories ) ; }
public Filter createFilter ( Class < ? > [ ] categories ) { return new IncludesAny ( categories ) ; }
public static Class < ? > getClass ( String className ) throws ClassNotFoundException { return Class . forName ( className , true , currentThread ( ) . getContextClassLoader ( ) ) ; }
public Filter createFilterFromFilterSpec ( String filterSpec ) throws FilterFactoryNotCreatedException , FilterFactory . FilterNotCreatedException { String filterFactoryFqcn ; FilterFactoryParams args ; if ( filterSpec . contains ( " = " ) ) { String [ ] tuple = filterSpec . split ( " = " , 2 ) ; filterFactoryFqcn = tuple [ 0 ] ; args = new FilterFactoryParams . OneArg ( tuple [ 1 ] ) ; } else { filterFactoryFqcn = filterSpec ; args = new FilterFactoryParams . ZeroArg ( ) ; } return createFilter ( filterFactoryFqcn , args ) ; }
public Filter createFilter ( Class < ? extends FilterFactory > filterFactoryClass , FilterFactoryParams args ) throws FilterFactory . FilterNotCreatedException , FilterFactoryNotCreatedException { return createFilter ( filterFactoryClass . getName ( ) , args ) ; }
public Filter createFilter ( String filterFactoryFqcn , FilterFactoryParams args ) throws FilterFactory . FilterNotCreatedException , FilterFactoryNotCreatedException { return args . apply ( filterFactoryFqcn ) ; }
public Filter apply ( String filterFactoryFqcn ) throws FilterFactory . FilterNotCreatedException , FilterFactoryNotCreatedException { try { FilterFactory filterFactory = ClassUtil . getClass ( filterFactoryFqcn )
abstract public Filter apply ( FilterFactory filterFactory ) throws Exception ; public static class ZeroArg extends FilterFactoryParams { @ Override public Filter apply ( FilterFactory filterFactory ) throws FilterFactory . FilterNotCreatedException { return filterFactory . createFilter ( ) ; } } public static class OneArg extends FilterFactoryParams { private final String args ; public OneArg ( String args ) { this . args = args ; } @ Override public Filter apply ( FilterFactory filterFactory ) throws FilterFactory . FilterNotCreatedException { return filterFactory . createFilter ( args ) ; } } }
public void parseArgs ( String [ ] args ) { parseParameters ( parseOptions ( args ) ) ; }
String [ ] parseOptions ( String [ ] args ) { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; for ( int i = 0 ; i ! = args . length ; + + i ) { String arg = args [ i ] ; try { if ( arg . equals ( " - - " ) ) { return Arrays . copyOfRange ( args , i + 1 , args . length ) ; } else if ( arg . startsWith ( " - - " ) ) { if ( arg . startsWith ( " - - filter = " ) | | arg . equals ( " - - filter " ) ) { String filterSpec ; if ( arg . equals ( " - - filter " ) ) { + + i ; filterSpec = args [ i ] ; } else { filterSpec = arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ; } filter = filter . intersect ( filterFactoryFactory . createFilterFromFilterSpec ( filterSpec ) ) ; } else { Description description = Description . createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , new Error ( " JUnit knows nothing about the " + arg + " option " ) ) ; failures . add ( failure ) ; } } else { return Arrays . copyOfRange ( args , i , args . length ) ; } } catch ( FilterFactory . FilterNotCreatedException e ) { system . out ( ) . println ( " Could not find filter : " + e . getMessage ( ) ) ; Description description = Description . createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } catch ( FilterFactoryFactory . FilterFactoryNotCreatedException e ) { system . out ( ) . println ( " Could not find filter factory : " + e . getMessage ( ) ) ; Description description = Description . createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } } return null ; }
void parseParameters ( String [ ] args ) { for ( String arg : args ) { try {
Result runMain ( JUnitSystem system , String . . . args ) { system . out ( ) . println ( " JUnit version " + Version . id ( ) ) ; JUnitCommandLineParser jUnitCommandLineParser = new JUnitCommandLineParser ( system ) ; jUnitCommandLineParser . parseArgs ( args ) ; filter = filter . intersect ( jUnitCommandLineParser . getFilter ( ) ) ; List < Class < ? > > classes = jUnitCommandLineParser . getClasses ( ) ; List < Failure > failures = jUnitCommandLineParser . getFailures ( ) ; RunListener listener = new TextListener ( system ) ; addListener ( listener ) ; Result result = run ( classes . toArray ( new Class < ? > [ 0 ] ) ) ; for ( Failure each : failures ) { result . getFailures ( ) . add ( each ) ; } return result ; }
public void shouldCreateFilter ( ) throws Exception { CategoryFilterFactory categoryFilterFactory = new CategoryFilterFactoryStub ( ) ; Filter filter = categoryFilterFactory . createFilter ( CategoryFilterFactoryStub . class . getName ( ) ) ; assertThat ( filter , is ( ( Filter ) null ) ) ; }
public void shouldThrowException ( ) throws Exception { expectedException . expect ( FilterFactory . FilterNotCreatedException . class ) ; CategoryFilterFactory categoryFilterFactory = new CategoryFilterFactoryStub ( ) ; Filter filter = categoryFilterFactory . createFilter ( " NonExistentFilter " ) ; assertThat ( filter , is ( ( Filter ) null ) ) ; }
protected Filter createFilter ( Class < ? > [ ] categories ) { return null ; }
public void shouldCreateFilterWithArguments ( ) throws Exception { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; Filter filter = filterFactoryFactory . createFilterFromFilterSpec ( ExcludeCategories . class . getName ( ) + " = " + DummyCategory . class . getName ( ) ) ; assertThat ( filter , instanceOf ( ExcludeCategories . ExcludesAny . class ) ) ; }
public void shouldCreateFilterWithNoArguments ( ) throws Exception { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; Filter filter = filterFactoryFactory . createFilterFromFilterSpec ( FilterFactoryStub . class . getName ( ) ) ; assertThat ( filter , is ( ( Filter ) null ) ) ; }
public void shouldCreateFilter ( ) throws Exception { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; Filter filter = filterFactoryFactory . createFilter ( FilterFactoryStub . class , new FilterFactoryParams . ZeroArg ( ) ) ; assertThat ( filter , is ( ( Filter ) null ) ) ; }
public Filter createFilter ( ) { return null ; }
public void shouldThrowFilterNotCreatedException ( ) throws Exception { expectedException . expect ( FilterNotCreatedException . class ) ; FilterFactoryParams filterFactoryParams = new FilterFactoryParamsStubThatThrowsFilterNotCreatedException ( ) ; filterFactoryParams . apply ( IncludeCategories . class . getName ( ) ) ; }
public void shouldThrowFilterFactoryNotCreatedException ( ) throws Exception { expectedException . expect ( FilterFactoryNotCreatedException . class ) ; FilterFactoryParams filterFactoryParams = new FilterFactoryParamsStubThatThrowsException ( ) ; filterFactoryParams . apply ( IncludeCategories . class . getName ( ) ) ; }
public void shouldCreateFilter ( ) throws Exception { FilterFactoryParams filterFactoryParams = new OneArg ( DummyCategory . class . getName ( ) ) ; Filter filter = filterFactoryParams . apply ( ExcludeCategories . class . getName ( ) ) ; assertThat ( filter , instanceOf ( ExcludeCategories . ExcludesAny . class ) ) ; }
public Filter apply ( FilterFactory filterFactory ) throws Exception { throw new FilterNotCreatedException ( " stub " , new Exception ( ) ) ; }
public Filter apply ( FilterFactory filterFactory ) throws Exception { throw new Exception ( " stub " ) ; }
public void shouldStopParsingOptionsUponDoubleHyphenArg ( ) throws Exception { String [ ] restOfArgs = jUnitCommandLineParser . parseOptions ( new String [ ] { " - - 0 " , " - - 1 " , " - - " , " - - 2 " , " - - 3 " } ) ; assertThat ( restOfArgs , is ( new String [ ] { " - - 2 " , " - - 3 " } ) ) ; }
public void shouldParseFilterArgWithEqualsSyntax ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + IncludeCategories . class . getName ( ) + " = " + DummyCategory0 . class . getName ( ) } ) ; Filter filter = jUnitCommandLineParser . getFilter ( ) ; assertThat ( filter , instanceOf ( IncludeCategories . IncludesAny . class ) ) ; }
public void shouldParseFilterArgInWhichValueIsASeparateArg ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter " , IncludeCategories . class . getName ( ) + " = " + DummyCategory0 . class . getName ( ) } ) ; Filter filter = jUnitCommandLineParser . getFilter ( ) ; assertThat ( filter , instanceOf ( IncludeCategories . IncludesAny . class ) ) ; }
public void shouldStopParsingOptionsUponNonOption ( ) throws Exception { String [ ] restOfArgs = jUnitCommandLineParser . parseOptions ( new String [ ] { " - - 0 " , " - - 1 " , " 2 " , " 3 " } ) ; assertThat ( restOfArgs , is ( new String [ ] { " 2 " , " 3 " } ) ) ; }
public void shouldCreateFailureUponUnknownOption ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - unknown - option " } ) ; List < Failure > failures = jUnitCommandLineParser . getFailures ( ) ; Throwable exception = failures . get ( 0 ) . getException ( ) ; assertThat ( exception , instanceOf ( JUnitCommandLineParser . Error . class ) ) ; }
public void shouldCreateFailureUponUncreatedFilter ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + FilterFactoryStub . class . getName ( ) } ) ; List < Failure > failures = jUnitCommandLineParser . getFailures ( ) ; Throwable exception = failures . get ( 0 ) . getException ( ) ; assertThat ( exception , instanceOf ( FilterFactory . FilterNotCreatedException . class ) ) ; }
public void shouldCreateFailureUponUnfoundFilterFactory ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = NonExistentFilterFactory " } ) ; List < Failure > failures = jUnitCommandLineParser . getFailures ( ) ; Throwable exception = failures . get ( 0 ) . getException ( ) ; assertThat ( exception , instanceOf ( FilterFactoryFactory . FilterFactoryNotCreatedException . class ) ) ; }
public void shouldAddToClasses ( ) { jUnitCommandLineParser . parseParameters ( new String [ ] { DummyTest . class . getName ( ) } ) ; List < Class < ? > > classes = jUnitCommandLineParser . getClasses ( ) ; Class < ? > testClass = classes . get ( 0 ) ; assertThat ( testClass . getName ( ) , is ( DummyTest . class . getName ( ) ) ) ; }
public void shouldCreateFailureUponUnknownTestClass ( ) throws Exception { jUnitCommandLineParser . parseParameters ( new String [ ] { " UnknownTestClass " } ) ; List < Failure > failures = jUnitCommandLineParser . getFailures ( ) ; Throwable exception = failures . get ( 0 ) . getException ( ) ; assertThat ( exception , instanceOf ( ClassNotFoundException . class ) ) ; }
public Filter createFilter ( ) throws FilterNotCreatedException { throw new FilterNotCreatedException ( " stub " , new Exception ( ) ) ; }
public void testRunStarted ( Description description ) throws Exception { } public void testRunFinished ( Result result ) throws Exception { } public void testStarted ( Description description ) throws Exception { } public void testFinished ( Description description ) throws Exception { } public void testFailure ( Failure failure ) throws Exception { } public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void testRunFinished ( Result result ) throws Exception { } public void testStarted ( Description description ) throws Exception { } public void testFinished ( Description description ) throws Exception { } public void testFailure ( Failure failure ) throws Exception { } public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void testStarted ( Description description ) throws Exception { } public void testFinished ( Description description ) throws Exception { } public void testFailure ( Failure failure ) throws Exception { } public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void testFinished ( Description description ) throws Exception { } public void testFailure ( Failure failure ) throws Exception { } public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void testFailure ( Failure failure ) throws Exception { } public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void testAssumptionFailure ( Failure failure ) { } public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void testIgnored ( Description description ) throws Exception { } @ Documented @ Target ( ElementType . TYPE ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ThreadSafe { } }
public void addListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot add a null listener " ) ; } fListeners . add ( wrapIfNotThreadSafe ( listener ) ) ; }
public void removeListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot remove a null listener " ) ; } fListeners . remove ( wrapIfNotThreadSafe ( listener ) ) ; }
RunListener wrapIfNotThreadSafe ( RunListener listener ) { return listener . getClass ( ) . isAnnotationPresent ( RunListener . ThreadSafe . class ) ? listener : new SynchronizedRunListener ( listener , this ) ;
void run ( ) { int capacity = fCurrentListeners . size ( ) ; ArrayList < RunListener > safeListeners = new ArrayList < RunListener > ( capacity ) ; ArrayList < Failure > failures = new ArrayList < Failure > ( capacity ) ; for ( RunListener listener : fCurrentListeners ) { try { notifyListener ( listener ) ; safeListeners . add ( listener ) ; } catch ( Exception e ) { failures . add ( new Failure ( Description . TEST_MECHANISM , e ) ) ; } } fireTestFailures ( safeListeners , failures ) ; }
abstract protected void notifyListener ( RunListener each ) throws Exception ; } public void fireTestRunStarted ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testRunStarted ( description ) ; } } . run ( ) ; } public void fireTestRunFinished ( final Result result ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testRunFinished ( result ) ; } } . run ( ) ; } public void fireTestStarted ( final Description description ) throws StoppedByUserException { if ( fPleaseStop ) { throw new StoppedByUserException ( ) ; } new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testStarted ( description ) ; } } . run ( ) ; } public void fireTestFailure ( Failure failure ) { fireTestFailures ( fListeners , asList ( failure ) ) ; } private void fireTestFailures ( List < RunListener > listeners , final List < Failure > failures ) { if ( ! failures . isEmpty ( ) ) { new SafeNotifier ( listeners ) { @ Override protected void notifyListener ( RunListener listener ) throws Exception { for ( Failure each : failures ) { listener . testFailure ( each ) ; } } } . run ( ) ; } } public void fireTestAssumptionFailed ( final Failure failure ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testAssumptionFailure ( failure ) ; } } . run ( ) ; } public void fireTestIgnored ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testIgnored ( description ) ; } } . run ( ) ; } public void fireTestFinished ( final Description description ) { new SafeNotifier ( ) { @ Override protected void notifyListener ( RunListener each ) throws Exception { each . testFinished ( description ) ; } } . run ( ) ; } public void pleaseStop ( ) { fPleaseStop = true ; } public void addFirstListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot add a null listener " ) ; } fListeners . add ( 0 , wrapIfNotThreadSafe ( listener ) ) ; } }
protected void notifyListener ( RunListener listener ) throws Exception { for ( Failure each : failures ) { listener . testFailure ( each ) ;
public void addFirstListener ( RunListener listener ) { if ( listener = = null ) { throw new NullPointerException ( " Cannot add a null listener " ) ; } fListeners . add ( 0 , wrapIfNotThreadSafe ( listener ) ) ; }
public void testRunStarted ( Description description ) throws Exception { synchronized ( fMonitor ) { fListener . testRunStarted ( description ) ;
public void testRunFinished ( Result result ) throws Exception { synchronized ( fMonitor ) { fListener . testRunFinished ( result ) ;
public void testStarted ( Description description ) throws Exception { synchronized ( fMonitor ) { fListener . testStarted ( description ) ;
public void testFinished ( Description description ) throws Exception { synchronized ( fMonitor ) { fListener . testFinished ( description ) ;
public void testFailure ( Failure failure ) throws Exception { synchronized ( fMonitor ) { fListener . testFailure ( failure ) ;
public void testAssumptionFailure ( Failure failure ) { synchronized ( fMonitor ) { fListener . testAssumptionFailure ( failure ) ;
public void testIgnored ( Description description ) throws Exception { synchronized ( fMonitor ) { fListener . testIgnored ( description ) ;
public int hashCode ( ) { return fListener . hashCode ( ) ; }
public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( ! ( other instanceof SynchronizedRunListener ) ) { return false ; } SynchronizedRunListener that = ( SynchronizedRunListener ) other ; return fListener . equals ( that . fListener ) ; }
public String toString ( ) { return fListener . toString ( ) + " ( with synchronization wrapper ) " ; }
public void testStarted ( Description description ) throws Exception { fTestStarted . incrementAndGet ( ) ; }
public void realUsage ( ) throws Exception { ConcurrentRunListener listener1 = new ConcurrentRunListener ( ) ; ConcurrentRunListener listener2 = new ConcurrentRunListener ( ) ; fNotifier . addListener ( listener1 ) ; fNotifier . addListener ( listener2 ) ; final int numParallelTests = 4 ; ExecutorService pool = Executors . newFixedThreadPool ( numParallelTests ) ; for ( int i = 0 ; i < numParallelTests ; + + i ) { pool . submit ( new Runnable ( ) { public void run ( ) { fNotifier . fireTestStarted ( null ) ; } } ) ; } pool . shutdown ( ) ; assertTrue ( pool . awaitTermination ( TIMEOUT , TimeUnit . SECONDS ) ) ; fNotifier . removeListener ( listener1 ) ; fNotifier . removeListener ( listener2 ) ; assertThat ( listener1 . fTestStarted . get ( ) , is ( numParallelTests ) ) ; assertThat ( listener2 . fTestStarted . get ( ) , is ( numParallelTests ) ) ; }
public void run ( ) { fNotifier . fireTestStarted ( null ) ; }
public void testStarted ( Description description ) throws Exception { if ( throwFromTestStarted ) { throw new Exception ( ) ;
public void testFailure ( Failure failure ) throws Exception { hasTestFailure = true ; }
protected abstract void addListener ( ExaminedListener listener ) ; public void test ( ) throws Exception { int totalListenersFailures = 0 ; Random random = new Random ( 42 ) ; ExaminedListener [ ] examinedListeners = new ExaminedListener [ 1000 ] ; for ( int i = 0 ; i < examinedListeners . length ; + + i ) { boolean fail = random . nextDouble ( ) > = 0 . 5d ; if ( fail ) { + + totalListenersFailures ; } examinedListeners [ i ] = new ExaminedListener ( fail ) ; } final AtomicBoolean condition = new AtomicBoolean ( true ) ; final CyclicBarrier trigger = new CyclicBarrier ( 2 ) ; final CountDownLatch latch = new CountDownLatch ( 10 ) ; ExecutorService notificationsPool = Executors . newFixedThreadPool ( 4 ) ; notificationsPool . submit ( new Callable < Void > ( ) { public Void call ( ) throws Exception { trigger . await ( ) ; while ( condition . get ( ) ) { fNotifier . fireTestStarted ( null ) ; latch . countDown ( ) ; } fNotifier . fireTestStarted ( null ) ; return null ; } } ) ; trigger . await ( TIMEOUT , TimeUnit . SECONDS ) ; latch . await ( TIMEOUT , TimeUnit . SECONDS ) ; for ( ExaminedListener examinedListener : examinedListeners ) { addListener ( examinedListener ) ; } notificationsPool . shutdown ( ) ; condition . set ( false ) ; assertTrue ( notificationsPool . awaitTermination ( TIMEOUT , TimeUnit . SECONDS ) ) ; if ( totalListenersFailures ! = 0 ) { int countTestFailures = examinedListeners . length - countReportedTestFailures ( examinedListeners ) ; assertThat ( totalListenersFailures , is ( countTestFailures ) ) ; } } } @ Test public void reportConcurrentFailuresAfterAddListener ( ) throws Exception { new AbstractConcurrentFailuresTest ( ) { @ Override protected void addListener ( ExaminedListener listener ) { fNotifier . addListener ( listener ) ; } } . test ( ) ; } @ Test public void reportConcurrentFailuresAfterAddFirstListener ( ) throws Exception { new AbstractConcurrentFailuresTest ( ) { @ Override protected void addListener ( ExaminedListener listener ) { fNotifier . addFirstListener ( listener ) ; } } . test ( ) ; } private static int countReportedTestFailures ( ExaminedListener [ ] listeners ) { int count = 0 ; for ( ExaminedListener listener : listeners ) { if ( listener . hasTestFailure ) { + + count ; } } return count ; } }
public void test ( ) throws Exception { int totalListenersFailures = 0 ; Random random = new Random ( 42 ) ; ExaminedListener [ ] examinedListeners = new ExaminedListener [ 1000 ] ; for ( int i = 0 ; i < examinedListeners . length ; + + i ) { boolean fail = random . nextDouble ( ) > = 0 . 5d ; if ( fail ) { + + totalListenersFailures ; } examinedListeners [ i ] = new ExaminedListener ( fail ) ; } final AtomicBoolean condition = new AtomicBoolean ( true ) ; final CyclicBarrier trigger = new CyclicBarrier ( 2 ) ; final CountDownLatch latch = new CountDownLatch ( 10 ) ; ExecutorService notificationsPool = Executors . newFixedThreadPool ( 4 ) ; notificationsPool . submit ( new Callable < Void > ( ) { public Void call ( ) throws Exception { trigger . await ( ) ; while ( condition . get ( ) ) { fNotifier . fireTestStarted ( null ) ; latch . countDown ( ) ; } fNotifier . fireTestStarted ( null ) ; return null ; } } ) ; trigger . await ( TIMEOUT , TimeUnit . SECONDS ) ; latch . await ( TIMEOUT , TimeUnit . SECONDS ) ; for ( ExaminedListener examinedListener : examinedListeners ) { addListener ( examinedListener ) ; } notificationsPool . shutdown ( ) ; condition . set ( false ) ; assertTrue ( notificationsPool . awaitTermination ( TIMEOUT , TimeUnit . SECONDS ) ) ; if ( totalListenersFailures ! = 0 ) {
public Void call ( ) throws Exception { trigger . await ( ) ; while ( condition . get ( ) ) { fNotifier . fireTestStarted ( null ) ; latch . countDown ( ) ; } fNotifier . fireTestStarted ( null ) ; return null ; }
public void reportConcurrentFailuresAfterAddListener ( ) throws Exception { new AbstractConcurrentFailuresTest ( ) { @ Override
protected void addListener ( ExaminedListener listener ) { fNotifier . addListener ( listener ) ; }
public void reportConcurrentFailuresAfterAddFirstListener ( ) throws Exception { new AbstractConcurrentFailuresTest ( ) { @ Override
protected void addListener ( ExaminedListener listener ) { fNotifier . addFirstListener ( listener ) ; }
private static int countReportedTestFailures ( ExaminedListener [ ] listeners ) { int count = 0 ; for ( ExaminedListener listener : listeners ) { if ( listener . hasTestFailure ) { + + count ; } } return count ; }
public void notifiesSecondListenerIfFirstThrowsException ( ) { FailureListener failureListener = new FailureListener ( ) ; fNotifier . addListener ( new CorruptListener ( ) ) ; fNotifier . addListener ( failureListener ) ; fNotifier . fireTestFailure ( new Failure ( null , null ) ) ; assertNotNull ( " The FailureListener registered no failure . " , failureListener . failure ) ;
public void hasNoProblemsWithFailingListeners ( ) { fNotifier . addListener ( new CorruptListener ( ) ) ; fNotifier . addListener ( new FailureListener ( ) ) ; fNotifier . addListener ( new CorruptListener ( ) ) ; fNotifier . fireTestRunFinished ( new Result ( ) ) ; }
public void addAndRemoveWithNonThreadSafeListener ( ) { CountingListener listener = new CountingListener ( ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 0 ) ) ; fNotifier . addListener ( listener ) ; fNotifier . fireTestStarted ( null ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 1 ) ) ; fNotifier . removeListener ( listener ) ; fNotifier . fireTestStarted ( null ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 1 ) ) ; }
public void addFirstAndRemoveWithNonThreadSafeListener ( ) { CountingListener listener = new CountingListener ( ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 0 ) ) ; fNotifier . addFirstListener ( listener ) ; fNotifier . fireTestStarted ( null ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 1 ) ) ; fNotifier . removeListener ( listener ) ; fNotifier . fireTestStarted ( null ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 1 ) ) ; }
public void addAndRemoveWithThreadSafeListener ( ) { ThreadSafeListener listener = new ThreadSafeListener ( ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 0 ) ) ; fNotifier . addListener ( listener ) ; fNotifier . fireTestStarted ( null ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 1 ) ) ; fNotifier . removeListener ( listener ) ; fNotifier . fireTestStarted ( null ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 1 ) ) ; }
public void addFirstAndRemoveWithThreadSafeListener ( ) { ThreadSafeListener listener = new ThreadSafeListener ( ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 0 ) ) ; fNotifier . addFirstListener ( listener ) ; fNotifier . fireTestStarted ( null ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 1 ) ) ; fNotifier . removeListener ( listener ) ; fNotifier . fireTestStarted ( null ) ; assertThat ( listener . fTestStarted . get ( ) , is ( 1 ) ) ; }
public void wrapIfNotThreadSafeShouldNotWrapThreadSafeListeners ( ) { ThreadSafeListener listener = new ThreadSafeListener ( ) ; ; assertSame ( listener , new RunNotifier ( ) . wrapIfNotThreadSafe ( listener ) ) ; }
public void wrapIfNotThreadSafeShouldWrapNonThreadSafeListeners ( ) { CountingListener listener = new CountingListener ( ) ; RunListener wrappedListener = new RunNotifier ( ) . wrapIfNotThreadSafe ( listener ) ; assertThat ( wrappedListener , instanceOf ( SynchronizedRunListener . class ) ) ; }
public String toString ( ) { return fMethod . toString ( ) ; }
public int hashCode ( ) { return fName . hashCode ( ) ; }
public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( ! ( obj instanceof MethodSignature ) ) { return false ; } MethodSignature that = ( MethodSignature ) obj ; return fName . equals ( that . fName ) & & fParameterTypes . equals ( that . fParameterTypes ) ; }
public void overridesAllMethodsInRunListener ( ) { Set < MethodSignature > runListenerMethods = getAllDeclaredMethods ( RunListener . class ) ; Set < MethodSignature > synchronizedRunListenerMethods = getAllDeclaredMethods ( SynchronizedRunListener . class ) ; assertTrue ( synchronizedRunListenerMethods . containsAll ( runListenerMethods ) ) ; }
public String toString ( ) { return " NamedListener " ; }
public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( ! ( obj instanceof NamedListener ) ) { return false ; } NamedListener that = ( NamedListener ) obj ; return this . fName . equals ( that . fName ) ; }
public void namedListenerCorrectlyImplementsEqualsAndHashCode ( ) { NamedListener listener1 = new NamedListener ( " blue " ) ; NamedListener listener2 = new NamedListener ( " blue " ) ; NamedListener listener3 = new NamedListener ( " red " ) ; assertTrue ( listener1 . equals ( listener1 ) ) ; assertTrue ( listener2 . equals ( listener2 ) ) ; assertTrue ( listener3 . equals ( listener3 ) ) ; assertFalse ( listener1 . equals ( null ) ) ; assertFalse ( listener1 . equals ( new Object ( ) ) ) ; assertTrue ( listener1 . equals ( listener2 ) ) ; assertTrue ( listener2 . equals ( listener1 ) ) ; assertFalse ( listener1 . equals ( listener3 ) ) ; assertFalse ( listener3 . equals ( listener1 ) ) ; assertEquals ( listener1 . hashCode ( ) , listener2 . hashCode ( ) ) ; assertNotEquals ( listener1 . hashCode ( ) , listener3 . hashCode ( ) ) ; }
public void toStringDelegates ( ) { NamedListener listener = new NamedListener ( " blue " ) ; assertEquals ( " NamedListener " , listener . toString ( ) ) ; assertEquals ( " NamedListener ( with synchronization wrapper ) " , wrap ( listener ) . toString ( ) ) ; }
public void equalsDelegates ( ) { NamedListener listener1 = new NamedListener ( " blue " ) ; NamedListener listener2 = new NamedListener ( " blue " ) ; NamedListener listener3 = new NamedListener ( " red " ) ; assertEquals ( wrap ( listener1 ) , wrap ( listener1 ) ) ; assertEquals ( wrap ( listener1 ) , wrap ( listener2 ) ) ; assertNotEquals ( wrap ( listener1 ) , wrap ( listener3 ) ) ; assertNotEquals ( wrap ( listener1 ) , listener1 ) ; assertNotEquals ( listener1 , wrap ( listener1 ) ) ; }
public void hashCodeDelegates ( ) { NamedListener listener = new NamedListener ( " blue " ) ; assertEquals ( listener . hashCode ( ) , wrap ( listener ) . hashCode ( ) ) ; }
private SynchronizedRunListener wrap ( RunListener listener ) { return new SynchronizedRunListener ( listener , this ) ; }
public void noTheoryAnnotationMeansAssumeShouldIgnore ( ) { Assume . assumeTrue ( false ) ; }
public void theoryMeansOnlyAssumeShouldFail ( ) throws InitializationError { Result result = runTheoryClass ( TheoryWithNoUnassumedParameters . class ) ; Assert . assertEquals ( 1 , result . getFailureCount ( ) ) ; }
public void theoryWithNoUnassumedParameters ( boolean value ) { Assume . assumeTrue ( value ) ; }
public static Result runTheoryClass ( Class < ? > testClass ) throws InitializationError { Runner theoryRunner = new Theories ( testClass ) ; Request request = Request . runner ( theoryRunner ) ; return new JUnitCore ( ) . run ( request ) ; }
public void allIntsOk ( int x ) { } } @ RunWith ( Theories . class ) public static class HasUglyDataPointMethod { @ DataPoint public static int oneHundred ( ) { return 100 ; } @ DataPoint public static int oneUglyHundred ( ) { throw new RuntimeException ( ) ; } @ Theory public void allIntsOk ( int x ) { } } @ Test public void pickUpDataPointMethods ( ) { assertThat ( testResult ( HasDataPointMethod . class ) , isSuccessful ( ) ) ; } @ Test public void ignoreExceptionsFromDataPointMethods ( ) { assertThat ( testResult ( HasUglyDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public int oneHundred ( ) { return 100 ; } public Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void allIntsOk ( int x ) { } } @ Test public void pickUpDataPointMethods ( ) { assertThat ( testResult ( HasDataPointMethod . class ) , isSuccessful ( ) ) ; } @ Test public void ignoreExceptionsFromDataPointMethods ( ) { assertThat ( testResult ( HasUglyDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public int oneHundred ( ) { return 100 ; } public Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Exception { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public boolean canAcceptType ( Class < ? > candidate ) { return type . isAssignableFrom ( candidate ) | | canAcceptBoxed ( candidate ) | |
private boolean canAcceptBoxed ( Class < ? > candidate ) { if ( primitivesBoxingMap . containsKey ( candidate ) ) { Class < ? > wrapperClass = primitivesBoxingMap . get ( candidate ) ;
public void foo ( @ TestedOn ( ints = { 1 , 2 , 3 } ) int x ) { } @ Test public void getAnnotations ( ) throws SecurityException , NoSuchMethodException { Method method = getClass ( ) . getMethod ( " foo " , int . class ) ; List < Annotation > annotations = ParameterSignature . signatures ( method ) . get ( 0 ) . getAnnotations ( ) ; assertThat ( annotations , CoreMatchers . < TestedOn > hasItem ( isA ( TestedOn . class ) ) ) ; } public void intMethod ( int param ) { } public void integerMethod ( Integer param ) { } public void numberMethod ( Number param ) { } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " integerMethod " , Integer . class ) ) ; ParameterSignature integerSignature = signatures . get ( 0 ) ; assertTrue ( integerSignature . canAcceptType ( int . class ) ) ; } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; } @ Test public void wrapperTypesShouldBeAcceptedAsPrimitiveTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " intMethod " , int . class ) ) ; ParameterSignature intSignature = signatures . get ( 0 ) ; assertTrue ( intSignature . canAcceptType ( Integer . class ) ) ; } }
public void getAnnotations ( ) throws SecurityException , NoSuchMethodException { Method method = getClass ( ) . getMethod ( " foo " , int . class ) ; List < Annotation > annotations = ParameterSignature . signatures ( method ) . get ( 0 ) . getAnnotations ( ) ; assertThat ( annotations , CoreMatchers . < TestedOn > hasItem ( isA ( TestedOn . class ) ) ) ;
public void intMethod ( int param ) { } public void integerMethod ( Integer param ) { } public void numberMethod ( Number param ) { } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " integerMethod " , Integer . class ) ) ; ParameterSignature integerSignature = signatures . get ( 0 ) ; assertTrue ( integerSignature . canAcceptType ( int . class ) ) ; } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; } @ Test public void wrapperTypesShouldBeAcceptedAsPrimitiveTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " intMethod " , int . class ) ) ; ParameterSignature intSignature = signatures . get ( 0 ) ; assertTrue ( intSignature . canAcceptType ( Integer . class ) ) ; } }
public void integerMethod ( Integer param ) { } public void numberMethod ( Number param ) { } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " integerMethod " , Integer . class ) ) ; ParameterSignature integerSignature = signatures . get ( 0 ) ; assertTrue ( integerSignature . canAcceptType ( int . class ) ) ; } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; } @ Test public void wrapperTypesShouldBeAcceptedAsPrimitiveTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " intMethod " , int . class ) ) ; ParameterSignature intSignature = signatures . get ( 0 ) ; assertTrue ( intSignature . canAcceptType ( Integer . class ) ) ; } }
public void numberMethod ( Number param ) { } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " integerMethod " , Integer . class ) ) ; ParameterSignature integerSignature = signatures . get ( 0 ) ; assertTrue ( integerSignature . canAcceptType ( int . class ) ) ; } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; } @ Test public void wrapperTypesShouldBeAcceptedAsPrimitiveTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " intMethod " , int . class ) ) ; ParameterSignature intSignature = signatures . get ( 0 ) ; assertTrue ( intSignature . canAcceptType ( Integer . class ) ) ; } }
public void primitiveTypesShouldBeAcceptedAsWrapperTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " integerMethod " , Integer . class ) ) ; ParameterSignature integerSignature = signatures . get ( 0 ) ; assertTrue ( integerSignature . canAcceptType ( int . class ) ) ; }
public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; }
public void wrapperTypesShouldBeAcceptedAsPrimitiveTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " intMethod " , int . class ) ) ; ParameterSignature intSignature = signatures . get ( 0 ) ; assertTrue ( intSignature . canAcceptType ( Integer . class ) ) ; }
public void dataPointsArrayShouldBeRecognized ( ) throws Exception { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsArrayField . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; }
public void dataPointsArrayShouldBeRecognizedOnValueTypeNotFieldType ( ) throws Exception { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsArrayWithMatchingButInaccurateTypes . class . getMethod ( " theory " , Integer . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; }
public void dataPointsAnnotationMeansTreatAsArrayOnly ( ) throws Exception { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsWithObjectParameter . class . getMethod ( " theory " , Object . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertNotEquals ( HasDataPointsWithObjectParameter . objectField , assignment . getValue ( ) ) ;
public boolean canAcceptType ( Class < ? > candidate ) { return type . isAssignableFrom ( candidate ) | | isAssignableViaTypeConversion ( type , candidate ) ;
public boolean canPotentiallyAcceptType ( Class < ? > candidate ) { return candidate . isAssignableFrom ( type ) | | isAssignableViaTypeConversion ( candidate , type ) | |
private boolean isAssignableViaTypeConversion ( Class < ? > targetType , Class < ? > candidate ) { if ( convertableTypesMap . containsKey ( candidate ) ) { Class < ? > wrapperClass = convertableTypesMap . get ( candidate ) ;
public void foo ( @ TestedOn ( ints = { 1 , 2 , 3 } ) int x ) { } @ Test public void getAnnotations ( ) throws SecurityException , NoSuchMethodException { Method method = getClass ( ) . getMethod ( " foo " , int . class ) ; List < Annotation > annotations = ParameterSignature . signatures ( method ) . get ( 0 ) . getAnnotations ( ) ; assertThat ( annotations , CoreMatchers . < TestedOn > hasItem ( isA ( TestedOn . class ) ) ) ; } public void intMethod ( int param ) { } public void integerMethod ( Integer param ) { } public void numberMethod ( Number param ) { } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " integerMethod " , Integer . class ) ) ; ParameterSignature integerSignature = signatures . get ( 0 ) ; assertTrue ( integerSignature . canAcceptType ( int . class ) ) ; } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; } @ Test public void wrapperTypesShouldBeAcceptedAsPrimitiveTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " intMethod " , int . class ) ) ; ParameterSignature intSignature = signatures . get ( 0 ) ; assertTrue ( intSignature . canAcceptType ( Integer . class ) ) ; } }
public void intMethod ( int param ) { } public void integerMethod ( Integer param ) { } public void numberMethod ( Number param ) { } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " integerMethod " , Integer . class ) ) ; ParameterSignature integerSignature = signatures . get ( 0 ) ; assertTrue ( integerSignature . canAcceptType ( int . class ) ) ; } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; } @ Test public void wrapperTypesShouldBeAcceptedAsPrimitiveTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " intMethod " , int . class ) ) ; ParameterSignature intSignature = signatures . get ( 0 ) ; assertTrue ( intSignature . canAcceptType ( Integer . class ) ) ; } }
public void integerMethod ( Integer param ) { } public void numberMethod ( Number param ) { } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " integerMethod " , Integer . class ) ) ; ParameterSignature integerSignature = signatures . get ( 0 ) ; assertTrue ( integerSignature . canAcceptType ( int . class ) ) ; } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; } @ Test public void wrapperTypesShouldBeAcceptedAsPrimitiveTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " intMethod " , int . class ) ) ; ParameterSignature intSignature = signatures . get ( 0 ) ; assertTrue ( intSignature . canAcceptType ( Integer . class ) ) ; } }
public void numberMethod ( Number param ) { } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " integerMethod " , Integer . class ) ) ; ParameterSignature integerSignature = signatures . get ( 0 ) ; assertTrue ( integerSignature . canAcceptType ( int . class ) ) ; } @ Test public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; } @ Test public void wrapperTypesShouldBeAcceptedAsPrimitiveTypes ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " intMethod " , int . class ) ) ; ParameterSignature intSignature = signatures . get ( 0 ) ; assertTrue ( intSignature . canAcceptType ( Integer . class ) ) ; } }
public void primitiveTypesShouldBeAcceptedAsWrapperTypeAssignables ( ) throws Exception { List < ParameterSignature > signatures = ParameterSignature . signatures ( getClass ( ) . getMethod ( " numberMethod " , Number . class ) ) ; ParameterSignature numberSignature = signatures . get ( 0 ) ; assertTrue ( numberSignature . canAcceptType ( int . class ) ) ; }
public static Object object ( ) { return 1 ; }
public void dataPointMethodShouldBeRecognizedOnValueTypeNotFieldType ( ) throws Exception { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointMethodWithMatchingButInaccurateTypes . class . getMethod ( " theory " , Integer . class ) ) ; assertEquals ( 1 , assignments . size ( ) ) ; }
public static Integer object ( ) { return 1 ; }
public void dataPointMethodShouldBeRecognizedForOverlyGeneralParameters ( ) throws Exception { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointMethodWithOverlyGeneralTypes . class . getMethod ( " theory " , Object . class ) ) ; assertEquals ( 1 , assignments . size ( ) ) ; }
private static Map < Class < ? > , Class < ? > > buildConvertableTypesMap ( ) { Map < Class < ? > , Class < ? > > map = new HashMap < Class < ? > , Class < ? > > ( ) ; map . put ( boolean . class , Boolean . class ) ; map . put ( byte . class , Byte . class ) ; map . put ( short . class , Short . class ) ; map . put ( char . class , Character . class ) ; map . put ( int . class , Integer . class ) ; map . put ( long . class , Long . class ) ; map . put ( float . class , Float . class ) ; map . put ( double . class , Double . class ) ; Iterable < Entry < Class < ? > , Class < ? > > > initialEntries = new HashSet < Entry < Class < ? > , Class < ? > > > ( map . entrySet ( ) ) ; for ( Entry < Class < ? > , Class < ? > > entry : initialEntries ) { map . put ( entry . getValue ( ) , entry . getKey ( ) ) ; } return Collections . unmodifiableMap ( map ) ; }
private boolean isAssignableViaTypeConversion ( Class < ? > targetType , Class < ? > candidate ) { if ( CONVERTABLE_TYPES_MAP . containsKey ( candidate ) ) { Class < ? > wrapperClass = CONVERTABLE_TYPES_MAP . get ( candidate ) ;
public FilterFactoryParams parseArgs ( String args ) throws FilterNotCreatedException { try { return new CategoryFilterFactoryParams ( parseCategories ( args ) ) ;
public Filter createFilter ( FilterFactoryParams params ) { return createFilter ( ( ( CategoryFilterFactoryParams ) params ) . getCategories ( ) ) ; }
private Class < ? > [ ] parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = ClassUtil . getClass ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses . toArray ( new Class [ ] { } ) ; }
public Filter createFilter ( Class < ? > . . . categories ) { return new ExcludesAny ( categories ) ; }
public String describe ( ) { return " excludes " + super . describe ( ) ; }
public Filter createFilter ( Class < ? > . . . categories ) { return new IncludesAny ( categories ) ; }
public String describe ( ) { return " includes " + super . describe ( ) ; }
public FilterFactoryParams parseArgs ( String args ) throws FilterNotCreatedException { throw new UnsupportedOperationException ( ) ; }
abstract public Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException ; public static class NoFilterFactoryParams implements FilterFactoryParams { } public static class FilterNotCreatedException extends FilterFactoryFactory . FilterFactoryNotCreatedException { public FilterNotCreatedException ( String message ) { super ( message ) ; } } }
public Filter createFilterFromFilterSpec ( String filterSpec ) throws FilterFactoryNotCreatedException { FilterFactory filterFactory ; FilterFactoryParams params ; if ( filterSpec . contains ( " = " ) ) { String [ ] tuple = filterSpec . split ( " = " , 2 ) ;
public Filter createFilter ( Class < ? extends FilterFactory > filterFactoryClass , FilterFactoryParams params ) throws FilterFactoryNotCreatedException { FilterFactory filterFactory = createFilterFactory ( filterFactoryClass ) ; return filterFactory . createFilter ( params ) ; }
public Filter createFilter ( String filterFactoryFqcn , FilterFactoryParams params ) throws FilterFactoryNotCreatedException { FilterFactory filterFactory = createFilterFactory ( filterFactoryFqcn ) ; return filterFactory . createFilter ( params ) ; }
FilterFactory createFilterFactory ( String filterFactoryFqcn ) throws FilterFactoryNotCreatedException { Class < ? extends FilterFactory > filterFactoryClass ; try { filterFactoryClass = ClassUtil . getClass ( filterFactoryFqcn ) . asSubclass ( FilterFactory . class ) ; } catch ( Exception e ) { throw new FilterFactoryNotCreatedException ( e . getMessage ( ) ) ; } return createFilterFactory ( filterFactoryClass ) ; }
FilterFactory createFilterFactory ( Class < ? extends FilterFactory > filterFactoryClass ) throws FilterFactoryNotCreatedException { try { return filterFactoryClass
String [ ] parseOptions ( String [ ] args ) { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; for ( int i = 0 ; i ! = args . length ; + + i ) { String arg = args [ i ] ; try { if ( arg . equals ( " - - " ) ) { return Arrays . copyOfRange ( args , i + 1 , args . length ) ; } else if ( arg . startsWith ( " - - " ) ) { if ( arg . startsWith ( " - - filter = " ) | | arg . equals ( " - - filter " ) ) { String filterSpec ; if ( arg . equals ( " - - filter " ) ) { + + i ; filterSpec = args [ i ] ; } else { filterSpec = arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ; } filter = filter . intersect ( filterFactoryFactory . createFilterFromFilterSpec ( filterSpec ) ) ; } else { Description description = Description . createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , new CommandLineParserError ( " JUnit knows nothing about the " + arg + " option " ) ) ; failures . add ( failure ) ; } } else { return Arrays . copyOfRange ( args , i , args . length ) ; } } catch ( FilterFactory . FilterNotCreatedException e ) { system . out ( ) . println ( " Could not find filter : " + e . getMessage ( ) ) ; Description description = Description . createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } catch ( FilterFactoryFactory . FilterFactoryNotCreatedException e ) { system . out ( ) . println ( " Could not find filter factory : " + e . getMessage ( ) ) ; Description description = Description . createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } } return null ; }
public Request createRequest ( Computer computer ) { return Request . classes ( computer , classes . toArray ( new Class < ? > [ 0 ] ) )
public Result run ( Computer computer , Class < ? > . . . classes ) { Request request = Request . classes ( computer , classes ) ; return run ( request ) ; }
public void shouldCreateFilter ( ) throws Exception { CategoryFilterFactory categoryFilterFactory = new CategoryFilterFactoryStub ( ) ; FilterFactoryParams params = categoryFilterFactory . parseArgs ( CategoryFilterFactoryStub . class . getName ( ) ) ; Filter filter = categoryFilterFactory . createFilter ( params ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldThrowException ( ) throws Exception { CategoryFilterFactory categoryFilterFactory = new CategoryFilterFactoryStub ( ) ; expectedException . expect ( FilterFactory . FilterNotCreatedException . class ) ; categoryFilterFactory . parseArgs ( " NonExistentFilter " ) ; }
protected Filter createFilter ( Class < ? > [ ] categories ) { return new DummyFilter ( ) ; }
public String describe ( ) { return null ; }
public void shouldCreateFilterWithArguments ( ) throws Exception { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; Filter filter = filterFactoryFactory . createFilterFromFilterSpec ( ExcludeCategories . class . getName ( ) + " = " + DummyCategory . class . getName ( ) ) ; assertThat ( filter . describe ( ) , startsWith ( " excludes " ) ) ; }
public void shouldCreateFilterWithNoArguments ( ) throws Exception { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; Filter filter = filterFactoryFactory . createFilterFromFilterSpec ( FilterFactoryStub . class . getName ( ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldCreateFilter ( ) throws Exception { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; Filter filter = filterFactoryFactory . createFilter ( FilterFactoryStub . class , new NoFilterFactoryParams ( ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public Filter createFilter ( FilterFactoryParams unused ) { return new DummyFilter ( ) ; }
public void shouldRunAllTests ( ) { Result result = runJUnit ( DummyTestClass . class . getName ( ) , DummyTestClass0 . class . getName ( ) , DummyTestClass1 . class . getName ( ) , DummyTestClass01 . class . getName ( ) , DummyTestClass0TestMethod1 . class . getName ( ) ) ; assertWasRun ( DummyTestClass . class ) ; assertWasRun ( DummyTestClass0 . class ) ; assertWasRun ( DummyTestClass1 . class ) ; assertWasRun ( DummyTestClass01 . class ) ; assertWasRun ( DummyTestClass0TestMethod1 . class ) ; assertThat ( " runCount does not match " , result . getRunCount ( ) , is ( 5 ) ) ; assertThat ( " failureCount does not match " , result . getFailureCount ( ) , is ( 0 ) ) ; }
public void shouldExcludeSomeTests ( ) { Result result = runJUnit ( EXCLUDES_DUMMY_CATEGORY_1 , DummyTestClass . class . getName ( ) , DummyTestClass0 . class . getName ( ) , DummyTestClass1 . class . getName ( ) , DummyTestClass01 . class . getName ( ) , DummyTestClass0TestMethod1 . class . getName ( ) ) ; assertWasRun ( DummyTestClass . class ) ; assertWasRun ( DummyTestClass0 . class ) ; assertWasNotRun ( DummyTestClass1 . class ) ; assertWasNotRun ( DummyTestClass01 . class ) ; assertWasNotRun ( DummyTestClass0TestMethod1 . class ) ; assertThat ( " runCount does not match " , result . getRunCount ( ) , is ( 2 ) ) ; assertThat ( " failureCount does not match " , result . getFailureCount ( ) , is ( 0 ) ) ; }
public void shouldIncludeSomeTests ( ) { Result result = runJUnit ( INCLUDES_DUMMY_CATEGORY_0 , DummyTestClass . class . getName ( ) , DummyTestClass0 . class . getName ( ) , DummyTestClass1 . class . getName ( ) , DummyTestClass01 . class . getName ( ) , DummyTestClass0TestMethod1 . class . getName ( ) ) ; assertWasNotRun ( DummyTestClass . class ) ; assertWasRun ( DummyTestClass0 . class ) ; assertWasNotRun ( DummyTestClass1 . class ) ; assertWasRun ( DummyTestClass01 . class ) ; assertWasRun ( DummyTestClass0TestMethod1 . class ) ; assertThat ( " runCount does not match " , result . getRunCount ( ) , is ( 3 ) ) ; assertThat ( " failureCount does not match " , result . getFailureCount ( ) , is ( 0 ) ) ; }
public void shouldCombineFilters ( ) { Result result = runJUnit ( INCLUDES_DUMMY_CATEGORY_0 , EXCLUDES_DUMMY_CATEGORY_1 , DummyTestClass . class . getName ( ) , DummyTestClass0 . class . getName ( ) , DummyTestClass1 . class . getName ( ) , DummyTestClass01 . class . getName ( ) , DummyTestClass0TestMethod1 . class . getName ( ) ) ; assertWasNotRun ( DummyTestClass . class ) ; assertWasRun ( DummyTestClass0 . class ) ; assertWasNotRun ( DummyTestClass1 . class ) ; assertWasNotRun ( DummyTestClass01 . class ) ; assertWasNotRun ( DummyTestClass0TestMethod1 . class ) ; assertThat ( " runCount does not match " , result . getRunCount ( ) , is ( 1 ) ) ; assertThat ( " failureCount does not match " , result . getFailureCount ( ) , is ( 0 ) ) ; }
private void assertWasRun ( Class < ? > testClass ) { assertTrue ( testClass . getName ( ) + " expected to finish but did not " , testListener . wasRun ( testClass ) ) ; }
private void assertWasNotRun ( Class < ? > testClass ) { assertFalse ( testClass . getName ( ) + " expected not to have been started but was " ,
private boolean testFinished ( final Class < ? > testClass ) { return finishedTests . contains ( testClass . getName ( ) ) ; }
private boolean testStarted ( final Class < ? > testClass ) { return startedTests . contains ( testClass . getName ( ) ) ; }
public boolean wasRun ( final Class < ? > testClass ) { return testStarted ( testClass ) & & testFinished ( testClass ) ; }
public void shouldParseFilterArgWithEqualsSyntax ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + IncludeCategories . class . getName ( ) + " = " + DummyCategory0 . class . getName ( ) } ) ; Filter filter = jUnitCommandLineParser . getFilter ( ) ; assertThat ( filter . describe ( ) , startsWith ( " includes " ) ) ; }
public void shouldParseFilterArgInWhichValueIsASeparateArg ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter " , IncludeCategories . class . getName ( ) + " = " + DummyCategory0 . class . getName ( ) } ) ; Filter filter = jUnitCommandLineParser . getFilter ( ) ; assertThat ( filter . describe ( ) , startsWith ( " includes " ) ) ; }
public void shouldCreateFailureUponUnknownOption ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - unknown - option " } ) ; List < Failure > failures = jUnitCommandLineParser . getFailures ( ) ; Throwable exception = failures . get ( 0 ) . getException ( ) ; assertThat ( exception , instanceOf ( JUnitCommandLineParser . CommandLineParserError . class ) ) ; }
public Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException { throw new FilterNotCreatedException ( " stub " ) ; }
private static Map < Class < ? > , Class < ? > > buildConvertableTypesMap ( ) { Map < Class < ? > , Class < ? > > map = new HashMap < Class < ? > , Class < ? > > ( ) ; putSymmetrically ( map , boolean . class , Boolean . class ) ; putSymmetrically ( map , byte . class , Byte . class ) ; putSymmetrically ( map , short . class , Short . class ) ; putSymmetrically ( map , char . class , Character . class ) ; putSymmetrically ( map , int . class , Integer . class ) ; putSymmetrically ( map , long . class , Long . class ) ; putSymmetrically ( map , float . class , Float . class ) ; putSymmetrically ( map , double . class , Double . class ) ; return Collections . unmodifiableMap ( map ) ; }
private static < T > void putSymmetrically ( Map < T , T > map , T a , T b ) { map . put ( a , b ) ; map . put ( b , a ) ; }
public void shouldCreateFilterWithArguments ( ) throws Exception { Filter filter = filterFactoryFactory . createFilterFromFilterSpec ( ExcludeCategories . class . getName ( ) + " = " + DummyCategory . class . getName ( ) ) ; assertThat ( filter . describe ( ) , startsWith ( " excludes " ) ) ; }
public void shouldCreateFilterWithNoArguments ( ) throws Exception { Filter filter = filterFactoryFactory . createFilterFromFilterSpec ( FilterFactoryStub . class . getName ( ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldCreateFilter ( ) throws Exception { Filter filter = filterFactoryFactory . createFilter ( FilterFactoryStub . class , new NoFilterFactoryParams ( ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldThrowExceptionIfNotFilterFactory ( ) throws Exception { expectedException . expect ( FilterFactoryFactory . FilterFactoryNotCreatedException . class ) ; filterFactoryFactory . createFilterFactory ( NonFilterFactory . class . getName ( ) ) ; }
public void shouldThrowExceptionIfNotInstantiable ( ) throws Exception { expectedException . expect ( FilterFactoryFactory . FilterFactoryNotCreatedException . class ) ; filterFactoryFactory . createFilterFactory ( NonInstantiableFilterFactory . class ) ; }
public Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException { throw new FilterNotCreatedException ( " not implemented " ) ; }
public void shouldAddFailuresToResult ( ) { JUnitCore jUnitCore = new JUnitCore ( ) ; Result result = jUnitCore . runMain ( new TestSystem ( ) , " NonExistentTest " ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getException ( ) , instanceOf ( ClassNotFoundException . class ) ) ; }
public abstract List < PotentialAssignment > getValueSources ( ParameterSignature sig ) throws Throwable ; }
protected void collectInitializationErrors ( List < Throwable > errors ) { } @ Override public Statement methodBlock ( FrameworkMethod method ) { final Statement statement = super . methodBlock ( method ) ; return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { try { statement . evaluate ( ) ; handleDataPointSuccess ( ) ; } catch ( AssumptionViolatedException e ) { handleAssumptionViolation ( e ) ; } catch ( Throwable e ) { reportParameterizedError ( e , complete . getArgumentStrings ( nullsOk ( ) ) ) ; } } } ; } @ Override protected Statement methodInvoker ( FrameworkMethod method , Object test ) { return methodCompletesWithParameters ( method , complete , test ) ; } @ Override public Object createTest ( ) throws Exception { Object [ ] params = complete . getConstructorArguments ( ) ; if ( ! nullsOk ( ) ) { Assume . assumeNotNull ( params ) ; } return getTestClass ( ) . getOnlyConstructor ( ) . newInstance ( params ) ; } } . methodBlock ( fTestMethod ) . evaluate ( ) ; } private Statement methodCompletesWithParameters ( final FrameworkMethod method , final Assignments complete , final Object freshInstance ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { final Object [ ] values = complete . getMethodArguments ( ) ; if ( ! nullsOk ( ) ) { Assume . assumeNotNull ( values ) ; } method . invokeExplosively ( freshInstance , values ) ; } } ; } protected void handleAssumptionViolation ( AssumptionViolatedException e ) { fInvalidParameters . add ( e ) ; } protected void reportParameterizedError ( Throwable e , Object . . . params ) throws Throwable { if ( params . length = = 0 ) { throw e ; } throw new ParameterizedAssertionError ( e , fTestMethod . getName ( ) , params ) ; } private boolean nullsOk ( ) { Theory annotation = fTestMethod . getMethod ( ) . getAnnotation ( Theory . class ) ; if ( annotation = = null ) { return false ; } return annotation . nullsAccepted ( ) ; } protected void handleDataPointSuccess ( ) { successes + + ; } } }
public Object createTest ( ) throws Exception { Object [ ] params = complete . getConstructorArguments ( ) ; if ( ! nullsOk ( ) ) { Assume . assumeNotNull ( params ) ; } return getTestClass ( ) . getOnlyConstructor ( ) . newInstance ( params ) ; }
public void evaluate ( ) throws Throwable { final Object [ ] values = complete . getMethodArguments ( ) ; if ( ! nullsOk ( ) ) { Assume . assumeNotNull ( values ) ; } method . invokeExplosively ( freshInstance , values ) ; }
public List < PotentialAssignment > getValueSources ( ParameterSignature sig ) throws Throwable { List < PotentialAssignment > list = new ArrayList < PotentialAssignment > ( ) ; addSinglePointFields ( sig , list ) ; addMultiPointFields ( sig , list ) ; addSinglePointMethods ( sig , list ) ; addMultiPointMethods ( sig , list ) ; return list ; }
public Object [ ] getActualValues ( int start , int stop ) throws CouldNotGenerateValueException { Object [ ] values = new Object [ stop - start ] ; for ( int i = start ; i < stop ; i + + ) { values [ i - start ] = fAssigned . get ( i ) . getValue ( ) ; } return values ; }
public List < PotentialAssignment > potentialsForNextUnassigned ( ) throws Throwable { ParameterSignature unassigned = nextUnassigned ( ) ; return getSupplier ( unassigned ) . getValueSources ( unassigned ) ; }
public Object [ ] getConstructorArguments ( ) throws CouldNotGenerateValueException { return getActualValues ( 0 , getConstructorParameterCount ( ) ) ; }
public Object [ ] getMethodArguments ( ) throws CouldNotGenerateValueException { return getActualValues ( getConstructorParameterCount ( ) , fAssigned . size ( ) ) ; }
public Object [ ] getAllArguments ( ) throws CouldNotGenerateValueException { return getActualValues ( 0 , fAssigned . size ( ) ) ; }
public void theoryMeansOnlyAssumeShouldFail ( ) throws InitializationError { Result result = runTheoryClass ( TheoryWithNoUnassumedParameters . class ) ; Assert . assertEquals ( 1 , result . getFailureCount ( ) ) ; }
public static List < PotentialAssignment > potentialAssignments ( Method method ) throws Throwable { return Assignments . allUnassigned ( method , new TestClass ( method . getDeclaringClass ( ) ) )
private GuesserQueue createGuesserQueue ( Assignments incomplete ) throws Throwable { ParameterSignature nextUnassigned = incomplete . nextUnassigned ( ) ; if ( nextUnassigned . hasAnnotation ( Stub . class ) ) { GuesserQueue queue = new GuesserQueue ( ) ; queue . add ( new Guesser < Object > ( nextUnassigned . getType ( ) ) ) ; return queue ; } return GuesserQueue . forSingleValues ( incomplete . potentialsForNextUnassigned ( ) ) ; }
public void dataPointsAnnotationMeansTreatAsArrayOnly ( ) throws Throwable { List < PotentialAssignment > valueSources = allMemberValuesFor ( HasDataPoints . class , Object . class ) ; assertThat ( valueSources . size ( ) , is ( 2 ) ) ; }
public void dataPointsArrayFieldMayContainNullValue ( ) throws Throwable { List < PotentialAssignment > valueSources = allMemberValuesFor ( HasDataPointsFieldWithNullValue . class , Object . class ) ; assertThat ( valueSources . size ( ) , is ( 2 ) ) ; }
public void dataPointsArrayMethodMayContainNullValue ( ) throws Throwable { List < PotentialAssignment > valueSources = allMemberValuesFor ( HasDataPointsMethodWithNullValue . class , Integer . class ) ; assertThat ( valueSources . size ( ) , is ( 2 ) ) ; }
public static Object [ ] objects ( ) { throw new RuntimeException ( " failing method " ) ; }
public void allMembersFailsOnFailingDataPointsArrayMethod ( ) throws Throwable { expected . expect ( RuntimeException . class ) ; expected . expectMessage ( " failing method " ) ; allMemberValuesFor ( HasFailingDataPointsArrayMethod . class , Object . class ) ; }
private List < PotentialAssignment > allMemberValuesFor ( Class < ? > testClass , Class < ? > . . . constructorParameterTypes ) throws Throwable { return new AllMembersSupplier ( new TestClass ( testClass ) ) . getValueSources ( ParameterSignature . signatures (
public void shouldReturnOnlyTheNamedDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingAllNamedStrings " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 4 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItems ( " named field " , " named method " , " named single value " , " named single method value " ) ) ; }
public void shouldReturnOnlyTheNamedFieldDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingNamedFieldString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 1 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( " named field " ) ) ; }
public void shouldReturnOnlyTheNamedMethodDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingNamedMethodString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 1 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( " named method " ) ) ; }
public void shouldReturnOnlyTheNamedSingleFieldDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingNamedSingleFieldString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 1 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( " named single value " ) ) ; }
public void shouldReturnOnlyTheNamedSingleMethodDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingNamedSingleMethodString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 1 , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( " named single method value " ) ) ; }
public void shouldReturnNothingIfTheNamedDataPointsAreMissing ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( " methodWantingWrongNamedString " ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( 0 , assignedStrings . size ( ) ) ; }
public void allIntsOk ( int x ) { } } @ Test public void pickUpDataPointMethods ( ) { assertThat ( testResult ( HasDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasFailingSingleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void allIntsOk ( int x ) { } } @ Test public void shouldFailFromExceptionsInSingleDataPointMethods ( ) { assertThat ( testResult ( HasFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasFailingDataPointArrayMethod { @ DataPoints public static int [ ] num = { 1 , 2 , 3 } ; @ DataPoints public static int [ ] failingDataPoints ( ) { throw new RuntimeException ( ) ; } @ Theory public void allIntsOk ( int x ) { } } @ Test public void shouldFailFromExceptionsInDataPointArrayMethods ( ) { assertThat ( testResult ( HasFailingDataPointArrayMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodReturnsMutableObject { @ DataPoint public static List < Object > empty ( ) { return new ArrayList < Object > ( ) ; } @ DataPoint public static int ONE = 1 ; @ DataPoint public static int TWO = 2 ; @ Theory public void everythingsEmpty ( List < Object > first , int number ) { assertThat ( first . size ( ) , is ( 0 ) ) ; first . add ( " a " ) ; } } @ Test public void mutableObjectsAreCreatedAfresh ( ) { assertThat ( failures ( DataPointMethodReturnsMutableObject . class ) , empty ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public static int oneHundred ( ) { return 100 ; } public static Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; }
public void allIntsOk ( int x ) { } } @ Test public void shouldFailFromExceptionsInSingleDataPointMethods ( ) { assertThat ( testResult ( HasFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasFailingDataPointArrayMethod { @ DataPoints public static int [ ] num = { 1 , 2 , 3 } ; @ DataPoints public static int [ ] failingDataPoints ( ) { throw new RuntimeException ( ) ; } @ Theory public void allIntsOk ( int x ) { } } @ Test public void shouldFailFromExceptionsInDataPointArrayMethods ( ) { assertThat ( testResult ( HasFailingDataPointArrayMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodReturnsMutableObject { @ DataPoint public static List < Object > empty ( ) { return new ArrayList < Object > ( ) ; } @ DataPoint public static int ONE = 1 ; @ DataPoint public static int TWO = 2 ; @ Theory public void everythingsEmpty ( List < Object > first , int number ) { assertThat ( first . size ( ) , is ( 0 ) ) ; first . add ( " a " ) ; } } @ Test public void mutableObjectsAreCreatedAfresh ( ) { assertThat ( failures ( DataPointMethodReturnsMutableObject . class ) , empty ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public static int oneHundred ( ) { return 100 ; } public static Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void shouldFailFromExceptionsInSingleDataPointMethods ( ) { assertThat ( testResult ( HasFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; }
public static int [ ] failingDataPoints ( ) { throw new RuntimeException ( ) ; }
public void allIntsOk ( int x ) { } } @ Test public void shouldFailFromExceptionsInDataPointArrayMethods ( ) { assertThat ( testResult ( HasFailingDataPointArrayMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodReturnsMutableObject { @ DataPoint public static List < Object > empty ( ) { return new ArrayList < Object > ( ) ; } @ DataPoint public static int ONE = 1 ; @ DataPoint public static int TWO = 2 ; @ Theory public void everythingsEmpty ( List < Object > first , int number ) { assertThat ( first . size ( ) , is ( 0 ) ) ; first . add ( " a " ) ; } } @ Test public void mutableObjectsAreCreatedAfresh ( ) { assertThat ( failures ( DataPointMethodReturnsMutableObject . class ) , empty ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public static int oneHundred ( ) { return 100 ; } public static Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void shouldFailFromExceptionsInDataPointArrayMethods ( ) { assertThat ( testResult ( HasFailingDataPointArrayMethod . class ) , not ( isSuccessful ( ) ) ) ; }
public static Date notADataPoint ( ) { return new Date ( ) ; }
public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public void ignoreDataPointMethodsWithWrongTypes ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) )
public void shouldFilterOutNullSingleDataPoints ( ) { assertThat ( testResult ( ShouldFilterOutNullSingleDataPoints . class ) , isSuccessful ( ) ) ; }
public void shouldFilterOutNullElementsFromDataPointArrays ( ) { assertThat ( testResult ( ShouldFilterOutNullElementsFromDataPointArrays . class ) , isSuccessful ( ) ) ; }
public void ShouldRejectTheoriesWithOnlyDisallowedNullData ( ) { assertThat ( testResult ( ShouldRejectTheoriesWithOnlyDisallowedNullData . class ) , not ( isSuccessful ( ) ) ) ; }
public void theory ( @ FromDataPoints ( " named " ) String param ) { } } @ Test public void onlyUseSpecificDataPointsIfSpecified ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasSpecificDatapointsParameters . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ; } } }
public void onlyUseSpecificDataPointsIfSpecified ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasSpecificDatapointsParameters . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 5 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( " expected " ) ) ;
public void shouldPickUpDataPointsFromParameterSupplier ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( TestClassUsingParameterSupplier . class . getMethod ( " theoryMethod " , String . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; assertEquals ( DATAPOINTS . get ( 0 ) , assignments . get ( 0 ) . getValue ( ) ) ; assertEquals ( DATAPOINTS . get ( 1 ) , assignments . get ( 1 ) . getValue ( ) ) ; }
public void theory ( int x ) { } } @ Test public void shouldFailFromExceptionsInSingleDataPointMethods ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasFailingDataPointArrayMethod { @ DataPoints public static int [ ] num = { 1 , 2 , 3 } ; @ DataPoints public static int [ ] failingDataPoints ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldFailFromExceptionsInDataPointArrayMethods ( ) { assertThat ( testResult ( HasFailingDataPointArrayMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasIgnoredFailingSingleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = Throwable . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldIgnoreSingleDataPointMethodExceptionsOnRequest ( ) { assertThat ( testResult ( HasIgnoredFailingSingleDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasIgnoredFailingMultipleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoints ( ignoredExceptions = Throwable . class ) public static int [ ] failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldIgnoreMultipleDataPointMethodExceptionsOnRequest ( ) { assertThat ( testResult ( HasIgnoredFailingMultipleDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasWronglyIgnoredFailingSingleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = NullPointerException . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingSingleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasWronglyIgnoredFailingMultipleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = NullPointerException . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingMultipleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingMultipleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } }
public void shouldFailFromExceptionsInSingleDataPointMethods ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; }
public void theory ( int x ) { } } @ Test public void shouldFailFromExceptionsInDataPointArrayMethods ( ) { assertThat ( testResult ( HasFailingDataPointArrayMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasIgnoredFailingSingleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = Throwable . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldIgnoreSingleDataPointMethodExceptionsOnRequest ( ) { assertThat ( testResult ( HasIgnoredFailingSingleDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasIgnoredFailingMultipleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoints ( ignoredExceptions = Throwable . class ) public static int [ ] failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldIgnoreMultipleDataPointMethodExceptionsOnRequest ( ) { assertThat ( testResult ( HasIgnoredFailingMultipleDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasWronglyIgnoredFailingSingleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = NullPointerException . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingSingleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasWronglyIgnoredFailingMultipleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = NullPointerException . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingMultipleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingMultipleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } }
public void theory ( int x ) { } } @ Test public void shouldIgnoreSingleDataPointMethodExceptionsOnRequest ( ) { assertThat ( testResult ( HasIgnoredFailingSingleDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasIgnoredFailingMultipleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoints ( ignoredExceptions = Throwable . class ) public static int [ ] failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldIgnoreMultipleDataPointMethodExceptionsOnRequest ( ) { assertThat ( testResult ( HasIgnoredFailingMultipleDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasWronglyIgnoredFailingSingleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = NullPointerException . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingSingleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasWronglyIgnoredFailingMultipleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = NullPointerException . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingMultipleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingMultipleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } }
public void shouldIgnoreSingleDataPointMethodExceptionsOnRequest ( ) { assertThat ( testResult ( HasIgnoredFailingSingleDataPointMethod . class ) , isSuccessful ( ) ) ; }
public static int [ ] failingDataPoint ( ) { throw new RuntimeException ( ) ; }
public void theory ( int x ) { } } @ Test public void shouldIgnoreMultipleDataPointMethodExceptionsOnRequest ( ) { assertThat ( testResult ( HasIgnoredFailingMultipleDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class HasWronglyIgnoredFailingSingleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = NullPointerException . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingSingleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasWronglyIgnoredFailingMultipleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = NullPointerException . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingMultipleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingMultipleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } }
public void shouldIgnoreMultipleDataPointMethodExceptionsOnRequest ( ) { assertThat ( testResult ( HasIgnoredFailingMultipleDataPointMethod . class ) , isSuccessful ( ) ) ; }
public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingSingleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } @ RunWith ( Theories . class ) public static class HasWronglyIgnoredFailingMultipleDataPointMethod { @ DataPoint public static int num = 10 ; @ DataPoint ( ignoredExceptions = NullPointerException . class ) public static int failingDataPoint ( ) { throw new RuntimeException ( ) ; } @ Theory public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingMultipleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingMultipleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } }
public void shouldNotIgnoreNonMatchingSingleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingSingleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; }
public void theory ( int x ) { } } @ Test public void shouldNotIgnoreNonMatchingMultipleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingMultipleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; } }
public void shouldNotIgnoreNonMatchingMultipleDataPointExceptions ( ) { assertThat ( testResult ( HasWronglyIgnoredFailingMultipleDataPointMethod . class ) , not ( isSuccessful ( ) ) ) ; }
public void allIntsOk ( int x ) { } } @ Test public void pickUpDataPointMethods ( ) { assertThat ( testResult ( HasDataPointMethod . class ) , isSuccessful ( ) ) ; } @ RunWith ( Theories . class ) public static class DataPointMethodReturnsMutableObject { @ DataPoint public static List < Object > empty ( ) { return new ArrayList < Object > ( ) ; } @ DataPoint public static int ONE = 1 ; @ DataPoint public static int TWO = 2 ; @ Theory public void everythingsEmpty ( List < Object > first , int number ) { assertThat ( first . size ( ) , is ( 0 ) ) ; first . add ( " a " ) ; } } @ Test public void mutableObjectsAreCreatedAfresh ( ) { assertThat ( failures ( DataPointMethodReturnsMutableObject . class ) , empty ( ) ) ; } @ RunWith ( Theories . class ) public static class HasDateMethod { @ DataPoint public static int oneHundred ( ) { return 100 ; } public static Date notADataPoint ( ) { return new Date ( ) ; } @ Theory public void allIntsOk ( int x ) { } @ Theory public void onlyStringsOk ( String s ) { } @ Theory public void onlyDatesOk ( Date d ) { } } @ Test public void ignoreDataPointMethodsWithWrongTypes ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyStringsOk " , String . class ) ) . toString ( ) , not ( containsString ( " 100 " ) ) ) ; } @ Test public void ignoreDataPointMethodsWithoutAnnotation ( ) throws Throwable { assertThat ( potentialAssignments ( HasDateMethod . class . getMethod ( " onlyDatesOk " , Date . class ) ) . size ( ) , is ( 0 ) ) ; } private List < Failure > failures ( Class < ? > type ) { return JUnitCore . runClasses ( type ) . getFailures ( ) ; } private Matcher < Iterable < Failure > > empty ( ) { return everyItem ( nullValue ( Failure . class ) ) ; } }
public List < PotentialAssignment > potentialsForNextUnassigned ( ) throws Exception { ParameterSignature unassigned = nextUnassigned ( ) ; List < PotentialAssignment > assignments = getSupplier ( unassigned ) . getValueSources ( unassigned ) ; if ( assignments . size ( ) = = 0 ) { assignments = generateAssignmentsFromTypeAlone ( unassigned ) ; } return assignments ; }
private List < PotentialAssignment > generateAssignmentsFromTypeAlone ( ParameterSignature unassigned ) { Class < ? > paramType = unassigned . getType ( ) ; if ( paramType . isEnum ( ) ) { return new EnumSupplier ( paramType ) . getValueSources ( unassigned ) ;
private ParameterSupplier getSupplier ( ParameterSignature unassigned ) throws Exception { ParametersSuppliedBy annotation = unassigned . findDeepAnnotation ( ParametersSuppliedBy . class ) ; if ( annotation ! = null ) { return buildParameterSupplierFromClass ( annotation . value ( ) ) ;
public void theory ( ENUM e ) { } public void theory ( boolean b ) { } } @ Test public void shouldAutomaticallyGenerateEnumDataPoints ( ) throws Exception { assertEquals ( ENUM . values ( ) . length , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ Test public void shouldAutomaticallyGenerateBooleanDataPoints ( ) throws Exception { assertEquals ( 2 , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificEnumDataPoint { @ DataPoint public static ENUM value = ENUM . OTHER_VALUE ; public void theory ( ENUM e ) { } } @ Test public void shouldNotAutogenerateEnumDataPointsWhenSpecificDataPointGiven ( ) throws Exception { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificEnumDataPoint . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificBooleanDataPoint { @ DataPoint public static boolean value = true ; public void theory ( boolean b ) { } } @ Test public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Exception { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } }
public void theory ( boolean b ) { } } @ Test public void shouldAutomaticallyGenerateEnumDataPoints ( ) throws Exception { assertEquals ( ENUM . values ( ) . length , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ Test public void shouldAutomaticallyGenerateBooleanDataPoints ( ) throws Exception { assertEquals ( 2 , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificEnumDataPoint { @ DataPoint public static ENUM value = ENUM . OTHER_VALUE ; public void theory ( ENUM e ) { } } @ Test public void shouldNotAutogenerateEnumDataPointsWhenSpecificDataPointGiven ( ) throws Exception { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificEnumDataPoint . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificBooleanDataPoint { @ DataPoint public static boolean value = true ; public void theory ( boolean b ) { } } @ Test public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Exception { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } }
public void shouldAutomaticallyGenerateEnumDataPoints ( ) throws Exception { assertEquals ( ENUM . values ( ) . length , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ;
public void shouldAutomaticallyGenerateBooleanDataPoints ( ) throws Exception { assertEquals ( 2 , potentialAssignments ( TheoryTestClassWithAutogeneratedParameterValues . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ;
public void theory ( ENUM e ) { } } @ Test public void shouldNotAutogenerateEnumDataPointsWhenSpecificDataPointGiven ( ) throws Exception { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificEnumDataPoint . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ; } @ RunWith ( Theories . class ) public static class TheoryTestClassWithSpecificBooleanDataPoint { @ DataPoint public static boolean value = true ; public void theory ( boolean b ) { } } @ Test public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Exception { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } }
public void shouldNotAutogenerateEnumDataPointsWhenSpecificDataPointGiven ( ) throws Exception { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificEnumDataPoint . class . getMethod ( " theory " , ENUM . class ) ) . size ( ) ) ;
public void theory ( boolean b ) { } } @ Test public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Exception { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ; } }
public void shouldNotAutogenerateBooleanDataPointsWhenSpecificDataPointGiven ( ) throws Exception { assertEquals ( 1 , potentialAssignments ( TheoryTestClassWithSpecificBooleanDataPoint . class . getMethod ( " theory " , boolean . class ) ) . size ( ) ) ;
public Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException { try { return createFilter ( parseCategories ( params . getArgs ( ) ) ) ;
protected abstract Filter createFilter ( Class < ? > [ ] categories ) ; private Class < ? > [ ] parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = ClassUtil . getClass ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses . toArray ( new Class [ ] { } ) ; } }
abstract public Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException ; public static class FilterNotCreatedException extends FilterFactoryFactory . FilterFactoryNotCreatedException { public FilterNotCreatedException ( String message ) { super ( message ) ; } } }
public Filter createFilterFromFilterSpec ( Description description , String filterSpec ) throws FilterFactoryNotCreatedException { String filterFactoryFqcn ; FilterFactoryParams params ; if ( filterSpec . contains ( " = " ) ) { String [ ] tuple = filterSpec . split ( " = " , 2 ) ; filterFactoryFqcn = tuple [ 0 ] ; params = new FilterFactoryParams ( description , tuple [ 1 ] ) ; } else { filterFactoryFqcn = filterSpec ; params = new FilterFactoryParams ( description ) ; } return createFilter ( filterFactoryFqcn , params ) ; }
String [ ] parseOptions ( String [ ] args ) { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; for ( int i = 0 ; i ! = args . length ; + + i ) { String arg = args [ i ] ; try { if ( arg . equals ( " - - " ) ) { return Arrays . copyOfRange ( args , i + 1 , args . length ) ; } else if ( arg . startsWith ( " - - " ) ) { if ( arg . startsWith ( " - - filter = " ) | | arg . equals ( " - - filter " ) ) { String filterSpec ; if ( arg . equals ( " - - filter " ) ) { + + i ; filterSpec = args [ i ] ; } else { filterSpec = arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ; } filter = filter . intersect ( filterFactoryFactory . createFilterFromFilterSpec ( createSuiteDescription ( arg ) , filterSpec ) ) ; } else { Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , new CommandLineParserError ( " JUnit knows nothing about the " + arg + " option " ) ) ; failures . add ( failure ) ; } } else { return Arrays . copyOfRange ( args , i , args . length ) ; } } catch ( FilterFactory . FilterNotCreatedException e ) { system . out ( ) . println ( " Could not find filter : " + e . getMessage ( ) ) ; Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } catch ( FilterFactoryFactory . FilterFactoryNotCreatedException e ) { system . out ( ) . println ( " Could not find filter factory : " + e . getMessage ( ) ) ; Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } } return null ; }
public void shouldCreateFilter ( ) throws Exception { CategoryFilterFactory categoryFilterFactory = new CategoryFilterFactoryStub ( ) ; FilterFactoryParams params = new FilterFactoryParams ( Description . createSuiteDescription ( testName . getMethodName ( ) ) , CategoryFilterFactoryStub . class . getName ( ) ) ; Filter filter = categoryFilterFactory . createFilter ( params ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldCreateFilterWithArguments ( ) throws Exception { Filter filter = filterFactoryFactory . createFilterFromFilterSpec ( createSuiteDescription ( testName . getMethodName ( ) ) , ExcludeCategories . class . getName ( ) + " = " + DummyCategory . class . getName ( ) ) ; assertThat ( filter . describe ( ) , startsWith ( " excludes " ) ) ; }
public void shouldCreateFilterWithNoArguments ( ) throws Exception { Filter filter = filterFactoryFactory . createFilterFromFilterSpec ( createSuiteDescription ( testName . getMethodName ( ) ) , FilterFactoryStub . class . getName ( ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldCreateFilter ( ) throws Exception { Filter filter = filterFactoryFactory . createFilter ( FilterFactoryStub . class , new FilterFactoryParams ( createSuiteDescription ( testName . getMethodName ( ) ) ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException ; public static class FilterNotCreatedException extends FilterFactoryFactory . FilterFactoryNotCreatedException { public FilterNotCreatedException ( Exception exception ) { super ( exception ) ; } } }
public Filter createFilterFromFilterSpec ( Description description , String filterSpec ) throws FilterFactoryNotCreatedException { if ( filterSpec . contains ( " = " ) ) { String [ ] tuple = filterSpec . split ( " = " , 2 ) ;
FilterFactory createFilterFactory ( String filterFactoryFqcn ) throws FilterFactoryNotCreatedException { Class < ? extends FilterFactory > filterFactoryClass ; try { filterFactoryClass = ClassUtil . getClass ( filterFactoryFqcn ) . asSubclass ( FilterFactory . class ) ; } catch ( Exception e ) { throw new FilterFactoryNotCreatedException ( e ) ; } return createFilterFactory ( filterFactoryClass ) ; }
FilterFactory createFilterFactory ( Class < ? extends FilterFactory > filterFactoryClass ) throws FilterFactoryNotCreatedException { try { return filterFactoryClass . getConstructor ( ) . newInstance ( ) ;
String [ ] parseOptions ( String [ ] args ) { FilterFactoryFactory filterFactoryFactory = new FilterFactoryFactory ( ) ; for ( int i = 0 ; i ! = args . length ; + + i ) { String arg = args [ i ] ; try { if ( arg . equals ( " - - " ) ) { return copyArray ( args , i + 1 , args . length ) ; } else if ( arg . startsWith ( " - - " ) ) { if ( arg . startsWith ( " - - filter = " ) | | arg . equals ( " - - filter " ) ) { String filterSpec ; if ( arg . equals ( " - - filter " ) ) { + + i ; if ( i < args . length ) { filterSpec = args [ i ] ; } else { Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , new CommandLineParserError ( arg + " value not specified " ) ) ; failures . add ( failure ) ; break ; } } else { filterSpec = arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ; } filter = filter . intersect ( filterFactoryFactory . createFilterFromFilterSpec ( createSuiteDescription ( arg ) , filterSpec ) ) ; } else { Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , new CommandLineParserError ( " JUnit knows nothing about the " + arg + " option " ) ) ; failures . add ( failure ) ; } } else { return copyArray ( args , i , args . length ) ; } } catch ( FilterFactory . FilterNotCreatedException e ) { system . out ( ) . println ( " Could not find filter : " + e . getMessage ( ) ) ; Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } catch ( FilterFactoryFactory . FilterFactoryNotCreatedException e ) { system . out ( ) . println ( " Could not find filter factory : " + e . getMessage ( ) ) ; Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } } return null ; }
private String [ ] copyArray ( String [ ] args , int from , int to ) { ArrayList < String > result = new ArrayList < String > ( ) ; for ( int j = from ; j ! = to ; + + j ) { result . add ( args [ j ] ) ; } return result . toArray ( new String [ ] { } ) ; }
public Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException { throw new FilterNotCreatedException ( new Exception ( " not implemented " ) ) ; }
public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue ( ) { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter " } ) ; List < Failure > failures = jUnitCommandLineParser . getFailures ( ) ; Throwable exception = failures . get ( 0 ) . getException ( ) ; assertThat ( exception , instanceOf ( JUnitCommandLineParser . CommandLineParserError . class ) ) ; }
public Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException { throw new FilterNotCreatedException ( new Exception ( " stub " ) ) ; }
public void shouldCreateFilter ( ) throws Exception { FilterFactoryParams params = new FilterFactoryParams ( Description . createSuiteDescription ( testName . getMethodName ( ) ) , CategoryFilterFactoryStub . class . getName ( ) ) ; Filter filter = categoryFilterFactory . createFilter ( params ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldThrowException ( ) throws Exception { FilterFactoryParams params = new FilterFactoryParams ( Description . createSuiteDescription ( testName . getMethodName ( ) ) , " NonExistentFilter " ) ; expectedException . expect ( FilterFactory . FilterNotCreatedException . class ) ; categoryFilterFactory . createFilter ( params ) ; }
protected abstract Filter createFilter ( Class < ? > . . . categories ) ; private Class < ? > [ ] parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = ClassUtil . getClass ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses . toArray ( new Class [ ] { } ) ; } }
protected Filter createFilter ( Class < ? > . . . categories ) { return new ExcludesAny ( categories ) ; }
protected Filter createFilter ( Class < ? > . . . categories ) { return new IncludesAny ( categories ) ; }
protected abstract Filter createFilter ( Class < ? > . . . categories ) ; private Class < ? > [ ] parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = Classes . getClass ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses . toArray ( new Class [ ] { } ) ; } }
private Class < ? > [ ] parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = Classes . getClass ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses . toArray ( new Class [ ] { } ) ; }
public static Filter createFilterFromFilterSpec ( Description description , String filterSpec ) throws FilterFactoryNotCreatedException { if ( filterSpec . contains ( " = " ) ) { String [ ] tuple = filterSpec . split ( " = " , 2 ) ;
public static Filter createFilter ( String filterFactoryFqcn , FilterFactoryParams params ) throws FilterFactoryNotCreatedException { FilterFactory filterFactory = createFilterFactory ( filterFactoryFqcn ) ; return filterFactory . createFilter ( params ) ; }
public static Filter createFilter ( Class < ? extends FilterFactory > filterFactoryClass , FilterFactoryParams params ) throws FilterFactoryNotCreatedException { FilterFactory filterFactory = createFilterFactory ( filterFactoryClass ) ; return filterFactory . createFilter ( params ) ; }
static FilterFactory createFilterFactory ( String filterFactoryFqcn ) throws FilterFactoryNotCreatedException { Class < ? extends FilterFactory > filterFactoryClass ; try { filterFactoryClass = Classes . getClass ( filterFactoryFqcn ) . asSubclass ( FilterFactory . class ) ; } catch ( Exception e ) { throw new FilterFactoryNotCreatedException ( e ) ; } return createFilterFactory ( filterFactoryClass ) ; }
static FilterFactory createFilterFactory ( Class < ? extends FilterFactory > filterFactoryClass ) throws FilterFactoryNotCreatedException { try { return filterFactoryClass . getConstructor ( ) . newInstance ( ) ;
public Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException ; public static class FilterNotCreatedException extends FilterFactories . FilterFactoryNotCreatedException { public FilterNotCreatedException ( Exception exception ) { super ( exception ) ; } } }
String [ ] parseOptions ( String [ ] args ) { for ( int i = 0 ; i ! = args . length ; + + i ) { String arg = args [ i ] ; try { if ( arg . equals ( " - - " ) ) { return copyArray ( args , i + 1 , args . length ) ; } else if ( arg . startsWith ( " - - " ) ) { if ( arg . startsWith ( " - - filter = " ) | | arg . equals ( " - - filter " ) ) { String filterSpec ; if ( arg . equals ( " - - filter " ) ) { + + i ; if ( i < args . length ) { filterSpec = args [ i ] ; } else { Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , new CommandLineParserError ( arg + " value not specified " ) ) ; failures . add ( failure ) ; break ; } } else { filterSpec = arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ; } filter = filter . intersect ( FilterFactories . createFilterFromFilterSpec ( createSuiteDescription ( arg ) , filterSpec ) ) ; } else { Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , new CommandLineParserError ( " JUnit knows nothing about the " + arg + " option " ) ) ; failures . add ( failure ) ; } } else { return copyArray ( args , i , args . length ) ; } } catch ( FilterFactory . FilterNotCreatedException e ) { system . out ( ) . println ( " Could not find filter : " + e . getMessage ( ) ) ; Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } catch ( FilterFactories . FilterFactoryNotCreatedException e ) { system . out ( ) . println ( " Could not find filter factory : " + e . getMessage ( ) ) ; Description description = createSuiteDescription ( arg ) ; Failure failure = new Failure ( description , e ) ; failures . add ( failure ) ; } } return null ; }
public void shouldCreateFilterWithArguments ( ) throws Exception { Filter filter = FilterFactories . createFilterFromFilterSpec ( createSuiteDescription ( testName . getMethodName ( ) ) , ExcludeCategories . class . getName ( ) + " = " + DummyCategory . class . getName ( ) ) ; assertThat ( filter . describe ( ) , startsWith ( " excludes " ) ) ; }
public void shouldCreateFilterWithNoArguments ( ) throws Exception { Filter filter = FilterFactories . createFilterFromFilterSpec ( createSuiteDescription ( testName . getMethodName ( ) ) , FilterFactoryStub . class . getName ( ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldCreateFilter ( ) throws Exception { Filter filter = FilterFactories . createFilter ( FilterFactoryStub . class , new FilterFactoryParams ( createSuiteDescription ( testName . getMethodName ( ) ) ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldThrowExceptionIfNotFilterFactory ( ) throws Exception { expectedException . expect ( FilterFactories . FilterFactoryNotCreatedException . class ) ; FilterFactories . createFilterFactory ( NonFilterFactory . class . getName ( ) ) ; }
public void shouldThrowExceptionIfNotInstantiable ( ) throws Exception { expectedException . expect ( FilterFactories . FilterFactoryNotCreatedException . class ) ; FilterFactories . createFilterFactory ( NonInstantiableFilterFactory . class ) ; }
public void shouldCreateFailureUponUnfoundFilterFactory ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = NonExistentFilterFactory " } ) ; List < Failure > failures = jUnitCommandLineParser . getFailures ( ) ; Throwable exception = failures . get ( 0 ) . getException ( ) ; assertThat ( exception , instanceOf ( FilterFactories . FilterFactoryNotCreatedException . class ) ) ; }
Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException ; static class FilterNotCreatedException extends FilterFactories . FilterFactoryNotCreatedException { public FilterNotCreatedException ( Exception exception ) { super ( exception ) ; } } }
public void evaluate ( ) throws Throwable { FutureTask < Throwable > task = new FutureTask < Throwable > ( new CallableStatement ( ) ) ; Thread thread = new Thread ( task , " Time - limited test " ) ; thread . setDaemon ( true ) ; thread . start ( ) ; Throwable throwable = getResult ( task , thread ) ; if ( throwable ! = null ) { throw throwable ;
private Exception createTimeoutException ( Thread thread ) { StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; Exception exception = new Exception ( String . format ( " test timed out after % d % s " , fTimeout , fTimeUnit . name ( ) . toLowerCase ( ) ) ) ; if ( stackTrace ! = null ) { exception . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } return exception ; }
public Throwable call ( ) throws Exception { try { fOriginalStatement . evaluate ( ) ; } catch ( Exception e ) { throw e ; } catch ( Throwable e ) { return e ; } return null ; }
private void addDataPointsValues ( Class < ? > type , ParameterSignature sig , String name , List < PotentialAssignment > list , Object value ) { if ( type . isArray ( ) ) { addArrayValues ( sig , name , list , value ) ;
private void addIterableValues ( ParameterSignature sig , String name , List < PotentialAssignment > list , Iterable < ? > iterable ) { Iterator < ? > iterator = iterable . iterator ( ) ; int i = 0 ; while ( iterator . hasNext ( ) ) { Object value = iterator . next ( ) ;
public void dataPointsArrayShouldBeRecognized ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsArrayField . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; }
public void dataPointsArrayShouldBeRecognizedOnValueTypeNotFieldType ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsArrayWithMatchingButInaccurateTypes . class . getMethod ( " theory " , Integer . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; }
public void dataPointMethodShouldBeRecognizedForOverlyGeneralParameters ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointMethodWithOverlyGeneralTypes . class . getMethod ( " theory " , Object . class ) ) ; assertEquals ( 1 , assignments . size ( ) ) ; }
public void dataPointsAnnotationMeansTreatAsArrayOnly ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsWithObjectParameter . class . getMethod ( " theory " , Object . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertNotEquals ( HasDataPointsWithObjectParameter . objectField , assignment . getValue ( ) ) ;
public void dataPointsCollectionFieldsShouldBeRecognized ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsListField . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; }
public void theory ( String param ) { } } @ Test public void dataPointsCollectionMethodShouldBeRecognized ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsListMethod . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; } public static class HasDataPointsListFieldWithOverlyGenericTypes { @ DataPoints public static List < Object > list = Arrays . asList ( " string " , new Object ( ) ) ; @ Theory public void theory ( String param ) { } } @ Test public void dataPointsCollectionShouldBeRecognizedIgnoringStrangeTypes ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsListFieldWithOverlyGenericTypes . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 1 , assignments . size ( ) ) ; } }
public void dataPointsCollectionMethodShouldBeRecognized ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsListMethod . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 2 , assignments . size ( ) ) ; }
public void theory ( String param ) { } } @ Test public void dataPointsCollectionShouldBeRecognizedIgnoringStrangeTypes ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsListFieldWithOverlyGenericTypes . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 1 , assignments . size ( ) ) ; } }
public void dataPointsCollectionShouldBeRecognizedIgnoringStrangeTypes ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsListFieldWithOverlyGenericTypes . class . getMethod ( " theory " , String . class ) ) ; assertEquals ( 1 , assignments . size ( ) ) ; }
private Description describeCause ( Throwable child ) { return Description . createTestDescription ( fTestClass , " initializationError : " + child ) ;
String [ ] parseOptions ( String [ ] args ) { for ( int i = 0 ; i ! = args . length ; + + i ) { String arg = args [ i ] ; try { if ( arg . equals ( " - - " ) ) { return copyArray ( args , i + 1 , args . length ) ; } else if ( arg . startsWith ( " - - " ) ) { if ( arg . startsWith ( " - - filter = " ) | | arg . equals ( " - - filter " ) ) { String filterSpec ; if ( arg . equals ( " - - filter " ) ) { + + i ; if ( i < args . length ) { filterSpec = args [ i ] ; } else { parserErrors . add ( new CommandLineParserError ( arg + " value not specified " ) ) ; break ; } } else { filterSpec = arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ; } filter = filter . intersect ( FilterFactories . createFilterFromFilterSpec ( createSuiteDescription ( arg ) , filterSpec ) ) ; } else { parserErrors . add ( new CommandLineParserError ( " JUnit knows nothing about the " + arg + " option " ) ) ; } } else { return copyArray ( args , i , args . length ) ; } } catch ( FilterFactory . FilterNotCreatedException e ) { system . out ( ) . println ( " Could not find filter : " + e . getMessage ( ) ) ; parserErrors . add ( e ) ; } catch ( FilterFactories . FilterFactoryNotCreatedException e ) { system . out ( ) . println ( " Could not find filter factory : " + e . getMessage ( ) ) ; parserErrors . add ( e ) ; } } return null ; }
public Request createRequest ( Computer computer ) { if ( parserErrors . isEmpty ( ) ) { return Request
Result runMain ( JUnitSystem system , String . . . args ) { system . out ( ) . println ( " JUnit version " + Version . id ( ) ) ; JUnitCommandLineParser jUnitCommandLineParser = new JUnitCommandLineParser ( system ) ; jUnitCommandLineParser . parseArgs ( args ) ; RunListener listener = new TextListener ( system ) ; addListener ( listener ) ; return run ( jUnitCommandLineParser . createRequest ( defaultComputer ( ) ) ) ; }
public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue ( ) { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter " } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void shouldCreateFailureUponUnknownOption ( ) throws Exception { String unknownOption = " - - unknown - option " ; jUnitCommandLineParser . parseOptions ( new String [ ] { unknownOption } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void shouldCreateFailureUponUncreatedFilter ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + FilterFactoryStub . class . getName ( ) } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void shouldCreateFailureUponUnfoundFilterFactory ( ) throws Exception { String nonExistentFilterFactory = " NonExistentFilterFactory " ; jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + nonExistentFilterFactory } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void shouldCreateFailureUponUnknownTestClass ( ) throws Exception { String unknownTestClass = " UnknownTestClass " ; jUnitCommandLineParser . parseParameters ( new String [ ] { unknownTestClass } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void fireTestFailure ( Failure failure ) { failures . add ( failure ) ; }
public void addChild ( Description description ) { fChildren . add ( description ) ; }
public boolean isTest ( ) { return fChildren . isEmpty ( ) ; }
public int testCount ( ) { if ( isTest ( ) ) { return 1 ; } int result = 0 ; for ( Description child : fChildren ) { result + = child . testCount ( ) ; } return result ; }
public void run ( ) { ParentRunner . this . runChild ( each , notifier ) ; }
private void sortChild ( T child , Sorter sorter ) { sorter . apply ( child ) ; }
private Comparator < ? super T > comparator ( final Sorter sorter ) { return new Comparator < T > ( ) { public int compare ( T o1 , T o2 ) {
public int compare ( T o1 , T o2 ) { return sorter . compare ( describeChild ( o1 ) , describeChild ( o2 ) ) ; }
private static < T > List < T > getAnnotatedMembers ( Map < Class < ? > , List < T > > map , Class < ? extends Annotation > type ) { if ( ! map . containsKey ( type ) ) { map . put ( type , new CopyOnWriteArrayList < T > ( ) ) ; } return map . get ( type ) ; }
private static boolean runsTopToBottom ( Class < ? extends Annotation > annotation ) { return annotation . equals ( Before . class ) | | annotation . equals ( BeforeClass . class ) ;
private Description describeCause ( Throwable child ) { return Description . createTestDescription ( fTestClass , " initializationError : " + child ) ;
public static Filter createFilterFromFilterSpec ( Description description , String filterSpec ) throws FilterNotCreatedException { if ( filterSpec . contains ( " = " ) ) { String [ ] tuple = filterSpec . split ( " = " , 2 ) ;
public static Filter createFilter ( String filterFactoryFqcn , FilterFactoryParams params ) throws FilterNotCreatedException { FilterFactory filterFactory = createFilterFactory ( filterFactoryFqcn ) ; return filterFactory . createFilter ( params ) ; }
public static Filter createFilter ( Class < ? extends FilterFactory > filterFactoryClass , FilterFactoryParams params ) throws FilterNotCreatedException { FilterFactory filterFactory = createFilterFactory ( filterFactoryClass ) ; return filterFactory . createFilter ( params ) ; }
Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException ; public static class FilterNotCreatedException extends ClassNotFoundException { public FilterNotCreatedException ( Exception exception ) { super ( exception . getMessage ( ) , exception ) ; } } }
String [ ] parseOptions ( String [ ] args ) { for ( int i = 0 ; i ! = args . length ; + + i ) { String arg = args [ i ] ; try { if ( arg . equals ( " - - " ) ) { return copyArray ( args , i + 1 , args . length ) ; } else if ( arg . startsWith ( " - - " ) ) { if ( arg . startsWith ( " - - filter = " ) | | arg . equals ( " - - filter " ) ) { String filterSpec ; if ( arg . equals ( " - - filter " ) ) { + + i ; if ( i < args . length ) { filterSpec = args [ i ] ; } else { parserErrors . add ( new CommandLineParserError ( arg + " value not specified " ) ) ; break ; } } else { filterSpec = arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ; } filter = filter . intersect ( FilterFactories . createFilterFromFilterSpec ( createSuiteDescription ( arg ) , filterSpec ) ) ; } else { parserErrors . add ( new CommandLineParserError ( " JUnit knows nothing about the " + arg + " option " ) ) ; } } else { return copyArray ( args , i , args . length ) ; } } catch ( FilterFactory . FilterNotCreatedException e ) { system . out ( ) . println ( " Could not find filter : " + e . getMessage ( ) ) ; parserErrors . add ( e ) ; } } return new String [ ] { } ; }
public void shouldCreateFilter ( ) throws Exception { FilterFactoryParams params = new FilterFactoryParams ( CategoryFilterFactoryStub . class . getName ( ) ) ; Filter filter = categoryFilterFactory . createFilter ( params ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldThrowException ( ) throws Exception { FilterFactoryParams params = new FilterFactoryParams ( " NonExistentFilter " ) ; expectedException . expect ( FilterFactory . FilterNotCreatedException . class ) ; categoryFilterFactory . createFilter ( params ) ; }
public void shouldCreateFilter ( ) throws Exception { Filter filter = FilterFactories . createFilter ( FilterFactoryStub . class , new FilterFactoryParams ( ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue ( ) { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter " } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void shouldCreateFailureUponUnknownOption ( ) throws Exception { String unknownOption = " - - unknown - option " ; jUnitCommandLineParser . parseOptions ( new String [ ] { unknownOption } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void shouldCreateFailureUponUncreatedFilter ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + FilterFactoryStub . class . getName ( ) } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void shouldCreateFailureUponUnfoundFilterFactory ( ) throws Exception { String nonExistentFilterFactory = " NonExistentFilterFactory " ; jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + nonExistentFilterFactory } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void shouldCreateFailureUponUnknownTestClass ( ) throws Exception { String unknownTestClass = " UnknownTestClass " ; jUnitCommandLineParser . parseParameters ( new String [ ] { unknownTestClass } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , allOf ( containsString ( " initializationError : " ) ,
public void shouldAddFailuresToResult ( ) { JUnitCore jUnitCore = new JUnitCore ( ) ; Result result = jUnitCore . runMain ( new TestSystem ( ) , " NonExistentTest " ) ; assertThat ( result . getFailureCount ( ) , is ( 1 ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getException ( ) , instanceOf ( IllegalArgumentException . class ) ) ; }
private Description describeCause ( Throwable child ) { return Description . createTestDescription ( fTestClass , " initializationError : " ) ; }
public static Filter createFilterFromFilterSpec ( Description description , String filterSpec ) throws FilterFactory . FilterNotCreatedException { if ( filterSpec . contains ( " = " ) ) { String [ ] tuple = filterSpec . split ( " = " , 2 ) ;
public static Filter createFilter ( String filterFactoryFqcn , FilterFactoryParams params ) throws FilterFactory . FilterNotCreatedException { FilterFactory filterFactory = createFilterFactory ( filterFactoryFqcn ) ; return filterFactory . createFilter ( params ) ; }
public static Filter createFilter ( Class < ? extends FilterFactory > filterFactoryClass , FilterFactoryParams params ) throws FilterFactory . FilterNotCreatedException { FilterFactory filterFactory = createFilterFactory ( filterFactoryClass ) ; return filterFactory . createFilter ( params ) ; }
static FilterFactory createFilterFactory ( String filterFactoryFqcn ) throws FilterNotCreatedException { Class < ? extends FilterFactory > filterFactoryClass ; try { filterFactoryClass = Classes . getClass ( filterFactoryFqcn ) . asSubclass ( FilterFactory . class ) ; } catch ( Exception e ) { throw new FilterNotCreatedException ( e ) ; } return createFilterFactory ( filterFactoryClass ) ; }
static FilterFactory createFilterFactory ( Class < ? extends FilterFactory > filterFactoryClass ) throws FilterNotCreatedException { try { return filterFactoryClass . getConstructor ( ) . newInstance ( ) ;
Filter createFilter ( FilterFactoryParams params ) throws FilterNotCreatedException ; public static class FilterNotCreatedException extends Exception { public FilterNotCreatedException ( Exception exception ) { super ( exception . getMessage ( ) , exception ) ; } } }
public void shouldThrowExceptionIfNotFilterFactory ( ) throws Exception { expectedException . expect ( FilterFactory . FilterNotCreatedException . class ) ; FilterFactories . createFilterFactory ( NonFilterFactory . class . getName ( ) ) ; }
public void shouldThrowExceptionIfNotInstantiable ( ) throws Exception { expectedException . expect ( FilterFactory . FilterNotCreatedException . class ) ; FilterFactories . createFilterFactory ( NonInstantiableFilterFactory . class ) ; }
public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue ( ) { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter " } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError : " ) ) ; }
public void shouldCreateFailureUponUnknownOption ( ) throws Exception { String unknownOption = " - - unknown - option " ; jUnitCommandLineParser . parseOptions ( new String [ ] { unknownOption } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError : " ) ) ; }
public void shouldCreateFailureUponUncreatedFilter ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + FilterFactoryStub . class . getName ( ) } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError : " ) ) ; }
public void shouldCreateFailureUponUnfoundFilterFactory ( ) throws Exception { String nonExistentFilterFactory = " NonExistentFilterFactory " ; jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + nonExistentFilterFactory } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError : " ) ) ; }
public void shouldCreateFailureUponUnknownTestClass ( ) throws Exception { String unknownTestClass = " UnknownTestClass " ; jUnitCommandLineParser . parseParameters ( new String [ ] { unknownTestClass } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError : " ) ) ; }
private Description describeCause ( Throwable child ) { return Description . createTestDescription ( fTestClass , " initializationError : " ) ;
public static Filter createFilterFromFilterSpec ( Description description , String filterSpec ) throws FilterFactory . FilterNotCreatedException { String [ ] tuple ; if ( filterSpec . contains ( " = " ) ) { tuple = filterSpec . split ( " = " , 2 ) ; } else { tuple = new String [ ] { filterSpec , " " } ; } return createFilter ( tuple [ 0 ] , new FilterFactoryParams ( tuple [ 1 ] ) ) ; }
public void shouldCreateFilter ( ) throws Exception { Filter filter = FilterFactories . createFilter ( FilterFactoryStub . class , new FilterFactoryParams ( " " ) ) ; assertThat ( filter , instanceOf ( DummyFilter . class ) ) ; }
public void stringsWithoutPrePostFix ( ) { ComparisonFailure cf = new ComparisonFailure ( " usermsg " , " a " , " b " ) ; assertEquals ( " usermsg expected : < [ a ] > but was : < [ b ] > " , cf . getMessage ( ) ) ; }
public void testStartSame ( ) { ComparisonFailure failure = new ComparisonFailure ( " " , " ba " , " bc " ) ; assertEquals ( " expected : < b [ a ] > but was : < b [ c ] > " , failure . getMessage ( ) ) ; }
public void testEndSame ( ) { ComparisonFailure failure = new ComparisonFailure ( " " , " ab " , " cb " ) ; assertEquals ( " expected : < [ a ] b > but was : < [ c ] b > " , failure . getMessage ( ) ) ; }
public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] {
public void compactFailureMessage ( ) { ComparisonFailure failure = new ComparisonFailure ( " " , expected , actual ) ; assertEquals ( message , failure . getMessage ( ) ) ; }
private String compactString ( String source ) { String result = DELTA_START + source . substring ( fPrefix , source . length ( ) - fSuffix ) + DELTA_END ; if ( fPrefix > 0 ) { result = computeCommonPrefix ( ) + result ; } if ( fSuffix > 0 ) { result = result + computeCommonSuffix ( ) ; } return result ; }
private void findCommonSuffix ( ) { int expectedSuffix = fExpected . length ( ) - 1 ; int actualSuffix = fActual . length ( ) - 1 ; for ( ; actualSuffix > = fPrefix & & expectedSuffix > = fPrefix ; actualSuffix - - , expectedSuffix - - ) { if ( fExpected . charAt ( expectedSuffix ) ! = fActual . charAt ( actualSuffix ) ) { break ; } } fSuffix = fExpected . length ( ) - expectedSuffix - 1 ; }
private String computeCommonSuffix ( ) { int end = Math . min ( fExpected . length ( ) - fSuffix + fContextLength , fExpected . length ( ) ) ; return fExpected . substring ( fExpected . length ( ) - fSuffix , end ) + ( fExpected . length ( ) - fSuffix < fExpected . length ( ) - fContextLength ? ELLIPSIS : " " ) ; }
String [ ] parseOptions ( String [ ] args ) { for ( int i = 0 ; i ! = args . length ; + + i ) { String arg = args [ i ] ; try { if ( arg . equals ( " - - " ) ) { return copyArray ( args , i + 1 , args . length ) ; } else if ( arg . startsWith ( " - - " ) ) { if ( arg . startsWith ( " - - filter = " ) | | arg . equals ( " - - filter " ) ) { String filterSpec ; if ( arg . equals ( " - - filter " ) ) { + + i ; if ( i < args . length ) { filterSpec = args [ i ] ; } else { parserErrors . add ( new CommandLineParserError ( arg + " value not specified " ) ) ; break ; } } else { filterSpec = arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ; } filter = filter . intersect ( FilterFactories . createFilterFromFilterSpec ( createSuiteDescription ( arg ) , filterSpec ) ) ; } else { parserErrors . add ( new CommandLineParserError ( " JUnit knows nothing about the " + arg + " option " ) ) ; } } else { return copyArray ( args , i , args . length ) ; } } catch ( FilterFactory . FilterNotCreatedException e ) { parserErrors . add ( e ) ; } } return new String [ ] { } ; }
Result runMain ( JUnitSystem system , String . . . args ) { system . out ( ) . println ( " JUnit version " + Version . id ( ) ) ; JUnitCommandLineParser jUnitCommandLineParser = new JUnitCommandLineParser ( ) ; jUnitCommandLineParser . parseArgs ( args ) ; RunListener listener = new TextListener ( system ) ; addListener ( listener ) ; return run ( jUnitCommandLineParser . createRequest ( defaultComputer ( ) ) ) ; }
public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue ( ) { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter " } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public void shouldCreateFailureUponUnknownOption ( ) throws Exception { String unknownOption = " - - unknown - option " ; jUnitCommandLineParser . parseOptions ( new String [ ] { unknownOption } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public void shouldCreateFailureUponUncreatedFilter ( ) throws Exception { jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + FilterFactoryStub . class . getName ( ) } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public void shouldCreateFailureUponUnfoundFilterFactory ( ) throws Exception { String nonExistentFilterFactory = " NonExistentFilterFactory " ; jUnitCommandLineParser . parseOptions ( new String [ ] { " - - filter = " + nonExistentFilterFactory } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public void shouldCreateFailureUponUnknownTestClass ( ) throws Exception { String unknownTestClass = " UnknownTestClass " ; jUnitCommandLineParser . parseParameters ( new String [ ] { unknownTestClass } ) ; Runner runner = jUnitCommandLineParser . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public static JUnitCommandLineParseResult parse ( String [ ] args ) { JUnitCommandLineParseResult result = new JUnitCommandLineParseResult ( ) ; result . parseArgs ( args ) ; return result ; }
void parseArgs ( String [ ] args ) { parseParameters ( parseOptions ( args ) ) ; }
Result runMain ( JUnitSystem system , String . . . args ) { system . out ( ) . println ( " JUnit version " + Version . id ( ) ) ; JUnitCommandLineParseResult jUnitCommandLineParseResult = JUnitCommandLineParseResult . parse ( args ) ; RunListener listener = new TextListener ( system ) ; addListener ( listener ) ; return run ( jUnitCommandLineParseResult . createRequest ( defaultComputer ( ) ) ) ; }
public void shouldStopParsingOptionsUponDoubleHyphenArg ( ) throws Exception { String [ ] restOfArgs = jUnitCommandLineParseResult . parseOptions ( new String [ ] { " - - 0 " , " - - 1 " , " - - " , " - - 2 " , " - - 3 " } ) ; assertThat ( restOfArgs , is ( new String [ ] { " - - 2 " , " - - 3 " } ) ) ; }
public void shouldParseFilterArgWithEqualsSyntax ( ) throws Exception { jUnitCommandLineParseResult . parseOptions ( new String [ ] { " - - filter = " + IncludeCategories . class . getName ( ) + " = " + DummyCategory0 . class . getName ( ) } ) ; Filter filter = jUnitCommandLineParseResult . getFilter ( ) ; assertThat ( filter . describe ( ) , startsWith ( " includes " ) ) ; }
public void shouldCreateFailureUponBaldFilterOptionNotFollowedByValue ( ) { jUnitCommandLineParseResult . parseOptions ( new String [ ] { " - - filter " } ) ; Runner runner = jUnitCommandLineParseResult . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public void shouldParseFilterArgInWhichValueIsASeparateArg ( ) throws Exception { jUnitCommandLineParseResult . parseOptions ( new String [ ] { " - - filter " , IncludeCategories . class . getName ( ) + " = " + DummyCategory0 . class . getName ( ) } ) ; Filter filter = jUnitCommandLineParseResult . getFilter ( ) ; assertThat ( filter . describe ( ) , startsWith ( " includes " ) ) ; }
public void shouldStopParsingOptionsUponNonOption ( ) throws Exception { String [ ] restOfArgs = jUnitCommandLineParseResult . parseOptions ( new String [ ] { " - - 0 " , " - - 1 " , " 2 " , " 3 " } ) ; assertThat ( restOfArgs , is ( new String [ ] { " 2 " , " 3 " } ) ) ; }
public void shouldCreateFailureUponUnknownOption ( ) throws Exception { String unknownOption = " - - unknown - option " ; jUnitCommandLineParseResult . parseOptions ( new String [ ] { unknownOption } ) ; Runner runner = jUnitCommandLineParseResult . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public void shouldCreateFailureUponUncreatedFilter ( ) throws Exception { jUnitCommandLineParseResult . parseOptions ( new String [ ] { " - - filter = " + FilterFactoryStub . class . getName ( ) } ) ; Runner runner = jUnitCommandLineParseResult . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public void shouldCreateFailureUponUnfoundFilterFactory ( ) throws Exception { String nonExistentFilterFactory = " NonExistentFilterFactory " ; jUnitCommandLineParseResult . parseOptions ( new String [ ] { " - - filter = " + nonExistentFilterFactory } ) ; Runner runner = jUnitCommandLineParseResult . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
public void shouldAddToClasses ( ) { jUnitCommandLineParseResult . parseParameters ( new String [ ] { DummyTest . class . getName ( ) } ) ; List < Class < ? > > classes = jUnitCommandLineParseResult . getClasses ( ) ; Class < ? > testClass = classes . get ( 0 ) ; assertThat ( testClass . getName ( ) , is ( DummyTest . class . getName ( ) ) ) ; }
public void shouldCreateFailureUponUnknownTestClass ( ) throws Exception { String unknownTestClass = " UnknownTestClass " ; jUnitCommandLineParseResult . parseParameters ( new String [ ] { unknownTestClass } ) ; Runner runner = jUnitCommandLineParseResult . createRequest ( new Computer ( ) ) . getRunner ( ) ; Description description = runner . getDescription ( ) . getChildren ( ) . get ( 0 ) ; assertThat ( description . toString ( ) , containsString ( " initializationError " ) ) ; }
protected List < FrameworkMethod > computeTestMethods ( ) { List < FrameworkMethod > testMethods = new ArrayList < FrameworkMethod > ( super . computeTestMethods ( ) ) ; List < FrameworkMethod > theoryMethods = getTestClass ( ) . getAnnotatedMethods ( Theory . class ) ; testMethods . removeAll ( theoryMethods ) ; testMethods . addAll ( theoryMethods ) ; return testMethods ; }
private List < Runner > createRunnersForParameters ( Iterable < Object [ ] > allParameters , String namePattern ) throws Exception { try { int i = 0 ;
protected List < TestRule > classRules ( ) { List < TestRule > result = new ArrayList < TestRule > ( fTestClass . getAnnotatedMethodValues ( null , ClassRule . class , TestRule . class ) ) ; result . addAll ( fTestClass . getAnnotatedFieldValues ( null , ClassRule . class , TestRule . class ) ) ; return result ; }
public List < FrameworkMethod > getAnnotatedMethods ( Class < ? extends Annotation > annotationClass ) { return Collections . unmodifiableList ( getAnnotatedMembers ( fMethodsForAnnotations , annotationClass , false ) ) ; }
public List < FrameworkField > getAnnotatedFields ( Class < ? extends Annotation > annotationClass ) { return Collections . unmodifiableList ( getAnnotatedMembers ( fFieldsForAnnotations , annotationClass , false ) ) ; }
private static < T > List < T > getAnnotatedMembers ( Map < Class < ? > , List < T > > map , Class < ? extends Annotation > type , boolean canFill ) { if ( ! map . containsKey ( type ) & & canFill ) { map . put ( type , new ArrayList < T > ( ) ) ; } List < T > members = map . get ( type ) ; return members = = null ? Collections . < T > emptyList ( ) : members ; }
protected List < TestRule > classRules ( ) { List < TestRule > result = fTestClass . getAnnotatedMethodValues ( null , ClassRule . class , TestRule . class ) ; result = new ArrayList < TestRule > ( result ) ; result . addAll ( fTestClass . getAnnotatedFieldValues ( null , ClassRule . class , TestRule . class ) ) ; return result ; }
public Runner buildRunner ( Class < ? extends Runner > runnerClass , Class < ? > testClass ) throws Exception { try { return runnerClass . getConstructor ( Class . class ) . newInstance ( testClass ) ;
protected List < TestRule > classRules ( ) { List < TestRule > result = fTestClass . getAnnotatedMethodValues ( null , ClassRule . class , TestRule . class ) ; result . addAll ( fTestClass . getAnnotatedFieldValues ( null , ClassRule . class , TestRule . class ) ) ; return result ; }
public void filter ( Filter filter ) throws NoTestsRemainException { synchronized ( fChildrenLock ) { List < T > filteredChildren = new ArrayList < T > ( getFilteredChildren ( ) ) ;
private static < T > List < T > getAnnotatedMembers ( Map < Class < ? > , List < T > > map , Class < ? extends Annotation > type , boolean fillIfAbsent ) { if ( ! map . containsKey ( type ) & & fillIfAbsent ) { map . put ( type , new ArrayList < T > ( ) ) ; } List < T > members = map . get ( type ) ; return members = = null ? Collections . < T > emptyList ( ) : members ; }
private Runner createRunnerWithNotNormalizedParameters ( String pattern , int index , Object parametersOrSingleParameter ) throws InitializationError { Object [ ] parameters = ( parametersOrSingleParameter instanceof Object [ ] ) ? ( Object [ ] ) parametersOrSingleParameter : new Object [ ] { parametersOrSingleParameter } ; return createRunner ( pattern , index , parameters ) ; }
private Iterable < Object > allParameters ( ) throws Throwable { Object parameters = getParametersMethod ( ) . invokeExplosively ( null ) ; if ( parameters instanceof Iterable ) { return ( Iterable < Object > ) parameters ;
private List < Runner > createRunnersForParameters ( Iterable < Object > allParameters , String namePattern ) throws Exception { try { int i = 0 ;
public void aTest ( ) { } } @ Test public void beforeAndAfterClassAreRun ( ) { fLog = " " ; JUnitCore . runClasses ( BeforeAndAfter . class ) ; assertEquals ( " before after " , fLog ) ; } @ RunWith ( Parameterized . class ) static public class EmptyTest { @ BeforeClass public static void before ( ) { fLog + = " before " ; } @ AfterClass public static void after ( ) { fLog + = " after " ; } } @ Test public void validateClassCatchesNoParameters ( ) { Result result = JUnitCore . runClasses ( EmptyTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class IncorrectTest { @ Test public int test ( ) { return 0 ; } @ Parameters public static Collection < Object [ ] > data ( ) { return Collections . singletonList ( new Object [ ] { 1 } ) ; } } @ Test public void failuresAddedForBadTestMethod ( ) throws Exception { Result result = JUnitCore . runClasses ( IncorrectTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ProtectedParametersTest { @ Parameters protected static Collection < Object [ ] > data ( ) { return Collections . emptyList ( ) ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersNotPublic ( ) throws Exception { Result result = JUnitCore . runClasses ( ProtectedParametersTest . class ) ; String expected = String . format ( " No public static parameters method on class % s " , ProtectedParametersTest . class . getName ( ) ) ; assertEquals ( expected , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ParametersNotIterable { @ Parameters public static String data ( ) { return " foo " ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersNotPublic ( ) throws Exception { Result result = JUnitCore . runClasses ( ProtectedParametersTest . class ) ; String expected = String . format ( " No public static parameters method on class % s " , ProtectedParametersTest . class . getName ( ) ) ; assertEquals ( expected , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ParametersNotIterable { @ Parameters public static String data ( ) { return " foo " ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } }
public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } }
public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ;
public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; }
public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } }
public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; }
public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } }
public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; }
public static void main ( String . . . args ) { Result result = new JUnitCore ( ) . runMain ( new RealSystem ( ) , args ) ; System . exit ( result . wasSuccessful ( ) ? 0 : 1 ) ; }
public boolean shouldRun ( Description description ) { return false ; }
public String describe ( ) { return " filter all " ; }
public void filter_noTestsRemain ( ) throws NoTestsRemainException { JUnit38ClassRunner runner = new JUnit38ClassRunner ( OneTest . class ) ; runner . filter ( new RejectAllFilter ( ) ) ; }
public void annotatedFieldValues ( ) { TestClass tc = new TestClass ( FieldAnnotated . class ) ; List < String > values = tc . getAnnotatedFieldValues ( new FieldAnnotated ( ) , Rule . class , String . class ) ; assertThat ( values , hasItem ( " andromeda " ) ) ; assertThat ( values . size ( ) , is ( 1 ) ) ; }
public String methodToBeMatched ( ) { return " jupiter " ; }
public int methodOfWrongType ( ) { return 0 ; }
public void annotatedMethodValues ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; List < String > values = tc . getAnnotatedMethodValues ( new MethodsAnnotated ( ) , Ignore . class , String . class ) ; assertThat ( values , hasItem ( " jupiter " ) ) ; assertThat ( values . size ( ) , is ( 1 ) ) ; }
public static Exception rethrowAsException ( Throwable e ) throws Exception { Throwables . < Exception > rethrow ( e ) ; return null ; }
private static < T extends Throwable > void rethrow ( Throwable e ) throws T { throw ( T ) e ; }
public static void assertEmpty ( List < Throwable > errors ) throws Exception { if ( errors . isEmpty ( ) ) { return ; } if ( errors . size ( ) = = 1 ) { throw Throwables . rethrowAsException ( errors . get ( 0 ) ) ; } throw new org . junit . internal . runners . model . MultipleFailureException ( errors ) ; }
public void assertEmptyDoesNotThrowForEmptyList ( ) throws Exception { MultipleFailureException . assertEmpty ( Collections . < Throwable > emptyList ( ) ) ; }
public void assertEmptyRethrowsSingleRuntimeException ( ) throws Exception { Throwable exception = new ExpectedException ( " pesto " ) ; List < Throwable > errors = Collections . singletonList ( exception ) ; try { MultipleFailureException . assertEmpty ( errors ) ;
public void assertEmptyRethrowsSingleError ( ) throws Exception { Throwable exception = new AnnotationFormatError ( " changeo " ) ; List < Throwable > errors = Collections . singletonList ( exception ) ; try { MultipleFailureException . assertEmpty ( errors ) ;
public void assertEmptyThrowsMutipleFailureExceptionForManyThrowables ( ) throws Exception { List < Throwable > errors = new ArrayList < Throwable > ( ) ; errors . add ( new ExpectedException ( " basil " ) ) ; errors . add ( new RuntimeException ( " garlic " ) ) ; try { MultipleFailureException . assertEmpty ( errors ) ;
public String describe ( ) { return " filter all " ; }
public void filterNoTestsRemain ( ) throws NoTestsRemainException { JUnit38ClassRunner runner = new JUnit38ClassRunner ( OneTest . class ) ; runner . filter ( new RejectAllFilter ( ) ) ; }
public boolean shouldRun ( Description description ) { if ( description . isTest ( ) ) { return false ; } return true ; }
public void evaluate ( ) throws Throwable { FutureTask < Throwable > task = new FutureTask < Throwable > ( new CallableStatement ( ) ) ; fThreadGroup = new ThreadGroup ( " FailOnTimeoutGroup " ) ; Thread thread = new Thread ( fThreadGroup , task , " Time - limited test " ) ; thread . setDaemon ( true ) ; thread . start ( ) ; Throwable throwable = getResult ( task , thread ) ; if ( throwable ! = null ) { throw throwable ;
private Exception createTimeoutException ( Thread thread ) { StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; final Thread stuckThread = getStuckThread ( thread ) ; String message = String . format ( " test timed out after % d % s " , fTimeout , fTimeUnit . name ( ) . toLowerCase ( ) ) ; Exception exception = ( stuckThread = = null ) ? new Exception ( message ) : new ExceptionWithThread ( message , stuckThread , " Appears to be stuck in thread { 0 } " ) ; if ( stackTrace ! = null ) { exception . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } return exception ; }
private Exception createTimeoutException ( Thread thread ) { StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; final Thread stuckThread = getStuckThread ( thread ) ; Exception exception = new Exception ( String . format ( " test timed out after % d % s " , fTimeout , fTimeUnit . name ( ) . toLowerCase ( ) ) ) ; if ( stuckThread ! = null ) { Exception stuckThreadException = new Exception ( " Appears to be stuck in thread " + stuckThread . getName ( ) ) ; StackTraceElement [ ] threadStack ; try { threadStack = stuckThread . getStackTrace ( ) ; } catch ( SecurityException e ) { threadStack = new StackTraceElement [ 0 ] ; } stuckThreadException . setStackTrace ( threadStack ) ; exception = new MultipleFailureException ( Arrays . < Throwable > asList ( exception , stuckThreadException ) ) ; } if ( stackTrace ! = null ) { exception . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } return exception ; }
private long cpuTime ( Thread thr ) { ThreadMXBean mxBean = ManagementFactory . getThreadMXBean ( ) ; if ( mxBean . isThreadCpuTimeSupported ( ) ) { try { return mxBean . getThreadCpuTime ( thr . getId ( ) ) ; } catch ( UnsupportedOperationException e ) { } } return 0 ; }
public void evaluate ( ) throws Throwable { FutureTask < Throwable > task = new FutureTask < Throwable > ( new CallableStatement ( ) ) ; fThreadGroup = new ThreadGroup ( " FailOnTimeoutGroup " ) ; Thread thread = new Thread ( fThreadGroup , task , " Time - limited test " ) ; thread . setDaemon ( true ) ; thread . start ( ) ; Throwable throwable = getResult ( task , thread ) ; if ( throwable ! = null ) { throw throwable ;
private Exception createTimeoutException ( Thread thread ) { Exception resultException ; StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; final Thread stuckThread = getStuckThread ( thread ) ; Exception currThreadException = new Exception ( String . format ( " test timed out after % d % s " , fTimeout , fTimeUnit . name ( ) . toLowerCase ( ) ) ) ; if ( stuckThread ! = null ) { Exception stuckThreadException = new Exception ( " Appears to be stuck in thread " + stuckThread . getName ( ) ) ; stuckThreadException . setStackTrace ( getStackTrace ( stuckThread ) ) ; resultException = new MultipleFailureException ( Arrays . < Throwable > asList ( currThreadException , stuckThreadException ) ) ; } else { resultException = currThreadException ; } if ( stackTrace ! = null ) { currThreadException . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } return resultException ; }
private long cpuTime ( Thread thr ) { ThreadMXBean mxBean = ManagementFactory . getThreadMXBean ( ) ; if ( mxBean . isThreadCpuTimeSupported ( ) ) { try { return mxBean . getThreadCpuTime ( thr . getId ( ) ) ; } catch ( UnsupportedOperationException e ) { } } return 0 ; }
public void success ( ) { } } @ Test public void successWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( SuccessWithTimeoutTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } static public class TimeoutFailureTest { @ Test ( timeout = 100 ) public void success ( ) throws InterruptedException { Thread . sleep ( 40000 ) ; } } @ Ignore ( " was breaking gump " ) @ Test public void timeoutFailure ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeoutFailureTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertEquals ( InterruptedException . class , result . getFailures ( ) . get ( 0 ) . getException ( ) . getClass ( ) ) ; } static public class InfiniteLoopTest { @ Test ( timeout = 100 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { } } } } @ Test public void infiniteLoop ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertTrue ( exception . getMessage ( ) . contains ( " test timed out after 100 milliseconds " ) ) ; } static public class ImpatientLoopTest { @ Test ( timeout = 1 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) ; } } @ Ignore ( " This breaks sporadically with time differences just slightly more than 200ms " ) @ Test public void infiniteLoopRunsForApproximatelyLengthOfTimeout ( ) throws Exception { JUnitCore . runClasses ( InfiniteLoopTest . class , ImpatientLoopTest . class ) ; long longTime = runAndTime ( InfiniteLoopTest . class ) ; long shortTime = runAndTime ( ImpatientLoopTest . class ) ; long difference = longTime - shortTime ; assertTrue ( String . format ( " Difference was % sms " , difference ) , difference < 200 ) ; } private long runAndTime ( Class < ? > clazz ) { JUnitCore core = new JUnitCore ( ) ; long startTime = System . currentTimeMillis ( ) ; core . run ( clazz ) ; long totalTime = System . currentTimeMillis ( ) - startTime ; return totalTime ; } private String stackForException ( Throwable exception ) { Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; return buffer . toString ( ) ; } @ Test public void stalledThreadAppearsInStackTrace ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( stackForException ( exception ) , containsString ( " infiniteLoop " ) ) ; } static public class InfiniteLoopMultithreaded { static private class threadTest implements Runnable { private boolean fStall ; public threadTest ( boolean stall ) { fStall = stall ; } public void run ( ) { if ( fStall ) for ( ; ; ) ; try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { } } } public void failure ( boolean mainThreadStalls ) throws Exception { Thread t1 = new Thread ( new threadTest ( false ) , " timeout - thr1 " ) ; Thread t2 = new Thread ( new threadTest ( ! mainThreadStalls ) , " timeout - thr2 " ) ; Thread t3 = new Thread ( new threadTest ( false ) , " timeout - thr3 " ) ; t1 . start ( ) ; t2 . start ( ) ; t3 . start ( ) ; if ( mainThreadStalls ) for ( ; ; ) ; t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; } } static public class InfiniteLoopWithStuckThreadTest { @ Test ( timeout = 100 ) public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( false ) ; } } static public class InfiniteLoopStuckInMainThreadTest { @ Test ( timeout = 100 ) public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( true ) ; } } @ Test public void timeoutFailureMultithreaded ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopWithStuckThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; Throwable exception [ ] = new Throwable [ 2 ] ; for ( int i = 0 ; i < 2 ; i + + ) exception [ i ] = result . getFailures ( ) . get ( i ) . getException ( ) ; assertThat ( exception [ 0 ] . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( stackForException ( exception [ 0 ] ) , containsString ( " Thread . join " ) ) ; assertThat ( exception [ 1 ] . getMessage ( ) , containsString ( " Appears to be stuck in thread timeout - thr2 " ) ) ; } @ Test public void timeoutFailureMultithreadedStuckInMain ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopStuckInMainThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( exception . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( exception . getMessage ( ) , not ( containsString ( " Appears to be stuck " ) ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( InfiniteLoopTest . class ) . run ( result ) ; assertEquals ( 1 , result . errorCount ( ) ) ; } public static class WillTimeOut { static boolean afterWasCalled = false ; @ Test ( timeout = 1 ) public void test ( ) { for ( ; ; ) { try { Thread . sleep ( 10000 ) ; } catch ( InterruptedException e ) { } } } @ After public void after ( ) { afterWasCalled = true ; } } @ Test public void makeSureAfterIsCalledAfterATimeout ( ) { JUnitCore . runClasses ( WillTimeOut . class ) ; assertThat ( WillTimeOut . afterWasCalled , is ( true ) ) ; } }
private String stackForException ( Throwable exception ) { Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; return buffer . toString ( ) ; }
public void stalledThreadAppearsInStackTrace ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( stackForException ( exception ) , containsString ( " infiniteLoop " ) ) ; }
public void run ( ) { if ( fStall ) for ( ; ; ) ; try { Thread . sleep ( 50 ) ;
public void failure ( boolean mainThreadStalls ) throws Exception { Thread t1 = new Thread ( new threadTest ( false ) , " timeout - thr1 " ) ; Thread t2 = new Thread ( new threadTest ( ! mainThreadStalls ) , " timeout - thr2 " ) ; Thread t3 = new Thread ( new threadTest ( false ) , " timeout - thr3 " ) ; t1 . start ( ) ; t2 . start ( ) ; t3 . start ( ) ; if ( mainThreadStalls ) for ( ; ; ) ; t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; }
public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( false ) ; }
public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( true ) ; }
public void timeoutFailureMultithreaded ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopWithStuckThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; Throwable exception [ ] = new Throwable [ 2 ] ; for ( int i = 0 ; i < 2 ; i + + ) exception [ i ] = result . getFailures ( ) . get ( i ) . getException ( ) ; assertThat ( exception [ 0 ] . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( stackForException ( exception [ 0 ] ) , containsString ( " Thread . join " ) ) ; assertThat ( exception [ 1 ] . getMessage ( ) , containsString ( " Appears to be stuck in thread timeout - thr2 " ) ) ; }
public void timeoutFailureMultithreadedStuckInMain ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopStuckInMainThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( exception . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( exception . getMessage ( ) , not ( containsString ( " Appears to be stuck " ) ) ) ; }
public void success ( ) { } } @ Test public void successWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( SuccessWithTimeoutTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } static public class TimeoutFailureTest { @ Test ( timeout = 100 ) public void success ( ) throws InterruptedException { Thread . sleep ( 40000 ) ; } } @ Ignore ( " was breaking gump " ) @ Test public void timeoutFailure ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeoutFailureTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertEquals ( InterruptedException . class , result . getFailures ( ) . get ( 0 ) . getException ( ) . getClass ( ) ) ; } static public class InfiniteLoopTest { @ Test ( timeout = 100 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { } } } } @ Test public void infiniteLoop ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertTrue ( exception . getMessage ( ) . contains ( " test timed out after 100 milliseconds " ) ) ; } static public class ImpatientLoopTest { @ Test ( timeout = 1 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) ; } } @ Ignore ( " This breaks sporadically with time differences just slightly more than 200ms " ) @ Test public void infiniteLoopRunsForApproximatelyLengthOfTimeout ( ) throws Exception { JUnitCore . runClasses ( InfiniteLoopTest . class , ImpatientLoopTest . class ) ; long longTime = runAndTime ( InfiniteLoopTest . class ) ; long shortTime = runAndTime ( ImpatientLoopTest . class ) ; long difference = longTime - shortTime ; assertTrue ( String . format ( " Difference was % sms " , difference ) , difference < 200 ) ; } private long runAndTime ( Class < ? > clazz ) { JUnitCore core = new JUnitCore ( ) ; long startTime = System . currentTimeMillis ( ) ; core . run ( clazz ) ; long totalTime = System . currentTimeMillis ( ) - startTime ; return totalTime ; } private String stackForException ( Throwable exception ) { Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; return buffer . toString ( ) ; } @ Test public void stalledThreadAppearsInStackTrace ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( stackForException ( exception ) , containsString ( " infiniteLoop " ) ) ; } static public class InfiniteLoopMultithreaded { static private class threadTest implements Runnable { private boolean fStall ; public threadTest ( boolean stall ) { fStall = stall ; } public void run ( ) { if ( fStall ) for ( ; ; ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } } public void failure ( boolean mainThreadStalls ) throws Exception { Thread t1 = new Thread ( new threadTest ( false ) , " timeout - thr1 " ) ; Thread t2 = new Thread ( new threadTest ( ! mainThreadStalls ) , " timeout - thr2 " ) ; Thread t3 = new Thread ( new threadTest ( false ) , " timeout - thr3 " ) ; t1 . start ( ) ; t2 . start ( ) ; t3 . start ( ) ; if ( mainThreadStalls ) for ( ; ; ) ; t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; } } static public class InfiniteLoopWithStuckThreadTest { @ Test ( timeout = 100 ) public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( false ) ; } } static public class InfiniteLoopStuckInMainThreadTest { @ Test ( timeout = 100 ) public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( true ) ; } } @ Test public void timeoutFailureMultithreaded ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopWithStuckThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; Throwable exception [ ] = new Throwable [ 2 ] ; for ( int i = 0 ; i < 2 ; i + + ) exception [ i ] = result . getFailures ( ) . get ( i ) . getException ( ) ; assertThat ( exception [ 0 ] . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( stackForException ( exception [ 0 ] ) , containsString ( " Thread . join " ) ) ; assertThat ( exception [ 1 ] . getMessage ( ) , containsString ( " Appears to be stuck in thread timeout - thr2 " ) ) ; } @ Test public void timeoutFailureMultithreadedStuckInMain ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopStuckInMainThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( exception . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( exception . getMessage ( ) , not ( containsString ( " Appears to be stuck " ) ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( InfiniteLoopTest . class ) . run ( result ) ; assertEquals ( 1 , result . errorCount ( ) ) ; } public static class WillTimeOut { static boolean afterWasCalled = false ; @ Test ( timeout = 1 ) public void test ( ) { for ( ; ; ) { try { Thread . sleep ( 10000 ) ; } catch ( InterruptedException e ) { } } } @ After public void after ( ) { afterWasCalled = true ; } } @ Test public void makeSureAfterIsCalledAfterATimeout ( ) { JUnitCore . runClasses ( WillTimeOut . class ) ; assertThat ( WillTimeOut . afterWasCalled , is ( true ) ) ; } }
public void run ( ) { if ( fStall ) for ( ; ; ) ; try { Thread . sleep ( 500 ) ;
private Exception createTimeoutException ( Thread thread ) { StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; final Thread stuckThread = getStuckThread ( thread ) ; Exception currThreadException = new Exception ( String . format ( " test timed out after % d % s " , fTimeout , fTimeUnit . name ( ) . toLowerCase ( ) ) ) ; if ( stackTrace ! = null ) { currThreadException . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } if ( stuckThread ! = null ) { Exception stuckThreadException =
public void success ( ) { } } @ Test public void successWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( SuccessWithTimeoutTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } public static class TimeoutFailureTest { @ Test ( timeout = 100 ) public void success ( ) throws InterruptedException { Thread . sleep ( 40000 ) ; } } @ Ignore ( " was breaking gump " ) @ Test public void timeoutFailure ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeoutFailureTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertEquals ( InterruptedException . class , result . getFailures ( ) . get ( 0 ) . getException ( ) . getClass ( ) ) ; } public static class InfiniteLoopTest { @ Test ( timeout = 100 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { } } } } @ Test public void infiniteLoop ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertTrue ( exception . getMessage ( ) . contains ( " test timed out after 100 milliseconds " ) ) ; } public static class ImpatientLoopTest { @ Test ( timeout = 1 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) ; } } @ Ignore ( " This breaks sporadically with time differences just slightly more than 200ms " ) @ Test public void infiniteLoopRunsForApproximatelyLengthOfTimeout ( ) throws Exception { JUnitCore . runClasses ( InfiniteLoopTest . class , ImpatientLoopTest . class ) ; long longTime = runAndTime ( InfiniteLoopTest . class ) ; long shortTime = runAndTime ( ImpatientLoopTest . class ) ; long difference = longTime - shortTime ; assertTrue ( String . format ( " Difference was % sms " , difference ) , difference < 200 ) ; } private long runAndTime ( Class < ? > clazz ) { JUnitCore core = new JUnitCore ( ) ; long startTime = System . currentTimeMillis ( ) ; core . run ( clazz ) ; long totalTime = System . currentTimeMillis ( ) - startTime ; return totalTime ; } private String stackForException ( Throwable exception ) { Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; return buffer . toString ( ) ; } @ Test public void stalledThreadAppearsInStackTrace ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( stackForException ( exception ) , containsString ( " infiniteLoop " ) ) ; } public static class InfiniteLoopMultithreaded { private static class ThreadTest implements Runnable { private boolean fStall ; public ThreadTest ( boolean stall ) { fStall = stall ; } public void run ( ) { if ( fStall ) for ( ; ; ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } } public void failure ( boolean mainThreadStalls ) throws Exception { Thread t1 = new Thread ( new ThreadTest ( false ) , " timeout - thr1 " ) ; Thread t2 = new Thread ( new ThreadTest ( ! mainThreadStalls ) , " timeout - thr2 " ) ; Thread t3 = new Thread ( new ThreadTest ( false ) , " timeout - thr3 " ) ; t1 . start ( ) ; t2 . start ( ) ; t3 . start ( ) ; if ( mainThreadStalls ) for ( ; ; ) ; t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; } } public static class InfiniteLoopWithStuckThreadTest { @ Test ( timeout = 100 ) public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( false ) ; } } public static class InfiniteLoopStuckInMainThreadTest { @ Test ( timeout = 100 ) public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( true ) ; } } @ Test public void timeoutFailureMultithreaded ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopWithStuckThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; Throwable exception [ ] = new Throwable [ 2 ] ; for ( int i = 0 ; i < 2 ; i + + ) exception [ i ] = result . getFailures ( ) . get ( i ) . getException ( ) ; assertThat ( exception [ 0 ] . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( stackForException ( exception [ 0 ] ) , containsString ( " Thread . join " ) ) ; assertThat ( exception [ 1 ] . getMessage ( ) , containsString ( " Appears to be stuck in thread timeout - thr2 " ) ) ; } @ Test public void timeoutFailureMultithreadedStuckInMain ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopStuckInMainThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( exception . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( exception . getMessage ( ) , not ( containsString ( " Appears to be stuck " ) ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( InfiniteLoopTest . class ) . run ( result ) ; assertEquals ( 1 , result . errorCount ( ) ) ; } public static class WillTimeOut { static boolean afterWasCalled = false ; @ Test ( timeout = 1 ) public void test ( ) { for ( ; ; ) { try { Thread . sleep ( 10000 ) ; } catch ( InterruptedException e ) { } } } @ After public void after ( ) { afterWasCalled = true ; } } @ Test public void makeSureAfterIsCalledAfterATimeout ( ) { JUnitCore . runClasses ( WillTimeOut . class ) ; assertThat ( WillTimeOut . afterWasCalled , is ( true ) ) ; } }
private String stackForException ( Throwable exception ) { Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; return buffer . toString ( ) ; }
public void run ( ) { if ( fStall ) for ( ; ; ) ; try { Thread . sleep ( 500 ) ;
public void failure ( boolean mainThreadStalls ) throws Exception { Thread t1 = new Thread ( new ThreadTest ( false ) , " timeout - thr1 " ) ; Thread t2 = new Thread ( new ThreadTest ( ! mainThreadStalls ) , " timeout - thr2 " ) ; Thread t3 = new Thread ( new ThreadTest ( false ) , " timeout - thr3 " ) ; t1 . start ( ) ; t2 . start ( ) ; t3 . start ( ) ; if ( mainThreadStalls ) for ( ; ; ) ; t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; }
void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) ; void validateAnnotatedField ( Field field , List < Throwable > errors ) ; void validateAnnotatedMethod ( Method method , List < Throwable > errors ) ; }
void validateAnnotatedField ( Field field , List < Throwable > errors ) ; void validateAnnotatedMethod ( Method method , List < Throwable > errors ) ; }
void validateAnnotatedMethod ( Method method , List < Throwable > errors ) ; }
public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { final Set < Class < ? > > incompatibleAnnotations = buildIncompatibleAnnotationsSet ( ) ; Annotation [ ] declaredAnnotations = method . getDeclaredAnnotations ( ) ; for ( Annotation annotation : declaredAnnotations ) { for ( Class clazz : incompatibleAnnotations ) { if ( annotation . annotationType ( ) . isAssignableFrom ( clazz ) ) { addErrorMessage ( errors , clazz ) ; } } } } private Set < Class < ? > > buildIncompatibleAnnotationsSet ( ) { final Set < Class < ? > > incompatibleAnnotations = new HashSet < Class < ? > > ( ) ; incompatibleAnnotations . add ( BeforeClass . class ) ; incompatibleAnnotations . add ( AfterClass . class ) ; incompatibleAnnotations . add ( Before . class ) ; incompatibleAnnotations . add ( After . class ) ; return incompatibleAnnotations ; } private void addErrorMessage ( List < Throwable > errors , Class clazz ) { String message = String . format ( " @ % s can not be combined with @ Category " , clazz . getSimpleName ( ) ) ; errors . add ( new Throwable ( message ) ) ; } }
public void validateAnnotatedField ( Field field , List < Throwable > errors ) { } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { final Set < Class < ? > > incompatibleAnnotations = buildIncompatibleAnnotationsSet ( ) ; Annotation [ ] declaredAnnotations = method . getDeclaredAnnotations ( ) ; for ( Annotation annotation : declaredAnnotations ) { for ( Class clazz : incompatibleAnnotations ) { if ( annotation . annotationType ( ) . isAssignableFrom ( clazz ) ) { addErrorMessage ( errors , clazz ) ; } } } } private Set < Class < ? > > buildIncompatibleAnnotationsSet ( ) { final Set < Class < ? > > incompatibleAnnotations = new HashSet < Class < ? > > ( ) ; incompatibleAnnotations . add ( BeforeClass . class ) ; incompatibleAnnotations . add ( AfterClass . class ) ; incompatibleAnnotations . add ( Before . class ) ; incompatibleAnnotations . add ( After . class ) ; return incompatibleAnnotations ; } private void addErrorMessage ( List < Throwable > errors , Class clazz ) { String message = String . format ( " @ % s can not be combined with @ Category " , clazz . getSimpleName ( ) ) ; errors . add ( new Throwable ( message ) ) ; } }
public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { final Set < Class < ? > > incompatibleAnnotations = buildIncompatibleAnnotationsSet ( ) ; Annotation [ ] declaredAnnotations = method . getDeclaredAnnotations ( ) ; for ( Annotation annotation : declaredAnnotations ) { for ( Class clazz : incompatibleAnnotations ) {
private Set < Class < ? > > buildIncompatibleAnnotationsSet ( ) { final Set < Class < ? > > incompatibleAnnotations = new HashSet < Class < ? > > ( ) ; incompatibleAnnotations . add ( BeforeClass . class ) ; incompatibleAnnotations . add ( AfterClass . class ) ; incompatibleAnnotations . add ( Before . class ) ; incompatibleAnnotations . add ( After . class ) ; return incompatibleAnnotations ; }
private void addErrorMessage ( List < Throwable > errors , Class clazz ) { String message = String . format ( " @ % s can not be combined with @ Category " , clazz . getSimpleName ( ) ) ; errors . add ( new Throwable ( message ) ) ; }
protected void collectInitializationErrors ( List < Throwable > errors ) { validatePublicVoidNoArgMethods ( BeforeClass . class , true , errors ) ; validatePublicVoidNoArgMethods ( AfterClass . class , true , errors ) ; validateClassRules ( errors ) ; invokeValidators ( errors ) ; }
private void invokeValidators ( List < Throwable > errors ) { invokeValidatorsOnClass ( errors ) ; invokeValidatorsOnMethods ( errors ) ; invokeValidatorsOnFields ( errors ) ; }
private void invokeValidatorsOnClass ( List < Throwable > errors ) { Annotation [ ] annotations = getTestClass ( ) . getAnnotations ( ) ; for ( Annotation annotation : annotations ) { if ( hasValidatorAnnotation ( annotation ) ) {
private void invokeValidatorsOnClass ( Annotation annotation , List < Throwable > errors ) { List < AnnotationValidator > annotationValidators = createAnnotationValidators ( annotation ) ; for ( AnnotationValidator annotationValidator : annotationValidators ) { annotationValidator . validateAnnotatedClass ( getTestClass ( ) . getJavaClass ( ) , errors ) ;
private void invokeValidatorsOnMethod ( Annotation annotation , FrameworkMethod frameworkMethod , List < Throwable > errors ) { List < AnnotationValidator > annotationValidators = createAnnotationValidators ( annotation ) ; for ( AnnotationValidator annotationValidator : annotationValidators ) { annotationValidator . validateAnnotatedMethod ( frameworkMethod . getMethod ( ) , errors ) ;
private void invokeValidatorsOnField ( Annotation annotation , FrameworkField frameworkField , List < Throwable > errors ) { List < AnnotationValidator > annotationValidators = createAnnotationValidators ( annotation ) ; for ( AnnotationValidator annotationValidator : annotationValidators ) { annotationValidator . validateAnnotatedField ( frameworkField . getField ( ) , errors ) ;
private List < AnnotationValidator > createAnnotationValidators ( Annotation annotation ) { List < AnnotationValidator > validators = new ArrayList < AnnotationValidator > ( ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; Validator validatorAnnotation = annotationType . getAnnotation ( Validator . class ) ; Class < ? > [ ] classes = validatorAnnotation . value ( ) ; for ( Class clazz : classes ) { try { AnnotationValidator annotationValidator = ( AnnotationValidator ) clazz . newInstance ( ) ; validators . add ( annotationValidator ) ; } catch ( Exception e ) { throw new RuntimeException ( " Could not create AnnotationValidator class " + clazz . getName ( ) , e ) ; } } return validators ; }
public void annotatedFieldsAreReturned ( ) { Set < FrameworkField > annotatedFields = new TestClass ( ClassWithAnnotatedFields . class ) . getAnnotatedFields ( ) ; assertThat ( annotatedFields . size ( ) , is ( 3 ) ) ; Set < String > fieldNames = new HashSet < String > ( ) ; for ( FrameworkField field : annotatedFields ) { fieldNames . add ( field . getName ( ) ) ; } assertThat ( fieldNames , hasItems ( " field1 " , " field2 " , " folder " ) ) ; }
public void before ( ) { } @ Test public void test1 ( ) { } @ Test public void test2 ( ) { } @ After public void after ( ) { } public void unannotated ( ) { } } @ Test public void annotatedMethodsAreReturned ( ) { Set < FrameworkMethod > annotatedMethods = new TestClass ( ClassWithAnnotatedMethods . class ) . getAnnotatedMethods ( ) ; assertThat ( annotatedMethods . size ( ) , is ( 4 ) ) ; Set < String > methodNames = new HashSet < String > ( ) ; for ( FrameworkMethod method : annotatedMethods ) { methodNames . add ( method . getName ( ) ) ; } assertThat ( methodNames , hasItems ( " before " , " after " , " test1 " , " test2 " ) ) ; } }
public void test1 ( ) { } @ Test public void test2 ( ) { } @ After public void after ( ) { } public void unannotated ( ) { } } @ Test public void annotatedMethodsAreReturned ( ) { Set < FrameworkMethod > annotatedMethods = new TestClass ( ClassWithAnnotatedMethods . class ) . getAnnotatedMethods ( ) ; assertThat ( annotatedMethods . size ( ) , is ( 4 ) ) ; Set < String > methodNames = new HashSet < String > ( ) ; for ( FrameworkMethod method : annotatedMethods ) { methodNames . add ( method . getName ( ) ) ; } assertThat ( methodNames , hasItems ( " before " , " after " , " test1 " , " test2 " ) ) ; } }
public void test2 ( ) { } @ After public void after ( ) { } public void unannotated ( ) { } } @ Test public void annotatedMethodsAreReturned ( ) { Set < FrameworkMethod > annotatedMethods = new TestClass ( ClassWithAnnotatedMethods . class ) . getAnnotatedMethods ( ) ; assertThat ( annotatedMethods . size ( ) , is ( 4 ) ) ; Set < String > methodNames = new HashSet < String > ( ) ; for ( FrameworkMethod method : annotatedMethods ) { methodNames . add ( method . getName ( ) ) ; } assertThat ( methodNames , hasItems ( " before " , " after " , " test1 " , " test2 " ) ) ; } }
public void after ( ) { } public void unannotated ( ) { } } @ Test public void annotatedMethodsAreReturned ( ) { Set < FrameworkMethod > annotatedMethods = new TestClass ( ClassWithAnnotatedMethods . class ) . getAnnotatedMethods ( ) ; assertThat ( annotatedMethods . size ( ) , is ( 4 ) ) ; Set < String > methodNames = new HashSet < String > ( ) ; for ( FrameworkMethod method : annotatedMethods ) { methodNames . add ( method . getName ( ) ) ; } assertThat ( methodNames , hasItems ( " before " , " after " , " test1 " , " test2 " ) ) ; } }
public void unannotated ( ) { } } @ Test public void annotatedMethodsAreReturned ( ) { Set < FrameworkMethod > annotatedMethods = new TestClass ( ClassWithAnnotatedMethods . class ) . getAnnotatedMethods ( ) ; assertThat ( annotatedMethods . size ( ) , is ( 4 ) ) ; Set < String > methodNames = new HashSet < String > ( ) ; for ( FrameworkMethod method : annotatedMethods ) { methodNames . add ( method . getName ( ) ) ; } assertThat ( methodNames , hasItems ( " before " , " after " , " test1 " , " test2 " ) ) ; } }
public void annotatedMethodsAreReturned ( ) { Set < FrameworkMethod > annotatedMethods = new TestClass ( ClassWithAnnotatedMethods . class ) . getAnnotatedMethods ( ) ; assertThat ( annotatedMethods . size ( ) , is ( 4 ) ) ; Set < String > methodNames = new HashSet < String > ( ) ; for ( FrameworkMethod method : annotatedMethods ) { methodNames . add ( method . getName ( ) ) ; } assertThat ( methodNames , hasItems ( " before " , " after " , " test1 " , " test2 " ) ) ; }
public static void methodWithCategoryAndBeforeClass ( ) { } @ AfterClass @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfterClass ( ) { } @ Before @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( method , errors ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass , errors ) ; assertThat ( errors . isEmpty ( ) , is ( true ) ) ; } }
public static void methodWithCategoryAndAfterClass ( ) { } @ Before @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( method , errors ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass , errors ) ; assertThat ( errors . isEmpty ( ) , is ( true ) ) ; } }
public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( method , errors ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass , errors ) ; assertThat ( errors . isEmpty ( ) , is ( true ) ) ; } }
public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( method , errors ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass , errors ) ; assertThat ( errors . isEmpty ( ) , is ( true ) ) ; } }
public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( method , errors ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass , errors ) ; assertThat ( errors . isEmpty ( ) , is ( true ) ) ; } }
public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; }
public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; }
public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; }
public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; }
private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( method , errors ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; }
public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { List < Throwable > errors = new ArrayList < Throwable > ( ) ; Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass , errors ) ; assertThat ( errors . isEmpty ( ) , is ( true ) ) ; }
public void test1 ( ) throws Exception { } @ Test public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator implements AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ Validator ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } public static class SampleCategory { } public static class SampleTest { @ Category ( SampleCategory . class ) @ Before public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator implements AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ Validator ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } public static class SampleCategory { } public static class SampleTest { @ Category ( SampleCategory . class ) @ Before public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator implements AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ Validator ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } public static class SampleCategory { } public static class SampleTest { @ Category ( SampleCategory . class ) @ Before public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ;
public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ;
private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ;
public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; }
public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; }
public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; }
public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } public static class SampleCategory { } public static class SampleTest { @ Category ( SampleCategory . class ) @ Before public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } public static class SampleCategory { } public static class SampleTest { @ Category ( SampleCategory . class ) @ Before public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } public static class SampleCategory { } public static class SampleTest { @ Category ( SampleCategory . class ) @ Before public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ;
public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ;
public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ;
public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ;
public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { final Set < Class < ? > > incompatibleAnnotations = buildIncompatibleAnnotationsSet ( ) ; Annotation [ ] declaredAnnotations = method . getDeclaredAnnotations ( ) ; for ( Annotation annotation : declaredAnnotations ) { for ( Class clazz : incompatibleAnnotations ) { if ( annotation . annotationType ( ) . isAssignableFrom ( clazz ) ) { addErrorMessage ( errors , clazz ) ; } } } } private Set < Class < ? > > buildIncompatibleAnnotationsSet ( ) { if ( fIncompatibleAnnotations = = null ) { fIncompatibleAnnotations = new HashSet < Class < ? > > ( ) ; fIncompatibleAnnotations . add ( BeforeClass . class ) ; fIncompatibleAnnotations . add ( AfterClass . class ) ; fIncompatibleAnnotations . add ( Before . class ) ; fIncompatibleAnnotations . add ( After . class ) ; } return fIncompatibleAnnotations ; } private void addErrorMessage ( List < Throwable > errors , Class clazz ) { String message = String . format ( " @ % s can not be combined with @ Category " , clazz . getSimpleName ( ) ) ; errors . add ( new Throwable ( message ) ) ; } }
public void validateAnnotatedField ( Field field , List < Throwable > errors ) { } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { final Set < Class < ? > > incompatibleAnnotations = buildIncompatibleAnnotationsSet ( ) ; Annotation [ ] declaredAnnotations = method . getDeclaredAnnotations ( ) ; for ( Annotation annotation : declaredAnnotations ) { for ( Class clazz : incompatibleAnnotations ) { if ( annotation . annotationType ( ) . isAssignableFrom ( clazz ) ) { addErrorMessage ( errors , clazz ) ; } } } } private Set < Class < ? > > buildIncompatibleAnnotationsSet ( ) { if ( fIncompatibleAnnotations = = null ) { fIncompatibleAnnotations = new HashSet < Class < ? > > ( ) ; fIncompatibleAnnotations . add ( BeforeClass . class ) ; fIncompatibleAnnotations . add ( AfterClass . class ) ; fIncompatibleAnnotations . add ( Before . class ) ; fIncompatibleAnnotations . add ( After . class ) ; } return fIncompatibleAnnotations ; } private void addErrorMessage ( List < Throwable > errors , Class clazz ) { String message = String . format ( " @ % s can not be combined with @ Category " , clazz . getSimpleName ( ) ) ; errors . add ( new Throwable ( message ) ) ; } }
public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { final Set < Class < ? > > incompatibleAnnotations = buildIncompatibleAnnotationsSet ( ) ; Annotation [ ] declaredAnnotations = method . getDeclaredAnnotations ( ) ; for ( Annotation annotation : declaredAnnotations ) { for ( Class clazz : incompatibleAnnotations ) {
private Set < Class < ? > > buildIncompatibleAnnotationsSet ( ) { if ( fIncompatibleAnnotations = = null ) { fIncompatibleAnnotations = new HashSet < Class < ? > > ( ) ; fIncompatibleAnnotations . add ( BeforeClass . class ) ; fIncompatibleAnnotations . add ( AfterClass . class ) ; fIncompatibleAnnotations . add ( Before . class ) ; fIncompatibleAnnotations . add ( After . class ) ; } return fIncompatibleAnnotations ; }
private void invokeValidatorsOnMethods ( List < Throwable > errors ) { Map < Class < ? extends Annotation > , List < FrameworkMethod > > annotationMap = getTestClass ( ) . getAnnotationToMethods ( ) ; for ( Class < ? extends Annotation > annotation : annotationMap . keySet ( ) ) { if ( hasValidatorAnnotation ( annotation ) ) {
private void invokeValidatorsOnFields ( List < Throwable > errors ) { Map < Class < ? extends Annotation > , List < FrameworkField > > annotationMap = getTestClass ( ) . getAnnotationToFields ( ) ; for ( Class < ? extends Annotation > annotation : annotationMap . keySet ( ) ) { if ( hasValidatorAnnotation ( annotation ) ) {
private boolean hasValidatorAnnotation ( Annotation annotation ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; boolean hasValidatorAnnotation ; if ( fAnnotationTypeToValidatorMap . containsKey ( annotationType ) ) { hasValidatorAnnotation = fAnnotationTypeToValidatorMap . get ( annotationType ) ! = null ; } else { hasValidatorAnnotation = hasValidatorAnnotation ( annotationType ) ; if ( ! hasValidatorAnnotation ) { fAnnotationTypeToValidatorMap . put ( annotationType , null ) ; } } return hasValidatorAnnotation ; }
private AnnotationValidator createAnnotationValidator ( Class < ? extends Annotation > annotationType ) { ValidateWith validateWithAnnotation = annotationType . getAnnotation ( ValidateWith . class ) ; Class < ? > clazz = validateWithAnnotation . value ( ) ; try { AnnotationValidator annotationValidator = ( AnnotationValidator ) clazz . newInstance ( ) ;
private < T > List < T > getAnnotatedMembers ( Map < Class < ? extends Annotation > , List < T > > map , Class < ? extends Annotation > type , boolean fillIfAbsent ) { if ( ! map . containsKey ( type ) & & fillIfAbsent ) { map . put ( type , new ArrayList < T > ( ) ) ; } List < T > members = map . get ( type ) ; return members = = null ? Collections . < T > emptyList ( ) : members ; }
public void test1 ( ) throws Exception { } @ Test public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator implements AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ ValidateWith ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } public static class SampleCategory { } public static class SampleTest { @ Category ( SampleCategory . class ) @ Before public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator implements AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ ValidateWith ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } public static class SampleCategory { } public static class SampleTest { @ Category ( SampleCategory . class ) @ Before public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator implements AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ ValidateWith ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } public static class SampleCategory { } public static class SampleTest { @ Category ( SampleCategory . class ) @ Before public void before ( ) { } @ Test public void hello ( ) { } } @ Test public void categoryCannotBeCombinedWithBefore ( ) { assertClassHasFailureMessage ( SampleTest . class , 1 , " @ Before can not be combined with @ Category " ) ; } }
public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ;
public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ;
private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ;
private void invokeValidatorsOnClass ( List < Throwable > errors ) { Annotation [ ] annotations = getTestClass ( ) . getAnnotations ( ) ; for ( Annotation annotation : annotations ) { if ( hasValidatorAnnotation ( annotation . annotationType ( ) ) ) {
private void invokeValidatorsOnMethods ( List < Throwable > errors ) { Map < Class < ? extends Annotation > , List < FrameworkMethod > > annotationMap = getTestClass ( ) . getAnnotationToMethods ( ) ; for ( Class < ? extends Annotation > annotation : annotationMap . keySet ( ) ) { if ( hasValidatorAnnotation ( annotation ) ) {
private void invokeValidatorsOnFields ( List < Throwable > errors ) { Map < Class < ? extends Annotation > , List < FrameworkField > > annotationMap = getTestClass ( ) . getAnnotationToFields ( ) ; for ( Class < ? extends Annotation > annotation : annotationMap . keySet ( ) ) { if ( hasValidatorAnnotation ( annotation ) ) {
private boolean hasValidatorAnnotation ( Class < ? extends Annotation > annotationType ) { return getAnnotationValidator ( annotationType ) ! = null ; }
private AnnotationValidator createAnnotationValidator ( Class < ? extends Annotation > annotationType ) { ValidateWith validateWithAnnotation = annotationType . getAnnotation ( ValidateWith . class ) ; if ( validateWithAnnotation = = null ) { return null ; } Class < ? > clazz = validateWithAnnotation . value ( ) ; try { AnnotationValidator annotationValidator = ( AnnotationValidator ) clazz . newInstance ( ) ;
public void test1 ( ) throws Exception { } @ Test public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator implements AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ ValidateWith ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator implements AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ ValidateWith ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator implements AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ ValidateWith ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { } public void validateAnnotatedField ( Field field , List < Throwable > errors ) { } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { } }
public void validateAnnotatedField ( Field field , List < Throwable > errors ) { } public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { } }
public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { } }
public AnnotationValidator createAnnotationValidator ( ValidateWith validateWithAnnotation ) { if ( validateWithAnnotation = = null ) { return new AnnotationValidator ( ) ; } if ( fAnnotationTypeToValidatorMap . containsKey ( validateWithAnnotation ) ) { return fAnnotationTypeToValidatorMap . get ( validateWithAnnotation ) ; } Class < ? > clazz = validateWithAnnotation . value ( ) ; try { AnnotationValidator annotationValidator = ( AnnotationValidator ) clazz . newInstance ( ) ;
public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { Annotation [ ] declaredAnnotations = method . getDeclaredAnnotations ( ) ; for ( Annotation annotation : declaredAnnotations ) { for ( Class clazz : fIncompatibleAnnotations ) {
private static Set < Class < ? extends Annotation > > buildIncompatibleAnnotationsSet ( ) { Set < Class < ? extends Annotation > > incompatibleAnnotations = new HashSet < Class < ? extends Annotation > > ( ) ; incompatibleAnnotations . add ( BeforeClass . class ) ; incompatibleAnnotations . add ( AfterClass . class ) ; incompatibleAnnotations . add ( Before . class ) ; incompatibleAnnotations . add ( After . class ) ; return Collections . unmodifiableSet ( incompatibleAnnotations ) ; }
private void invokeValidatorsOnClass ( List < Throwable > errors ) { Annotation [ ] annotations = getTestClass ( ) . getAnnotations ( ) ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ;
private void invokeValidatorsOnMethods ( List < Throwable > errors ) { Map < Class < ? extends Annotation > , List < FrameworkMethod > > annotationMap = getTestClass ( ) . getAnnotationToMethods ( ) ; for ( Class < ? extends Annotation > annotationType : annotationMap . keySet ( ) ) { ValidateWith validateWithAnnotation = annotationType . getAnnotation ( ValidateWith . class ) ;
private void invokeValidatorsOnFields ( List < Throwable > errors ) { Map < Class < ? extends Annotation > , List < FrameworkField > > annotationMap = getTestClass ( ) . getAnnotationToFields ( ) ; for ( Class < ? extends Annotation > annotationType : annotationMap . keySet ( ) ) { ValidateWith validateWithAnnotation = annotationType . getAnnotation ( ValidateWith . class ) ;
public void nullArgumentReturnsDefaultAnnotationValidator ( ) { AnnotationValidator annotationValidator = new AnnotationValidatorFactory ( ) . createAnnotationValidator ( null ) ; assertThat ( annotationValidator , is ( instanceOf ( AnnotationValidator . class ) ) ) ; }
public void exceptionWhenValidatorIsNotAnAnnotationValidator ( ) { exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Error when creating AnnotationValidator class " + " org . junit . experimental . validator . AnnotationValidatorFactoryTest $ ValidatorThatThrowsException " ) ; ValidateWith validateWith = SampleTestWithValidatorThatThrowsException . class . getAnnotation ( ValidateWith . class ) ; new AnnotationValidatorFactory ( ) . createAnnotationValidator ( validateWith ) ; }
public void createAnnotationValidator ( ) { ValidateWith validateWith = SampleTestWithValidator . class . getAnnotation ( ValidateWith . class ) ; AnnotationValidator annotationValidator = new AnnotationValidatorFactory ( ) . createAnnotationValidator ( validateWith ) ; assertThat ( annotationValidator , is ( instanceOf ( Validator . class ) ) ) ; }
public void test1 ( ) throws Exception { } @ Test public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator extends AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; @ Override public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } @ Override public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } @ Override public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ ValidateWith ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test2 ( ) throws Exception { } @ Test public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator extends AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; @ Override public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } @ Override public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } @ Override public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ ValidateWith ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test3 ( ) throws Exception { } } @ Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be public . " ) ; } @ Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , 2 , " The @ ClassRule ' temporaryFolder ' must be static . " ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , int failureCount , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( failureCount ) ) ; assertThat ( result . getFailures ( ) . get ( 0 ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class ExampleAnnotationValidator extends AnnotationValidator { private static final String ANNOTATED_METHOD_CALLED = " annotated method called " ; private static final String ANNOTATED_FIELD_CALLED = " annotated field called " ; private static final String ANNOTATED_CLASS_CALLED = " annotated class called " ; @ Override public void validateAnnotatedClass ( Class < ? > type , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; } @ Override public void validateAnnotatedField ( Field field , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; } @ Override public void validateAnnotatedMethod ( Method method , List < Throwable > errors ) { errors . add ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ Inherited @ ValidateWith ( ExampleAnnotationValidator . class ) public @ interface ExampleAnnotationWithValidator { } public static class AnnotationValidatorMethodTest { @ ExampleAnnotationWithValidator @ Test public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , 1 , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public List < Throwable > validateAnnotatedMethod ( Method method ) { List < Throwable > errors = new ArrayList < Throwable > ( ) ; Annotation [ ] declaredAnnotations = method . getDeclaredAnnotations ( ) ; for ( Annotation annotation : declaredAnnotations ) { for ( Class clazz : fIncompatibleAnnotations ) { if ( annotation . annotationType ( ) . isAssignableFrom ( clazz ) ) { addErrorMessage ( errors , clazz ) ; } } } return Collections . unmodifiableList ( errors ) ; }
public List < Throwable > validateAnnotatedClass ( Class < ? > type ) { return Collections . emptyList ( ) ; }
public List < Throwable > validateAnnotatedField ( Field field ) { return Collections . emptyList ( ) ;
public List < Throwable > validateAnnotatedMethod ( Method method ) { return Collections . emptyList ( ) ; }
public AnnotationValidator createAnnotationValidator ( ValidateWith validateWithAnnotation ) { if ( validateWithAnnotation = = null ) { return new AnnotationValidator ( ) { } ; } AnnotationValidator validator = fAnnotationTypeToValidatorMap . get ( validateWithAnnotation ) ; if ( validator ! = null ) { return validator ; } Class < ? extends AnnotationValidator > clazz = validateWithAnnotation . value ( ) ; try { AnnotationValidator annotationValidator = clazz . newInstance ( ) ;
private static < T > List < T > getAnnotatedMembers ( Map < Class < ? extends Annotation > , List < T > > map , Class < ? extends Annotation > type , boolean fillIfAbsent ) { if ( ! map . containsKey ( type ) & & fillIfAbsent ) { map . put ( type , new ArrayList < T > ( ) ) ; } List < T > members = map . get ( type ) ; return members = = null ? Collections . < T > emptyList ( ) : members ; }
public static void methodWithCategoryAndBeforeClass ( ) { } @ AfterClass @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfterClass ( ) { } @ Before @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategoryAndAfterClass ( ) { } @ Before @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Throwable throwable = errors . get ( 0 ) ; assertThat ( throwable . getMessage ( ) , is ( expectedErrorMessage ) ) ; }
public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Throwable > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; }
public List < Throwable > validateAnnotatedClass ( Class < ? > type ) { return Arrays . asList ( new Throwable ( ANNOTATED_CLASS_CALLED ) ) ; }
public List < Throwable > validateAnnotatedField ( Field field ) { return Arrays . asList ( new Throwable ( ANNOTATED_FIELD_CALLED ) ) ; }
public List < Throwable > validateAnnotatedMethod ( Method method ) { return Arrays . asList ( new Throwable ( ANNOTATED_METHOD_CALLED ) ) ; }
public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ;
public void validatorIsCalledForAMethod ( ) throws InitializationError { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ;
public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ;
public AnnotationValidator createAnnotationValidator ( ValidateWith validateWithAnnotation ) { AnnotationValidator validator = fAnnotationTypeToValidatorMap . get ( validateWithAnnotation ) ; if ( validator ! = null ) { return validator ; } Class < ? extends AnnotationValidator > clazz = validateWithAnnotation . value ( ) ; if ( clazz = = null ) { throw new IllegalArgumentException ( " Can ' t create validator , value is null in annotation " + validateWithAnnotation . getClass ( ) . getName ( ) ) ; } try { AnnotationValidator annotationValidator = clazz . newInstance ( ) ;
private AnnotationValidator createAnnotationValidator ( ValidateWith validateWithAnnotation ) { if ( validateWithAnnotation = = null ) { return new AnnotationValidator ( ) { } ; } return fAnnotationValidatorFactory . createAnnotationValidator ( validateWithAnnotation ) ; }
private static < T extends FrameworkMember < T > > void convertListValuesToBeUnmodifiable ( Map < Class < ? extends Annotation > , List < T > > methodsForAnnotations ) { for ( Class < ? extends Annotation > clazz : methodsForAnnotations . keySet ( ) ) { methodsForAnnotations . put ( clazz , Collections . unmodifiableList ( methodsForAnnotations . get ( clazz ) ) ) ;
public void exceptionWhenAnnotationWithNullClassIsPassedIn ( ) { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " Can ' t create validator , value is null in " + " annotation org . junit . experimental . validator . AnnotationValidatorFactoryTest $ ValidatorWithNullValue " ) ; new AnnotationValidatorFactory ( ) . createAnnotationValidator ( new ValidatorWithNullValue ( ) ) ; }
public Class < ? extends AnnotationValidator > value ( ) { return null ; }
public Class < ? extends Annotation > annotationType ( ) { return ValidateWith . class ; }
public void exceptionWhenAnnotationValidatorCantBeCreated ( ) { exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Exception received when creating AnnotationValidator class " + " org . junit . experimental . validator . AnnotationValidatorFactoryTest $ ValidatorThatThrowsException " ) ; ValidateWith validateWith = SampleTestWithValidatorThatThrowsException . class . getAnnotation ( ValidateWith . class ) ; new AnnotationValidatorFactory ( ) . createAnnotationValidator ( validateWith ) ; }
public void annotationToMethods ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkMethod > > annotationToMethods = tc . getAnnotationToMethods ( ) ; List < FrameworkMethod > methods = annotationToMethods . get ( Ignore . class ) ; assertThat ( methods . size ( ) , is ( 2 ) ) ; }
public void annotationToMethodsReturnsUnmodifiableMap ( ) { exception . expect ( UnsupportedOperationException . class ) ; TestClass tc = new TestClass ( MethodsAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkMethod > > annotationToMethods = tc . getAnnotationToMethods ( ) ; annotationToMethods . put ( Ignore . class , null ) ; }
public void annotationToMethodsReturnsValuesInTheMapThatAreUnmodifiable ( ) { exception . expect ( UnsupportedOperationException . class ) ; TestClass tc = new TestClass ( MethodsAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkMethod > > annotationToMethods = tc . getAnnotationToMethods ( ) ; annotationToMethods . put ( Ignore . class , null ) ; }
public void annotationToFields ( ) { TestClass tc = new TestClass ( FieldAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkField > > annotationToFields = tc . getAnnotationToFields ( ) ; List < FrameworkField > fields = annotationToFields . get ( Rule . class ) ; assertThat ( fields . size ( ) , is ( 2 ) ) ; }
public void annotationToFieldsReturnsUnmodifiableMap ( ) { exception . expect ( UnsupportedOperationException . class ) ; TestClass tc = new TestClass ( FieldAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkField > > annotationToFields = tc . getAnnotationToFields ( ) ; annotationToFields . put ( Rule . class , null ) ; }
public void annotationToFieldsReturnsValuesInTheMapThatAreUnmodifiable ( ) { exception . expect ( UnsupportedOperationException . class ) ; TestClass tc = new TestClass ( FieldAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkField > > annotationToFields = tc . getAnnotationToFields ( ) ; List < FrameworkField > fields = annotationToFields . get ( Rule . class ) ; fields . add ( null ) ; }
public void exceptionWhenAnnotationValidatorCantBeCreated ( ) { ValidateWith validateWith = SampleTestWithValidatorThatThrowsException . class . getAnnotation ( ValidateWith . class ) ; exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Exception received when creating AnnotationValidator class " + " org . junit . experimental . validator . AnnotationValidatorFactoryTest $ ValidatorThatThrowsException " ) ; new AnnotationValidatorFactory ( ) . createAnnotationValidator ( validateWith ) ; }
public void annotationToMethodsReturnsUnmodifiableMap ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkMethod > > annotationToMethods = tc . getAnnotationToMethods ( ) ; exception . expect ( UnsupportedOperationException . class ) ; annotationToMethods . put ( Ignore . class , null ) ; }
public void annotationToMethodsReturnsValuesInTheMapThatAreUnmodifiable ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkMethod > > annotationToMethods = tc . getAnnotationToMethods ( ) ; List < FrameworkMethod > methods = annotationToMethods . get ( Ignore . class ) ; exception . expect ( UnsupportedOperationException . class ) ; methods . add ( null ) ; }
public void annotationToFieldsReturnsUnmodifiableMap ( ) { TestClass tc = new TestClass ( FieldAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkField > > annotationToFields = tc . getAnnotationToFields ( ) ; exception . expect ( UnsupportedOperationException . class ) ; annotationToFields . put ( Rule . class , null ) ; }
public void annotationToFieldsReturnsValuesInTheMapThatAreUnmodifiable ( ) { TestClass tc = new TestClass ( FieldAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkField > > annotationToFields = tc . getAnnotationToFields ( ) ; List < FrameworkField > fields = annotationToFields . get ( Rule . class ) ; exception . expect ( UnsupportedOperationException . class ) ; fields . add ( null ) ; }
public int compare ( Field field1 , Field field2 ) { return field1 . getName ( ) . compareTo ( field2 . getName ( ) ) ; }
private static < T extends FrameworkMember < T > > void convertListValuesToBeUnmodifiable ( Map < Class < ? extends Annotation > , List < T > > source , Map < Class < ? extends Annotation > , List < T > > target ) { Set < Class < ? extends Annotation > > classes = source . keySet ( ) ; for ( Class < ? extends Annotation > clazz : classes ) { target . put ( clazz , Collections . unmodifiableList ( source . get ( clazz ) ) ) ;
public void annotationToFieldsReturnsKeysInADeterministicOrder ( ) { TestClass tc = new TestClass ( MultipleFieldsAnnotated . class ) ; Map < Class < ? extends Annotation > , List < FrameworkField > > annotationToFields = tc . getAnnotationToFields ( ) ; List < Class < ? extends Annotation > > keys = new ArrayList < Class < ? extends Annotation > > ( ) ; for ( Class < ? extends Annotation > annotation : annotationToFields . keySet ( ) ) { keys . add ( annotation ) ; } assertThat ( keys . get ( 0 ) , CoreMatchers . < Class < ? extends Annotation > > is ( DataPoint . class ) ) ; assertThat ( keys . get ( 1 ) , CoreMatchers . < Class < ? extends Annotation > > is ( Rule . class ) ) ; }
public void exceptionWhenAnnotationWithNullClassIsPassedIn ( ) { exception . expect ( IllegalArgumentException . class ) ; exception . expectMessage ( " Can ' t create validator , value is null in " + " annotation org . junit . validator . AnnotationValidatorFactoryTest $ ValidatorWithNullValue " ) ; new AnnotationValidatorFactory ( ) . createAnnotationValidator ( new ValidatorWithNullValue ( ) ) ; }
public void exceptionWhenAnnotationValidatorCantBeCreated ( ) { ValidateWith validateWith = SampleTestWithValidatorThatThrowsException . class . getAnnotation ( ValidateWith . class ) ; exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Exception received when creating AnnotationValidator class " + " org . junit . validator . AnnotationValidatorFactoryTest $ ValidatorThatThrowsException " ) ; new AnnotationValidatorFactory ( ) . createAnnotationValidator ( validateWith ) ; }
private static < T extends FrameworkMember < T > > void convertListValuesToBeUnmodifiable ( Map < Class < ? extends Annotation > , List < T > > source , Map < Class < ? extends Annotation > , List < T > > target ) { for ( Map . Entry < Class < ? extends Annotation > , List < T > > entry : source . entrySet ( ) ) { target . put ( entry . getKey ( ) , Collections . unmodifiableList ( entry . getValue ( ) ) ) ;
private static < T extends FrameworkMember < T > > Map < Class < ? extends Annotation > , List < T > > makeDeeplyUnmodifiable ( Map < Class < ? extends Annotation > , List < T > > source ) { LinkedHashMap < Class < ? extends Annotation > , List < T > > copy = new LinkedHashMap < Class < ? extends Annotation > , List < T > > ( ) ; for ( Map . Entry < Class < ? extends Annotation > , List < T > > entry : source . entrySet ( ) ) { copy . put ( entry . getKey ( ) , Collections . unmodifiableList ( entry . getValue ( ) ) ) ; } return Collections . unmodifiableMap ( copy ) ; }
public List < Exception > validateAnnotatedMethod ( Method method ) { List < Exception > errors = new ArrayList < Exception > ( ) ; Annotation [ ] declaredAnnotations = method . getDeclaredAnnotations ( ) ; for ( Annotation annotation : declaredAnnotations ) { for ( Class clazz : INCOMPATIBLE_ANNOTATIONS ) { if ( annotation . annotationType ( ) . isAssignableFrom ( clazz ) ) { addErrorMessage ( errors , clazz ) ; } } } return unmodifiableList ( errors ) ; }
private void addErrorMessage ( List < Exception > errors , Class clazz ) { String message = String . format ( " @ % s can not be combined with @ Category " , clazz . getSimpleName ( ) ) ; errors . add ( new Exception ( message ) ) ; }
public List < Exception > validateAnnotatedClass ( Class < ? > type ) { return NO_VALIDATION_ERRORS ; }
public List < Exception > validateAnnotatedField ( Field field ) { return NO_VALIDATION_ERRORS ;
public List < Exception > validateAnnotatedMethod ( Method method ) { return NO_VALIDATION_ERRORS ; }
public static void methodWithCategoryAndBeforeClass ( ) { } @ AfterClass @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfterClass ( ) { } @ Before @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategoryAndAfterClass ( ) { } @ Before @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBeforeClass " ) ; testAndAssertErrrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfterClass " ) ; testAndAssertErrrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndBefore " ) ; testAndAssertErrrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) throws NoSuchMethodException { Method method = CategoryTest . class . getMethod ( " methodWithCategoryAndAfter " ) ; testAndAssertErrrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
private void testAndAssertErrrorMessage ( Method method , String expectedErrorMessage ) throws NoSuchMethodException { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; }
public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { Method beforeClass = CategoryTest . class . getMethod ( " methodWithCategory " ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( beforeClass ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; }
public List < Exception > validateAnnotatedClass ( Class < ? > type ) { return asList ( new Exception ( ANNOTATED_CLASS_CALLED ) ) ; }
public List < Exception > validateAnnotatedField ( Field field ) { return asList ( new Exception ( ANNOTATED_FIELD_CALLED ) ) ; }
public List < Exception > validateAnnotatedMethod ( Method method ) { return asList ( new Exception ( ANNOTATED_METHOD_CALLED ) ) ; }
public List < Exception > validateAnnotatedMethod ( FrameworkMethod method ) { List < Exception > errors = new ArrayList < Exception > ( ) ; Annotation [ ] annotations = method . getAnnotations ( ) ; for ( Annotation annotation : annotations ) { for ( Class clazz : INCOMPATIBLE_ANNOTATIONS ) { if ( annotation . annotationType ( ) . isAssignableFrom ( clazz ) ) { addErrorMessage ( errors , clazz ) ; } } } return unmodifiableList ( errors ) ; }
public List < Exception > validateAnnotatedClass ( TestClass testClass ) { return NO_VALIDATION_ERRORS ; }
public List < Exception > validateAnnotatedField ( FrameworkField field ) { return NO_VALIDATION_ERRORS ;
public List < Exception > validateAnnotatedMethod ( FrameworkMethod method ) { return NO_VALIDATION_ERRORS ; }
public static void methodWithCategoryAndBeforeClass ( ) { } @ AfterClass @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfterClass ( ) { } @ Before @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( BeforeClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( AfterClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( Before . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( After . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrorMessage ( FrameworkMethod method , String expectedErrorMessage ) { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { FrameworkMethod method = new FrameworkMethod ( CategoryTest . class . getMethod ( " methodWithCategory " ) ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategoryAndAfterClass ( ) { } @ Before @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( BeforeClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( AfterClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( Before . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( After . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrorMessage ( FrameworkMethod method , String expectedErrorMessage ) { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { FrameworkMethod method = new FrameworkMethod ( CategoryTest . class . getMethod ( " methodWithCategory " ) ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategoryAndBefore ( ) { } @ After @ Category ( value = SampleCategory . class ) public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( BeforeClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( AfterClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( Before . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( After . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrorMessage ( FrameworkMethod method , String expectedErrorMessage ) { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { FrameworkMethod method = new FrameworkMethod ( CategoryTest . class . getMethod ( " methodWithCategory " ) ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategoryAndAfter ( ) { } @ Category ( value = SampleCategory . class ) public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( BeforeClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( AfterClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( Before . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( After . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrorMessage ( FrameworkMethod method , String expectedErrorMessage ) { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { FrameworkMethod method = new FrameworkMethod ( CategoryTest . class . getMethod ( " methodWithCategory " ) ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public static void methodWithCategory ( ) { } } @ Test public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( BeforeClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( AfterClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( Before . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ Before can not be combined with @ Category " ) ; } @ Test public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( After . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ After can not be combined with @ Category " ) ; } private void testAndAssertErrorMessage ( FrameworkMethod method , String expectedErrorMessage ) { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; } @ Test public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { FrameworkMethod method = new FrameworkMethod ( CategoryTest . class . getMethod ( " methodWithCategory " ) ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; } }
public void errorIsAddedWhenCategoryIsUsedWithBeforeClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( BeforeClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ BeforeClass can not be combined with @ Category " ) ; }
public void errorIsAddedWhenCategoryIsUsedWithAfterClass ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( AfterClass . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ AfterClass can not be combined with @ Category " ) ; }
public void errorIsAddedWhenCategoryIsUsedWithBefore ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( Before . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ Before can not be combined with @ Category " ) ; }
public void errorIsAddedWhenCategoryIsUsedWithAfter ( ) { FrameworkMethod method = new TestClass ( CategoryTest . class ) . getAnnotatedMethods ( After . class ) . get ( 0 ) ; testAndAssertErrorMessage ( method , " @ After can not be combined with @ Category " ) ; }
private void testAndAssertErrorMessage ( FrameworkMethod method , String expectedErrorMessage ) { List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; Exception exception = errors . get ( 0 ) ; assertThat ( exception . getMessage ( ) , is ( expectedErrorMessage ) ) ; }
public void errorIsNotAddedWhenCategoryIsNotCombinedWithIllegalCombination ( ) throws NoSuchMethodException { FrameworkMethod method = new FrameworkMethod ( CategoryTest . class . getMethod ( " methodWithCategory " ) ) ; List < Exception > errors = new CategoryValidator ( ) . validateAnnotatedMethod ( method ) ; assertThat ( errors . size ( ) , is ( 0 ) ) ; }
public List < Exception > validateAnnotatedClass ( TestClass testClass ) { return asList ( new Exception ( ANNOTATED_CLASS_CALLED ) ) ; }
public List < Exception > validateAnnotatedField ( FrameworkField field ) { return asList ( new Exception ( ANNOTATED_FIELD_CALLED ) ) ; }
public List < Exception > validateAnnotatedMethod ( FrameworkMethod method ) { return asList ( new Exception ( ANNOTATED_METHOD_CALLED ) ) ; }
static public void assertNotEquals ( String message , long unexpected , long actual ) { if ( unexpected = = actual ) { failEquals ( message , actual ) ;
static public void assertNotEquals ( String message , double unexpected , double actual , double delta ) { if ( ! doubleIsDifferent ( unexpected , actual , delta ) ) { failEquals ( message , actual ) ;
static public void assertEquals ( String message , double expected , double actual , double delta ) { if ( doubleIsDifferent ( expected , actual , delta ) ) { failNotEquals ( message , expected , actual ) ;
static public void assertEquals ( String message , float expected , float actual , float delta ) { if ( floatIsDifferent ( expected , actual , delta ) ) { failNotEquals ( message , expected , actual ) ;
static public void assertNotEquals ( String message , float unexpected , float actual , float delta ) { if ( ! floatIsDifferent ( unexpected , actual , delta ) ) { failEquals ( message , actual ) ;
static public void assertEquals ( String message , long expected , long actual ) { if ( expected ! = actual ) { failNotEquals ( message , expected , actual ) ;
public boolean shouldRun ( Description description ) { return description . isSuite ( ) ; }
public void filterNoTestsRemain ( ) throws NoTestsRemainException { JUnit38ClassRunner runner = new JUnit38ClassRunner ( OneTest . class ) ; runner . filter ( new RejectAllTestsFilter ( ) ) ; }
static public void assertNotEquals ( String message , long unexpected , long actual ) { if ( unexpected = = actual ) { failEquals ( message , Long . valueOf ( actual ) ) ;
static public void assertNotEquals ( String message , double unexpected , double actual , double delta ) { if ( ! doubleIsDifferent ( unexpected , actual , delta ) ) { failEquals ( message , Double . valueOf ( actual ) ) ;
static public void assertEquals ( String message , double expected , double actual , double delta ) { if ( doubleIsDifferent ( expected , actual , delta ) ) { failNotEquals ( message , Double . valueOf ( expected ) , Double . valueOf ( actual ) ) ;
static public void assertEquals ( String message , float expected , float actual , float delta ) { if ( floatIsDifferent ( expected , actual , delta ) ) { failNotEquals ( message , Float . valueOf ( expected ) , Float . valueOf ( actual ) ) ;
static public void assertNotEquals ( String message , float unexpected , float actual , float delta ) { if ( ! floatIsDifferent ( unexpected , actual , delta ) ) { failEquals ( message , Float . valueOf ( actual ) ) ;
static public void assertEquals ( String message , long expected , long actual ) { if ( expected ! = actual ) { failNotEquals ( message , Long . valueOf ( expected ) , Long . valueOf ( actual ) ) ;
private Exception createTimeoutException ( Thread thread ) { StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; final Thread stuckThread = fLookForStuckThread ? getStuckThread ( thread ) : null ; Exception currThreadException = new Exception ( String . format ( " test timed out after % d % s " , fTimeout , fTimeUnit . name ( ) . toLowerCase ( ) ) ) ; if ( stackTrace ! = null ) { currThreadException . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } if ( stuckThread ! = null ) { Exception stuckThreadException =
public Timeout lookForStuckThread ( boolean enable ) { fLookForStuckThread = enable ; return this ; }
public Statement apply ( Statement base , Description description ) { return new FailOnTimeout ( base , fTimeout , fTimeUnit , fLookForStuckThread ) ; }
public void success ( ) { } } @ Test public void successWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( SuccessWithTimeoutTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } public static class TimeoutFailureTest { @ Test ( timeout = 100 ) public void success ( ) throws InterruptedException { Thread . sleep ( 40000 ) ; } } @ Ignore ( " was breaking gump " ) @ Test public void timeoutFailure ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeoutFailureTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertEquals ( InterruptedException . class , result . getFailures ( ) . get ( 0 ) . getException ( ) . getClass ( ) ) ; } public static class InfiniteLoopTest { @ Test ( timeout = 100 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { } } } } @ Test public void infiniteLoop ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertTrue ( exception . getMessage ( ) . contains ( " test timed out after 100 milliseconds " ) ) ; } public static class ImpatientLoopTest { @ Test ( timeout = 1 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) ; } } @ Ignore ( " This breaks sporadically with time differences just slightly more than 200ms " ) @ Test public void infiniteLoopRunsForApproximatelyLengthOfTimeout ( ) throws Exception { JUnitCore . runClasses ( InfiniteLoopTest . class , ImpatientLoopTest . class ) ; long longTime = runAndTime ( InfiniteLoopTest . class ) ; long shortTime = runAndTime ( ImpatientLoopTest . class ) ; long difference = longTime - shortTime ; assertTrue ( String . format ( " Difference was % sms " , difference ) , difference < 200 ) ; } private long runAndTime ( Class < ? > clazz ) { JUnitCore core = new JUnitCore ( ) ; long startTime = System . currentTimeMillis ( ) ; core . run ( clazz ) ; long totalTime = System . currentTimeMillis ( ) - startTime ; return totalTime ; } private String stackForException ( Throwable exception ) { Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; return buffer . toString ( ) ; } @ Test public void stalledThreadAppearsInStackTrace ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( stackForException ( exception ) , containsString ( " infiniteLoop " ) ) ; } public static class InfiniteLoopMultithreaded { private static class ThreadTest implements Runnable { private boolean fStall ; public ThreadTest ( boolean stall ) { fStall = stall ; } public void run ( ) { if ( fStall ) for ( ; ; ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } } public void failure ( boolean mainThreadStalls ) throws Exception { Thread t1 = new Thread ( new ThreadTest ( false ) , " timeout - thr1 " ) ; Thread t2 = new Thread ( new ThreadTest ( ! mainThreadStalls ) , " timeout - thr2 " ) ; Thread t3 = new Thread ( new ThreadTest ( false ) , " timeout - thr3 " ) ; t1 . start ( ) ; t2 . start ( ) ; t3 . start ( ) ; if ( mainThreadStalls ) for ( ; ; ) ; t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; } } public static class InfiniteLoopWithStuckThreadTest { @ Rule public TestRule globalTimeout = new Timeout ( 100 , TimeUnit . MILLISECONDS ) . lookForStuckThread ( true ) ; @ Test public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( false ) ; } } public static class InfiniteLoopStuckInMainThreadTest { @ Rule public TestRule globalTimeout = new Timeout ( 100 , TimeUnit . MILLISECONDS ) . lookForStuckThread ( true ) ; @ Test public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( true ) ; } } @ Test public void timeoutFailureMultithreaded ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopWithStuckThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; Throwable exception [ ] = new Throwable [ 2 ] ; for ( int i = 0 ; i < 2 ; i + + ) exception [ i ] = result . getFailures ( ) . get ( i ) . getException ( ) ; assertThat ( exception [ 0 ] . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( stackForException ( exception [ 0 ] ) , containsString ( " Thread . join " ) ) ; assertThat ( exception [ 1 ] . getMessage ( ) , containsString ( " Appears to be stuck in thread timeout - thr2 " ) ) ; } @ Test public void timeoutFailureMultithreadedStuckInMain ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopStuckInMainThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( exception . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( exception . getMessage ( ) , not ( containsString ( " Appears to be stuck " ) ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( InfiniteLoopTest . class ) . run ( result ) ; assertEquals ( 1 , result . errorCount ( ) ) ; } public static class WillTimeOut { static boolean afterWasCalled = false ; @ Test ( timeout = 1 ) public void test ( ) { for ( ; ; ) { try { Thread . sleep ( 10000 ) ; } catch ( InterruptedException e ) { } } } @ After public void after ( ) { afterWasCalled = true ; } } @ Test public void makeSureAfterIsCalledAfterATimeout ( ) { JUnitCore . runClasses ( WillTimeOut . class ) ; assertThat ( WillTimeOut . afterWasCalled , is ( true ) ) ; } }
public ExpectedException handleAssertionErrors ( ) { return this ; }
public ExpectedException handleAssumptionViolatedExceptions ( ) { return this ; }
public void evaluate ( ) throws Throwable { try { fNext . evaluate ( ) ; } catch ( Throwable e ) { handleException ( e ) ; return ; } if ( fMatcherBuilder . expectsThrowable ( ) ) { failDueToMissingException ( ) ;
public void throwsNothing ( ) { } } public static class ThrowExceptionWithExpectedType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new NullPointerException ( ) ; } } public static class ThrowExceptionWithExpectedPartOfMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerExceptionWithMessage ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( ARBITRARY_MESSAGE ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " something else " ) ; } } public static class ThrowExceptionWithWrongType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new IllegalArgumentException ( ) ; } } public static class HasWrongMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expectMessage ( " expectedMessage " ) ; throw new IllegalArgumentException ( " actualMessage " ) ; } } public static class ThrowNoExceptionButExpectExceptionWithType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; } } public static class WronglyExpectsExceptionMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowAnything ( ) { thrown . expectMessage ( " anything ! " ) ; } } public static class ExpectsSubstring { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( " This could throw anything ! ( as long as it has the right substring ) " ) ; } } public static class ExpectsSubstringNullMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( ) ; } } public static class ExpectsMessageMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( startsWith ( ARBITRARY_MESSAGE ) ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " ! " ) ; } } public static class ExpectedMessageMatcherFails { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( equalTo ( " Wrong start " ) ) ; throw new NullPointerException ( " Back ! " ) ; } } public static class ExpectsMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( any ( Exception . class ) ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class ExpectsMultipleMatchers { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class ExpectAssertionErrorWhichIsNotThrown { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void fails ( ) { thrown . expect ( AssertionError . class ) ; } } public static class FailBeforeExpectingException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void fails ( ) { fail ( ARBITRARY_MESSAGE ) ; thrown . expect ( IllegalArgumentException . class ) ; } } public static class FailedAssumptionAndExpectException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void failedAssumption ( ) { assumeTrue ( false ) ; thrown . expect ( NullPointerException . class ) ; } } public static class ThrowExceptionWithMatchingCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExceptionWithMatchingCause ( ) { NullPointerException expectedCause = new NullPointerException ( " expected cause " ) ; thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( expectedCause ) ) ; throw new IllegalArgumentException ( " Ack ! " , expectedCause ) ; } } public static class ThrowExpectedNullCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExpectedNullCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( nullValue ( Throwable . class ) ) ; throw new IllegalArgumentException ( " Ack ! " ) ; } } public static class ThrowUnexpectedCause { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void throwWithCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( new NullPointerException ( " expected cause " ) ) ) ; throw new IllegalArgumentException ( " Ack ! " , new NullPointerException ( " an unexpected cause " ) ) ; } } public static class CustomMessageWithoutExpectedException { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . reportMissingExceptionWithMessage ( ARBITRARY_MESSAGE ) ; } } }
public void fails ( ) { thrown . expect ( AssertionError . class ) ; }
public void fails ( ) { fail ( ARBITRARY_MESSAGE ) ; thrown . expect ( IllegalArgumentException . class ) ; }
public void failedAssumption ( ) { assumeTrue ( false ) ; thrown . expect ( NullPointerException . class ) ; }
public void evaluate ( ) throws Throwable { try { fNext . evaluate ( ) ; } catch ( Throwable e ) { handleException ( e ) ; return ; } if ( isAnyExceptionExpected ( ) ) { failDueToMissingException ( ) ;
private void handleException ( Throwable e ) throws Throwable { if ( isAnyExceptionExpected ( ) ) { assertThat ( e , fMatcherBuilder . build ( ) ) ;
private boolean isAnyExceptionExpected ( ) { return fMatcherBuilder . expectsThrowable ( ) ; }
private String missingExceptionMessage ( ) { String expectation = StringDescription . toString ( fMatcherBuilder . build ( ) ) ; return format ( missingExceptionMessage , expectation ) ; }
protected void describeMismatchSafely ( EventCollector item , org . hamcrest . Description description ) { description . appendValue ( item . fFailures . size ( ) ) ; description . appendText ( " failures " ) ; }
protected void describeMismatchSafely ( EventCollector item , org . hamcrest . Description description ) { description . appendText ( " was " ) ; hasSingleFailure ( ) . describeMismatch ( item , description ) ; description . appendText ( " : " ) ; boolean first = true ; for ( Failure f : item . fFailures ) { if ( ! first ) {
public void throwsNothing ( ) { } } public static class ThrowExceptionWithExpectedType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new NullPointerException ( ) ; } } public static class ThrowExceptionWithExpectedPartOfMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerExceptionWithMessage ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( ARBITRARY_MESSAGE ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " something else " ) ; } } public static class ThrowExceptionWithWrongType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; throw new IllegalArgumentException ( ) ; } } public static class HasWrongMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsNullPointerException ( ) { thrown . expectMessage ( " expectedMessage " ) ; throw new IllegalArgumentException ( " actualMessage " ) ; } } public static class ThrowNoExceptionButExpectExceptionWithType { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowNullPointerException ( ) { thrown . expect ( NullPointerException . class ) ; } } public static class WronglyExpectsExceptionMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void doesntThrowAnything ( ) { thrown . expectMessage ( " anything ! " ) ; } } public static class ExpectsSubstring { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( " This could throw anything ! ( as long as it has the right substring ) " ) ; } } public static class ExpectsSubstringNullMessage { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( " anything ! " ) ; throw new NullPointerException ( ) ; } } public static class ExpectsMessageMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( startsWith ( ARBITRARY_MESSAGE ) ) ; throw new NullPointerException ( ARBITRARY_MESSAGE + " ! " ) ; } } public static class ExpectedMessageMatcherFails { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expectMessage ( equalTo ( " Wrong start " ) ) ; throw new NullPointerException ( " Back ! " ) ; } } public static class ExpectsMatcher { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( any ( Exception . class ) ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class ExpectsMultipleMatchers { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwsMore ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; throw new NullPointerException ( " Ack ! " ) ; } } public static class ExpectAssertionErrorWhichIsNotThrown { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void fails ( ) { thrown . expect ( AssertionError . class ) ; } } public static class FailBeforeExpectingException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void fails ( ) { fail ( ARBITRARY_MESSAGE ) ; thrown . expect ( IllegalArgumentException . class ) ; } } public static class FailedAssumptionAndExpectException { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void failedAssumption ( ) { assumeTrue ( false ) ; thrown . expect ( NullPointerException . class ) ; } } public static class ThrowExceptionWithMatchingCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExceptionWithMatchingCause ( ) { NullPointerException expectedCause = new NullPointerException ( " expected cause " ) ; thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( expectedCause ) ) ; throw new IllegalArgumentException ( " Ack ! " , expectedCause ) ; } } public static class ThrowExpectedNullCause { @ Rule public ExpectedException thrown = none ( ) ; @ Test public void throwExpectedNullCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( nullValue ( Throwable . class ) ) ; throw new IllegalArgumentException ( " Ack ! " ) ; } } public static class ThrowUnexpectedCause { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void throwWithCause ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . expectMessage ( " Ack ! " ) ; thrown . expectCause ( is ( new NullPointerException ( " expected cause " ) ) ) ; throw new IllegalArgumentException ( " Ack ! " , new NullPointerException ( " an unexpected cause " ) ) ; } } public static class UseNoCustomMessage { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; } } public static class UseCustomMessageWithPlaceHolder { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . reportMissingExceptionWithMessage ( ARBITRARY_MESSAGE + " - % s " ) ; } } public static class UseCustomMessageWithoutPlaceHolder { @ Rule public ExpectedException thrown = ExpectedException . none ( ) ; @ Test public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . reportMissingExceptionWithMessage ( ARBITRARY_MESSAGE ) ; } } }
public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; }
public void noThrow ( ) { thrown . expect ( IllegalArgumentException . class ) ; thrown . reportMissingExceptionWithMessage ( ARBITRARY_MESSAGE + " - % s " ) ;
public void beforeFailsButTestMethodIsIgnored ( ) { runClassAndVerifyNoFailures ( HasBeforeClassButTestIsIgnored . class , " BeforeClass should not have been executed because the test method is ignored ! " ) ;
public void wholeClassIsIgnored ( ) { runClassAndVerifyNoFailures ( BeforeClassAndTestFailButClassIsIgnored . class ,
public void afterFailsButTestMethodIsIgnored ( ) { runClassAndVerifyNoFailures ( HasAfterClassButTestIsIgnored . class ,
public void beforeFailsButTestIsFiltered ( ) { Result result = new JUnitCore ( ) . run ( Request . classes ( HasBeforeClassButTestIsFiltered . class , HasUnfilteredTest . class ) . filterWith ( CategoryFilter . exclude ( FilteredTests . class ) ) ) ; analyseResult ( result , " der fail " ) ; }
private void runClassAndVerifyNoFailures ( Class < ? > klass , String testFailureDescription ) { Result result = JUnitCore . runClasses ( klass ) ; analyseResult ( result , testFailureDescription ) ; }
private void analyseResult ( Result result , String testFailureDescription ) { List < Failure > failures = result . getFailures ( ) ; if ( failures . isEmpty ( ) = = false ) { analyzeFailure ( failures . get ( 0 ) , testFailureDescription ) ;
private void analyzeFailure ( Failure failure , String testFailureDescription ) { String actualFailureMsg = failure . getMessage ( ) ; if ( OUR_FAILURE_MSG . equals ( actualFailureMsg ) ) { fail ( testFailureDescription ) ; } fail ( " Unexpected failure : " + actualFailureMsg ) ; }
public void beforeFailsButNoTests ( ) { runClassAndVerifyNoFailures ( HasBeforeClassButNoTests . class ,
public Statement apply ( Statement base , Description description ) { throw new RuntimeException ( " this rule is broken " ) ; }
public void brokenRuleButTestMethodIsIgnored ( ) { runClassAndVerifyNoFailures ( HasBrokenRuleButTestIsIgnored . class , " The rule should have been executed because the test method is ignored ! " ) ;
public void test ( ) throws Exception { fail ( " test ( ) should not be run " ) ; }
public void unfilteredTest ( ) throws Exception { } }
protected void validatePublicVoidNoArgMethods ( Class < ? extends Annotation > annotation , boolean isStatic , List < Throwable > errors ) { List < FrameworkMethod > methods = getTestClass ( ) . getAnnotatedMethods ( annotation ) ; for ( FrameworkMethod eachTestMethod : methods ) { eachTestMethod . validatePublicVoidNoArg ( isStatic , errors ) ;
protected Statement classBlock ( final RunNotifier notifier ) { Statement statement = childrenInvoker ( notifier ) ; if ( statement instanceof ParentRunner . EmptyStatement = = false ) { statement = withBeforeClasses ( statement ) ; statement = withAfterClasses ( statement ) ; statement = withClassRules ( statement ) ; } return statement ; }
protected Statement withBeforeClasses ( Statement statement ) { List < FrameworkMethod > befores = fTestClass . getAnnotatedMethods ( BeforeClass . class ) ; return befores . isEmpty ( ) ? statement : new RunBefores ( statement , befores , null ) ;
protected Statement withAfterClasses ( Statement statement ) { List < FrameworkMethod > afters = fTestClass . getAnnotatedMethods ( AfterClass . class ) ; return afters . isEmpty ( ) ? statement : new RunAfters ( statement , afters , null ) ;
private Statement withClassRules ( Statement statement ) { List < TestRule > classRules = classRules ( ) ; return classRules . isEmpty ( ) ? statement : new RunRules ( statement , classRules , getDescription ( ) ) ;
protected List < TestRule > classRules ( ) { List < TestRule > result = fTestClass . getAnnotatedMethodValues ( null , ClassRule . class , TestRule . class ) ; result . addAll ( fTestClass . getAnnotatedFieldValues ( null , ClassRule . class , TestRule . class ) ) ; return result ; }
protected Statement childrenInvoker ( final RunNotifier notifier ) { final Collection < T > filteredChildren = getFilteredChildren ( ) ; Collection < T > filteredChildrenCopy = new ArrayList < T > ( filteredChildren ) ; for ( T child : filteredChildren ) { if ( isIgnoredMethod ( child ) ) { Description childDescription = describeChild ( child ) ; notifier . fireTestIgnored ( childDescription ) ; filteredChildrenCopy . remove ( child ) ; } } final Collection < T > filteredChildrenWithoutIgnores = Collections . unmodifiableCollection ( filteredChildrenCopy ) ; if ( filteredChildrenWithoutIgnores . isEmpty ( ) ) { return new EmptyStatement ( ) ; } return new Statement ( ) { @ Override
public void evaluate ( ) { runChildren ( notifier , filteredChildrenWithoutIgnores ) ; }
private boolean isIgnoredMethod ( T child ) { return child instanceof FrameworkMethod & & ( ( FrameworkMethod ) child ) . isIgnored ( ) ;
protected final void runLeaf ( Statement statement , Description description , RunNotifier notifier ) { EachTestNotifier eachNotifier = new EachTestNotifier ( notifier , description ) ; eachNotifier . fireTestStarted ( ) ; try { statement . evaluate ( ) ;
public void run ( final RunNotifier notifier ) { EachTestNotifier testNotifier = new EachTestNotifier ( notifier , getDescription ( ) ) ; try { Statement statement = classBlock ( notifier ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { synchronized ( fChildrenLock ) { List < T > filteredChildren = new ArrayList < T > ( getFilteredChildren ( ) ) ;
private void validate ( ) throws InitializationError { List < Throwable > errors = new ArrayList < Throwable > ( ) ; collectInitializationErrors ( errors ) ; if ( ! errors . isEmpty ( ) ) { throw new InitializationError ( errors ) ;
protected void runChild ( final FrameworkMethod method , RunNotifier notifier ) { Description description = describeChild ( method ) ; if ( method . isIgnored ( ) ) { notifier . fireTestIgnored ( description ) ;
private void runChildren ( final RunNotifier notifier , Collection < T > filteredChildren ) { final RunnerScheduler scheduler = fScheduler ; try { for ( final T each : filteredChildren ) {
protected Statement childrenInvoker ( final RunNotifier notifier ) { final Collection < T > filteredChildrenWithoutIgnores = getFilteredChildrenWithoutIgnores ( notifier ) ; if ( filteredChildrenWithoutIgnores . isEmpty ( ) ) { return new EmptyStatement ( ) ; } return new Statement ( ) { @ Override
private Collection < T > getFilteredChildrenWithoutIgnores ( final RunNotifier notifier ) { final Collection < T > filteredChildren = getFilteredChildren ( ) ; Collection < T > filteredChildrenCopy = new ArrayList < T > ( filteredChildren ) ; for ( T child : filteredChildren ) { if ( isIgnoredMethod ( child ) ) { Description childDescription = describeChild ( child ) ; notifier . fireTestIgnored ( childDescription ) ; filteredChildrenCopy . remove ( child ) ; } } return Collections . unmodifiableCollection ( filteredChildrenCopy ) ;
protected Statement classBlock ( final RunNotifier notifier ) { Statement statement = childrenInvoker ( notifier ) ; if ( statementHasTestsToRun ( statement ) ) { statement = withBeforeClasses ( statement ) ; statement = withAfterClasses ( statement ) ; statement = withClassRules ( statement ) ; } return statement ; }
private boolean statementHasTestsToRun ( Statement statement ) { return statement instanceof ParentRunner . EmptyStatement = = false ; }
public void beforeFailsButTestIsFiltered ( ) { Result result = new JUnitCore ( ) . run ( Request . classes ( HasBeforeClassButTestIsFiltered . class , HasUnfilteredTest . class ) . filterWith ( CategoryFilter . exclude ( FilteredTests . class ) ) ) ; analyseResult ( result , " der fail " ) ; }
private void runClassAndVerifyNoFailures ( Class < ? > klass , String testFailureDescription ) { Result result = JUnitCore . runClasses ( klass ) ; analyseResult ( result , testFailureDescription ) ; }
private void analyseResult ( Result result , String testFailureDescription ) { List < Failure > failures = result . getFailures ( ) ; if ( failures . isEmpty ( ) = = false ) { analyzeFailure ( failures . get ( 0 ) , testFailureDescription ) ;
private void analyzeFailure ( Failure failure , String testFailureDescription ) { String actualFailureMsg = failure . getMessage ( ) ; if ( OUR_FAILURE_MSG . equals ( actualFailureMsg ) ) { fail ( testFailureDescription ) ; } fail ( " Unexpected failure : " + actualFailureMsg ) ; }
public static void beforeClass ( ) { fail ( OUR_FAILURE_MSG ) ; }
public static void afterClass ( ) { fail ( OUR_FAILURE_MSG ) ; }
public static void beforeClass ( ) { fail ( ClassLevelMethodsOnlyRunWhenNecessaryTest . OUR_FAILURE_MSG ) ; }
private boolean statementHasTestsToRun ( Statement statement ) { return statement ! = ALL_TESTS_IGNORED ; }
protected Statement childrenInvoker ( final RunNotifier notifier ) { final Collection < T > filteredChildrenWithoutIgnores = getFilteredChildrenWithoutIgnored ( notifier ) ; if ( filteredChildrenWithoutIgnores . isEmpty ( ) ) { return ALL_TESTS_IGNORED ; } return new Statement ( ) { @ Override
private Collection < T > getFilteredChildrenWithoutIgnored ( final RunNotifier notifier ) { final Collection < T > filteredChildren = getFilteredChildren ( ) ; Collection < T > filteredChildrenCopy = new ArrayList < T > ( filteredChildren ) ; for ( T child : filteredChildren ) { if ( isIgnoredMethod ( child ) ) { Description childDescription = describeChild ( child ) ; notifier . fireTestIgnored ( childDescription ) ; filteredChildrenCopy . remove ( child ) ; } } return Collections . unmodifiableCollection ( filteredChildrenCopy ) ;
public static void beforeClass ( ) { fail ( ClassLevelMethodsWithIgnoreTest . FAILURE_MESSAGE ) ; }
public void test ( ) throws Exception { fail ( " test ( ) should not run " ) ; }
public void beforeFailsButTestMethodIsIgnored ( ) { runClassAndVerifyNoFailures ( BeforeClassWithIgnoredTest . class , " BeforeClass should not have been executed because the test method is ignored ! " ) ;
public void wholeClassIsIgnored ( ) { runClassAndVerifyNoFailures ( BeforeClassWithIgnoredClass . class ,
public static void afterClass ( ) { fail ( ClassLevelMethodsWithIgnoreTest . FAILURE_MESSAGE ) ; }
public void afterFailsButTestMethodIsIgnored ( ) { runClassAndVerifyNoFailures ( AfterClassWithIgnoredTest . class ,
public void unfilteredTest ( ) { } } @ Test public void beforeFailsButTestIsFiltered ( ) { Result result = new JUnitCore ( ) . run ( Request . classes ( BeforeClassWithFilteredTest . class , HasUnfilteredTest . class ) . filterWith ( CategoryFilter . exclude ( FilteredTests . class ) ) ) ; analyseResult ( result , " der fail " ) ; } public static class BrokenRule implements TestRule { public Statement apply ( Statement base , Description description ) { throw new RuntimeException ( " this rule is broken " ) ; } } public static class ClassRuleWithIgnoredTest { @ ClassRule public static BrokenRule brokenRule = new BrokenRule ( ) ; @ Ignore @ Test public void test ( ) throws Exception { fail ( " test ( ) should not be run " ) ; } } @ Test public void brokenRuleButTestMethodIsIgnored ( ) { runClassAndVerifyNoFailures ( ClassRuleWithIgnoredTest . class , " The rule should have been executed because the test method is ignored ! " ) ; } private void runClassAndVerifyNoFailures ( Class < ? > klass , String testFailureDescription ) { Result result = JUnitCore . runClasses ( klass ) ; analyseResult ( result , testFailureDescription ) ; } private void analyseResult ( Result result , String testFailureDescription ) { List < Failure > failures = result . getFailures ( ) ; if ( failures . isEmpty ( ) = = false ) { analyzeFailure ( failures . get ( 0 ) , testFailureDescription ) ; } } private void analyzeFailure ( Failure failure , String testFailureDescription ) { String actualFailureMsg = failure . getMessage ( ) ; if ( FAILURE_MESSAGE . equals ( actualFailureMsg ) ) { fail ( testFailureDescription ) ; } fail ( " Unexpected failure : " + actualFailureMsg ) ; } }
public void beforeFailsButTestIsFiltered ( ) { Result result = new JUnitCore ( ) . run ( Request . classes ( BeforeClassWithFilteredTest . class , HasUnfilteredTest . class ) . filterWith ( CategoryFilter . exclude ( FilteredTests . class ) ) ) ; analyseResult ( result , " der fail " ) ; }
public void test ( ) throws Exception { fail ( " test ( ) should not be run " ) ; }
public void brokenRuleButTestMethodIsIgnored ( ) { runClassAndVerifyNoFailures ( ClassRuleWithIgnoredTest . class , " The rule should have been executed because the test method is ignored ! " ) ;
private void analyzeFailure ( Failure failure , String testFailureDescription ) { String actualFailureMsg = failure . getMessage ( ) ; if ( FAILURE_MESSAGE . equals ( actualFailureMsg ) ) { fail ( testFailureDescription ) ; } fail ( " Unexpected failure : " + actualFailureMsg ) ; }
public static void beforeClass ( ) { fail ( FAILURE_MESSAGE ) ; }
public void beforeClassShouldNotRunWhenAllTestsAreIgnored ( ) { runClassAndVerifyNoFailures ( BeforeClassWithIgnoredTest . class , " BeforeClass should not have been executed because the test method is ignored ! " ) ;
public void beforeClassShouldNotRunWhenWholeClassIsIgnored ( ) { runClassAndVerifyNoFailures ( BeforeClassWithIgnoredClass . class ,
public static void afterClass ( ) { fail ( FAILURE_MESSAGE ) ; }
public void afterClassShouldNotRunWhenAllTestsAreIgnored ( ) { runClassAndVerifyNoFailures ( AfterClassWithIgnoredTest . class ,
public void unfilteredTest ( ) { } } @ Test public void beforeClassShouldNotRunWhenAllTestsAreFiltered ( ) { Result result = new JUnitCore ( ) . run ( Request . classes ( BeforeClassWithFilteredTest . class , HasUnfilteredTest . class ) . filterWith ( CategoryFilter . exclude ( FilteredTests . class ) ) ) ; analyseResult ( result , " BeforeClass should not have been executed because the test method is filtered ! " ) ; } public static class BrokenRule implements TestRule { public Statement apply ( Statement base , Description description ) { throw new RuntimeException ( " this rule is broken " ) ; } } public static class ClassRuleWithIgnoredTest { @ ClassRule public static BrokenRule brokenRule = new BrokenRule ( ) ; @ Ignore @ Test public void test ( ) throws Exception { fail ( " test ( ) should not be run " ) ; } } @ Test public void classRuleShouldNotBeAppliedWhenAllTestsAreIgnored ( ) { runClassAndVerifyNoFailures ( ClassRuleWithIgnoredTest . class , " The class rule should have been applied because the test method is ignored ! " ) ; } private void runClassAndVerifyNoFailures ( Class < ? > klass , String testFailureDescription ) { Result result = JUnitCore . runClasses ( klass ) ; analyseResult ( result , testFailureDescription ) ; } private void analyseResult ( Result result , String testFailureDescription ) { List < Failure > failures = result . getFailures ( ) ; if ( failures . isEmpty ( ) = = false ) { analyzeFailure ( failures . get ( 0 ) , testFailureDescription ) ; } } private void analyzeFailure ( Failure failure , String testFailureDescription ) { String actualFailureMsg = failure . getMessage ( ) ; if ( FAILURE_MESSAGE . equals ( actualFailureMsg ) ) { fail ( testFailureDescription ) ; } fail ( " Unexpected failure : " + actualFailureMsg ) ; } }
public void beforeClassShouldNotRunWhenAllTestsAreFiltered ( ) { Result result = new JUnitCore ( ) . run ( Request . classes ( BeforeClassWithFilteredTest . class , HasUnfilteredTest . class ) . filterWith ( CategoryFilter . exclude ( FilteredTests . class ) ) ) ; analyseResult ( result , " BeforeClass should not have been executed because the test method is filtered ! " ) ; }
public void classRuleShouldNotBeAppliedWhenAllTestsAreIgnored ( ) { runClassAndVerifyNoFailures ( ClassRuleWithIgnoredTest . class , " The class rule should have been applied because the test method is ignored ! " ) ;
private Collection < T > getFilteredChildrenWithoutIgnored ( final RunNotifier notifier ) { final Collection < T > filteredChildren = getFilteredChildren ( ) ; Collection < T > filteredChildrenCopy = new ArrayList < T > ( filteredChildren ) ; for ( T child : filteredChildren ) { if ( isIgnoredMethod ( child ) ) { Description childDescription = describeChild ( child ) ; notifier . fireTestIgnored ( childDescription ) ; filteredChildrenCopy . remove ( child ) ; } } return Collections . unmodifiableCollection ( filteredChildrenCopy ) ;
public void afterClassShouldNotRunWhenAllTestsAreIgnored ( ) { runClassAndVerifyNoFailures ( AfterClassWithIgnoredTest . class , " AfterClass should not have been executed because the test method is ignored ! " ) ;
public void unfilteredTest ( ) { } } @ Test public void beforeClassShouldNotRunWhenAllTestsAreFiltered ( ) { Result result = new JUnitCore ( ) . run ( Request . classes ( BeforeClassWithFilteredTest . class , HasUnfilteredTest . class ) . filterWith ( CategoryFilter . exclude ( FilteredTests . class ) ) ) ; analyseResult ( result , " BeforeClass should not have been executed because the test method is filtered ! " ) ; } public static class BrokenRule implements TestRule { public Statement apply ( Statement base , Description description ) { throw new RuntimeException ( " this rule is broken " ) ; } } public static class ClassRuleWithIgnoredTest { @ ClassRule public static BrokenRule brokenRule = new BrokenRule ( ) ; @ Ignore @ Test public void test ( ) throws Exception { fail ( " test ( ) should not be run " ) ; } } @ Test public void classRuleShouldNotBeAppliedWhenAllTestsAreIgnored ( ) { runClassAndVerifyNoFailures ( ClassRuleWithIgnoredTest . class , " The class rule should have been applied because the test method is ignored ! " ) ; } private void runClassAndVerifyNoFailures ( Class < ? > klass , String testFailureDescription ) { Result result = JUnitCore . runClasses ( klass ) ; analyseResult ( result , testFailureDescription ) ; } private void analyseResult ( Result result , String testFailureDescription ) { List < Failure > failures = result . getFailures ( ) ; if ( failures . isEmpty ( ) = = false ) { analyzeFailure ( failures . get ( 0 ) , testFailureDescription ) ; } } private void analyzeFailure ( Failure failure , String testFailureDescription ) { String actualFailureMsg = failure . getMessage ( ) ; if ( FAILURE_MESSAGE . equals ( actualFailureMsg ) ) { fail ( testFailureDescription ) ; } fail ( " Unexpected failure : " + actualFailureMsg ) ; } }
public void beforeClassShouldNotRunWhenAllTestsAreFiltered ( ) { Result result = new JUnitCore ( ) . run ( Request . classes ( BeforeClassWithFilteredTest . class , HasUnfilteredTest . class ) . filterWith ( CategoryFilter . exclude ( FilteredTests . class ) ) ) ; analyseResult ( result ,
private Collection < T > getFilteredChildrenWithoutIgnored ( final RunNotifier notifier ) { final Collection < T > filteredChildren = getFilteredChildren ( ) ; Collection < T > filteredChildrenCopy = new ArrayList < T > ( filteredChildren ) ; for ( T child : filteredChildren ) { if ( isIgnoredMethod ( child ) ) { Description childDescription = describeChild ( child ) ; notifier . fireTestIgnored ( childDescription ) ; filteredChildrenCopy . remove ( child ) ; } } return Collections . unmodifiableCollection ( filteredChildrenCopy ) ;
protected void runChild ( final FrameworkMethod method , RunNotifier notifier ) { Description description = describeChild ( method ) ; if ( isIgnored ( method ) ) { notifier . fireTestIgnored ( description ) ;
protected boolean isIgnored ( FrameworkMethod child ) { return child . getAnnotation ( Ignore . class ) ! = null ; }
private Collection < T > getFilteredChildrenWithoutIgnored ( final RunNotifier notifier ) { final Collection < T > filteredChildren = getFilteredChildren ( ) ; Collection < T > filteredChildrenCopy = new ArrayList < T > ( filteredChildren ) ; for ( T child : filteredChildren ) { if ( isIgnored ( child ) ) { Description childDescription = describeChild ( child ) ; notifier . fireTestIgnored ( childDescription ) ; filteredChildrenCopy . remove ( child ) ; } } return Collections . unmodifiableCollection ( filteredChildrenCopy ) ;
protected boolean isIgnored ( T child ) { return false ; }
private boolean statementHasTestsToRun ( Statement statement ) { if ( statement instanceof ParentRunner . ChildrenAwareStatement = = false ) { return true ; } @ SuppressWarnings ( " unchecked " ) Collection < T > children = ( ( ParentRunner < T > . ChildrenAwareStatement ) statement ) . getChildren ( ) ; return isAnyChildNotIgnored ( children ) ; }
private boolean isAnyChildNotIgnored ( Collection < T > children ) { for ( T child : children ) { if ( isIgnored ( child ) = = false ) { return true ; } } return false ; }
public void evaluate ( ) { runChildren ( notifier , getChildren ( ) ) ; }
private Thread [ ] copyThreads ( Thread [ ] threads , int count ) { int length = Math . min ( count , threads . length ) ; Thread [ ] result = new Thread [ length ] ; for ( int i = 0 ; i < length ; i + + ) result [ i ] = threads [ i ] ; return result ; }
protected Statement classBlock ( final RunNotifier notifier ) { Statement statement = childrenInvoker ( notifier ) ; if ( areAllChildrenIgnored ( ) = = false ) { statement = withBeforeClasses ( statement ) ; statement = withAfterClasses ( statement ) ; statement = withClassRules ( statement ) ; } return statement ; }
protected Statement classBlock ( final RunNotifier notifier ) { Statement statement = childrenInvoker ( notifier ) ; if ( ! areAllChildrenIgnored ( ) ) { statement = withBeforeClasses ( statement ) ; statement = withAfterClasses ( statement ) ; statement = withClassRules ( statement ) ; } return statement ; }
protected TestClass createTestClass ( Class < ? > testClass ) { return new TestClass ( testClass ) ; }
public Timeout lookingForStuckThread ( boolean enable ) { return new Timeout ( this , enable ) ; }
public void success ( ) { } } @ Test public void successWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( SuccessWithTimeoutTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } public static class TimeoutFailureTest { @ Test ( timeout = 100 ) public void success ( ) throws InterruptedException { Thread . sleep ( 40000 ) ; } } @ Ignore ( " was breaking gump " ) @ Test public void timeoutFailure ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeoutFailureTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; assertEquals ( InterruptedException . class , result . getFailures ( ) . get ( 0 ) . getException ( ) . getClass ( ) ) ; } public static class InfiniteLoopTest { @ Test ( timeout = 100 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { } } } } @ Test public void infiniteLoop ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertTrue ( exception . getMessage ( ) . contains ( " test timed out after 100 milliseconds " ) ) ; } public static class ImpatientLoopTest { @ Test ( timeout = 1 ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) ; } } @ Ignore ( " This breaks sporadically with time differences just slightly more than 200ms " ) @ Test public void infiniteLoopRunsForApproximatelyLengthOfTimeout ( ) throws Exception { JUnitCore . runClasses ( InfiniteLoopTest . class , ImpatientLoopTest . class ) ; long longTime = runAndTime ( InfiniteLoopTest . class ) ; long shortTime = runAndTime ( ImpatientLoopTest . class ) ; long difference = longTime - shortTime ; assertTrue ( String . format ( " Difference was % sms " , difference ) , difference < 200 ) ; } private long runAndTime ( Class < ? > clazz ) { JUnitCore core = new JUnitCore ( ) ; long startTime = System . currentTimeMillis ( ) ; core . run ( clazz ) ; long totalTime = System . currentTimeMillis ( ) - startTime ; return totalTime ; } private String stackForException ( Throwable exception ) { Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; return buffer . toString ( ) ; } @ Test public void stalledThreadAppearsInStackTrace ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( stackForException ( exception ) , containsString ( " infiniteLoop " ) ) ; } public static class InfiniteLoopMultithreaded { private static class ThreadTest implements Runnable { private boolean fStall ; public ThreadTest ( boolean stall ) { fStall = stall ; } public void run ( ) { if ( fStall ) for ( ; ; ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } } public void failure ( boolean mainThreadStalls ) throws Exception { Thread t1 = new Thread ( new ThreadTest ( false ) , " timeout - thr1 " ) ; Thread t2 = new Thread ( new ThreadTest ( ! mainThreadStalls ) , " timeout - thr2 " ) ; Thread t3 = new Thread ( new ThreadTest ( false ) , " timeout - thr3 " ) ; t1 . start ( ) ; t2 . start ( ) ; t3 . start ( ) ; if ( mainThreadStalls ) for ( ; ; ) ; t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; } } public static class InfiniteLoopWithStuckThreadTest { @ Rule public TestRule globalTimeout = new Timeout ( 100 , TimeUnit . MILLISECONDS ) . lookingForStuckThread ( true ) ; @ Test public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( false ) ; } } public static class InfiniteLoopStuckInMainThreadTest { @ Rule public TestRule globalTimeout = new Timeout ( 100 , TimeUnit . MILLISECONDS ) . lookingForStuckThread ( true ) ; @ Test public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( true ) ; } } @ Test public void timeoutFailureMultithreaded ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopWithStuckThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 2 , result . getFailureCount ( ) ) ; Throwable exception [ ] = new Throwable [ 2 ] ; for ( int i = 0 ; i < 2 ; i + + ) exception [ i ] = result . getFailures ( ) . get ( i ) . getException ( ) ; assertThat ( exception [ 0 ] . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( stackForException ( exception [ 0 ] ) , containsString ( " Thread . join " ) ) ; assertThat ( exception [ 1 ] . getMessage ( ) , containsString ( " Appears to be stuck in thread timeout - thr2 " ) ) ; } @ Test public void timeoutFailureMultithreadedStuckInMain ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopStuckInMainThreadTest . class ) ; assertEquals ( 1 , result . getRunCount ( ) ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( 0 ) . getException ( ) ; assertThat ( exception . getMessage ( ) , containsString ( " test timed out after 100 milliseconds " ) ) ; assertThat ( exception . getMessage ( ) , not ( containsString ( " Appears to be stuck " ) ) ) ; } @ Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( InfiniteLoopTest . class ) . run ( result ) ; assertEquals ( 1 , result . errorCount ( ) ) ; } public static class WillTimeOut { static boolean afterWasCalled = false ; @ Test ( timeout = 1 ) public void test ( ) { for ( ; ; ) { try { Thread . sleep ( 10000 ) ; } catch ( InterruptedException e ) { } } } @ After public void after ( ) { afterWasCalled = true ; } } @ Test public void makeSureAfterIsCalledAfterATimeout ( ) { JUnitCore . runClasses ( WillTimeOut . class ) ; assertThat ( WillTimeOut . afterWasCalled , is ( true ) ) ; } }
private void validateMember ( FrameworkMember < ? > member , List < Throwable > errors ) { validatePublicClass ( member , errors ) ; validateStatic ( member , errors ) ; validatePublic ( member , errors ) ; validateTestRuleOrMethodRule ( member , errors ) ; }
private void validatePublicClass ( FrameworkMember < ? > member , List < Throwable > errors ) { if ( fStaticMembers & & ! isDeclaringClassPublic ( member ) ) { addError ( errors , member , " must be declared in a public class . " ) ;
private void validateStatic ( FrameworkMember < ? > member , List < Throwable > errors ) { if ( fStaticMembers & & ! member . isStatic ( ) ) { addError ( errors , member , " must be static . " ) ; } if ( ! fStaticMembers & & member . isStatic ( ) ) { addError ( errors , member , " must not be static . " ) ;
private boolean isDeclaringClassPublic ( FrameworkMember < ? > member ) { return Modifier . isPublic ( member . getDeclaringClass ( ) . getModifiers ( ) ) ; }
abstract Annotation [ ] getAnnotations ( ) ; abstract boolean isShadowedBy ( T otherMember ) ; boolean isShadowedBy ( List < T > members ) { for ( T each : members ) { if ( isShadowedBy ( each ) ) { return true ; } } return false ; } public abstract boolean isPublic ( ) ; public abstract boolean isStatic ( ) ; public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
abstract boolean isShadowedBy ( T otherMember ) ; boolean isShadowedBy ( List < T > members ) { for ( T each : members ) { if ( isShadowedBy ( each ) ) { return true ; } } return false ; } public abstract boolean isPublic ( ) ; public abstract boolean isStatic ( ) ; public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
public abstract boolean isPublic ( ) ; public abstract boolean isStatic ( ) ; public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
public abstract boolean isStatic ( ) ; public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
public void rejectClassRuleInNonPublicClass ( ) { TestClass target = new TestClass ( NonPublicTestWithClassRule . class ) ; CLASS_RULE_VALIDATOR . validate ( target , errors ) ; assertOneErrorWithMessage ( " The @ ClassRule ' temporaryFolder ' must be declared in a public class . " ) ; }
private boolean hasCorrectCategoryAnnotation ( Description description ) { final Set < Class < ? > > childCategories = categories ( description ) ; if ( childCategories . isEmpty ( ) ) { return fIncluded . isEmpty ( ) ; } if ( ! fExcluded . isEmpty ( ) ) { if ( fExcludedAny ) { if ( matchesAnyParentCategories ( childCategories , fExcluded ) ) { return false ; } } else { if ( matchesAllParentCategories ( childCategories , fExcluded ) ) { return false ; } } } if ( fIncluded . isEmpty ( ) ) {
public List < Exception > validateAnnotatedMethod ( FrameworkMethod method ) { List < Exception > errors = new ArrayList < Exception > ( ) ; Annotation [ ] annotations = method . getAnnotations ( ) ; for ( Annotation annotation : annotations ) { for ( Class < ? > clazz : INCOMPATIBLE_ANNOTATIONS ) { if ( annotation . annotationType ( ) . isAssignableFrom ( clazz ) ) { addErrorMessage ( errors , clazz ) ; } } } return unmodifiableList ( errors ) ; }
private void addErrorMessage ( List < Exception > errors , Class < ? > clazz ) { String message = String . format ( " @ % s can not be combined with @ Category " , clazz . getSimpleName ( ) ) ; errors . add ( new Exception ( message ) ) ; }
protected Filter createFilter ( Class < ? > . . . categories ) { return new DummyFilter ( ) ; }
public void namedListenerCorrectlyImplementsEqualsAndHashCode ( ) { NamedListener listener1 = new NamedListener ( " blue " ) ; NamedListener listener2 = new NamedListener ( " blue " ) ; NamedListener listener3 = new NamedListener ( " red " ) ; assertTrue ( listener1 . equals ( listener1 ) ) ; assertTrue ( listener2 . equals ( listener2 ) ) ; assertTrue ( listener3 . equals ( listener3 ) ) ; assertFalse ( listener1 . equals ( null ) ) ; assertFalse ( listener1 . equals ( new Object ( ) ) ) ; assertTrue ( listener1 . equals ( listener2 ) ) ; assertTrue ( listener2 . equals ( listener1 ) ) ; assertFalse ( listener1 . equals ( listener3 ) ) ; assertFalse ( listener3 . equals ( listener1 ) ) ; assertEquals ( listener1 . hashCode ( ) , listener2 . hashCode ( ) ) ; assertNotEquals ( listener1 . hashCode ( ) , listener3 . hashCode ( ) ) ; }
public void toStringDelegates ( ) { NamedListener listener = new NamedListener ( " blue " ) ; assertEquals ( " NamedListener " , listener . toString ( ) ) ; assertEquals ( " NamedListener ( with synchronization wrapper ) " , wrap ( listener ) . toString ( ) ) ; }
public void equalsDelegates ( ) { NamedListener listener1 = new NamedListener ( " blue " ) ; NamedListener listener2 = new NamedListener ( " blue " ) ; NamedListener listener3 = new NamedListener ( " red " ) ; assertEquals ( wrap ( listener1 ) , wrap ( listener1 ) ) ; assertEquals ( wrap ( listener1 ) , wrap ( listener2 ) ) ; assertNotEquals ( wrap ( listener1 ) , wrap ( listener3 ) ) ; assertNotEquals ( wrap ( listener1 ) , listener1 ) ; assertNotEquals ( listener1 , wrap ( listener1 ) ) ; }
public void nothing ( ) { } } @ Test public void ruleIsIntroducedAndEvaluated ( ) { wasRun = false ; JUnitCore . runClasses ( ExampleTest . class ) ; assertTrue ( wasRun ) ; } public static class SonOfExampleTest extends ExampleTest { } @ Test public void ruleIsIntroducedAndEvaluatedOnSubclass ( ) { wasRun = false ; JUnitCore . runClasses ( SonOfExampleTest . class ) ; assertTrue ( wasRun ) ; } private static int runCount ; public static class MultipleRuleTest { private static class Increment implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { runCount + + ; base . evaluate ( ) ; } ; } ; } } @ Rule public MethodRule incrementor1 = new Increment ( ) ; @ Rule public MethodRule incrementor2 = new Increment ( ) ; @ Test public void nothing ( ) { } } @ Test public void multipleRulesAreRun ( ) { runCount = 0 ; JUnitCore . runClasses ( MultipleRuleTest . class ) ; assertEquals ( 2 , runCount ) ; } public static class NoRulesTest { public int x ; @ Test public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { Result result = JUnitCore . runClasses ( NoRulesTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; Result result = JUnitCore . runClasses ( OnFailureTest . class ) ; assertEquals ( " nothing AssertionError " , log ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } }
public void nothing ( ) { } } @ Test public void multipleRulesAreRun ( ) { runCount = 0 ; JUnitCore . runClasses ( MultipleRuleTest . class ) ; assertEquals ( 2 , runCount ) ; } public static class NoRulesTest { public int x ; @ Test public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { Result result = JUnitCore . runClasses ( NoRulesTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; Result result = JUnitCore . runClasses ( OnFailureTest . class ) ; assertEquals ( " nothing AssertionError " , log ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } }
public void nothing ( ) { } } @ Test public void ignoreNonRules ( ) { Result result = JUnitCore . runClasses ( NoRulesTest . class ) ; assertEquals ( 0 , result . getFailureCount ( ) ) ; } private static String log ; public static class OnFailureTest { @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) ; } } ; @ Test public void nothing ( ) { fail ( ) ; } } @ Test public void onFailure ( ) { log = " " ; Result result = JUnitCore . runClasses ( OnFailureTest . class ) ; assertEquals ( " nothing AssertionError " , log ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } public static class WatchmanTest { private static String watchedLog ; @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + e . getClass ( ) . getSimpleName ( ) + " \ n " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + " " + " success ! \ n " ; } } ; @ Test public void fails ( ) { fail ( ) ; } @ Test public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } }
public void succeeds ( ) { } } @ Test public void succeeded ( ) { WatchmanTest . watchedLog = " " ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " fails AssertionError " ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( " succeeds success ! " ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @ Before public void before ( ) { watchedLog + = " before " ; } @ Rule public MethodRule watchman = new TestWatchman ( ) { @ Override public void starting ( FrameworkMethod method ) { watchedLog + = " starting " ; } @ Override public void finished ( FrameworkMethod method ) { watchedLog + = " finished " ; } @ Override public void succeeded ( FrameworkMethod method ) { watchedLog + = " succeeded " ; } } ; @ After public void after ( ) { watchedLog + = " after " ; } @ Test public void succeeds ( ) { watchedLog + = " test " ; } } @ Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = " " ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( " starting before test after succeeded finished " ) ) ; } public static class WrongTypedField { @ Rule public int x = 5 ; @ Test public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } }
public void foo ( ) { } } @ Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @ Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( " must implement MethodRule " ) ) ; } public static class PrivateRule { @ Rule private TestRule rule = new TestName ( ) ; @ Test public void foo ( ) { } } @ Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( " must be public " ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @ Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @ Rule public CustomTestName counter = new CustomTestName ( ) ; @ Test public void foo ( ) { assertEquals ( " foo " , counter . name ) ; } } @ Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } }
public void run5 ( ) throws IOException { logger . append ( " run5 " ) ; Random rnd = new Random ( ) ; byte [ ] data = new byte [ 1024 ] ; File tmp = tmpFile . newFile ( ) ; while ( true ) { RandomAccessFile randomAccessFile = new RandomAccessFile ( tmp , " rw " ) ;
public void timeUnitTimeout ( ) { HasGlobalTimeUnitTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalTimeUnitTimeout . class ) ; assertEquals ( 6 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run4 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run5 " ) ) ; assertThat ( HasGlobalTimeUnitTimeout . logger . toString ( ) , containsString ( " run6 " ) ) ; }
public void longTimeout ( ) { HasGlobalLongTimeout . logger . setLength ( 0 ) ; Result result = JUnitCore . runClasses ( HasGlobalLongTimeout . class ) ; assertEquals ( 6 , result . getFailureCount ( ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run1 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run2 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run3 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run4 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run5 " ) ) ; assertThat ( HasGlobalLongTimeout . logger . toString ( ) , containsString ( " run6 " ) ) ; }
public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } }
public void validatorIsCalledForAMethod ( ) { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ;
public String methodToBeMatched ( ) { return " jupiter " ; }
private Exception createTimeoutException ( Thread thread ) { StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; final Thread stuckThread = fLookForStuckThread ? getStuckThread ( thread ) : null ; Exception currThreadException = new TestFailedOnTimeoutException ( String . format ( " test timed out after % d % s " , fTimeout , fTimeUnit . name ( ) . toLowerCase ( ) ) ) ; if ( stackTrace ! = null ) { currThreadException . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } if ( stuckThread ! = null ) { Exception stuckThreadException =
public void throwsTestFailedWithTimeoutException ( ) throws Throwable { thrown . expect ( TestFailedOnTimeoutException . class ) ; evaluateWithWaitDuration ( TIMEOUT + 50 ) ; }
private Exception createTimeoutException ( Thread thread ) { StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; final Thread stuckThread = fLookForStuckThread ? getStuckThread ( thread ) : null ; Exception currThreadException = new TestFailedOnTimeoutException ( fTimeout , fTimeUnit ) ; if ( stackTrace ! = null ) { currThreadException . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } if ( stuckThread ! = null ) { Exception stuckThreadException =
public void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime ( ) throws Throwable { thrown . expect ( TestFailedOnTimeoutException . class ) ; evaluateWithWaitDuration ( 0 ) ; evaluateWithWaitDuration ( TIMEOUT + 50 ) ; }
public void throwsExceptionWithTimeoutValueAndTimeUnitSet ( ) throws Throwable { thrown . expect ( exceptionWithTimeout ( 100 , TimeUnit . MILLISECONDS ) ) ; evaluateWithWaitDuration ( TIMEOUT + 50 ) ; }
private BaseMatcher < TestFailedOnTimeoutException > exceptionWithTimeout ( final long timeout , final TimeUnit unit ) { return new BaseMatcher < TestFailedOnTimeoutException > ( ) {
public boolean matches ( Object item ) { TestFailedOnTimeoutException exception = ( TestFailedOnTimeoutException ) item ; return exception . getTimeout ( ) = = timeout & & exception . getTimeUnit ( ) . equals ( unit ) ;
public void describeTo ( Description description ) { description . appendText ( String . format ( " timeout value of % d % s " , timeout , unit . name ( ) . toLowerCase ( ) ) ) ;
public void describeMismatch ( Object item , Description description ) { TestFailedOnTimeoutException exception = ( TestFailedOnTimeoutException ) item ; description . appendText ( String . format ( " was timeout value of % d % s " , exception . getTimeout ( ) , exception . getTimeUnit ( ) . name ( ) . toLowerCase ( ) ) ) ;
public void throwsExceptionWithTimeoutValueAndTimeUnitSet ( ) throws Throwable { try { evaluateWithWaitDuration ( TIMEOUT + 50 ) ;
private Exception createTimeoutException ( Thread thread ) { StackTraceElement [ ] stackTrace = thread . getStackTrace ( ) ; final Thread stuckThread = fLookForStuckThread ? getStuckThread ( thread ) : null ; Exception currThreadException = new TestTimedOutException ( fTimeout , fTimeUnit ) ; if ( stackTrace ! = null ) { currThreadException . setStackTrace ( stackTrace ) ; thread . interrupt ( ) ; } if ( stuckThread ! = null ) { Exception stuckThreadException =
public void throwsTestTimedOutException ( ) throws Throwable { thrown . expect ( TestTimedOutException . class ) ; evaluateWithWaitDuration ( TIMEOUT + 50 ) ; }
public void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime ( ) throws Throwable { thrown . expect ( TestTimedOutException . class ) ; evaluateWithWaitDuration ( 0 ) ; evaluateWithWaitDuration ( TIMEOUT + 50 ) ; }
public void cannotBeCreatedWithoutUnderlyingField ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( " FrameworkField cannot be created without an underlying field . " ) ; new FrameworkField ( null ) ; }
public void cannotBeCreatedWithoutUnderlyingField ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( " FrameworkMethod cannot be created without an underlying method . " ) ; new FrameworkMethod ( null ) ; }
public String toString ( ) { return fField . toString ( ) ; }
public String toString ( ) { return fMethod . toString ( ) ; }
public void hasToStringWhichPrintsFieldName ( ) throws Exception { Field field = ClassWithDummyField . class . getField ( " dummyField " ) ; FrameworkField frameworkField = new FrameworkField ( field ) ; assertTrue ( frameworkField . toString ( ) . contains ( " dummyField " ) ) ; }
public void hasToStringWhichPrintsMethodName ( ) throws Exception { Method method = ClassWithDummyMethod . class . getMethod ( " dummyMethod " ) ; FrameworkMethod frameworkMethod = new FrameworkMethod ( method ) ; assertTrue ( frameworkMethod . toString ( ) . contains ( " dummyMethod " ) ) ; }
abstract Annotation [ ] getAnnotations ( ) ; abstract boolean isShadowedBy ( T otherMember ) ; boolean isShadowedBy ( List < T > members ) { for ( T each : members ) { if ( isShadowedBy ( each ) ) { return true ; } } return false ; } protected abstract int getModifiers ( ) ; public boolean isStatic ( ) { return Modifier . isStatic ( getModifiers ( ) ) ; } public boolean isPublic ( ) { return Modifier . isPublic ( getModifiers ( ) ) ; } public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
abstract boolean isShadowedBy ( T otherMember ) ; boolean isShadowedBy ( List < T > members ) { for ( T each : members ) { if ( isShadowedBy ( each ) ) { return true ; } } return false ; } protected abstract int getModifiers ( ) ; public boolean isStatic ( ) { return Modifier . isStatic ( getModifiers ( ) ) ; } public boolean isPublic ( ) { return Modifier . isPublic ( getModifiers ( ) ) ; } public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
protected abstract int getModifiers ( ) ; public boolean isStatic ( ) { return Modifier . isStatic ( getModifiers ( ) ) ; } public boolean isPublic ( ) { return Modifier . isPublic ( getModifiers ( ) ) ; } public abstract String getName ( ) ; public abstract Class < ? > getType ( ) ; public abstract Class < ? > getDeclaringClass ( ) ; }
public boolean isStatic ( ) { return Modifier . isStatic ( getModifiers ( ) ) ; }
public boolean isPublic ( ) { return Modifier . isPublic ( getModifiers ( ) ) ; }
public void throwsTestTimedOutException ( ) throws Throwable { thrown . expect ( TestTimedOutException . class ) ; evaluateWithWaitDuration ( TIMEOUT + 50 ) ; }
protected void collectInitializationErrors ( List < Throwable > errors ) { validatePublicVoidNoArgMethods ( BeforeClass . class , true , errors ) ; validatePublicVoidNoArgMethods ( AfterClass . class , true , errors ) ; validateClassRules ( errors ) ; errors . addAll ( fAnnotationsValidator . validateTestClass ( getTestClass ( ) ) ) ; }
private < T > List < T > collectValues ( Map < ? , List < T > > map ) { Set < T > values = new LinkedHashSet < T > ( ) ; for ( List < T > additionalValues : map . values ( ) ) { values . addAll ( additionalValues ) ; } return new ArrayList < T > ( values ) ; }
public int compare ( Field left , Field right ) { return left . getName ( ) . compareTo ( right . getName ( ) ) ; }
public int compare ( FrameworkMethod left , FrameworkMethod right ) { return NAME_ASCENDING . compare ( left . getMethod ( ) , right . getMethod ( ) ) ; }
public AnnotationValidator createAnnotationValidator ( ValidateWith validateWithAnnotation ) { AnnotationValidator validator = VALIDATORS_FOR_ANNOTATION_TYPES . get ( validateWithAnnotation ) ; if ( validator ! = null ) { return validator ; } Class < ? extends AnnotationValidator > clazz = validateWithAnnotation . value ( ) ; if ( clazz = = null ) { throw new IllegalArgumentException ( " Can ' t create validator , value is null in annotation " + validateWithAnnotation . getClass ( ) . getName ( ) ) ; } try { AnnotationValidator annotationValidator = clazz . newInstance ( ) ;
public List < Exception > validateTestClass ( TestClass testClass ) { List < Exception > validationErrors = new ArrayList < Exception > ( ) ; for ( AnnotatableValidator < ? > validator : VALIDATORS ) { List < Exception > additionalErrors = validator . validateTestClass ( testClass ) ; validationErrors . addAll ( additionalErrors ) ; } return validationErrors ; }
List < Exception > validateAnnotatable ( AnnotationValidator validator , TestClass testClass ) { return validator . validateAnnotatedClass ( testClass ) ; }
Iterable < FrameworkMethod > getAnnotatablesForTestClass ( TestClass testClass ) { return testClass . getAnnotatedMethods ( ) ; }
List < Exception > validateAnnotatable ( AnnotationValidator validator , FrameworkMethod method ) { return validator . validateAnnotatedMethod ( method ) ; }
List < Exception > validateAnnotatable ( AnnotationValidator validator , FrameworkField field ) { return validator . validateAnnotatedField ( field ) ; }
public void providesAnnotatedFieldsSortedByName ( ) { TestClass tc = new TestClass ( FieldAnnotated . class ) ; List < FrameworkField > annotatedFields = tc . getAnnotatedFields ( ) ; assertThat ( " Wrong number of annotated fields . " , annotatedFields . size ( ) , is ( 3 ) ) ; assertThat ( " First annotated field is wrong . " , annotatedFields . iterator ( ) . next ( ) . getName ( ) , is ( " fieldA " ) ) ;
public void annotatedFieldValues ( ) { TestClass tc = new TestClass ( FieldAnnotated . class ) ; List < String > values = tc . getAnnotatedFieldValues ( new FieldAnnotated ( ) , Rule . class , String . class ) ; assertThat ( values , hasItem ( " andromeda " ) ) ; assertThat ( values . size ( ) , is ( 1 ) ) ; }
public int methodC ( ) { return 0 ; }
public String methodA ( ) { return " jupiter " ; }
public int methodB ( ) { return 0 ; }
public void providesAnnotatedMethodsSortedByName ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; List < FrameworkMethod > annotatedMethods = tc . getAnnotatedMethods ( ) ; assertThat ( " Wrong number of annotated methods . " , annotatedMethods . size ( ) , is ( 3 ) ) ; assertThat ( " First annotated method is wrong . " , annotatedMethods . iterator ( ) . next ( ) . getName ( ) , is ( " methodA " ) ) ;
public void annotatedMethodValues ( ) { TestClass tc = new TestClass ( MethodsAnnotated . class ) ; List < String > values = tc . getAnnotatedMethodValues ( new MethodsAnnotated ( ) , Ignore . class , String . class ) ; assertThat ( values , hasItem ( " jupiter " ) ) ; assertThat ( values . size ( ) , is ( 1 ) ) ; }
public void test ( ) { } } public static class AnnotationValidatorFieldTest { @ ExampleAnnotationWithValidator private String field ; @ Test public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String expectedFailure ) { AnnotationsValidator validator = new AnnotationsValidator ( ) ; Collection < Exception > errors = validator . validateTestClass ( new TestClass ( klass ) ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; assertThat ( errors . iterator ( ) . next ( ) . getMessage ( ) , is ( expectedFailure ) ) ; } }
public void test ( ) { } } @ ExampleAnnotationWithValidator public static class AnnotationValidatorClassTest { @ Test public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String expectedFailure ) { AnnotationsValidator validator = new AnnotationsValidator ( ) ; Collection < Exception > errors = validator . validateTestClass ( new TestClass ( klass ) ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; assertThat ( errors . iterator ( ) . next ( ) . getMessage ( ) , is ( expectedFailure ) ) ; } }
public void test ( ) { } } @ Test public void validatorIsCalledForAClass ( ) { assertClassHasFailureMessage ( AnnotationValidatorClassTest . class , ExampleAnnotationValidator . ANNOTATED_CLASS_CALLED ) ; } @ Test public void validatorIsCalledForAMethod ( ) { assertClassHasFailureMessage ( AnnotationValidatorMethodTest . class , ExampleAnnotationValidator . ANNOTATED_METHOD_CALLED ) ; } @ Test public void validatorIsCalledForAField ( ) { assertClassHasFailureMessage ( AnnotationValidatorFieldTest . class , ExampleAnnotationValidator . ANNOTATED_FIELD_CALLED ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String expectedFailure ) { AnnotationsValidator validator = new AnnotationsValidator ( ) ; Collection < Exception > errors = validator . validateTestClass ( new TestClass ( klass ) ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; assertThat ( errors . iterator ( ) . next ( ) . getMessage ( ) , is ( expectedFailure ) ) ; } }
private void assertClassHasFailureMessage ( Class < ? > klass , String expectedFailure ) { AnnotationsValidator validator = new AnnotationsValidator ( ) ; Collection < Exception > errors = validator . validateTestClass ( new TestClass ( klass ) ) ; assertThat ( errors . size ( ) , is ( 1 ) ) ; assertThat ( errors . iterator ( ) . next ( ) . getMessage ( ) , is ( expectedFailure ) ) ;
protected abstract Filter createFilter ( List < Class < ? > > categories ) ; private List < Class < ? > > parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = Classes . getClass ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses ; } }
private List < Class < ? > > parseCategories ( String categories ) throws ClassNotFoundException { List < Class < ? > > categoryClasses = new ArrayList < Class < ? > > ( ) ; for ( String category : categories . split ( " , " ) ) { Class < ? > categoryClass = Classes . getClass ( category ) ; categoryClasses . add ( categoryClass ) ; } return categoryClasses ; }
protected Filter createFilter ( List < Class < ? > > categories ) { return new ExcludesAny ( categories ) ; }
protected Filter createFilter ( List < Class < ? > > categories ) { return new IncludesAny ( categories ) ; }
protected Filter createFilter ( List < Class < ? > > categories ) { return new DummyFilter ( ) ; }
static public void assertEquals ( String message , double expected , double actual , double delta ) { if ( Double . compare ( expected , actual ) = = 0 ) { return ; } if ( ! ( Math . abs ( expected - actual ) < = delta ) ) { failNotEquals ( message , Double . valueOf ( expected ) , Double . valueOf ( actual ) ) ;
static public void assertEquals ( String message , float expected , float actual , float delta ) { if ( Float . compare ( expected , actual ) = = 0 ) { return ; } if ( ! ( Math . abs ( expected - actual ) < = delta ) ) { failNotEquals ( message , Float . valueOf ( expected ) , Float . valueOf ( actual ) ) ;
static public void assertEquals ( String message , long expected , long actual ) { assertEquals ( message , Long . valueOf ( expected ) , Long . valueOf ( actual ) ) ; }
static public void assertEquals ( String message , byte expected , byte actual ) { assertEquals ( message , Byte . valueOf ( expected ) , Byte . valueOf ( actual ) ) ; }
static public void assertEquals ( String message , char expected , char actual ) { assertEquals ( message , Character . valueOf ( expected ) , Character . valueOf ( actual ) ) ; }
static public void assertEquals ( String message , short expected , short actual ) { assertEquals ( message , Short . valueOf ( expected ) , Short . valueOf ( actual ) ) ; }
static public void assertEquals ( String message , int expected , int actual ) { assertEquals ( message , Integer . valueOf ( expected ) , Integer . valueOf ( actual ) ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( fFailedTest + " : " + fThrownException . getMessage ( ) ) ; return sb . toString ( ) ; }
public String trace ( ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; thrownException ( ) . printStackTrace ( writer ) ; return stringWriter . toString ( ) ; }
public static String join ( String delimiter , Collection < Object > values ) { StringBuilder sb = new StringBuilder ( ) ; Iterator < Object > iter = values . iterator ( ) ; while ( iter . hasNext ( ) ) { Object next = iter . next ( ) ; sb . append ( stringValueOf ( next ) ) ; if ( iter . hasNext ( ) ) { sb . append ( delimiter ) ; } } return sb . toString ( ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getTestHeader ( ) + " : " + fThrownException . getMessage ( ) ) ; return sb . toString ( ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ " + amount ( ) + " " + currency ( ) + " ] " ) ; return sb . toString ( ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; for ( Money each : fMonies ) { sb . append ( each ) ; } sb . append ( " } " ) ; return sb . toString ( ) ; }
public String toString ( ) { return fFailedTest + " : " + fThrownException . getMessage ( ) ; }
public String toString ( ) { return getTestHeader ( ) + " : " + fThrownException . getMessage ( ) ; }
public String toString ( ) { return " [ " + amount ( ) + " " + currency ( ) + " ] " ; }
public String toString ( ) { return fTestRunsStarted . size ( ) + " test runs started , " + fTestRunsFinished . size ( ) + " test runs finished , "
public boolean equals ( Object obj ) { return obj instanceof ParameterizedAssertionError & & toString ( ) . equals ( obj . toString ( ) ) ; }
public void isNotEqualToNull ( ParameterizedAssertionError a ) { assertFalse ( a . equals ( null ) ) ; }
public static junit . framework . Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( new OldTest ( " notObviouslyATest " ) ) ; return suite ; }
public Integer runWithCheckForSystemExit ( Runnable runnable ) { SecurityManager oldSecurityManager = System . getSecurityManager ( ) ; System . setSecurityManager ( new NoExitSecurityManager ( oldSecurityManager ) ) ; PrintStream oldOut = System . out ; System . setOut ( new PrintStream ( new ByteArrayOutputStream ( ) ) ) ; try { runnable . run ( ) ;
public void addError ( Test test , Throwable e ) ; public void addFailure ( Test test , AssertionFailedError e ) ; public void endTest ( Test test ) ; public void startTest ( Test test ) ; }
public void addFailure ( Test test , AssertionFailedError e ) ; public void endTest ( Test test ) ; public void startTest ( Test test ) ; }
public synchronized void addError ( Test test , Throwable e ) { fErrors . add ( new TestFailure ( test , e ) ) ; for ( TestListener each : cloneListeners ( ) ) { each . addError ( test , e ) ;
public synchronized void addFailure ( Test test , AssertionFailedError e ) { fFailures . add ( new TestFailure ( test , e ) ) ; for ( TestListener each : cloneListeners ( ) ) { each . addFailure ( test , e ) ;
private static String exceptionToString ( Throwable e ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; e . printStackTrace ( writer ) ; return stringWriter . toString ( ) ; }
public synchronized void addError ( final Test test , final Throwable e ) { testFailed ( TestRunListener . STATUS_ERROR , test , e ) ; }
public synchronized void addFailure ( final Test test , final AssertionFailedError e ) { testFailed ( TestRunListener . STATUS_FAILURE , test , e ) ; }
public void addError ( Test test , Throwable e ) { getWriter ( ) . print ( " E " ) ; }
public static void assumeNoException ( Throwable e ) { assumeThat ( e , nullValue ( ) ) ; }
public static void assumeNoException ( String message , Throwable e ) { assumeThat ( message , e , nullValue ( ) ) ; }
public void addError ( Test test , Throwable e ) { Failure failure = new Failure ( asDescription ( test ) , e ) ; fNotifier . fireTestFailure ( failure ) ; }
public void evaluate ( ) throws Throwable { List < Throwable > errors = new ArrayList < Throwable > ( ) ; startingQuietly ( description , errors ) ; try { base . evaluate ( ) ; succeededQuietly ( description , errors ) ; } catch ( AssumptionViolatedException e ) { errors . add ( e ) ; skippedQuietly ( e , description , errors ) ; } catch ( Throwable e ) { errors . add ( e ) ; failedQuietly ( e , description , errors ) ; } finally { finishedQuietly ( description , errors ) ; } MultipleFailureException . assertEmpty ( errors ) ; }
private void failedQuietly ( Throwable e , Description description , List < Throwable > errors ) { try { failed ( e , description ) ;
public void addError ( Test test , Throwable e ) { fErrorCount + + ; }
public void testEnded ( String testName ) { } @ Override public void testFailed ( int status , Test test , Throwable e ) { } @ Override public void testStarted ( String testName ) { } } public static class NonStatic { public Test suite ( ) { return null ; } } public void testInvokeNonStaticSuite ( ) { BaseTestRunner runner = new MockRunner ( ) ; runner . getTest ( " junit . tests . runner . BaseTestRunnerTest $ NonStatic " ) ; } public static class DoesntExtendTestCase { public static Test suite ( ) { return new TestSuite ( ) ; } } public void testInvokeSuiteOnNonSubclassOfTestCase ( ) { MockRunner runner = new MockRunner ( ) ; runner . getTest ( DoesntExtendTestCase . class . getName ( ) ) ; assertFalse ( runner . fRunFailed ) ; } }
public void testFailed ( int status , Test test , Throwable e ) { } @ Override public void testStarted ( String testName ) { } } public static class NonStatic { public Test suite ( ) { return null ; } } public void testInvokeNonStaticSuite ( ) { BaseTestRunner runner = new MockRunner ( ) ; runner . getTest ( " junit . tests . runner . BaseTestRunnerTest $ NonStatic " ) ; } public static class DoesntExtendTestCase { public static Test suite ( ) { return new TestSuite ( ) ; } } public void testInvokeSuiteOnNonSubclassOfTestCase ( ) { MockRunner runner = new MockRunner ( ) ; runner . getTest ( DoesntExtendTestCase . class . getName ( ) ) ; assertFalse ( runner . fRunFailed ) ; } }
private void assertCompletesNormally ( ) { } @ Test ( expected = AssumptionViolatedException . class ) public void assumeTrueWorks ( ) { Assume . assumeTrue ( false ) ; } public static class HasFailingAssumeInBefore { @ Before public void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforePreventsTestRun ( ) { assertThat ( testResult ( HasFailingAssumeInBefore . class ) , isSuccessful ( ) ) ; } public static class HasFailingAssumeInBeforeClass { @ BeforeClass public static void checkForSomethingThatIsntThere ( ) { assumeTrue ( false ) ; } @ Test public void failing ( ) { fail ( ) ; } } @ Test public void failingAssumptionInBeforeClassIgnoresClass ( ) { assertThat ( testResult ( HasFailingAssumeInBeforeClass . class ) , isSuccessful ( ) ) ; } public static class AssumptionFailureInConstructor { public AssumptionFailureInConstructor ( ) { assumeTrue ( false ) ; } @ Test public void shouldFail ( ) { fail ( ) ; } } @ Test public void failingAssumptionInConstructorIgnoresClass ( ) { assertThat ( testResult ( AssumptionFailureInConstructor . class ) , isSuccessful ( ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void assumeWithExpectedException ( ) { assumeTrue ( false ) ; } final static String message = " Some random message string . " ; final static Throwable e = new Throwable ( ) ; public static class HasAssumeWithMessage { @ Test public void testMethod ( ) { assumeTrue ( message , false ) ; } } @ Test public void assumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessage . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } public static class HasAssumeWithMessageAndCause { @ Test public void testMethod ( ) { assumeNoException ( message , e ) ; } } @ Test public void assumptionsWithMessageAndCause ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessageAndCause . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; assertSame ( failures . get ( 0 ) . getException ( ) . getCause ( ) , e ) ; } public static class HasFailingAssumptionWithMessage { @ Test public void assumptionsFail ( ) { assumeThat ( message , 3 , is ( 4 ) ) ; fail ( ) ; } } @ Test public void failedAssumptionsWithMessage ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasFailingAssumptionWithMessage . class ) ; assertEquals ( failures . size ( ) , 1 ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; } private static List < Failure > runAndGetAssumptionFailures ( Class < ? > clazz ) { final List < Failure > failures = new ArrayList < Failure > ( ) ; final JUnitCore core = new JUnitCore ( ) ; core . addListener ( new RunListener ( ) { @ Override public void testAssumptionFailure ( Failure failure ) { failures . add ( failure ) ; } } ) ; core . run ( clazz ) ; return failures ; } }
public void testMethod ( ) { assumeNoException ( message , e ) ; }
public void assumptionsWithMessageAndCause ( ) { final List < Failure > failures = runAndGetAssumptionFailures ( HasAssumeWithMessageAndCause . class ) ; assertTrue ( failures . get ( 0 ) . getMessage ( ) . contains ( message ) ) ; assertSame ( failures . get ( 0 ) . getException ( ) . getCause ( ) , e ) ; }
protected void failed ( Throwable e , Description description ) { throw new RuntimeException ( " watcher failed failure " ) ; }
public void testNotifyResult ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( ErrorTest . class ) ; TestResult result = new TestResult ( ) ; final StringBuffer log = new StringBuffer ( ) ; result . addListener ( new TestListener ( ) { public void startTest ( junit . framework . Test test ) { log . append ( " start " + test ) ; } public void endTest ( junit . framework . Test test ) { log . append ( " end " + test ) ; } public void addFailure ( junit . framework . Test test , AssertionFailedError t ) { log . append ( " failure " + test ) ; } public void addError ( junit . framework . Test test , Throwable e ) { log . append ( " error " + test ) ; } } ) ; adapter . run ( result ) ; String testName = String . format ( " error ( % s ) " , ErrorTest . class . getName ( ) ) ; assertEquals ( String . format ( " start % s error % s end % s " , testName , testName , testName ) , log . toString ( ) ) ; }
public void addError ( junit . framework . Test test , Throwable e ) { log . append ( " error " + test ) ; }
public void addError ( junit . framework . Test test , Throwable e ) { fError = test ; }
private Runner createRunnerWithNotNormalizedParameters ( String pattern , int index , Object parametersOrSingleParameter ) throws InitializationError { Object [ ] parameters = ( parametersOrSingleParameter instanceof Object [ ] ) ? ( Object [ ] ) parametersOrSingleParameter : new Object [ ] { parametersOrSingleParameter } ; TestWithParameters test = createTestWithParameters ( getTestClass ( ) , pattern , index , parameters ) ; return createRunnerForTest ( test ) ; }
protected Runner createRunnerForTest ( TestWithParameters test ) throws InitializationError { return new TestClassRunnerForParameters ( test ) ; }
private static TestWithParameters createTestWithParameters ( TestClass testClass , String pattern , int index , Object [ ] parameters ) { String finalPattern = pattern . replaceAll ( " \ \ { index \ \ } " , Integer . toString ( index ) ) ; String name = MessageFormat . format ( finalPattern , parameters ) ; return new TestWithParameters ( " [ " + name + " ] " , testClass , Arrays . asList ( parameters ) ) ;
public int hashCode ( ) { return ( fClass = = null ) ? 0 : fClass . hashCode ( ) ; }
public int hashCode ( ) { int prime = 14747 ; int result = prime + fName . hashCode ( ) ; result = prime * result + fTestClass . hashCode ( ) ; return prime * result + fParameters . hashCode ( ) ; }
public String toString ( ) { return fTestClass . getName ( ) + " ' " + fName + " ' with parameters " + fParameters ;
private static void notNull ( Object value , String message ) { if ( value = = null ) { throw new NullPointerException ( message ) ;
public void isEqualToTestClassThatWrapsSameJavaClass ( ) { TestClass testClass = new TestClass ( DummyClass . class ) ; TestClass testClassThatWrapsSameJavaClass = new TestClass ( DummyClass . class ) ; assertTrue ( testClass . equals ( testClassThatWrapsSameJavaClass ) ) ; }
public void isEqualToTestClassThatWrapsNoJavaClassToo ( ) { TestClass testClass = new TestClass ( null ) ; TestClass testClassThatWrapsNoJavaClassToo = new TestClass ( null ) ; assertTrue ( testClass . equals ( testClassThatWrapsNoJavaClassToo ) ) ; }
public void isNotEqualToTestClassThatWrapsADifferentJavaClass ( ) { TestClass testClass = new TestClass ( DummyClass . class ) ; TestClass testClassThatWrapsADifferentJavaClass = new TestClass ( AnotherDummyClass . class ) ; assertFalse ( testClass . equals ( testClassThatWrapsADifferentJavaClass ) ) ; }
public void isNotEqualToNull ( ) { TestClass testClass = new TestClass ( DummyClass . class ) ; assertFalse ( testClass . equals ( null ) ) ; }
public void hasSameHashCodeAsTestClassThatWrapsSameJavaClass ( ) { TestClass testClass = new TestClass ( DummyClass . class ) ; TestClass testClassThatWrapsSameJavaClass = new TestClass ( DummyClass . class ) ; assertEquals ( testClass . hashCode ( ) , testClassThatWrapsSameJavaClass . hashCode ( ) ) ;
public void hasHashCodeWithoutJavaClass ( ) { TestClass testClass = new TestClass ( null ) ; testClass . hashCode ( ) ;
public void cannotBeCreatedWithoutAName ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( " The name is missing . " ) ; new TestWithParameters ( null , DUMMY_TEST_CLASS , DUMMY_PARAMETERS ) ; }
public void cannotBeCreatedWithoutTestClass ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( " The test class is missing . " ) ; new TestWithParameters ( DUMMY_NAME , null , DUMMY_PARAMETERS ) ; }
public void cannotBeCreatedWithoutParameters ( ) { thrown . expect ( NullPointerException . class ) ; thrown . expectMessage ( " The parameters are missing . " ) ; new TestWithParameters ( DUMMY_NAME , DUMMY_TEST_CLASS , ( List < Object > ) null ) ;
public void doesNotAllowToModifyProvidedParameters ( ) { TestWithParameters test = new TestWithParameters ( DUMMY_NAME , DUMMY_TEST_CLASS , DUMMY_PARAMETERS ) ; thrown . expect ( UnsupportedOperationException . class ) ; test . getParameters ( ) . set ( 0 , " another parameter " ) ; }
public void doesNotConsiderParametersWhichChangedAfterTestInstantiation ( ) { List < Object > parameters = Arrays . < Object > asList ( " dummy parameter " ) ; TestWithParameters test = new TestWithParameters ( DUMMY_NAME , DUMMY_TEST_CLASS , parameters ) ; parameters . set ( 0 , " another parameter " ) ; assertEquals ( asList ( " dummy parameter " ) , test . getParameters ( ) ) ; }
public void isEqualToTestWithSameNameAndTestClassAndParameters ( ) { TestWithParameters firstTest = new TestWithParameters ( DUMMY_NAME , new TestClass ( DummyClass . class ) , Arrays . < Object > asList ( " a " , " b " ) ) ; TestWithParameters secondTest = new TestWithParameters ( DUMMY_NAME , new TestClass ( DummyClass . class ) , Arrays . < Object > asList ( " a " , " b " ) ) ; assertEquals ( firstTest , secondTest ) ; }
public void isNotEqualToTestWithDifferentName ( ) { TestWithParameters firstTest = new TestWithParameters ( " name " , DUMMY_TEST_CLASS , DUMMY_PARAMETERS ) ; TestWithParameters secondTest = new TestWithParameters ( " another name " , DUMMY_TEST_CLASS , DUMMY_PARAMETERS ) ; assertNotEquals ( firstTest , secondTest ) ; }
public void isNotEqualToTestWithDifferentTestClass ( ) { TestWithParameters firstTest = new TestWithParameters ( DUMMY_NAME , new TestClass ( DummyClass . class ) , DUMMY_PARAMETERS ) ; TestWithParameters secondTest = new TestWithParameters ( DUMMY_NAME , new TestClass ( AnotherDummyClass . class ) , DUMMY_PARAMETERS ) ; assertNotEquals ( firstTest , secondTest ) ; }
public void isNotEqualToTestWithDifferentParameters ( ) { TestWithParameters firstTest = new TestWithParameters ( DUMMY_NAME , DUMMY_TEST_CLASS , Arrays . < Object > asList ( " a " ) ) ; TestWithParameters secondTest = new TestWithParameters ( DUMMY_NAME , DUMMY_TEST_CLASS , Arrays . < Object > asList ( " b " ) ) ; assertNotEquals ( firstTest , secondTest ) ; }
public void isNotEqualToObjectWithDifferentClass ( ) { TestWithParameters test = new TestWithParameters ( DUMMY_NAME , DUMMY_TEST_CLASS , DUMMY_PARAMETERS ) ; assertNotEquals ( test , new Integer ( 3 ) ) ; }
public void hasSameHashCodeAsEqualTest ( ) { TestWithParameters firstTest = new TestWithParameters ( DUMMY_NAME , DUMMY_TEST_CLASS , DUMMY_PARAMETERS ) ; TestWithParameters secondTest = new TestWithParameters ( DUMMY_NAME , DUMMY_TEST_CLASS , DUMMY_PARAMETERS ) ; assertEquals ( firstTest . hashCode ( ) , secondTest . hashCode ( ) ) ; }
public void hasMeaningfulToString ( ) { TestWithParameters test = new TestWithParameters ( " name " , new TestClass ( DummyClass . class ) , Arrays . < Object > asList ( " first parameter " , " second parameter " ) ) ; assertEquals ( " Wrong toString ( ) . " ,
protected Runner createRunnerForTest ( TestWithParameters test ) throws InitializationError { return new BlockJUnit4ClassRunnerWithParameters ( test ) ; }
public Object createTest ( ) throws Exception { if ( fieldsAreAnnotated ( ) ) { return createTestUsingFieldInjection ( ) ;
private Object createTestUsingConstructorInjection ( ) throws Exception { return getTestClass ( ) . getOnlyConstructor ( ) . newInstance ( fParameters ) ; }
private Object createTestUsingFieldInjection ( ) throws Exception { List < FrameworkField > annotatedFieldsByParameter = getAnnotatedFieldsByParameter ( ) ; if ( annotatedFieldsByParameter . size ( ) ! = fParameters . length ) { throw new Exception ( " Wrong number of parameters and @ Parameter fields . " + " @ Parameter fields counted : " + annotatedFieldsByParameter . size ( ) + " , available parameters : " + fParameters . length + " . " ) ; } Object testClassInstance = getTestClass ( ) . getJavaClass ( ) . newInstance ( ) ; for ( FrameworkField each : annotatedFieldsByParameter ) { Field field = each . getField ( ) ; Parameter annotation = field . getAnnotation ( Parameter . class ) ; int index = annotation . value ( ) ; try { field . set ( testClassInstance , fParameters [ index ] ) ; } catch ( IllegalArgumentException iare ) { throw new Exception ( getTestClass ( ) . getName ( ) + " : Trying to set " + field . getName ( ) + " with the value " + fParameters [ index ] + " that is not the right type ( " + fParameters [ index ] . getClass ( ) . getSimpleName ( ) + " instead of " + field . getType ( ) . getSimpleName ( ) + " ) . " , iare ) ; } } return testClassInstance ; }
protected String testName ( FrameworkMethod method ) { return method . getName ( ) + getName ( ) ; }
protected void validateConstructor ( List < Throwable > errors ) { validateOnlyOneConstructor ( errors ) ; if ( fieldsAreAnnotated ( ) ) { validateZeroArgConstructor ( errors ) ;
protected void validateFields ( List < Throwable > errors ) { super . validateFields ( errors ) ; if ( fieldsAreAnnotated ( ) ) { List < FrameworkField > annotatedFieldsByParameter = getAnnotatedFieldsByParameter ( ) ;
protected Statement classBlock ( RunNotifier notifier ) { return childrenInvoker ( notifier ) ; }
private ParametersRunnerFactory getParametersRunnerFactory ( Class < ? > klass ) throws InstantiationException , IllegalAccessException { UseParametersRunnerFactory annotation = klass . getAnnotation ( UseParametersRunnerFactory . class ) ; if ( annotation = = null ) { return DEFAULT_FACTORY ;
private TestWithParameters createTestWithNotNormalizedParameters ( String pattern , int index , Object parametersOrSingleParameter ) { Object [ ] parameters = ( parametersOrSingleParameter instanceof Object [ ] ) ? ( Object [ ] ) parametersOrSingleParameter : new Object [ ] { parametersOrSingleParameter } ; return createTestWithParameters ( getTestClass ( ) , pattern , index , parameters ) ;
private List < Runner > createRunnersForParameters ( Iterable < Object > allParameters , String namePattern , ParametersRunnerFactory runnerFactory ) throws InitializationError , Exception { try { List < TestWithParameters > tests = createTestsForParameters (
private List < TestWithParameters > createTestsForParameters ( Iterable < Object > allParameters , String namePattern ) throws Exception { int i = 0 ; List < TestWithParameters > children = new ArrayList < TestWithParameters > ( ) ; for ( Object parametersOfSingleTest : allParameters ) { children . add ( createTestWithNotNormalizedParameters ( namePattern , i + + , parametersOfSingleTest ) ) ; } return children ; }
public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { return new BlockJUnit4ClassRunnerWithParameters ( test ) ; }
Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError ; }
public void aTest ( ) { } } @ Test public void beforeAndAfterClassAreRun ( ) { fLog = " " ; JUnitCore . runClasses ( BeforeAndAfter . class ) ; assertEquals ( " before after " , fLog ) ; } @ RunWith ( Parameterized . class ) static public class EmptyTest { @ BeforeClass public static void before ( ) { fLog + = " before " ; } @ AfterClass public static void after ( ) { fLog + = " after " ; } } @ Test public void validateClassCatchesNoParameters ( ) { Result result = JUnitCore . runClasses ( EmptyTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class IncorrectTest { @ Test public int test ( ) { return 0 ; } @ Parameters public static Collection < Object [ ] > data ( ) { return Collections . singletonList ( new Object [ ] { 1 } ) ; } } @ Test public void failuresAddedForBadTestMethod ( ) throws Exception { Result result = JUnitCore . runClasses ( IncorrectTest . class ) ; assertEquals ( 1 , result . getFailureCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ProtectedParametersTest { @ Parameters protected static Collection < Object [ ] > data ( ) { return Collections . emptyList ( ) ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersNotPublic ( ) { assertTestCreatesSingleFailureWithMessage ( ProtectedParametersTest . class , " No public static parameters method on class " + ProtectedParametersTest . class . getName ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ParametersNotIterable { @ Parameters public static String data ( ) { return " foo " ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } }
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersNotPublic ( ) { assertTestCreatesSingleFailureWithMessage ( ProtectedParametersTest . class , " No public static parameters method on class " + ProtectedParametersTest . class . getName ( ) ) ; } @ RunWith ( Parameterized . class ) static public class ParametersNotIterable { @ Parameters public static String data ( ) { return " foo " ; } @ Test public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } }
public void meaningfulFailureWhenParametersNotPublic ( ) { assertTestCreatesSingleFailureWithMessage ( ProtectedParametersTest . class , " No public static parameters method on class "
public void aTest ( ) { } } @ Test public void meaningfulFailureWhenParametersAreNotAnIterable ( ) { assertThat ( testResult ( ParametersNotIterable . class ) . toString ( ) , containsString ( " ParametersNotIterable . data ( ) must return an Iterable of arrays . " ) ) ; } @ RunWith ( Parameterized . class ) static public class PrivateConstructor { private PrivateConstructor ( int x ) { } @ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 } } ) ; } @ Test public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } }
public void aTest ( ) { } } @ Test ( expected = InitializationError . class ) public void exceptionWhenPrivateConstructor ( ) throws Throwable { new Parameterized ( PrivateConstructor . class ) ; } @ RunWith ( Parameterized . class ) static public class FibonacciTestWithArray { @ Parameters ( name = " { index } : fib ( { 0 } ) = { 1 } " ) public static Object [ ] [ ] data ( ) { return new Object [ ] [ ] { { 0 , 0 } , { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 4 , 3 } , { 5 , 5 } , { 6 , 8 } } ; } private final int fInput ; private final int fExpected ; public FibonacciTestWithArray ( int input , int expected ) { fInput = input ; fExpected = expected ; } @ Test public void test ( ) { assertEquals ( fExpected , fib ( fInput ) ) ; } private int fib ( int x ) { return 0 ; } } @ Test public void runsEveryTestOfArray ( ) { Result result = JUnitCore . runClasses ( FibonacciTestWithArray . class ) ; assertEquals ( 7 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithArray { @ Parameters public static Object [ ] data ( ) { return new Object [ ] { " first test " , " second test " } ; } public SingleArgumentTestWithArray ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfArray ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithArray . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } @ RunWith ( Parameterized . class ) static public class SingleArgumentTestWithIterable { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " first test " , " second test " ) ; } public SingleArgumentTestWithIterable ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } }
public void aTest ( ) { } } @ Test public void runsForEverySingleArgumentOfIterable ( ) { Result result = JUnitCore . runClasses ( SingleArgumentTestWithIterable . class ) ; assertEquals ( 2 , result . getRunCount ( ) ) ; } static public class ExceptionThrowingRunnerFactory implements ParametersRunnerFactory { public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ; } } @ RunWith ( Parameterized . class ) @ UseParametersRunnerFactory ( ExceptionThrowingRunnerFactory . class ) static public class TestWithUseParametersRunnerFactoryAnnotation { @ Parameters public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; } public TestWithUseParametersRunnerFactoryAnnotation ( Object argument ) { } @ Test public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } }
public Runner createRunnerForTestWithParameters ( TestWithParameters test ) throws InitializationError { throw new InitializationError ( " Called ExceptionThrowingRunnerFactory . " ) ;
public static Iterable < ? extends Object > data ( ) { return asList ( " single test " ) ; }
public void aTest ( ) { } } @ Test public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class , " Called ExceptionThrowingRunnerFactory . " ) ; } private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } }
public void usesParametersRunnerFactoryThatWasSpecifiedByAnnotation ( ) { assertTestCreatesSingleFailureWithMessage ( TestWithUseParametersRunnerFactoryAnnotation . class ,
private void assertTestCreatesSingleFailureWithMessage ( Class < ? > test , String message ) { Result result = JUnitCore . runClasses ( test ) ; assertEquals ( 1 , result . getFailures ( ) . size ( ) ) ; assertEquals ( message , result . getFailures ( ) . get ( 0 ) . getMessage ( ) ) ; }
private String compact ( String message ) { if ( expected = = null | | actual = = null | | areStringsEqual ( ) ) { return Assert . format ( message , expected , actual ) ; } findCommonPrefix ( ) ; findCommonSuffix ( ) ; String expected = compactString ( this . expected ) ; String actual = compactString ( this . actual ) ; return Assert . format ( message , expected , actual ) ; }
private String compactString ( String source ) { String result = DELTA_START + source . substring ( prefix , source . length ( ) - suffix ) + DELTA_END ; if ( prefix > 0 ) { result = computeCommonPrefix ( ) + result ; } if ( suffix > 0 ) { result = result + computeCommonSuffix ( ) ; } return result ; }
private void findCommonPrefix ( ) { prefix = 0 ; int end = Math . min ( expected . length ( ) , actual . length ( ) ) ; for ( ; prefix < end ; prefix + + ) { if ( expected . charAt ( prefix ) ! = actual . charAt ( prefix ) ) {
private void findCommonSuffix ( ) { int expectedSuffix = expected . length ( ) - 1 ; int actualSuffix = actual . length ( ) - 1 ; for ( ; actualSuffix > = prefix & & expectedSuffix > = prefix ; actualSuffix - - , expectedSuffix - - ) { if ( expected . charAt ( expectedSuffix ) ! = actual . charAt ( actualSuffix ) ) { break ; } } suffix = expected . length ( ) - expectedSuffix - 1 ; }
private String computeCommonPrefix ( ) { return ( prefix > contextLength ? ELLIPSIS : " " ) + expected . substring ( Math . max ( 0 , prefix - contextLength ) , prefix ) ; }
private String computeCommonSuffix ( ) { int end = Math . min ( expected . length ( ) - suffix + contextLength , expected . length ( ) ) ; return expected . substring ( expected . length ( ) - suffix , end ) + ( expected . length ( ) - suffix < expected . length ( ) - contextLength ? ELLIPSIS : " " ) ; }
private boolean areStringsEqual ( ) { return expected . equals ( actual ) ; }
protected void runWithIncompleteAssignment ( Assignments incomplete ) throws Throwable { for ( PotentialAssignment source : incomplete . potentialsForNextUnassigned ( ) ) {
public static Assignments allUnassigned ( Method testMethod , TestClass testClass ) { List < ParameterSignature > signatures ; signatures = ParameterSignature . signatures ( testClass . getOnlyConstructor ( ) ) ; signatures . addAll ( ParameterSignature . signatures ( testMethod ) ) ; return new Assignments ( new ArrayList < PotentialAssignment > ( ) , signatures , testClass ) ;
public List < PotentialAssignment > potentialsForNextUnassigned ( ) throws Throwable { ParameterSignature unassigned = nextUnassigned ( ) ; List < PotentialAssignment > assignments = getSupplier ( unassigned ) . getValueSources ( unassigned ) ; if ( assignments . size ( ) = = 0 ) { assignments = generateAssignmentsFromTypeAlone ( unassigned ) ; } return assignments ; }
private String [ ] copyArray ( String [ ] args , int from , int to ) { ArrayList < String > result = new ArrayList < String > ( ) ; for ( int j = from ; j ! = to ; + + j ) { result . add ( args [ j ] ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; }
protected void runWithIncompleteAssignment ( Assignments incomplete ) throws Throwable { GuesserQueue guessers = createGuesserQueue ( incomplete ) ; queues . add ( guessers ) ; while ( ! guessers . isEmpty ( ) ) runWithAssignment ( incomplete . assignNext ( guessers . remove ( 0 ) ) ) ; queues . remove ( guessers ) ; }
public void testNotifyResult ( ) { JUnit4TestAdapter adapter = new JUnit4TestAdapter ( ErrorTest . class ) ; TestResult result = new TestResult ( ) ; final StringBuffer log = new StringBuffer ( ) ; result . addListener ( new TestListener ( ) { public void startTest ( junit . framework . Test test ) { log . append ( " start " ) . append ( test ) ; } public void endTest ( junit . framework . Test test ) { log . append ( " end " ) . append ( test ) ; } public void addFailure ( junit . framework . Test test , AssertionFailedError t ) { log . append ( " failure " ) . append ( test ) ; } public void addError ( junit . framework . Test test , Throwable e ) { log . append ( " error " + test ) ; } } ) ; adapter . run ( result ) ; String testName = String . format ( " error ( % s ) " , ErrorTest . class . getName ( ) ) ; assertEquals ( String . format ( " start % s error % s end % s " , testName , testName , testName ) , log . toString ( ) ) ; }
public void startTest ( junit . framework . Test test ) { log . append ( " start " ) . append ( test ) ; }
public void endTest ( junit . framework . Test test ) { log . append ( " end " ) . append ( test ) ; }
public void addFailure ( junit . framework . Test test , AssertionFailedError t ) { log . append ( " failure " ) . append ( test ) ; }
public void cannotCreateWithNullClass ( ) { new ErrorReportingRunner ( null , new RuntimeException ( ) ) ; }
